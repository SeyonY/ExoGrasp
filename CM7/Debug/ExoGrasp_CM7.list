
ExoGrasp_CM7.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000298  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000180e0  080002a0  080002a0  000012a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000a158  08018380  08018380  00019380  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080224d8  080224d8  00024d30  2**0
                  CONTENTS
  4 .ARM          00000008  080224d8  080224d8  000234d8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  080224e0  080224e0  00024d30  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080224e0  080224e0  000234e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  080224e4  080224e4  000234e4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000d30  24000000  080224e8  00024000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000054f4  24000d40  08023218  00024d40  2**5
                  ALLOC
 10 ._user_heap_stack 00001000  20000000  20000000  00025000  2**0
                  ALLOC
 11 .ARM.attributes 0000002e  00000000  00000000  00024d30  2**0
                  CONTENTS, READONLY
 12 .debug_info   0002fb2c  00000000  00000000  00024d5e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00005b3f  00000000  00000000  0005488a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00002370  00000000  00000000  0005a3d0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 00001b76  00000000  00000000  0005c740  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  0004239d  00000000  00000000  0005e2b6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   000300fa  00000000  00000000  000a0653  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    001b656a  00000000  00000000  000d074d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000086  00000000  00000000  00286cb7  2**0
                  CONTENTS, READONLY
 20 .debug_frame  0000a29c  00000000  00000000  00286d40  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000045  00000000  00000000  00290fdc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080002a0 <__do_global_dtors_aux>:
 80002a0:	b510      	push	{r4, lr}
 80002a2:	4c05      	ldr	r4, [pc, #20]	@ (80002b8 <__do_global_dtors_aux+0x18>)
 80002a4:	7823      	ldrb	r3, [r4, #0]
 80002a6:	b933      	cbnz	r3, 80002b6 <__do_global_dtors_aux+0x16>
 80002a8:	4b04      	ldr	r3, [pc, #16]	@ (80002bc <__do_global_dtors_aux+0x1c>)
 80002aa:	b113      	cbz	r3, 80002b2 <__do_global_dtors_aux+0x12>
 80002ac:	4804      	ldr	r0, [pc, #16]	@ (80002c0 <__do_global_dtors_aux+0x20>)
 80002ae:	f3af 8000 	nop.w
 80002b2:	2301      	movs	r3, #1
 80002b4:	7023      	strb	r3, [r4, #0]
 80002b6:	bd10      	pop	{r4, pc}
 80002b8:	24000d40 	.word	0x24000d40
 80002bc:	00000000 	.word	0x00000000
 80002c0:	08018368 	.word	0x08018368

080002c4 <frame_dummy>:
 80002c4:	b508      	push	{r3, lr}
 80002c6:	4b03      	ldr	r3, [pc, #12]	@ (80002d4 <frame_dummy+0x10>)
 80002c8:	b11b      	cbz	r3, 80002d2 <frame_dummy+0xe>
 80002ca:	4903      	ldr	r1, [pc, #12]	@ (80002d8 <frame_dummy+0x14>)
 80002cc:	4803      	ldr	r0, [pc, #12]	@ (80002dc <frame_dummy+0x18>)
 80002ce:	f3af 8000 	nop.w
 80002d2:	bd08      	pop	{r3, pc}
 80002d4:	00000000 	.word	0x00000000
 80002d8:	24000d44 	.word	0x24000d44
 80002dc:	08018368 	.word	0x08018368

080002e0 <strlen>:
 80002e0:	4603      	mov	r3, r0
 80002e2:	f813 2b01 	ldrb.w	r2, [r3], #1
 80002e6:	2a00      	cmp	r2, #0
 80002e8:	d1fb      	bne.n	80002e2 <strlen+0x2>
 80002ea:	1a18      	subs	r0, r3, r0
 80002ec:	3801      	subs	r0, #1
 80002ee:	4770      	bx	lr

080002f0 <memchr>:
 80002f0:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 80002f4:	2a10      	cmp	r2, #16
 80002f6:	db2b      	blt.n	8000350 <memchr+0x60>
 80002f8:	f010 0f07 	tst.w	r0, #7
 80002fc:	d008      	beq.n	8000310 <memchr+0x20>
 80002fe:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000302:	3a01      	subs	r2, #1
 8000304:	428b      	cmp	r3, r1
 8000306:	d02d      	beq.n	8000364 <memchr+0x74>
 8000308:	f010 0f07 	tst.w	r0, #7
 800030c:	b342      	cbz	r2, 8000360 <memchr+0x70>
 800030e:	d1f6      	bne.n	80002fe <memchr+0xe>
 8000310:	b4f0      	push	{r4, r5, r6, r7}
 8000312:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000316:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800031a:	f022 0407 	bic.w	r4, r2, #7
 800031e:	f07f 0700 	mvns.w	r7, #0
 8000322:	2300      	movs	r3, #0
 8000324:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000328:	3c08      	subs	r4, #8
 800032a:	ea85 0501 	eor.w	r5, r5, r1
 800032e:	ea86 0601 	eor.w	r6, r6, r1
 8000332:	fa85 f547 	uadd8	r5, r5, r7
 8000336:	faa3 f587 	sel	r5, r3, r7
 800033a:	fa86 f647 	uadd8	r6, r6, r7
 800033e:	faa5 f687 	sel	r6, r5, r7
 8000342:	b98e      	cbnz	r6, 8000368 <memchr+0x78>
 8000344:	d1ee      	bne.n	8000324 <memchr+0x34>
 8000346:	bcf0      	pop	{r4, r5, r6, r7}
 8000348:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 800034c:	f002 0207 	and.w	r2, r2, #7
 8000350:	b132      	cbz	r2, 8000360 <memchr+0x70>
 8000352:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000356:	3a01      	subs	r2, #1
 8000358:	ea83 0301 	eor.w	r3, r3, r1
 800035c:	b113      	cbz	r3, 8000364 <memchr+0x74>
 800035e:	d1f8      	bne.n	8000352 <memchr+0x62>
 8000360:	2000      	movs	r0, #0
 8000362:	4770      	bx	lr
 8000364:	3801      	subs	r0, #1
 8000366:	4770      	bx	lr
 8000368:	2d00      	cmp	r5, #0
 800036a:	bf06      	itte	eq
 800036c:	4635      	moveq	r5, r6
 800036e:	3803      	subeq	r0, #3
 8000370:	3807      	subne	r0, #7
 8000372:	f015 0f01 	tst.w	r5, #1
 8000376:	d107      	bne.n	8000388 <memchr+0x98>
 8000378:	3001      	adds	r0, #1
 800037a:	f415 7f80 	tst.w	r5, #256	@ 0x100
 800037e:	bf02      	ittt	eq
 8000380:	3001      	addeq	r0, #1
 8000382:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
 8000386:	3001      	addeq	r0, #1
 8000388:	bcf0      	pop	{r4, r5, r6, r7}
 800038a:	3801      	subs	r0, #1
 800038c:	4770      	bx	lr
 800038e:	bf00      	nop

08000390 <__aeabi_frsub>:
 8000390:	f080 4000 	eor.w	r0, r0, #2147483648	@ 0x80000000
 8000394:	e002      	b.n	800039c <__addsf3>
 8000396:	bf00      	nop

08000398 <__aeabi_fsub>:
 8000398:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000

0800039c <__addsf3>:
 800039c:	0042      	lsls	r2, r0, #1
 800039e:	bf1f      	itttt	ne
 80003a0:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 80003a4:	ea92 0f03 	teqne	r2, r3
 80003a8:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 80003ac:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80003b0:	d06a      	beq.n	8000488 <__addsf3+0xec>
 80003b2:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80003b6:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 80003ba:	bfc1      	itttt	gt
 80003bc:	18d2      	addgt	r2, r2, r3
 80003be:	4041      	eorgt	r1, r0
 80003c0:	4048      	eorgt	r0, r1
 80003c2:	4041      	eorgt	r1, r0
 80003c4:	bfb8      	it	lt
 80003c6:	425b      	neglt	r3, r3
 80003c8:	2b19      	cmp	r3, #25
 80003ca:	bf88      	it	hi
 80003cc:	4770      	bxhi	lr
 80003ce:	f010 4f00 	tst.w	r0, #2147483648	@ 0x80000000
 80003d2:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 80003d6:	f020 407f 	bic.w	r0, r0, #4278190080	@ 0xff000000
 80003da:	bf18      	it	ne
 80003dc:	4240      	negne	r0, r0
 80003de:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 80003e2:	f441 0100 	orr.w	r1, r1, #8388608	@ 0x800000
 80003e6:	f021 417f 	bic.w	r1, r1, #4278190080	@ 0xff000000
 80003ea:	bf18      	it	ne
 80003ec:	4249      	negne	r1, r1
 80003ee:	ea92 0f03 	teq	r2, r3
 80003f2:	d03f      	beq.n	8000474 <__addsf3+0xd8>
 80003f4:	f1a2 0201 	sub.w	r2, r2, #1
 80003f8:	fa41 fc03 	asr.w	ip, r1, r3
 80003fc:	eb10 000c 	adds.w	r0, r0, ip
 8000400:	f1c3 0320 	rsb	r3, r3, #32
 8000404:	fa01 f103 	lsl.w	r1, r1, r3
 8000408:	f000 4300 	and.w	r3, r0, #2147483648	@ 0x80000000
 800040c:	d502      	bpl.n	8000414 <__addsf3+0x78>
 800040e:	4249      	negs	r1, r1
 8000410:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 8000414:	f5b0 0f00 	cmp.w	r0, #8388608	@ 0x800000
 8000418:	d313      	bcc.n	8000442 <__addsf3+0xa6>
 800041a:	f1b0 7f80 	cmp.w	r0, #16777216	@ 0x1000000
 800041e:	d306      	bcc.n	800042e <__addsf3+0x92>
 8000420:	0840      	lsrs	r0, r0, #1
 8000422:	ea4f 0131 	mov.w	r1, r1, rrx
 8000426:	f102 0201 	add.w	r2, r2, #1
 800042a:	2afe      	cmp	r2, #254	@ 0xfe
 800042c:	d251      	bcs.n	80004d2 <__addsf3+0x136>
 800042e:	f1b1 4f00 	cmp.w	r1, #2147483648	@ 0x80000000
 8000432:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000436:	bf08      	it	eq
 8000438:	f020 0001 	biceq.w	r0, r0, #1
 800043c:	ea40 0003 	orr.w	r0, r0, r3
 8000440:	4770      	bx	lr
 8000442:	0049      	lsls	r1, r1, #1
 8000444:	eb40 0000 	adc.w	r0, r0, r0
 8000448:	3a01      	subs	r2, #1
 800044a:	bf28      	it	cs
 800044c:	f5b0 0f00 	cmpcs.w	r0, #8388608	@ 0x800000
 8000450:	d2ed      	bcs.n	800042e <__addsf3+0x92>
 8000452:	fab0 fc80 	clz	ip, r0
 8000456:	f1ac 0c08 	sub.w	ip, ip, #8
 800045a:	ebb2 020c 	subs.w	r2, r2, ip
 800045e:	fa00 f00c 	lsl.w	r0, r0, ip
 8000462:	bfaa      	itet	ge
 8000464:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8000468:	4252      	neglt	r2, r2
 800046a:	4318      	orrge	r0, r3
 800046c:	bfbc      	itt	lt
 800046e:	40d0      	lsrlt	r0, r2
 8000470:	4318      	orrlt	r0, r3
 8000472:	4770      	bx	lr
 8000474:	f092 0f00 	teq	r2, #0
 8000478:	f481 0100 	eor.w	r1, r1, #8388608	@ 0x800000
 800047c:	bf06      	itte	eq
 800047e:	f480 0000 	eoreq.w	r0, r0, #8388608	@ 0x800000
 8000482:	3201      	addeq	r2, #1
 8000484:	3b01      	subne	r3, #1
 8000486:	e7b5      	b.n	80003f4 <__addsf3+0x58>
 8000488:	ea4f 0341 	mov.w	r3, r1, lsl #1
 800048c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000490:	bf18      	it	ne
 8000492:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000496:	d021      	beq.n	80004dc <__addsf3+0x140>
 8000498:	ea92 0f03 	teq	r2, r3
 800049c:	d004      	beq.n	80004a8 <__addsf3+0x10c>
 800049e:	f092 0f00 	teq	r2, #0
 80004a2:	bf08      	it	eq
 80004a4:	4608      	moveq	r0, r1
 80004a6:	4770      	bx	lr
 80004a8:	ea90 0f01 	teq	r0, r1
 80004ac:	bf1c      	itt	ne
 80004ae:	2000      	movne	r0, #0
 80004b0:	4770      	bxne	lr
 80004b2:	f012 4f7f 	tst.w	r2, #4278190080	@ 0xff000000
 80004b6:	d104      	bne.n	80004c2 <__addsf3+0x126>
 80004b8:	0040      	lsls	r0, r0, #1
 80004ba:	bf28      	it	cs
 80004bc:	f040 4000 	orrcs.w	r0, r0, #2147483648	@ 0x80000000
 80004c0:	4770      	bx	lr
 80004c2:	f112 7200 	adds.w	r2, r2, #33554432	@ 0x2000000
 80004c6:	bf3c      	itt	cc
 80004c8:	f500 0000 	addcc.w	r0, r0, #8388608	@ 0x800000
 80004cc:	4770      	bxcc	lr
 80004ce:	f000 4300 	and.w	r3, r0, #2147483648	@ 0x80000000
 80004d2:	f043 40fe 	orr.w	r0, r3, #2130706432	@ 0x7f000000
 80004d6:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 80004da:	4770      	bx	lr
 80004dc:	ea7f 6222 	mvns.w	r2, r2, asr #24
 80004e0:	bf16      	itet	ne
 80004e2:	4608      	movne	r0, r1
 80004e4:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 80004e8:	4601      	movne	r1, r0
 80004ea:	0242      	lsls	r2, r0, #9
 80004ec:	bf06      	itte	eq
 80004ee:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 80004f2:	ea90 0f01 	teqeq	r0, r1
 80004f6:	f440 0080 	orrne.w	r0, r0, #4194304	@ 0x400000
 80004fa:	4770      	bx	lr

080004fc <__aeabi_ui2f>:
 80004fc:	f04f 0300 	mov.w	r3, #0
 8000500:	e004      	b.n	800050c <__aeabi_i2f+0x8>
 8000502:	bf00      	nop

08000504 <__aeabi_i2f>:
 8000504:	f010 4300 	ands.w	r3, r0, #2147483648	@ 0x80000000
 8000508:	bf48      	it	mi
 800050a:	4240      	negmi	r0, r0
 800050c:	ea5f 0c00 	movs.w	ip, r0
 8000510:	bf08      	it	eq
 8000512:	4770      	bxeq	lr
 8000514:	f043 4396 	orr.w	r3, r3, #1258291200	@ 0x4b000000
 8000518:	4601      	mov	r1, r0
 800051a:	f04f 0000 	mov.w	r0, #0
 800051e:	e01c      	b.n	800055a <__aeabi_l2f+0x2a>

08000520 <__aeabi_ul2f>:
 8000520:	ea50 0201 	orrs.w	r2, r0, r1
 8000524:	bf08      	it	eq
 8000526:	4770      	bxeq	lr
 8000528:	f04f 0300 	mov.w	r3, #0
 800052c:	e00a      	b.n	8000544 <__aeabi_l2f+0x14>
 800052e:	bf00      	nop

08000530 <__aeabi_l2f>:
 8000530:	ea50 0201 	orrs.w	r2, r0, r1
 8000534:	bf08      	it	eq
 8000536:	4770      	bxeq	lr
 8000538:	f011 4300 	ands.w	r3, r1, #2147483648	@ 0x80000000
 800053c:	d502      	bpl.n	8000544 <__aeabi_l2f+0x14>
 800053e:	4240      	negs	r0, r0
 8000540:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000544:	ea5f 0c01 	movs.w	ip, r1
 8000548:	bf02      	ittt	eq
 800054a:	4684      	moveq	ip, r0
 800054c:	4601      	moveq	r1, r0
 800054e:	2000      	moveq	r0, #0
 8000550:	f043 43b6 	orr.w	r3, r3, #1526726656	@ 0x5b000000
 8000554:	bf08      	it	eq
 8000556:	f1a3 5380 	subeq.w	r3, r3, #268435456	@ 0x10000000
 800055a:	f5a3 0300 	sub.w	r3, r3, #8388608	@ 0x800000
 800055e:	fabc f28c 	clz	r2, ip
 8000562:	3a08      	subs	r2, #8
 8000564:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8000568:	db10      	blt.n	800058c <__aeabi_l2f+0x5c>
 800056a:	fa01 fc02 	lsl.w	ip, r1, r2
 800056e:	4463      	add	r3, ip
 8000570:	fa00 fc02 	lsl.w	ip, r0, r2
 8000574:	f1c2 0220 	rsb	r2, r2, #32
 8000578:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 800057c:	fa20 f202 	lsr.w	r2, r0, r2
 8000580:	eb43 0002 	adc.w	r0, r3, r2
 8000584:	bf08      	it	eq
 8000586:	f020 0001 	biceq.w	r0, r0, #1
 800058a:	4770      	bx	lr
 800058c:	f102 0220 	add.w	r2, r2, #32
 8000590:	fa01 fc02 	lsl.w	ip, r1, r2
 8000594:	f1c2 0220 	rsb	r2, r2, #32
 8000598:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 800059c:	fa21 f202 	lsr.w	r2, r1, r2
 80005a0:	eb43 0002 	adc.w	r0, r3, r2
 80005a4:	bf08      	it	eq
 80005a6:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80005aa:	4770      	bx	lr

080005ac <__aeabi_uldivmod>:
 80005ac:	b953      	cbnz	r3, 80005c4 <__aeabi_uldivmod+0x18>
 80005ae:	b94a      	cbnz	r2, 80005c4 <__aeabi_uldivmod+0x18>
 80005b0:	2900      	cmp	r1, #0
 80005b2:	bf08      	it	eq
 80005b4:	2800      	cmpeq	r0, #0
 80005b6:	bf1c      	itt	ne
 80005b8:	f04f 31ff 	movne.w	r1, #4294967295
 80005bc:	f04f 30ff 	movne.w	r0, #4294967295
 80005c0:	f000 b96a 	b.w	8000898 <__aeabi_idiv0>
 80005c4:	f1ad 0c08 	sub.w	ip, sp, #8
 80005c8:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80005cc:	f000 f806 	bl	80005dc <__udivmoddi4>
 80005d0:	f8dd e004 	ldr.w	lr, [sp, #4]
 80005d4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80005d8:	b004      	add	sp, #16
 80005da:	4770      	bx	lr

080005dc <__udivmoddi4>:
 80005dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80005e0:	9d08      	ldr	r5, [sp, #32]
 80005e2:	460c      	mov	r4, r1
 80005e4:	2b00      	cmp	r3, #0
 80005e6:	d14e      	bne.n	8000686 <__udivmoddi4+0xaa>
 80005e8:	4694      	mov	ip, r2
 80005ea:	458c      	cmp	ip, r1
 80005ec:	4686      	mov	lr, r0
 80005ee:	fab2 f282 	clz	r2, r2
 80005f2:	d962      	bls.n	80006ba <__udivmoddi4+0xde>
 80005f4:	b14a      	cbz	r2, 800060a <__udivmoddi4+0x2e>
 80005f6:	f1c2 0320 	rsb	r3, r2, #32
 80005fa:	4091      	lsls	r1, r2
 80005fc:	fa20 f303 	lsr.w	r3, r0, r3
 8000600:	fa0c fc02 	lsl.w	ip, ip, r2
 8000604:	4319      	orrs	r1, r3
 8000606:	fa00 fe02 	lsl.w	lr, r0, r2
 800060a:	ea4f 471c 	mov.w	r7, ip, lsr #16
 800060e:	fa1f f68c 	uxth.w	r6, ip
 8000612:	fbb1 f4f7 	udiv	r4, r1, r7
 8000616:	ea4f 431e 	mov.w	r3, lr, lsr #16
 800061a:	fb07 1114 	mls	r1, r7, r4, r1
 800061e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000622:	fb04 f106 	mul.w	r1, r4, r6
 8000626:	4299      	cmp	r1, r3
 8000628:	d90a      	bls.n	8000640 <__udivmoddi4+0x64>
 800062a:	eb1c 0303 	adds.w	r3, ip, r3
 800062e:	f104 30ff 	add.w	r0, r4, #4294967295
 8000632:	f080 8112 	bcs.w	800085a <__udivmoddi4+0x27e>
 8000636:	4299      	cmp	r1, r3
 8000638:	f240 810f 	bls.w	800085a <__udivmoddi4+0x27e>
 800063c:	3c02      	subs	r4, #2
 800063e:	4463      	add	r3, ip
 8000640:	1a59      	subs	r1, r3, r1
 8000642:	fa1f f38e 	uxth.w	r3, lr
 8000646:	fbb1 f0f7 	udiv	r0, r1, r7
 800064a:	fb07 1110 	mls	r1, r7, r0, r1
 800064e:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000652:	fb00 f606 	mul.w	r6, r0, r6
 8000656:	429e      	cmp	r6, r3
 8000658:	d90a      	bls.n	8000670 <__udivmoddi4+0x94>
 800065a:	eb1c 0303 	adds.w	r3, ip, r3
 800065e:	f100 31ff 	add.w	r1, r0, #4294967295
 8000662:	f080 80fc 	bcs.w	800085e <__udivmoddi4+0x282>
 8000666:	429e      	cmp	r6, r3
 8000668:	f240 80f9 	bls.w	800085e <__udivmoddi4+0x282>
 800066c:	4463      	add	r3, ip
 800066e:	3802      	subs	r0, #2
 8000670:	1b9b      	subs	r3, r3, r6
 8000672:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
 8000676:	2100      	movs	r1, #0
 8000678:	b11d      	cbz	r5, 8000682 <__udivmoddi4+0xa6>
 800067a:	40d3      	lsrs	r3, r2
 800067c:	2200      	movs	r2, #0
 800067e:	e9c5 3200 	strd	r3, r2, [r5]
 8000682:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000686:	428b      	cmp	r3, r1
 8000688:	d905      	bls.n	8000696 <__udivmoddi4+0xba>
 800068a:	b10d      	cbz	r5, 8000690 <__udivmoddi4+0xb4>
 800068c:	e9c5 0100 	strd	r0, r1, [r5]
 8000690:	2100      	movs	r1, #0
 8000692:	4608      	mov	r0, r1
 8000694:	e7f5      	b.n	8000682 <__udivmoddi4+0xa6>
 8000696:	fab3 f183 	clz	r1, r3
 800069a:	2900      	cmp	r1, #0
 800069c:	d146      	bne.n	800072c <__udivmoddi4+0x150>
 800069e:	42a3      	cmp	r3, r4
 80006a0:	d302      	bcc.n	80006a8 <__udivmoddi4+0xcc>
 80006a2:	4290      	cmp	r0, r2
 80006a4:	f0c0 80f0 	bcc.w	8000888 <__udivmoddi4+0x2ac>
 80006a8:	1a86      	subs	r6, r0, r2
 80006aa:	eb64 0303 	sbc.w	r3, r4, r3
 80006ae:	2001      	movs	r0, #1
 80006b0:	2d00      	cmp	r5, #0
 80006b2:	d0e6      	beq.n	8000682 <__udivmoddi4+0xa6>
 80006b4:	e9c5 6300 	strd	r6, r3, [r5]
 80006b8:	e7e3      	b.n	8000682 <__udivmoddi4+0xa6>
 80006ba:	2a00      	cmp	r2, #0
 80006bc:	f040 8090 	bne.w	80007e0 <__udivmoddi4+0x204>
 80006c0:	eba1 040c 	sub.w	r4, r1, ip
 80006c4:	ea4f 481c 	mov.w	r8, ip, lsr #16
 80006c8:	fa1f f78c 	uxth.w	r7, ip
 80006cc:	2101      	movs	r1, #1
 80006ce:	fbb4 f6f8 	udiv	r6, r4, r8
 80006d2:	ea4f 431e 	mov.w	r3, lr, lsr #16
 80006d6:	fb08 4416 	mls	r4, r8, r6, r4
 80006da:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 80006de:	fb07 f006 	mul.w	r0, r7, r6
 80006e2:	4298      	cmp	r0, r3
 80006e4:	d908      	bls.n	80006f8 <__udivmoddi4+0x11c>
 80006e6:	eb1c 0303 	adds.w	r3, ip, r3
 80006ea:	f106 34ff 	add.w	r4, r6, #4294967295
 80006ee:	d202      	bcs.n	80006f6 <__udivmoddi4+0x11a>
 80006f0:	4298      	cmp	r0, r3
 80006f2:	f200 80cd 	bhi.w	8000890 <__udivmoddi4+0x2b4>
 80006f6:	4626      	mov	r6, r4
 80006f8:	1a1c      	subs	r4, r3, r0
 80006fa:	fa1f f38e 	uxth.w	r3, lr
 80006fe:	fbb4 f0f8 	udiv	r0, r4, r8
 8000702:	fb08 4410 	mls	r4, r8, r0, r4
 8000706:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
 800070a:	fb00 f707 	mul.w	r7, r0, r7
 800070e:	429f      	cmp	r7, r3
 8000710:	d908      	bls.n	8000724 <__udivmoddi4+0x148>
 8000712:	eb1c 0303 	adds.w	r3, ip, r3
 8000716:	f100 34ff 	add.w	r4, r0, #4294967295
 800071a:	d202      	bcs.n	8000722 <__udivmoddi4+0x146>
 800071c:	429f      	cmp	r7, r3
 800071e:	f200 80b0 	bhi.w	8000882 <__udivmoddi4+0x2a6>
 8000722:	4620      	mov	r0, r4
 8000724:	1bdb      	subs	r3, r3, r7
 8000726:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 800072a:	e7a5      	b.n	8000678 <__udivmoddi4+0x9c>
 800072c:	f1c1 0620 	rsb	r6, r1, #32
 8000730:	408b      	lsls	r3, r1
 8000732:	fa22 f706 	lsr.w	r7, r2, r6
 8000736:	431f      	orrs	r7, r3
 8000738:	fa20 fc06 	lsr.w	ip, r0, r6
 800073c:	fa04 f301 	lsl.w	r3, r4, r1
 8000740:	ea43 030c 	orr.w	r3, r3, ip
 8000744:	40f4      	lsrs	r4, r6
 8000746:	fa00 f801 	lsl.w	r8, r0, r1
 800074a:	0c38      	lsrs	r0, r7, #16
 800074c:	ea4f 4913 	mov.w	r9, r3, lsr #16
 8000750:	fbb4 fef0 	udiv	lr, r4, r0
 8000754:	fa1f fc87 	uxth.w	ip, r7
 8000758:	fb00 441e 	mls	r4, r0, lr, r4
 800075c:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 8000760:	fb0e f90c 	mul.w	r9, lr, ip
 8000764:	45a1      	cmp	r9, r4
 8000766:	fa02 f201 	lsl.w	r2, r2, r1
 800076a:	d90a      	bls.n	8000782 <__udivmoddi4+0x1a6>
 800076c:	193c      	adds	r4, r7, r4
 800076e:	f10e 3aff 	add.w	sl, lr, #4294967295
 8000772:	f080 8084 	bcs.w	800087e <__udivmoddi4+0x2a2>
 8000776:	45a1      	cmp	r9, r4
 8000778:	f240 8081 	bls.w	800087e <__udivmoddi4+0x2a2>
 800077c:	f1ae 0e02 	sub.w	lr, lr, #2
 8000780:	443c      	add	r4, r7
 8000782:	eba4 0409 	sub.w	r4, r4, r9
 8000786:	fa1f f983 	uxth.w	r9, r3
 800078a:	fbb4 f3f0 	udiv	r3, r4, r0
 800078e:	fb00 4413 	mls	r4, r0, r3, r4
 8000792:	ea49 4404 	orr.w	r4, r9, r4, lsl #16
 8000796:	fb03 fc0c 	mul.w	ip, r3, ip
 800079a:	45a4      	cmp	ip, r4
 800079c:	d907      	bls.n	80007ae <__udivmoddi4+0x1d2>
 800079e:	193c      	adds	r4, r7, r4
 80007a0:	f103 30ff 	add.w	r0, r3, #4294967295
 80007a4:	d267      	bcs.n	8000876 <__udivmoddi4+0x29a>
 80007a6:	45a4      	cmp	ip, r4
 80007a8:	d965      	bls.n	8000876 <__udivmoddi4+0x29a>
 80007aa:	3b02      	subs	r3, #2
 80007ac:	443c      	add	r4, r7
 80007ae:	ea43 400e 	orr.w	r0, r3, lr, lsl #16
 80007b2:	fba0 9302 	umull	r9, r3, r0, r2
 80007b6:	eba4 040c 	sub.w	r4, r4, ip
 80007ba:	429c      	cmp	r4, r3
 80007bc:	46ce      	mov	lr, r9
 80007be:	469c      	mov	ip, r3
 80007c0:	d351      	bcc.n	8000866 <__udivmoddi4+0x28a>
 80007c2:	d04e      	beq.n	8000862 <__udivmoddi4+0x286>
 80007c4:	b155      	cbz	r5, 80007dc <__udivmoddi4+0x200>
 80007c6:	ebb8 030e 	subs.w	r3, r8, lr
 80007ca:	eb64 040c 	sbc.w	r4, r4, ip
 80007ce:	fa04 f606 	lsl.w	r6, r4, r6
 80007d2:	40cb      	lsrs	r3, r1
 80007d4:	431e      	orrs	r6, r3
 80007d6:	40cc      	lsrs	r4, r1
 80007d8:	e9c5 6400 	strd	r6, r4, [r5]
 80007dc:	2100      	movs	r1, #0
 80007de:	e750      	b.n	8000682 <__udivmoddi4+0xa6>
 80007e0:	f1c2 0320 	rsb	r3, r2, #32
 80007e4:	fa20 f103 	lsr.w	r1, r0, r3
 80007e8:	fa0c fc02 	lsl.w	ip, ip, r2
 80007ec:	fa24 f303 	lsr.w	r3, r4, r3
 80007f0:	4094      	lsls	r4, r2
 80007f2:	430c      	orrs	r4, r1
 80007f4:	ea4f 481c 	mov.w	r8, ip, lsr #16
 80007f8:	fa00 fe02 	lsl.w	lr, r0, r2
 80007fc:	fa1f f78c 	uxth.w	r7, ip
 8000800:	fbb3 f0f8 	udiv	r0, r3, r8
 8000804:	fb08 3110 	mls	r1, r8, r0, r3
 8000808:	0c23      	lsrs	r3, r4, #16
 800080a:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800080e:	fb00 f107 	mul.w	r1, r0, r7
 8000812:	4299      	cmp	r1, r3
 8000814:	d908      	bls.n	8000828 <__udivmoddi4+0x24c>
 8000816:	eb1c 0303 	adds.w	r3, ip, r3
 800081a:	f100 36ff 	add.w	r6, r0, #4294967295
 800081e:	d22c      	bcs.n	800087a <__udivmoddi4+0x29e>
 8000820:	4299      	cmp	r1, r3
 8000822:	d92a      	bls.n	800087a <__udivmoddi4+0x29e>
 8000824:	3802      	subs	r0, #2
 8000826:	4463      	add	r3, ip
 8000828:	1a5b      	subs	r3, r3, r1
 800082a:	b2a4      	uxth	r4, r4
 800082c:	fbb3 f1f8 	udiv	r1, r3, r8
 8000830:	fb08 3311 	mls	r3, r8, r1, r3
 8000834:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000838:	fb01 f307 	mul.w	r3, r1, r7
 800083c:	42a3      	cmp	r3, r4
 800083e:	d908      	bls.n	8000852 <__udivmoddi4+0x276>
 8000840:	eb1c 0404 	adds.w	r4, ip, r4
 8000844:	f101 36ff 	add.w	r6, r1, #4294967295
 8000848:	d213      	bcs.n	8000872 <__udivmoddi4+0x296>
 800084a:	42a3      	cmp	r3, r4
 800084c:	d911      	bls.n	8000872 <__udivmoddi4+0x296>
 800084e:	3902      	subs	r1, #2
 8000850:	4464      	add	r4, ip
 8000852:	1ae4      	subs	r4, r4, r3
 8000854:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 8000858:	e739      	b.n	80006ce <__udivmoddi4+0xf2>
 800085a:	4604      	mov	r4, r0
 800085c:	e6f0      	b.n	8000640 <__udivmoddi4+0x64>
 800085e:	4608      	mov	r0, r1
 8000860:	e706      	b.n	8000670 <__udivmoddi4+0x94>
 8000862:	45c8      	cmp	r8, r9
 8000864:	d2ae      	bcs.n	80007c4 <__udivmoddi4+0x1e8>
 8000866:	ebb9 0e02 	subs.w	lr, r9, r2
 800086a:	eb63 0c07 	sbc.w	ip, r3, r7
 800086e:	3801      	subs	r0, #1
 8000870:	e7a8      	b.n	80007c4 <__udivmoddi4+0x1e8>
 8000872:	4631      	mov	r1, r6
 8000874:	e7ed      	b.n	8000852 <__udivmoddi4+0x276>
 8000876:	4603      	mov	r3, r0
 8000878:	e799      	b.n	80007ae <__udivmoddi4+0x1d2>
 800087a:	4630      	mov	r0, r6
 800087c:	e7d4      	b.n	8000828 <__udivmoddi4+0x24c>
 800087e:	46d6      	mov	lr, sl
 8000880:	e77f      	b.n	8000782 <__udivmoddi4+0x1a6>
 8000882:	4463      	add	r3, ip
 8000884:	3802      	subs	r0, #2
 8000886:	e74d      	b.n	8000724 <__udivmoddi4+0x148>
 8000888:	4606      	mov	r6, r0
 800088a:	4623      	mov	r3, r4
 800088c:	4608      	mov	r0, r1
 800088e:	e70f      	b.n	80006b0 <__udivmoddi4+0xd4>
 8000890:	3e02      	subs	r6, #2
 8000892:	4463      	add	r3, ip
 8000894:	e730      	b.n	80006f8 <__udivmoddi4+0x11c>
 8000896:	bf00      	nop

08000898 <__aeabi_idiv0>:
 8000898:	4770      	bx	lr
 800089a:	bf00      	nop

0800089c <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 800089c:	b480      	push	{r7}
 800089e:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 80008a0:	4b49      	ldr	r3, [pc, #292]	@ (80009c8 <SystemInit+0x12c>)
 80008a2:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80008a6:	4a48      	ldr	r2, [pc, #288]	@ (80009c8 <SystemInit+0x12c>)
 80008a8:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 80008ac:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
  #endif

    /*SEVONPEND enabled so that an interrupt coming from the CPU(n) interrupt signal is
     detectable by the CPU after a WFI/WFE instruction.*/
 SCB->SCR |= SCB_SCR_SEVONPEND_Msk;
 80008b0:	4b45      	ldr	r3, [pc, #276]	@ (80009c8 <SystemInit+0x12c>)
 80008b2:	691b      	ldr	r3, [r3, #16]
 80008b4:	4a44      	ldr	r2, [pc, #272]	@ (80009c8 <SystemInit+0x12c>)
 80008b6:	f043 0310 	orr.w	r3, r3, #16
 80008ba:	6113      	str	r3, [r2, #16]

#if defined(CORE_CM7)
  /* Reset the RCC clock configuration to the default reset state ------------*/
   /* Increasing the CPU frequency */
  if(FLASH_LATENCY_DEFAULT  > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 80008bc:	4b43      	ldr	r3, [pc, #268]	@ (80009cc <SystemInit+0x130>)
 80008be:	681b      	ldr	r3, [r3, #0]
 80008c0:	f003 030f 	and.w	r3, r3, #15
 80008c4:	2b06      	cmp	r3, #6
 80008c6:	d807      	bhi.n	80008d8 <SystemInit+0x3c>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
 80008c8:	4b40      	ldr	r3, [pc, #256]	@ (80009cc <SystemInit+0x130>)
 80008ca:	681b      	ldr	r3, [r3, #0]
 80008cc:	f023 030f 	bic.w	r3, r3, #15
 80008d0:	4a3e      	ldr	r2, [pc, #248]	@ (80009cc <SystemInit+0x130>)
 80008d2:	f043 0307 	orr.w	r3, r3, #7
 80008d6:	6013      	str	r3, [r2, #0]
  }

  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;
 80008d8:	4b3d      	ldr	r3, [pc, #244]	@ (80009d0 <SystemInit+0x134>)
 80008da:	681b      	ldr	r3, [r3, #0]
 80008dc:	4a3c      	ldr	r2, [pc, #240]	@ (80009d0 <SystemInit+0x134>)
 80008de:	f043 0301 	orr.w	r3, r3, #1
 80008e2:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80008e4:	4b3a      	ldr	r3, [pc, #232]	@ (80009d0 <SystemInit+0x134>)
 80008e6:	2200      	movs	r2, #0
 80008e8:	611a      	str	r2, [r3, #16]

  /* Reset HSEON, HSECSSON, CSION, HSI48ON, CSIKERON, PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
 80008ea:	4b39      	ldr	r3, [pc, #228]	@ (80009d0 <SystemInit+0x134>)
 80008ec:	681a      	ldr	r2, [r3, #0]
 80008ee:	4938      	ldr	r1, [pc, #224]	@ (80009d0 <SystemInit+0x134>)
 80008f0:	4b38      	ldr	r3, [pc, #224]	@ (80009d4 <SystemInit+0x138>)
 80008f2:	4013      	ands	r3, r2
 80008f4:	600b      	str	r3, [r1, #0]

   /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLASH_LATENCY_DEFAULT  < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY)))
 80008f6:	4b35      	ldr	r3, [pc, #212]	@ (80009cc <SystemInit+0x130>)
 80008f8:	681b      	ldr	r3, [r3, #0]
 80008fa:	f003 0308 	and.w	r3, r3, #8
 80008fe:	2b00      	cmp	r3, #0
 8000900:	d007      	beq.n	8000912 <SystemInit+0x76>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT));
 8000902:	4b32      	ldr	r3, [pc, #200]	@ (80009cc <SystemInit+0x130>)
 8000904:	681b      	ldr	r3, [r3, #0]
 8000906:	f023 030f 	bic.w	r3, r3, #15
 800090a:	4a30      	ldr	r2, [pc, #192]	@ (80009cc <SystemInit+0x130>)
 800090c:	f043 0307 	orr.w	r3, r3, #7
 8000910:	6013      	str	r3, [r2, #0]
  }

  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;
 8000912:	4b2f      	ldr	r3, [pc, #188]	@ (80009d0 <SystemInit+0x134>)
 8000914:	2200      	movs	r2, #0
 8000916:	619a      	str	r2, [r3, #24]

  /* Reset D2CFGR register */
  RCC->D2CFGR = 0x00000000;
 8000918:	4b2d      	ldr	r3, [pc, #180]	@ (80009d0 <SystemInit+0x134>)
 800091a:	2200      	movs	r2, #0
 800091c:	61da      	str	r2, [r3, #28]

  /* Reset D3CFGR register */
  RCC->D3CFGR = 0x00000000;
 800091e:	4b2c      	ldr	r3, [pc, #176]	@ (80009d0 <SystemInit+0x134>)
 8000920:	2200      	movs	r2, #0
 8000922:	621a      	str	r2, [r3, #32]

  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x02020200;
 8000924:	4b2a      	ldr	r3, [pc, #168]	@ (80009d0 <SystemInit+0x134>)
 8000926:	4a2c      	ldr	r2, [pc, #176]	@ (80009d8 <SystemInit+0x13c>)
 8000928:	629a      	str	r2, [r3, #40]	@ 0x28

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x01FF0000;
 800092a:	4b29      	ldr	r3, [pc, #164]	@ (80009d0 <SystemInit+0x134>)
 800092c:	4a2b      	ldr	r2, [pc, #172]	@ (80009dc <SystemInit+0x140>)
 800092e:	62da      	str	r2, [r3, #44]	@ 0x2c
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x01010280;
 8000930:	4b27      	ldr	r3, [pc, #156]	@ (80009d0 <SystemInit+0x134>)
 8000932:	4a2b      	ldr	r2, [pc, #172]	@ (80009e0 <SystemInit+0x144>)
 8000934:	631a      	str	r2, [r3, #48]	@ 0x30
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;
 8000936:	4b26      	ldr	r3, [pc, #152]	@ (80009d0 <SystemInit+0x134>)
 8000938:	2200      	movs	r2, #0
 800093a:	635a      	str	r2, [r3, #52]	@ 0x34

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x01010280;
 800093c:	4b24      	ldr	r3, [pc, #144]	@ (80009d0 <SystemInit+0x134>)
 800093e:	4a28      	ldr	r2, [pc, #160]	@ (80009e0 <SystemInit+0x144>)
 8000940:	639a      	str	r2, [r3, #56]	@ 0x38

  /* Reset PLL2FRACR register */

  RCC->PLL2FRACR = 0x00000000;
 8000942:	4b23      	ldr	r3, [pc, #140]	@ (80009d0 <SystemInit+0x134>)
 8000944:	2200      	movs	r2, #0
 8000946:	63da      	str	r2, [r3, #60]	@ 0x3c
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x01010280;
 8000948:	4b21      	ldr	r3, [pc, #132]	@ (80009d0 <SystemInit+0x134>)
 800094a:	4a25      	ldr	r2, [pc, #148]	@ (80009e0 <SystemInit+0x144>)
 800094c:	641a      	str	r2, [r3, #64]	@ 0x40

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;
 800094e:	4b20      	ldr	r3, [pc, #128]	@ (80009d0 <SystemInit+0x134>)
 8000950:	2200      	movs	r2, #0
 8000952:	645a      	str	r2, [r3, #68]	@ 0x44

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8000954:	4b1e      	ldr	r3, [pc, #120]	@ (80009d0 <SystemInit+0x134>)
 8000956:	681b      	ldr	r3, [r3, #0]
 8000958:	4a1d      	ldr	r2, [pc, #116]	@ (80009d0 <SystemInit+0x134>)
 800095a:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 800095e:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 8000960:	4b1b      	ldr	r3, [pc, #108]	@ (80009d0 <SystemInit+0x134>)
 8000962:	2200      	movs	r2, #0
 8000964:	661a      	str	r2, [r3, #96]	@ 0x60

  /* Enable CortexM7 HSEM EXTI line (line 78)*/
  EXTI_D2->EMR3 |= 0x4000UL;
 8000966:	4b1f      	ldr	r3, [pc, #124]	@ (80009e4 <SystemInit+0x148>)
 8000968:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800096a:	4a1e      	ldr	r2, [pc, #120]	@ (80009e4 <SystemInit+0x148>)
 800096c:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8000970:	6253      	str	r3, [r2, #36]	@ 0x24

  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 8000972:	4b1d      	ldr	r3, [pc, #116]	@ (80009e8 <SystemInit+0x14c>)
 8000974:	681a      	ldr	r2, [r3, #0]
 8000976:	4b1d      	ldr	r3, [pc, #116]	@ (80009ec <SystemInit+0x150>)
 8000978:	4013      	ands	r3, r2
 800097a:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800097e:	d202      	bcs.n	8000986 <SystemInit+0xea>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
 8000980:	4b1b      	ldr	r3, [pc, #108]	@ (80009f0 <SystemInit+0x154>)
 8000982:	2201      	movs	r2, #1
 8000984:	601a      	str	r2, [r3, #0]
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D2 AXI-RAM or in Internal FLASH */
#endif /* USER_VECT_TAB_ADDRESS */

#elif defined(CORE_CM7)
  if(READ_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN) == 0U)
 8000986:	4b12      	ldr	r3, [pc, #72]	@ (80009d0 <SystemInit+0x134>)
 8000988:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
 800098c:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8000990:	2b00      	cmp	r3, #0
 8000992:	d113      	bne.n	80009bc <SystemInit+0x120>
  {
    /* Enable the FMC interface clock */
    SET_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
 8000994:	4b0e      	ldr	r3, [pc, #56]	@ (80009d0 <SystemInit+0x134>)
 8000996:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
 800099a:	4a0d      	ldr	r2, [pc, #52]	@ (80009d0 <SystemInit+0x134>)
 800099c:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 80009a0:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
    /*
     * Disable the FMC bank1 (enabled after reset).
     * This, prevents CPU speculation access on this bank which blocks the use of FMC during
     * 24us. During this time the others FMC master (such as LTDC) cannot use it!
     */
    FMC_Bank1_R->BTCR[0] = 0x000030D2;
 80009a4:	4b13      	ldr	r3, [pc, #76]	@ (80009f4 <SystemInit+0x158>)
 80009a6:	f243 02d2 	movw	r2, #12498	@ 0x30d2
 80009aa:	601a      	str	r2, [r3, #0]

    /* Disable the FMC interface clock */
    CLEAR_BIT(RCC->AHB3ENR, RCC_AHB3ENR_FMCEN);
 80009ac:	4b08      	ldr	r3, [pc, #32]	@ (80009d0 <SystemInit+0x134>)
 80009ae:	f8d3 30d4 	ldr.w	r3, [r3, #212]	@ 0xd4
 80009b2:	4a07      	ldr	r2, [pc, #28]	@ (80009d0 <SystemInit+0x134>)
 80009b4:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 80009b8:	f8c2 30d4 	str.w	r3, [r2, #212]	@ 0xd4
#endif /* USER_VECT_TAB_ADDRESS */

#else
#error Please #define CORE_CM4 or CORE_CM7
#endif /* CORE_CM4 */
}
 80009bc:	bf00      	nop
 80009be:	46bd      	mov	sp, r7
 80009c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80009c4:	4770      	bx	lr
 80009c6:	bf00      	nop
 80009c8:	e000ed00 	.word	0xe000ed00
 80009cc:	52002000 	.word	0x52002000
 80009d0:	58024400 	.word	0x58024400
 80009d4:	eaf6ed7f 	.word	0xeaf6ed7f
 80009d8:	02020200 	.word	0x02020200
 80009dc:	01ff0000 	.word	0x01ff0000
 80009e0:	01010280 	.word	0x01010280
 80009e4:	580000c0 	.word	0x580000c0
 80009e8:	5c001000 	.word	0x5c001000
 80009ec:	ffff0000 	.word	0xffff0000
 80009f0:	51008108 	.word	0x51008108
 80009f4:	52004000 	.word	0x52004000

080009f8 <ExitRun0Mode>:
  *
  * @param  None
  * @retval None
  */
void ExitRun0Mode(void)
{
 80009f8:	b480      	push	{r7}
 80009fa:	af00      	add	r7, sp, #0
  /* Wait till voltage level flag is set */
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0U)
  {}
#elif defined(USE_PWR_DIRECT_SMPS_SUPPLY) && defined(SMPS)
  /* Exit Run* mode */
  PWR->CR3 &= ~(PWR_CR3_LDOEN);
 80009fc:	4b09      	ldr	r3, [pc, #36]	@ (8000a24 <ExitRun0Mode+0x2c>)
 80009fe:	68db      	ldr	r3, [r3, #12]
 8000a00:	4a08      	ldr	r2, [pc, #32]	@ (8000a24 <ExitRun0Mode+0x2c>)
 8000a02:	f023 0302 	bic.w	r3, r3, #2
 8000a06:	60d3      	str	r3, [r2, #12]
  /* Wait till voltage level flag is set */
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0U)
 8000a08:	bf00      	nop
 8000a0a:	4b06      	ldr	r3, [pc, #24]	@ (8000a24 <ExitRun0Mode+0x2c>)
 8000a0c:	685b      	ldr	r3, [r3, #4]
 8000a0e:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8000a12:	2b00      	cmp	r3, #0
 8000a14:	d0f9      	beq.n	8000a0a <ExitRun0Mode+0x12>
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0U)
  {}
#else
  /* No system power supply configuration is selected at exit Run* mode */
#endif /* USE_PWR_LDO_SUPPLY */
}
 8000a16:	bf00      	nop
 8000a18:	bf00      	nop
 8000a1a:	46bd      	mov	sp, r7
 8000a1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a20:	4770      	bx	lr
 8000a22:	bf00      	nop
 8000a24:	58024800 	.word	0x58024800

08000a28 <pressureController>:
 */

#include "controller.h"


void pressureController(float *pressure, float target_pressure, handState_t state) {
 8000a28:	b580      	push	{r7, lr}
 8000a2a:	b084      	sub	sp, #16
 8000a2c:	af00      	add	r7, sp, #0
 8000a2e:	60f8      	str	r0, [r7, #12]
 8000a30:	ed87 0a02 	vstr	s0, [r7, #8]
 8000a34:	460b      	mov	r3, r1
 8000a36:	71fb      	strb	r3, [r7, #7]
	switch (state) {
 8000a38:	79fb      	ldrb	r3, [r7, #7]
 8000a3a:	2b00      	cmp	r3, #0
 8000a3c:	d002      	beq.n	8000a44 <pressureController+0x1c>
 8000a3e:	2b01      	cmp	r3, #1
 8000a40:	d015      	beq.n	8000a6e <pressureController+0x46>
				HAL_GPIO_WritePin(PUMP_GPIO_Port, PUMP_Pin, GPIO_PIN_RESET);
			else
				HAL_GPIO_WritePin(PUMP_GPIO_Port, PUMP_Pin, GPIO_PIN_SET);
			break;
		default:
			break;
 8000a42:	e039      	b.n	8000ab8 <pressureController+0x90>
			HAL_GPIO_WritePin(THUMB_GPIO_Port, THUMB_Pin, GPIO_PIN_RESET);
 8000a44:	2200      	movs	r2, #0
 8000a46:	2110      	movs	r1, #16
 8000a48:	481d      	ldr	r0, [pc, #116]	@ (8000ac0 <pressureController+0x98>)
 8000a4a:	f005 fd09 	bl	8006460 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(INDEX_GPIO_Port, INDEX_Pin, GPIO_PIN_RESET);
 8000a4e:	2200      	movs	r2, #0
 8000a50:	2120      	movs	r1, #32
 8000a52:	481b      	ldr	r0, [pc, #108]	@ (8000ac0 <pressureController+0x98>)
 8000a54:	f005 fd04 	bl	8006460 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(OTHER_SOL_GPIO_Port, OTHER_SOL_Pin, GPIO_PIN_RESET);
 8000a58:	2200      	movs	r2, #0
 8000a5a:	2140      	movs	r1, #64	@ 0x40
 8000a5c:	4818      	ldr	r0, [pc, #96]	@ (8000ac0 <pressureController+0x98>)
 8000a5e:	f005 fcff 	bl	8006460 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(PUMP_GPIO_Port, PUMP_Pin, GPIO_PIN_RESET);
 8000a62:	2200      	movs	r2, #0
 8000a64:	2180      	movs	r1, #128	@ 0x80
 8000a66:	4816      	ldr	r0, [pc, #88]	@ (8000ac0 <pressureController+0x98>)
 8000a68:	f005 fcfa 	bl	8006460 <HAL_GPIO_WritePin>
			break;
 8000a6c:	e024      	b.n	8000ab8 <pressureController+0x90>
			HAL_GPIO_WritePin(THUMB_GPIO_Port, THUMB_Pin, GPIO_PIN_SET);
 8000a6e:	2201      	movs	r2, #1
 8000a70:	2110      	movs	r1, #16
 8000a72:	4813      	ldr	r0, [pc, #76]	@ (8000ac0 <pressureController+0x98>)
 8000a74:	f005 fcf4 	bl	8006460 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(INDEX_GPIO_Port, INDEX_Pin, GPIO_PIN_SET);
 8000a78:	2201      	movs	r2, #1
 8000a7a:	2120      	movs	r1, #32
 8000a7c:	4810      	ldr	r0, [pc, #64]	@ (8000ac0 <pressureController+0x98>)
 8000a7e:	f005 fcef 	bl	8006460 <HAL_GPIO_WritePin>
			HAL_GPIO_WritePin(OTHER_SOL_GPIO_Port, OTHER_SOL_Pin, GPIO_PIN_SET);
 8000a82:	2201      	movs	r2, #1
 8000a84:	2140      	movs	r1, #64	@ 0x40
 8000a86:	480e      	ldr	r0, [pc, #56]	@ (8000ac0 <pressureController+0x98>)
 8000a88:	f005 fcea 	bl	8006460 <HAL_GPIO_WritePin>
			if (*pressure > target_pressure)
 8000a8c:	68fb      	ldr	r3, [r7, #12]
 8000a8e:	edd3 7a00 	vldr	s15, [r3]
 8000a92:	ed97 7a02 	vldr	s14, [r7, #8]
 8000a96:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8000a9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000a9e:	d505      	bpl.n	8000aac <pressureController+0x84>
				HAL_GPIO_WritePin(PUMP_GPIO_Port, PUMP_Pin, GPIO_PIN_RESET);
 8000aa0:	2200      	movs	r2, #0
 8000aa2:	2180      	movs	r1, #128	@ 0x80
 8000aa4:	4806      	ldr	r0, [pc, #24]	@ (8000ac0 <pressureController+0x98>)
 8000aa6:	f005 fcdb 	bl	8006460 <HAL_GPIO_WritePin>
			break;
 8000aaa:	e004      	b.n	8000ab6 <pressureController+0x8e>
				HAL_GPIO_WritePin(PUMP_GPIO_Port, PUMP_Pin, GPIO_PIN_SET);
 8000aac:	2201      	movs	r2, #1
 8000aae:	2180      	movs	r1, #128	@ 0x80
 8000ab0:	4803      	ldr	r0, [pc, #12]	@ (8000ac0 <pressureController+0x98>)
 8000ab2:	f005 fcd5 	bl	8006460 <HAL_GPIO_WritePin>
			break;
 8000ab6:	bf00      	nop
	}
}
 8000ab8:	bf00      	nop
 8000aba:	3710      	adds	r7, #16
 8000abc:	46bd      	mov	sp, r7
 8000abe:	bd80      	pop	{r7, pc}
 8000ac0:	58020c00 	.word	0x58020c00

08000ac4 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8000ac4:	b580      	push	{r7, lr}
 8000ac6:	b086      	sub	sp, #24
 8000ac8:	af00      	add	r7, sp, #0
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
 8000aca:	4b79      	ldr	r3, [pc, #484]	@ (8000cb0 <main+0x1ec>)
 8000acc:	695b      	ldr	r3, [r3, #20]
 8000ace:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8000ad2:	2b00      	cmp	r3, #0
 8000ad4:	d11b      	bne.n	8000b0e <main+0x4a>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8000ad6:	f3bf 8f4f 	dsb	sy
}
 8000ada:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8000adc:	f3bf 8f6f 	isb	sy
}
 8000ae0:	bf00      	nop

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 8000ae2:	4b73      	ldr	r3, [pc, #460]	@ (8000cb0 <main+0x1ec>)
 8000ae4:	2200      	movs	r2, #0
 8000ae6:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 8000aea:	f3bf 8f4f 	dsb	sy
}
 8000aee:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8000af0:	f3bf 8f6f 	isb	sy
}
 8000af4:	bf00      	nop
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 8000af6:	4b6e      	ldr	r3, [pc, #440]	@ (8000cb0 <main+0x1ec>)
 8000af8:	695b      	ldr	r3, [r3, #20]
 8000afa:	4a6d      	ldr	r2, [pc, #436]	@ (8000cb0 <main+0x1ec>)
 8000afc:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8000b00:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 8000b02:	f3bf 8f4f 	dsb	sy
}
 8000b06:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8000b08:	f3bf 8f6f 	isb	sy
}
 8000b0c:	e000      	b.n	8000b10 <main+0x4c>
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
 8000b0e:	bf00      	nop
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
 8000b10:	4b67      	ldr	r3, [pc, #412]	@ (8000cb0 <main+0x1ec>)
 8000b12:	695b      	ldr	r3, [r3, #20]
 8000b14:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8000b18:	2b00      	cmp	r3, #0
 8000b1a:	d138      	bne.n	8000b8e <main+0xca>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 8000b1c:	4b64      	ldr	r3, [pc, #400]	@ (8000cb0 <main+0x1ec>)
 8000b1e:	2200      	movs	r2, #0
 8000b20:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 8000b24:	f3bf 8f4f 	dsb	sy
}
 8000b28:	bf00      	nop
    __DSB();

    ccsidr = SCB->CCSIDR;
 8000b2a:	4b61      	ldr	r3, [pc, #388]	@ (8000cb0 <main+0x1ec>)
 8000b2c:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8000b30:	613b      	str	r3, [r7, #16]

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8000b32:	693b      	ldr	r3, [r7, #16]
 8000b34:	0b5b      	lsrs	r3, r3, #13
 8000b36:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8000b3a:	60fb      	str	r3, [r7, #12]
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8000b3c:	693b      	ldr	r3, [r7, #16]
 8000b3e:	08db      	lsrs	r3, r3, #3
 8000b40:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8000b44:	60bb      	str	r3, [r7, #8]
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000b46:	68fb      	ldr	r3, [r7, #12]
 8000b48:	015a      	lsls	r2, r3, #5
 8000b4a:	f643 73e0 	movw	r3, #16352	@ 0x3fe0
 8000b4e:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
 8000b50:	68ba      	ldr	r2, [r7, #8]
 8000b52:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000b54:	4956      	ldr	r1, [pc, #344]	@ (8000cb0 <main+0x1ec>)
 8000b56:	4313      	orrs	r3, r2
 8000b58:	f8c1 3260 	str.w	r3, [r1, #608]	@ 0x260
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 8000b5c:	68bb      	ldr	r3, [r7, #8]
 8000b5e:	1e5a      	subs	r2, r3, #1
 8000b60:	60ba      	str	r2, [r7, #8]
 8000b62:	2b00      	cmp	r3, #0
 8000b64:	d1ef      	bne.n	8000b46 <main+0x82>
    } while(sets-- != 0U);
 8000b66:	68fb      	ldr	r3, [r7, #12]
 8000b68:	1e5a      	subs	r2, r3, #1
 8000b6a:	60fa      	str	r2, [r7, #12]
 8000b6c:	2b00      	cmp	r3, #0
 8000b6e:	d1e5      	bne.n	8000b3c <main+0x78>
  __ASM volatile ("dsb 0xF":::"memory");
 8000b70:	f3bf 8f4f 	dsb	sy
}
 8000b74:	bf00      	nop
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 8000b76:	4b4e      	ldr	r3, [pc, #312]	@ (8000cb0 <main+0x1ec>)
 8000b78:	695b      	ldr	r3, [r3, #20]
 8000b7a:	4a4d      	ldr	r2, [pc, #308]	@ (8000cb0 <main+0x1ec>)
 8000b7c:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8000b80:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 8000b82:	f3bf 8f4f 	dsb	sy
}
 8000b86:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8000b88:	f3bf 8f6f 	isb	sy
}
 8000b8c:	e000      	b.n	8000b90 <main+0xcc>
    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
 8000b8e:	bf00      	nop
  /* Enable D-Cache---------------------------------------------------------*/
  SCB_EnableDCache();

/* USER CODE BEGIN Boot_Mode_Sequence_1 */
  /* Wait until CPU2 boots and enters in stop mode or timeout*/
  timeout = 0xFFFF;
 8000b90:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8000b94:	617b      	str	r3, [r7, #20]
  while((__HAL_RCC_GET_FLAG(RCC_FLAG_D2CKRDY) != RESET) && (timeout-- > 0));
 8000b96:	bf00      	nop
 8000b98:	4b46      	ldr	r3, [pc, #280]	@ (8000cb4 <main+0x1f0>)
 8000b9a:	681b      	ldr	r3, [r3, #0]
 8000b9c:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8000ba0:	2b00      	cmp	r3, #0
 8000ba2:	d004      	beq.n	8000bae <main+0xea>
 8000ba4:	697b      	ldr	r3, [r7, #20]
 8000ba6:	1e5a      	subs	r2, r3, #1
 8000ba8:	617a      	str	r2, [r7, #20]
 8000baa:	2b00      	cmp	r3, #0
 8000bac:	dcf4      	bgt.n	8000b98 <main+0xd4>
  if ( timeout < 0 )
 8000bae:	697b      	ldr	r3, [r7, #20]
 8000bb0:	2b00      	cmp	r3, #0
 8000bb2:	da01      	bge.n	8000bb8 <main+0xf4>
  {
  Error_Handler();
 8000bb4:	f000 fc10 	bl	80013d8 <Error_Handler>
  }
/* USER CODE END Boot_Mode_Sequence_1 */
  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8000bb8:	f001 f98c 	bl	8001ed4 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8000bbc:	f000 f896 	bl	8000cec <SystemClock_Config>
/* USER CODE BEGIN Boot_Mode_Sequence_2 */
/* When system initialization is finished, Cortex-M7 will release Cortex-M4 by means of
HSEM notification */
/*HW semaphore Clock enable*/
__HAL_RCC_HSEM_CLK_ENABLE();
 8000bc0:	4b3c      	ldr	r3, [pc, #240]	@ (8000cb4 <main+0x1f0>)
 8000bc2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8000bc6:	4a3b      	ldr	r2, [pc, #236]	@ (8000cb4 <main+0x1f0>)
 8000bc8:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 8000bcc:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8000bd0:	4b38      	ldr	r3, [pc, #224]	@ (8000cb4 <main+0x1f0>)
 8000bd2:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8000bd6:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8000bda:	607b      	str	r3, [r7, #4]
 8000bdc:	687b      	ldr	r3, [r7, #4]
/*Take HSEM */
HAL_HSEM_FastTake(HSEM_ID_0);
 8000bde:	2000      	movs	r0, #0
 8000be0:	f005 fc58 	bl	8006494 <HAL_HSEM_FastTake>
/*Release HSEM in order to notify the CPU2(CM4)*/
HAL_HSEM_Release(HSEM_ID_0,0);
 8000be4:	2100      	movs	r1, #0
 8000be6:	2000      	movs	r0, #0
 8000be8:	f005 fc6e 	bl	80064c8 <HAL_HSEM_Release>
/* wait until CPU2 wakes up from stop mode */
timeout = 0xFFFF;
 8000bec:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8000bf0:	617b      	str	r3, [r7, #20]
while((__HAL_RCC_GET_FLAG(RCC_FLAG_D2CKRDY) == RESET) && (timeout-- > 0));
 8000bf2:	bf00      	nop
 8000bf4:	4b2f      	ldr	r3, [pc, #188]	@ (8000cb4 <main+0x1f0>)
 8000bf6:	681b      	ldr	r3, [r3, #0]
 8000bf8:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8000bfc:	2b00      	cmp	r3, #0
 8000bfe:	d104      	bne.n	8000c0a <main+0x146>
 8000c00:	697b      	ldr	r3, [r7, #20]
 8000c02:	1e5a      	subs	r2, r3, #1
 8000c04:	617a      	str	r2, [r7, #20]
 8000c06:	2b00      	cmp	r3, #0
 8000c08:	dcf4      	bgt.n	8000bf4 <main+0x130>
if ( timeout < 0 )
 8000c0a:	697b      	ldr	r3, [r7, #20]
 8000c0c:	2b00      	cmp	r3, #0
 8000c0e:	da01      	bge.n	8000c14 <main+0x150>
{
Error_Handler();
 8000c10:	f000 fbe2 	bl	80013d8 <Error_Handler>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8000c14:	f000 fa6c 	bl	80010f0 <MX_GPIO_Init>
  MX_DMA_Init();
 8000c18:	f000 fa42 	bl	80010a0 <MX_DMA_Init>
  MX_USART3_UART_Init();
 8000c1c:	f000 f9f4 	bl	8001008 <MX_USART3_UART_Init>
  MX_I2C1_Init();
 8000c20:	f000 f964 	bl	8000eec <MX_I2C1_Init>
  MX_ADC1_Init();
 8000c24:	f000 f8d4 	bl	8000dd0 <MX_ADC1_Init>
  MX_TIM3_Init();
 8000c28:	f000 f9a0 	bl	8000f6c <MX_TIM3_Init>
  MX_X_CUBE_AI_Init();
 8000c2c:	f00f f89c 	bl	800fd68 <MX_X_CUBE_AI_Init>
  /* USER CODE BEGIN 2 */
//  HAL_DMA_Init(&hdma_adc1);
  HAL_ADCEx_Calibration_Start(&hadc1, ADC_CALIB_OFFSET, ADC_SINGLE_ENDED);
 8000c30:	f240 72ff 	movw	r2, #2047	@ 0x7ff
 8000c34:	2100      	movs	r1, #0
 8000c36:	4820      	ldr	r0, [pc, #128]	@ (8000cb8 <main+0x1f4>)
 8000c38:	f002 feb2 	bl	80039a0 <HAL_ADCEx_Calibration_Start>
  HAL_TIM_Base_Start(&htim3);
 8000c3c:	481f      	ldr	r0, [pc, #124]	@ (8000cbc <main+0x1f8>)
 8000c3e:	f00a f853 	bl	800ace8 <HAL_TIM_Base_Start>
  HAL_ADC_Start_DMA(&hadc1, (uint32_t *)&adc_buffer[currentBufferIndex], TOTAL_SAMPLES);
 8000c42:	4b1f      	ldr	r3, [pc, #124]	@ (8000cc0 <main+0x1fc>)
 8000c44:	881b      	ldrh	r3, [r3, #0]
 8000c46:	b29b      	uxth	r3, r3
 8000c48:	005b      	lsls	r3, r3, #1
 8000c4a:	4a1e      	ldr	r2, [pc, #120]	@ (8000cc4 <main+0x200>)
 8000c4c:	4413      	add	r3, r2
 8000c4e:	f44f 7248 	mov.w	r2, #800	@ 0x320
 8000c52:	4619      	mov	r1, r3
 8000c54:	4818      	ldr	r0, [pc, #96]	@ (8000cb8 <main+0x1f4>)
 8000c56:	f001 fda9 	bl	80027ac <HAL_ADC_Start_DMA>
  /* USER CODE END 2 */

  /* Init scheduler */
  osKernelInitialize();
 8000c5a:	f00b feed 	bl	800ca38 <osKernelInitialize>
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* creation of mainTask */
  mainTaskHandle = osThreadNew(StartMainTask, NULL, &mainTask_attributes);
 8000c5e:	4a1a      	ldr	r2, [pc, #104]	@ (8000cc8 <main+0x204>)
 8000c60:	2100      	movs	r1, #0
 8000c62:	481a      	ldr	r0, [pc, #104]	@ (8000ccc <main+0x208>)
 8000c64:	f00b ff32 	bl	800cacc <osThreadNew>
 8000c68:	4603      	mov	r3, r0
 8000c6a:	4a19      	ldr	r2, [pc, #100]	@ (8000cd0 <main+0x20c>)
 8000c6c:	6013      	str	r3, [r2, #0]

  /* creation of controllerTask */
  controllerTaskHandle = osThreadNew(startControllerTask, NULL, &controllerTask_attributes);
 8000c6e:	4a19      	ldr	r2, [pc, #100]	@ (8000cd4 <main+0x210>)
 8000c70:	2100      	movs	r1, #0
 8000c72:	4819      	ldr	r0, [pc, #100]	@ (8000cd8 <main+0x214>)
 8000c74:	f00b ff2a 	bl	800cacc <osThreadNew>
 8000c78:	4603      	mov	r3, r0
 8000c7a:	4a18      	ldr	r2, [pc, #96]	@ (8000cdc <main+0x218>)
 8000c7c:	6013      	str	r3, [r2, #0]

  /* creation of predictionTask */
  predictionTaskHandle = osThreadNew(startPredictionTask, NULL, &predictionTask_attributes);
 8000c7e:	4a18      	ldr	r2, [pc, #96]	@ (8000ce0 <main+0x21c>)
 8000c80:	2100      	movs	r1, #0
 8000c82:	4818      	ldr	r0, [pc, #96]	@ (8000ce4 <main+0x220>)
 8000c84:	f00b ff22 	bl	800cacc <osThreadNew>
 8000c88:	4603      	mov	r3, r0
 8000c8a:	4a17      	ldr	r2, [pc, #92]	@ (8000ce8 <main+0x224>)
 8000c8c:	6013      	str	r3, [r2, #0]
  /* USER CODE BEGIN RTOS_EVENTS */
  /* add events, ... */
  /* USER CODE END RTOS_EVENTS */

  /* Initialize leds */
  BSP_LED_Init(LED_GREEN);
 8000c8e:	2000      	movs	r0, #0
 8000c90:	f001 f814 	bl	8001cbc <BSP_LED_Init>
  BSP_LED_Init(LED_YELLOW);
 8000c94:	2001      	movs	r0, #1
 8000c96:	f001 f811 	bl	8001cbc <BSP_LED_Init>
  BSP_LED_Init(LED_RED);
 8000c9a:	2002      	movs	r0, #2
 8000c9c:	f001 f80e 	bl	8001cbc <BSP_LED_Init>

  /* Initialize USER push-button, will be used to trigger an interrupt each time it's pressed.*/
  BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);
 8000ca0:	2101      	movs	r1, #1
 8000ca2:	2000      	movs	r0, #0
 8000ca4:	f001 f880 	bl	8001da8 <BSP_PB_Init>

  /* Start scheduler */
  osKernelStart();
 8000ca8:	f00b feea 	bl	800ca80 <osKernelStart>

  /* We should never get here as control is now taken by the scheduler */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 8000cac:	bf00      	nop
 8000cae:	e7fd      	b.n	8000cac <main+0x1e8>
 8000cb0:	e000ed00 	.word	0xe000ed00
 8000cb4:	58024400 	.word	0x58024400
 8000cb8:	24000d5c 	.word	0x24000d5c
 8000cbc:	24000e8c 	.word	0x24000e8c
 8000cc0:	24001310 	.word	0x24001310
 8000cc4:	24000ff0 	.word	0x24000ff0
 8000cc8:	0801861c 	.word	0x0801861c
 8000ccc:	08001269 	.word	0x08001269
 8000cd0:	24000fe4 	.word	0x24000fe4
 8000cd4:	08018640 	.word	0x08018640
 8000cd8:	08001359 	.word	0x08001359
 8000cdc:	24000fe8 	.word	0x24000fe8
 8000ce0:	08018664 	.word	0x08018664
 8000ce4:	0800139d 	.word	0x0800139d
 8000ce8:	24000fec 	.word	0x24000fec

08000cec <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8000cec:	b580      	push	{r7, lr}
 8000cee:	b09c      	sub	sp, #112	@ 0x70
 8000cf0:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8000cf2:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8000cf6:	224c      	movs	r2, #76	@ 0x4c
 8000cf8:	2100      	movs	r1, #0
 8000cfa:	4618      	mov	r0, r3
 8000cfc:	f016 fbfa 	bl	80174f4 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000d00:	1d3b      	adds	r3, r7, #4
 8000d02:	2220      	movs	r2, #32
 8000d04:	2100      	movs	r1, #0
 8000d06:	4618      	mov	r0, r3
 8000d08:	f016 fbf4 	bl	80174f4 <memset>

  /** Supply configuration update enable
  */
  HAL_PWREx_ConfigSupply(PWR_DIRECT_SMPS_SUPPLY);
 8000d0c:	2004      	movs	r0, #4
 8000d0e:	f006 fa13 	bl	8007138 <HAL_PWREx_ConfigSupply>

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
 8000d12:	2300      	movs	r3, #0
 8000d14:	603b      	str	r3, [r7, #0]
 8000d16:	4b2b      	ldr	r3, [pc, #172]	@ (8000dc4 <SystemClock_Config+0xd8>)
 8000d18:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8000d1a:	4a2a      	ldr	r2, [pc, #168]	@ (8000dc4 <SystemClock_Config+0xd8>)
 8000d1c:	f023 0301 	bic.w	r3, r3, #1
 8000d20:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8000d22:	4b28      	ldr	r3, [pc, #160]	@ (8000dc4 <SystemClock_Config+0xd8>)
 8000d24:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8000d26:	f003 0301 	and.w	r3, r3, #1
 8000d2a:	603b      	str	r3, [r7, #0]
 8000d2c:	4b26      	ldr	r3, [pc, #152]	@ (8000dc8 <SystemClock_Config+0xdc>)
 8000d2e:	699b      	ldr	r3, [r3, #24]
 8000d30:	f423 4340 	bic.w	r3, r3, #49152	@ 0xc000
 8000d34:	4a24      	ldr	r2, [pc, #144]	@ (8000dc8 <SystemClock_Config+0xdc>)
 8000d36:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8000d3a:	6193      	str	r3, [r2, #24]
 8000d3c:	4b22      	ldr	r3, [pc, #136]	@ (8000dc8 <SystemClock_Config+0xdc>)
 8000d3e:	699b      	ldr	r3, [r3, #24]
 8000d40:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
 8000d44:	603b      	str	r3, [r7, #0]
 8000d46:	683b      	ldr	r3, [r7, #0]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
 8000d48:	bf00      	nop
 8000d4a:	4b1f      	ldr	r3, [pc, #124]	@ (8000dc8 <SystemClock_Config+0xdc>)
 8000d4c:	699b      	ldr	r3, [r3, #24]
 8000d4e:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8000d52:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8000d56:	d1f8      	bne.n	8000d4a <SystemClock_Config+0x5e>

  /** Macro to configure the PLL clock source
  */
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSI);
 8000d58:	4b1c      	ldr	r3, [pc, #112]	@ (8000dcc <SystemClock_Config+0xe0>)
 8000d5a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8000d5c:	4a1b      	ldr	r2, [pc, #108]	@ (8000dcc <SystemClock_Config+0xe0>)
 8000d5e:	f023 0303 	bic.w	r3, r3, #3
 8000d62:	6293      	str	r3, [r2, #40]	@ 0x28

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 8000d64:	2302      	movs	r3, #2
 8000d66:	627b      	str	r3, [r7, #36]	@ 0x24
  RCC_OscInitStruct.HSIState = RCC_HSI_DIV1;
 8000d68:	2301      	movs	r3, #1
 8000d6a:	633b      	str	r3, [r7, #48]	@ 0x30
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8000d6c:	2340      	movs	r3, #64	@ 0x40
 8000d6e:	637b      	str	r3, [r7, #52]	@ 0x34
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 8000d70:	2300      	movs	r3, #0
 8000d72:	64bb      	str	r3, [r7, #72]	@ 0x48
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000d74:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8000d78:	4618      	mov	r0, r3
 8000d7a:	f006 fa37 	bl	80071ec <HAL_RCC_OscConfig>
 8000d7e:	4603      	mov	r3, r0
 8000d80:	2b00      	cmp	r3, #0
 8000d82:	d001      	beq.n	8000d88 <SystemClock_Config+0x9c>
  {
    Error_Handler();
 8000d84:	f000 fb28 	bl	80013d8 <Error_Handler>
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000d88:	233f      	movs	r3, #63	@ 0x3f
 8000d8a:	607b      	str	r3, [r7, #4]
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
 8000d8c:	2300      	movs	r3, #0
 8000d8e:	60bb      	str	r3, [r7, #8]
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
 8000d90:	2300      	movs	r3, #0
 8000d92:	60fb      	str	r3, [r7, #12]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV1;
 8000d94:	2300      	movs	r3, #0
 8000d96:	613b      	str	r3, [r7, #16]
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV1;
 8000d98:	2300      	movs	r3, #0
 8000d9a:	617b      	str	r3, [r7, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
 8000d9c:	2340      	movs	r3, #64	@ 0x40
 8000d9e:	61bb      	str	r3, [r7, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV1;
 8000da0:	2300      	movs	r3, #0
 8000da2:	61fb      	str	r3, [r7, #28]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV1;
 8000da4:	2300      	movs	r3, #0
 8000da6:	623b      	str	r3, [r7, #32]

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8000da8:	1d3b      	adds	r3, r7, #4
 8000daa:	2101      	movs	r1, #1
 8000dac:	4618      	mov	r0, r3
 8000dae:	f006 fe77 	bl	8007aa0 <HAL_RCC_ClockConfig>
 8000db2:	4603      	mov	r3, r0
 8000db4:	2b00      	cmp	r3, #0
 8000db6:	d001      	beq.n	8000dbc <SystemClock_Config+0xd0>
  {
    Error_Handler();
 8000db8:	f000 fb0e 	bl	80013d8 <Error_Handler>
  }
}
 8000dbc:	bf00      	nop
 8000dbe:	3770      	adds	r7, #112	@ 0x70
 8000dc0:	46bd      	mov	sp, r7
 8000dc2:	bd80      	pop	{r7, pc}
 8000dc4:	58000400 	.word	0x58000400
 8000dc8:	58024800 	.word	0x58024800
 8000dcc:	58024400 	.word	0x58024400

08000dd0 <MX_ADC1_Init>:
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{
 8000dd0:	b580      	push	{r7, lr}
 8000dd2:	b08a      	sub	sp, #40	@ 0x28
 8000dd4:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_MultiModeTypeDef multimode = {0};
 8000dd6:	f107 031c 	add.w	r3, r7, #28
 8000dda:	2200      	movs	r2, #0
 8000ddc:	601a      	str	r2, [r3, #0]
 8000dde:	605a      	str	r2, [r3, #4]
 8000de0:	609a      	str	r2, [r3, #8]
  ADC_ChannelConfTypeDef sConfig = {0};
 8000de2:	463b      	mov	r3, r7
 8000de4:	2200      	movs	r2, #0
 8000de6:	601a      	str	r2, [r3, #0]
 8000de8:	605a      	str	r2, [r3, #4]
 8000dea:	609a      	str	r2, [r3, #8]
 8000dec:	60da      	str	r2, [r3, #12]
 8000dee:	611a      	str	r2, [r3, #16]
 8000df0:	615a      	str	r2, [r3, #20]
 8000df2:	619a      	str	r2, [r3, #24]

  /* USER CODE END ADC1_Init 1 */

  /** Common config
  */
  hadc1.Instance = ADC1;
 8000df4:	4b39      	ldr	r3, [pc, #228]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000df6:	4a3a      	ldr	r2, [pc, #232]	@ (8000ee0 <MX_ADC1_Init+0x110>)
 8000df8:	601a      	str	r2, [r3, #0]
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV2;
 8000dfa:	4b38      	ldr	r3, [pc, #224]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000dfc:	f44f 2280 	mov.w	r2, #262144	@ 0x40000
 8000e00:	605a      	str	r2, [r3, #4]
  hadc1.Init.Resolution = ADC_RESOLUTION_16B;
 8000e02:	4b36      	ldr	r3, [pc, #216]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000e04:	2200      	movs	r2, #0
 8000e06:	609a      	str	r2, [r3, #8]
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
 8000e08:	4b34      	ldr	r3, [pc, #208]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000e0a:	2201      	movs	r2, #1
 8000e0c:	60da      	str	r2, [r3, #12]
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 8000e0e:	4b33      	ldr	r3, [pc, #204]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000e10:	2208      	movs	r2, #8
 8000e12:	611a      	str	r2, [r3, #16]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 8000e14:	4b31      	ldr	r3, [pc, #196]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000e16:	2200      	movs	r2, #0
 8000e18:	751a      	strb	r2, [r3, #20]
  hadc1.Init.ContinuousConvMode = DISABLE;
 8000e1a:	4b30      	ldr	r3, [pc, #192]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000e1c:	2200      	movs	r2, #0
 8000e1e:	755a      	strb	r2, [r3, #21]
  hadc1.Init.NbrOfConversion = 2;
 8000e20:	4b2e      	ldr	r3, [pc, #184]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000e22:	2202      	movs	r2, #2
 8000e24:	619a      	str	r2, [r3, #24]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8000e26:	4b2d      	ldr	r3, [pc, #180]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000e28:	2200      	movs	r2, #0
 8000e2a:	771a      	strb	r2, [r3, #28]
  hadc1.Init.ExternalTrigConv = ADC_EXTERNALTRIG_T3_TRGO;
 8000e2c:	4b2b      	ldr	r3, [pc, #172]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000e2e:	f44f 6290 	mov.w	r2, #1152	@ 0x480
 8000e32:	625a      	str	r2, [r3, #36]	@ 0x24
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
 8000e34:	4b29      	ldr	r3, [pc, #164]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000e36:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8000e3a:	629a      	str	r2, [r3, #40]	@ 0x28
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
 8000e3c:	4b27      	ldr	r3, [pc, #156]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000e3e:	2203      	movs	r2, #3
 8000e40:	62da      	str	r2, [r3, #44]	@ 0x2c
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8000e42:	4b26      	ldr	r3, [pc, #152]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000e44:	2200      	movs	r2, #0
 8000e46:	631a      	str	r2, [r3, #48]	@ 0x30
  hadc1.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
 8000e48:	4b24      	ldr	r3, [pc, #144]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000e4a:	2200      	movs	r2, #0
 8000e4c:	635a      	str	r2, [r3, #52]	@ 0x34
  hadc1.Init.OversamplingMode = DISABLE;
 8000e4e:	4b23      	ldr	r3, [pc, #140]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000e50:	2200      	movs	r2, #0
 8000e52:	f883 2038 	strb.w	r2, [r3, #56]	@ 0x38
  hadc1.Init.Oversampling.Ratio = 1;
 8000e56:	4b21      	ldr	r3, [pc, #132]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000e58:	2201      	movs	r2, #1
 8000e5a:	63da      	str	r2, [r3, #60]	@ 0x3c
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8000e5c:	481f      	ldr	r0, [pc, #124]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000e5e:	f001 fb03 	bl	8002468 <HAL_ADC_Init>
 8000e62:	4603      	mov	r3, r0
 8000e64:	2b00      	cmp	r3, #0
 8000e66:	d001      	beq.n	8000e6c <MX_ADC1_Init+0x9c>
  {
    Error_Handler();
 8000e68:	f000 fab6 	bl	80013d8 <Error_Handler>
  }

  /** Configure the ADC multi-mode
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
 8000e6c:	2300      	movs	r3, #0
 8000e6e:	61fb      	str	r3, [r7, #28]
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
 8000e70:	f107 031c 	add.w	r3, r7, #28
 8000e74:	4619      	mov	r1, r3
 8000e76:	4819      	ldr	r0, [pc, #100]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000e78:	f002 fe28 	bl	8003acc <HAL_ADCEx_MultiModeConfigChannel>
 8000e7c:	4603      	mov	r3, r0
 8000e7e:	2b00      	cmp	r3, #0
 8000e80:	d001      	beq.n	8000e86 <MX_ADC1_Init+0xb6>
  {
    Error_Handler();
 8000e82:	f000 faa9 	bl	80013d8 <Error_Handler>
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_15;
 8000e86:	4b17      	ldr	r3, [pc, #92]	@ (8000ee4 <MX_ADC1_Init+0x114>)
 8000e88:	603b      	str	r3, [r7, #0]
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8000e8a:	2306      	movs	r3, #6
 8000e8c:	607b      	str	r3, [r7, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 8000e8e:	2300      	movs	r3, #0
 8000e90:	60bb      	str	r3, [r7, #8]
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8000e92:	f240 73ff 	movw	r3, #2047	@ 0x7ff
 8000e96:	60fb      	str	r3, [r7, #12]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 8000e98:	2304      	movs	r3, #4
 8000e9a:	613b      	str	r3, [r7, #16]
  sConfig.Offset = 0;
 8000e9c:	2300      	movs	r3, #0
 8000e9e:	617b      	str	r3, [r7, #20]
  sConfig.OffsetSignedSaturation = DISABLE;
 8000ea0:	2300      	movs	r3, #0
 8000ea2:	767b      	strb	r3, [r7, #25]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000ea4:	463b      	mov	r3, r7
 8000ea6:	4619      	mov	r1, r3
 8000ea8:	480c      	ldr	r0, [pc, #48]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000eaa:	f001 ffa5 	bl	8002df8 <HAL_ADC_ConfigChannel>
 8000eae:	4603      	mov	r3, r0
 8000eb0:	2b00      	cmp	r3, #0
 8000eb2:	d001      	beq.n	8000eb8 <MX_ADC1_Init+0xe8>
  {
    Error_Handler();
 8000eb4:	f000 fa90 	bl	80013d8 <Error_Handler>
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_10;
 8000eb8:	4b0b      	ldr	r3, [pc, #44]	@ (8000ee8 <MX_ADC1_Init+0x118>)
 8000eba:	603b      	str	r3, [r7, #0]
  sConfig.Rank = ADC_REGULAR_RANK_2;
 8000ebc:	230c      	movs	r3, #12
 8000ebe:	607b      	str	r3, [r7, #4]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8000ec0:	463b      	mov	r3, r7
 8000ec2:	4619      	mov	r1, r3
 8000ec4:	4805      	ldr	r0, [pc, #20]	@ (8000edc <MX_ADC1_Init+0x10c>)
 8000ec6:	f001 ff97 	bl	8002df8 <HAL_ADC_ConfigChannel>
 8000eca:	4603      	mov	r3, r0
 8000ecc:	2b00      	cmp	r3, #0
 8000ece:	d001      	beq.n	8000ed4 <MX_ADC1_Init+0x104>
  {
    Error_Handler();
 8000ed0:	f000 fa82 	bl	80013d8 <Error_Handler>
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}
 8000ed4:	bf00      	nop
 8000ed6:	3728      	adds	r7, #40	@ 0x28
 8000ed8:	46bd      	mov	sp, r7
 8000eda:	bd80      	pop	{r7, pc}
 8000edc:	24000d5c 	.word	0x24000d5c
 8000ee0:	40022000 	.word	0x40022000
 8000ee4:	3ef08000 	.word	0x3ef08000
 8000ee8:	2a000400 	.word	0x2a000400

08000eec <MX_I2C1_Init>:
  * @brief I2C1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C1_Init(void)
{
 8000eec:	b580      	push	{r7, lr}
 8000eee:	af00      	add	r7, sp, #0
  /* USER CODE END I2C1_Init 0 */

  /* USER CODE BEGIN I2C1_Init 1 */

  /* USER CODE END I2C1_Init 1 */
  hi2c1.Instance = I2C1;
 8000ef0:	4b1b      	ldr	r3, [pc, #108]	@ (8000f60 <MX_I2C1_Init+0x74>)
 8000ef2:	4a1c      	ldr	r2, [pc, #112]	@ (8000f64 <MX_I2C1_Init+0x78>)
 8000ef4:	601a      	str	r2, [r3, #0]
  hi2c1.Init.Timing = 0x00707CBB;
 8000ef6:	4b1a      	ldr	r3, [pc, #104]	@ (8000f60 <MX_I2C1_Init+0x74>)
 8000ef8:	4a1b      	ldr	r2, [pc, #108]	@ (8000f68 <MX_I2C1_Init+0x7c>)
 8000efa:	605a      	str	r2, [r3, #4]
  hi2c1.Init.OwnAddress1 = 0;
 8000efc:	4b18      	ldr	r3, [pc, #96]	@ (8000f60 <MX_I2C1_Init+0x74>)
 8000efe:	2200      	movs	r2, #0
 8000f00:	609a      	str	r2, [r3, #8]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8000f02:	4b17      	ldr	r3, [pc, #92]	@ (8000f60 <MX_I2C1_Init+0x74>)
 8000f04:	2201      	movs	r2, #1
 8000f06:	60da      	str	r2, [r3, #12]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8000f08:	4b15      	ldr	r3, [pc, #84]	@ (8000f60 <MX_I2C1_Init+0x74>)
 8000f0a:	2200      	movs	r2, #0
 8000f0c:	611a      	str	r2, [r3, #16]
  hi2c1.Init.OwnAddress2 = 0;
 8000f0e:	4b14      	ldr	r3, [pc, #80]	@ (8000f60 <MX_I2C1_Init+0x74>)
 8000f10:	2200      	movs	r2, #0
 8000f12:	615a      	str	r2, [r3, #20]
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 8000f14:	4b12      	ldr	r3, [pc, #72]	@ (8000f60 <MX_I2C1_Init+0x74>)
 8000f16:	2200      	movs	r2, #0
 8000f18:	619a      	str	r2, [r3, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8000f1a:	4b11      	ldr	r3, [pc, #68]	@ (8000f60 <MX_I2C1_Init+0x74>)
 8000f1c:	2200      	movs	r2, #0
 8000f1e:	61da      	str	r2, [r3, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8000f20:	4b0f      	ldr	r3, [pc, #60]	@ (8000f60 <MX_I2C1_Init+0x74>)
 8000f22:	2200      	movs	r2, #0
 8000f24:	621a      	str	r2, [r3, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8000f26:	480e      	ldr	r0, [pc, #56]	@ (8000f60 <MX_I2C1_Init+0x74>)
 8000f28:	f005 fae2 	bl	80064f0 <HAL_I2C_Init>
 8000f2c:	4603      	mov	r3, r0
 8000f2e:	2b00      	cmp	r3, #0
 8000f30:	d001      	beq.n	8000f36 <MX_I2C1_Init+0x4a>
  {
    Error_Handler();
 8000f32:	f000 fa51 	bl	80013d8 <Error_Handler>
  }

  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 8000f36:	2100      	movs	r1, #0
 8000f38:	4809      	ldr	r0, [pc, #36]	@ (8000f60 <MX_I2C1_Init+0x74>)
 8000f3a:	f006 f865 	bl	8007008 <HAL_I2CEx_ConfigAnalogFilter>
 8000f3e:	4603      	mov	r3, r0
 8000f40:	2b00      	cmp	r3, #0
 8000f42:	d001      	beq.n	8000f48 <MX_I2C1_Init+0x5c>
  {
    Error_Handler();
 8000f44:	f000 fa48 	bl	80013d8 <Error_Handler>
  }

  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 8000f48:	2100      	movs	r1, #0
 8000f4a:	4805      	ldr	r0, [pc, #20]	@ (8000f60 <MX_I2C1_Init+0x74>)
 8000f4c:	f006 f8a7 	bl	800709e <HAL_I2CEx_ConfigDigitalFilter>
 8000f50:	4603      	mov	r3, r0
 8000f52:	2b00      	cmp	r3, #0
 8000f54:	d001      	beq.n	8000f5a <MX_I2C1_Init+0x6e>
  {
    Error_Handler();
 8000f56:	f000 fa3f 	bl	80013d8 <Error_Handler>
  }
  /* USER CODE BEGIN I2C1_Init 2 */

  /* USER CODE END I2C1_Init 2 */

}
 8000f5a:	bf00      	nop
 8000f5c:	bd80      	pop	{r7, pc}
 8000f5e:	bf00      	nop
 8000f60:	24000e38 	.word	0x24000e38
 8000f64:	40005400 	.word	0x40005400
 8000f68:	00707cbb 	.word	0x00707cbb

08000f6c <MX_TIM3_Init>:
  * @brief TIM3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM3_Init(void)
{
 8000f6c:	b580      	push	{r7, lr}
 8000f6e:	b088      	sub	sp, #32
 8000f70:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM3_Init 0 */

  /* USER CODE END TIM3_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8000f72:	f107 0310 	add.w	r3, r7, #16
 8000f76:	2200      	movs	r2, #0
 8000f78:	601a      	str	r2, [r3, #0]
 8000f7a:	605a      	str	r2, [r3, #4]
 8000f7c:	609a      	str	r2, [r3, #8]
 8000f7e:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8000f80:	1d3b      	adds	r3, r7, #4
 8000f82:	2200      	movs	r2, #0
 8000f84:	601a      	str	r2, [r3, #0]
 8000f86:	605a      	str	r2, [r3, #4]
 8000f88:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  htim3.Instance = TIM3;
 8000f8a:	4b1d      	ldr	r3, [pc, #116]	@ (8001000 <MX_TIM3_Init+0x94>)
 8000f8c:	4a1d      	ldr	r2, [pc, #116]	@ (8001004 <MX_TIM3_Init+0x98>)
 8000f8e:	601a      	str	r2, [r3, #0]
  htim3.Init.Prescaler = 6399;
 8000f90:	4b1b      	ldr	r3, [pc, #108]	@ (8001000 <MX_TIM3_Init+0x94>)
 8000f92:	f641 02ff 	movw	r2, #6399	@ 0x18ff
 8000f96:	605a      	str	r2, [r3, #4]
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000f98:	4b19      	ldr	r3, [pc, #100]	@ (8001000 <MX_TIM3_Init+0x94>)
 8000f9a:	2200      	movs	r2, #0
 8000f9c:	609a      	str	r2, [r3, #8]
  htim3.Init.Period = 9;
 8000f9e:	4b18      	ldr	r3, [pc, #96]	@ (8001000 <MX_TIM3_Init+0x94>)
 8000fa0:	2209      	movs	r2, #9
 8000fa2:	60da      	str	r2, [r3, #12]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8000fa4:	4b16      	ldr	r3, [pc, #88]	@ (8001000 <MX_TIM3_Init+0x94>)
 8000fa6:	2200      	movs	r2, #0
 8000fa8:	611a      	str	r2, [r3, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8000faa:	4b15      	ldr	r3, [pc, #84]	@ (8001000 <MX_TIM3_Init+0x94>)
 8000fac:	2200      	movs	r2, #0
 8000fae:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 8000fb0:	4813      	ldr	r0, [pc, #76]	@ (8001000 <MX_TIM3_Init+0x94>)
 8000fb2:	f009 fe41 	bl	800ac38 <HAL_TIM_Base_Init>
 8000fb6:	4603      	mov	r3, r0
 8000fb8:	2b00      	cmp	r3, #0
 8000fba:	d001      	beq.n	8000fc0 <MX_TIM3_Init+0x54>
  {
    Error_Handler();
 8000fbc:	f000 fa0c 	bl	80013d8 <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8000fc0:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8000fc4:	613b      	str	r3, [r7, #16]
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8000fc6:	f107 0310 	add.w	r3, r7, #16
 8000fca:	4619      	mov	r1, r3
 8000fcc:	480c      	ldr	r0, [pc, #48]	@ (8001000 <MX_TIM3_Init+0x94>)
 8000fce:	f00a f87b 	bl	800b0c8 <HAL_TIM_ConfigClockSource>
 8000fd2:	4603      	mov	r3, r0
 8000fd4:	2b00      	cmp	r3, #0
 8000fd6:	d001      	beq.n	8000fdc <MX_TIM3_Init+0x70>
  {
    Error_Handler();
 8000fd8:	f000 f9fe 	bl	80013d8 <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
 8000fdc:	2320      	movs	r3, #32
 8000fde:	607b      	str	r3, [r7, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8000fe0:	2300      	movs	r3, #0
 8000fe2:	60fb      	str	r3, [r7, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8000fe4:	1d3b      	adds	r3, r7, #4
 8000fe6:	4619      	mov	r1, r3
 8000fe8:	4805      	ldr	r0, [pc, #20]	@ (8001000 <MX_TIM3_Init+0x94>)
 8000fea:	f00a facb 	bl	800b584 <HAL_TIMEx_MasterConfigSynchronization>
 8000fee:	4603      	mov	r3, r0
 8000ff0:	2b00      	cmp	r3, #0
 8000ff2:	d001      	beq.n	8000ff8 <MX_TIM3_Init+0x8c>
  {
    Error_Handler();
 8000ff4:	f000 f9f0 	bl	80013d8 <Error_Handler>
  }
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */

}
 8000ff8:	bf00      	nop
 8000ffa:	3720      	adds	r7, #32
 8000ffc:	46bd      	mov	sp, r7
 8000ffe:	bd80      	pop	{r7, pc}
 8001000:	24000e8c 	.word	0x24000e8c
 8001004:	40000400 	.word	0x40000400

08001008 <MX_USART3_UART_Init>:
  * @brief USART3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART3_UART_Init(void)
{
 8001008:	b580      	push	{r7, lr}
 800100a:	af00      	add	r7, sp, #0
  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
 800100c:	4b22      	ldr	r3, [pc, #136]	@ (8001098 <MX_USART3_UART_Init+0x90>)
 800100e:	4a23      	ldr	r2, [pc, #140]	@ (800109c <MX_USART3_UART_Init+0x94>)
 8001010:	601a      	str	r2, [r3, #0]
  huart3.Init.BaudRate = 921600;
 8001012:	4b21      	ldr	r3, [pc, #132]	@ (8001098 <MX_USART3_UART_Init+0x90>)
 8001014:	f44f 2261 	mov.w	r2, #921600	@ 0xe1000
 8001018:	605a      	str	r2, [r3, #4]
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
 800101a:	4b1f      	ldr	r3, [pc, #124]	@ (8001098 <MX_USART3_UART_Init+0x90>)
 800101c:	2200      	movs	r2, #0
 800101e:	609a      	str	r2, [r3, #8]
  huart3.Init.StopBits = UART_STOPBITS_1;
 8001020:	4b1d      	ldr	r3, [pc, #116]	@ (8001098 <MX_USART3_UART_Init+0x90>)
 8001022:	2200      	movs	r2, #0
 8001024:	60da      	str	r2, [r3, #12]
  huart3.Init.Parity = UART_PARITY_NONE;
 8001026:	4b1c      	ldr	r3, [pc, #112]	@ (8001098 <MX_USART3_UART_Init+0x90>)
 8001028:	2200      	movs	r2, #0
 800102a:	611a      	str	r2, [r3, #16]
  huart3.Init.Mode = UART_MODE_TX_RX;
 800102c:	4b1a      	ldr	r3, [pc, #104]	@ (8001098 <MX_USART3_UART_Init+0x90>)
 800102e:	220c      	movs	r2, #12
 8001030:	615a      	str	r2, [r3, #20]
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8001032:	4b19      	ldr	r3, [pc, #100]	@ (8001098 <MX_USART3_UART_Init+0x90>)
 8001034:	2200      	movs	r2, #0
 8001036:	619a      	str	r2, [r3, #24]
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
 8001038:	4b17      	ldr	r3, [pc, #92]	@ (8001098 <MX_USART3_UART_Init+0x90>)
 800103a:	2200      	movs	r2, #0
 800103c:	61da      	str	r2, [r3, #28]
  huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800103e:	4b16      	ldr	r3, [pc, #88]	@ (8001098 <MX_USART3_UART_Init+0x90>)
 8001040:	2200      	movs	r2, #0
 8001042:	621a      	str	r2, [r3, #32]
  huart3.Init.ClockPrescaler = UART_PRESCALER_DIV1;
 8001044:	4b14      	ldr	r3, [pc, #80]	@ (8001098 <MX_USART3_UART_Init+0x90>)
 8001046:	2200      	movs	r2, #0
 8001048:	625a      	str	r2, [r3, #36]	@ 0x24
  huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800104a:	4b13      	ldr	r3, [pc, #76]	@ (8001098 <MX_USART3_UART_Init+0x90>)
 800104c:	2200      	movs	r2, #0
 800104e:	629a      	str	r2, [r3, #40]	@ 0x28
  if (HAL_UART_Init(&huart3) != HAL_OK)
 8001050:	4811      	ldr	r0, [pc, #68]	@ (8001098 <MX_USART3_UART_Init+0x90>)
 8001052:	f00a fb43 	bl	800b6dc <HAL_UART_Init>
 8001056:	4603      	mov	r3, r0
 8001058:	2b00      	cmp	r3, #0
 800105a:	d001      	beq.n	8001060 <MX_USART3_UART_Init+0x58>
  {
    Error_Handler();
 800105c:	f000 f9bc 	bl	80013d8 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart3, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
 8001060:	2100      	movs	r1, #0
 8001062:	480d      	ldr	r0, [pc, #52]	@ (8001098 <MX_USART3_UART_Init+0x90>)
 8001064:	f00b fbd9 	bl	800c81a <HAL_UARTEx_SetTxFifoThreshold>
 8001068:	4603      	mov	r3, r0
 800106a:	2b00      	cmp	r3, #0
 800106c:	d001      	beq.n	8001072 <MX_USART3_UART_Init+0x6a>
  {
    Error_Handler();
 800106e:	f000 f9b3 	bl	80013d8 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart3, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
 8001072:	2100      	movs	r1, #0
 8001074:	4808      	ldr	r0, [pc, #32]	@ (8001098 <MX_USART3_UART_Init+0x90>)
 8001076:	f00b fc0e 	bl	800c896 <HAL_UARTEx_SetRxFifoThreshold>
 800107a:	4603      	mov	r3, r0
 800107c:	2b00      	cmp	r3, #0
 800107e:	d001      	beq.n	8001084 <MX_USART3_UART_Init+0x7c>
  {
    Error_Handler();
 8001080:	f000 f9aa 	bl	80013d8 <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&huart3) != HAL_OK)
 8001084:	4804      	ldr	r0, [pc, #16]	@ (8001098 <MX_USART3_UART_Init+0x90>)
 8001086:	f00b fb8f 	bl	800c7a8 <HAL_UARTEx_DisableFifoMode>
 800108a:	4603      	mov	r3, r0
 800108c:	2b00      	cmp	r3, #0
 800108e:	d001      	beq.n	8001094 <MX_USART3_UART_Init+0x8c>
  {
    Error_Handler();
 8001090:	f000 f9a2 	bl	80013d8 <Error_Handler>
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}
 8001094:	bf00      	nop
 8001096:	bd80      	pop	{r7, pc}
 8001098:	24000ed8 	.word	0x24000ed8
 800109c:	40004800 	.word	0x40004800

080010a0 <MX_DMA_Init>:

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{
 80010a0:	b580      	push	{r7, lr}
 80010a2:	b082      	sub	sp, #8
 80010a4:	af00      	add	r7, sp, #0

  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
 80010a6:	4b11      	ldr	r3, [pc, #68]	@ (80010ec <MX_DMA_Init+0x4c>)
 80010a8:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 80010ac:	4a0f      	ldr	r2, [pc, #60]	@ (80010ec <MX_DMA_Init+0x4c>)
 80010ae:	f043 0301 	orr.w	r3, r3, #1
 80010b2:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
 80010b6:	4b0d      	ldr	r3, [pc, #52]	@ (80010ec <MX_DMA_Init+0x4c>)
 80010b8:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 80010bc:	f003 0301 	and.w	r3, r3, #1
 80010c0:	607b      	str	r3, [r7, #4]
 80010c2:	687b      	ldr	r3, [r7, #4]

  /* DMA interrupt init */
  /* DMA1_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream0_IRQn, 5, 0);
 80010c4:	2200      	movs	r2, #0
 80010c6:	2105      	movs	r1, #5
 80010c8:	200b      	movs	r0, #11
 80010ca:	f002 fe95 	bl	8003df8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream0_IRQn);
 80010ce:	200b      	movs	r0, #11
 80010d0:	f002 feac 	bl	8003e2c <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 5, 0);
 80010d4:	2200      	movs	r2, #0
 80010d6:	2105      	movs	r1, #5
 80010d8:	200c      	movs	r0, #12
 80010da:	f002 fe8d 	bl	8003df8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
 80010de:	200c      	movs	r0, #12
 80010e0:	f002 fea4 	bl	8003e2c <HAL_NVIC_EnableIRQ>

}
 80010e4:	bf00      	nop
 80010e6:	3708      	adds	r7, #8
 80010e8:	46bd      	mov	sp, r7
 80010ea:	bd80      	pop	{r7, pc}
 80010ec:	58024400 	.word	0x58024400

080010f0 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 80010f0:	b580      	push	{r7, lr}
 80010f2:	b08a      	sub	sp, #40	@ 0x28
 80010f4:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80010f6:	f107 0314 	add.w	r3, r7, #20
 80010fa:	2200      	movs	r2, #0
 80010fc:	601a      	str	r2, [r3, #0]
 80010fe:	605a      	str	r2, [r3, #4]
 8001100:	609a      	str	r2, [r3, #8]
 8001102:	60da      	str	r2, [r3, #12]
 8001104:	611a      	str	r2, [r3, #16]
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8001106:	4b52      	ldr	r3, [pc, #328]	@ (8001250 <MX_GPIO_Init+0x160>)
 8001108:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800110c:	4a50      	ldr	r2, [pc, #320]	@ (8001250 <MX_GPIO_Init+0x160>)
 800110e:	f043 0304 	orr.w	r3, r3, #4
 8001112:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8001116:	4b4e      	ldr	r3, [pc, #312]	@ (8001250 <MX_GPIO_Init+0x160>)
 8001118:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800111c:	f003 0304 	and.w	r3, r3, #4
 8001120:	613b      	str	r3, [r7, #16]
 8001122:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8001124:	4b4a      	ldr	r3, [pc, #296]	@ (8001250 <MX_GPIO_Init+0x160>)
 8001126:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800112a:	4a49      	ldr	r2, [pc, #292]	@ (8001250 <MX_GPIO_Init+0x160>)
 800112c:	f043 0301 	orr.w	r3, r3, #1
 8001130:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8001134:	4b46      	ldr	r3, [pc, #280]	@ (8001250 <MX_GPIO_Init+0x160>)
 8001136:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800113a:	f003 0301 	and.w	r3, r3, #1
 800113e:	60fb      	str	r3, [r7, #12]
 8001140:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8001142:	4b43      	ldr	r3, [pc, #268]	@ (8001250 <MX_GPIO_Init+0x160>)
 8001144:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001148:	4a41      	ldr	r2, [pc, #260]	@ (8001250 <MX_GPIO_Init+0x160>)
 800114a:	f043 0302 	orr.w	r3, r3, #2
 800114e:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8001152:	4b3f      	ldr	r3, [pc, #252]	@ (8001250 <MX_GPIO_Init+0x160>)
 8001154:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001158:	f003 0302 	and.w	r3, r3, #2
 800115c:	60bb      	str	r3, [r7, #8]
 800115e:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8001160:	4b3b      	ldr	r3, [pc, #236]	@ (8001250 <MX_GPIO_Init+0x160>)
 8001162:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001166:	4a3a      	ldr	r2, [pc, #232]	@ (8001250 <MX_GPIO_Init+0x160>)
 8001168:	f043 0308 	orr.w	r3, r3, #8
 800116c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8001170:	4b37      	ldr	r3, [pc, #220]	@ (8001250 <MX_GPIO_Init+0x160>)
 8001172:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001176:	f003 0308 	and.w	r3, r3, #8
 800117a:	607b      	str	r3, [r7, #4]
 800117c:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 800117e:	4b34      	ldr	r3, [pc, #208]	@ (8001250 <MX_GPIO_Init+0x160>)
 8001180:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001184:	4a32      	ldr	r2, [pc, #200]	@ (8001250 <MX_GPIO_Init+0x160>)
 8001186:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 800118a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 800118e:	4b30      	ldr	r3, [pc, #192]	@ (8001250 <MX_GPIO_Init+0x160>)
 8001190:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001194:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8001198:	603b      	str	r3, [r7, #0]
 800119a:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOD, THUMB_Pin|INDEX_Pin|OTHER_SOL_Pin|PUMP_Pin, GPIO_PIN_RESET);
 800119c:	2200      	movs	r2, #0
 800119e:	21f0      	movs	r1, #240	@ 0xf0
 80011a0:	482c      	ldr	r0, [pc, #176]	@ (8001254 <MX_GPIO_Init+0x164>)
 80011a2:	f005 f95d 	bl	8006460 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PC1 PC4 PC5 */
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5;
 80011a6:	2332      	movs	r3, #50	@ 0x32
 80011a8:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80011aa:	2302      	movs	r3, #2
 80011ac:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80011ae:	2300      	movs	r3, #0
 80011b0:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80011b2:	2300      	movs	r3, #0
 80011b4:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 80011b6:	230b      	movs	r3, #11
 80011b8:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80011ba:	f107 0314 	add.w	r3, r7, #20
 80011be:	4619      	mov	r1, r3
 80011c0:	4825      	ldr	r0, [pc, #148]	@ (8001258 <MX_GPIO_Init+0x168>)
 80011c2:	f004 ff9d 	bl	8006100 <HAL_GPIO_Init>

  /*Configure GPIO pins : PA1 PA2 PA7 */
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_7;
 80011c6:	2386      	movs	r3, #134	@ 0x86
 80011c8:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80011ca:	2302      	movs	r3, #2
 80011cc:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80011ce:	2300      	movs	r3, #0
 80011d0:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80011d2:	2300      	movs	r3, #0
 80011d4:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 80011d6:	230b      	movs	r3, #11
 80011d8:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80011da:	f107 0314 	add.w	r3, r7, #20
 80011de:	4619      	mov	r1, r3
 80011e0:	481e      	ldr	r0, [pc, #120]	@ (800125c <MX_GPIO_Init+0x16c>)
 80011e2:	f004 ff8d 	bl	8006100 <HAL_GPIO_Init>

  /*Configure GPIO pin : PB13 */
  GPIO_InitStruct.Pin = GPIO_PIN_13;
 80011e6:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 80011ea:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80011ec:	2302      	movs	r3, #2
 80011ee:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80011f0:	2300      	movs	r3, #0
 80011f2:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80011f4:	2300      	movs	r3, #0
 80011f6:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 80011f8:	230b      	movs	r3, #11
 80011fa:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80011fc:	f107 0314 	add.w	r3, r7, #20
 8001200:	4619      	mov	r1, r3
 8001202:	4817      	ldr	r0, [pc, #92]	@ (8001260 <MX_GPIO_Init+0x170>)
 8001204:	f004 ff7c 	bl	8006100 <HAL_GPIO_Init>

  /*Configure GPIO pins : THUMB_Pin INDEX_Pin OTHER_SOL_Pin PUMP_Pin */
  GPIO_InitStruct.Pin = THUMB_Pin|INDEX_Pin|OTHER_SOL_Pin|PUMP_Pin;
 8001208:	23f0      	movs	r3, #240	@ 0xf0
 800120a:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800120c:	2301      	movs	r3, #1
 800120e:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001210:	2300      	movs	r3, #0
 8001212:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001214:	2300      	movs	r3, #0
 8001216:	623b      	str	r3, [r7, #32]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8001218:	f107 0314 	add.w	r3, r7, #20
 800121c:	4619      	mov	r1, r3
 800121e:	480d      	ldr	r0, [pc, #52]	@ (8001254 <MX_GPIO_Init+0x164>)
 8001220:	f004 ff6e 	bl	8006100 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG11 PG13 */
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_13;
 8001224:	f44f 5320 	mov.w	r3, #10240	@ 0x2800
 8001228:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800122a:	2302      	movs	r3, #2
 800122c:	61bb      	str	r3, [r7, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800122e:	2300      	movs	r3, #0
 8001230:	61fb      	str	r3, [r7, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001232:	2300      	movs	r3, #0
 8001234:	623b      	str	r3, [r7, #32]
  GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 8001236:	230b      	movs	r3, #11
 8001238:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 800123a:	f107 0314 	add.w	r3, r7, #20
 800123e:	4619      	mov	r1, r3
 8001240:	4808      	ldr	r0, [pc, #32]	@ (8001264 <MX_GPIO_Init+0x174>)
 8001242:	f004 ff5d 	bl	8006100 <HAL_GPIO_Init>

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}
 8001246:	bf00      	nop
 8001248:	3728      	adds	r7, #40	@ 0x28
 800124a:	46bd      	mov	sp, r7
 800124c:	bd80      	pop	{r7, pc}
 800124e:	bf00      	nop
 8001250:	58024400 	.word	0x58024400
 8001254:	58020c00 	.word	0x58020c00
 8001258:	58020800 	.word	0x58020800
 800125c:	58020000 	.word	0x58020000
 8001260:	58020400 	.word	0x58020400
 8001264:	58021800 	.word	0x58021800

08001268 <StartMainTask>:
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_StartMainTask */
void StartMainTask(void *argument)
{
 8001268:	b590      	push	{r4, r7, lr}
 800126a:	b0bf      	sub	sp, #252	@ 0xfc
 800126c:	af1a      	add	r7, sp, #104	@ 0x68
 800126e:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN 5 */
  handState_t prev_hand_state = state;
 8001270:	4b2f      	ldr	r3, [pc, #188]	@ (8001330 <StartMainTask+0xc8>)
 8001272:	781b      	ldrb	r3, [r3, #0]
 8001274:	f887 308f 	strb.w	r3, [r7, #143]	@ 0x8f
  char msg[128];
  sprintf(msg, "Hello");
 8001278:	f107 030c 	add.w	r3, r7, #12
 800127c:	492d      	ldr	r1, [pc, #180]	@ (8001334 <StartMainTask+0xcc>)
 800127e:	4618      	mov	r0, r3
 8001280:	f016 f826 	bl	80172d0 <siprintf>
  HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
 8001284:	f107 030c 	add.w	r3, r7, #12
 8001288:	4618      	mov	r0, r3
 800128a:	f7ff f829 	bl	80002e0 <strlen>
 800128e:	4603      	mov	r3, r0
 8001290:	b29a      	uxth	r2, r3
 8001292:	f107 010c 	add.w	r1, r7, #12
 8001296:	f04f 33ff 	mov.w	r3, #4294967295
 800129a:	4827      	ldr	r0, [pc, #156]	@ (8001338 <StartMainTask+0xd0>)
 800129c:	f00a fa6e 	bl	800b77c <HAL_UART_Transmit>
  /* Infinite loop */
  for(;;)
  {
	if (prev_hand_state != state) {
 80012a0:	4b23      	ldr	r3, [pc, #140]	@ (8001330 <StartMainTask+0xc8>)
 80012a2:	781b      	ldrb	r3, [r3, #0]
 80012a4:	f897 208f 	ldrb.w	r2, [r7, #143]	@ 0x8f
 80012a8:	429a      	cmp	r2, r3
 80012aa:	d016      	beq.n	80012da <StartMainTask+0x72>
		sprintf(msg, "State: %d/n", state);
 80012ac:	4b20      	ldr	r3, [pc, #128]	@ (8001330 <StartMainTask+0xc8>)
 80012ae:	781b      	ldrb	r3, [r3, #0]
 80012b0:	461a      	mov	r2, r3
 80012b2:	f107 030c 	add.w	r3, r7, #12
 80012b6:	4921      	ldr	r1, [pc, #132]	@ (800133c <StartMainTask+0xd4>)
 80012b8:	4618      	mov	r0, r3
 80012ba:	f016 f809 	bl	80172d0 <siprintf>
		HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
 80012be:	f107 030c 	add.w	r3, r7, #12
 80012c2:	4618      	mov	r0, r3
 80012c4:	f7ff f80c 	bl	80002e0 <strlen>
 80012c8:	4603      	mov	r3, r0
 80012ca:	b29a      	uxth	r2, r3
 80012cc:	f107 010c 	add.w	r1, r7, #12
 80012d0:	f04f 33ff 	mov.w	r3, #4294967295
 80012d4:	4818      	ldr	r0, [pc, #96]	@ (8001338 <StartMainTask+0xd0>)
 80012d6:	f00a fa51 	bl	800b77c <HAL_UART_Transmit>
	}

	readPressureSensor(hi2c1, &pressure);
 80012da:	4c19      	ldr	r4, [pc, #100]	@ (8001340 <StartMainTask+0xd8>)
 80012dc:	4b19      	ldr	r3, [pc, #100]	@ (8001344 <StartMainTask+0xdc>)
 80012de:	9311      	str	r3, [sp, #68]	@ 0x44
 80012e0:	4668      	mov	r0, sp
 80012e2:	f104 0310 	add.w	r3, r4, #16
 80012e6:	2244      	movs	r2, #68	@ 0x44
 80012e8:	4619      	mov	r1, r3
 80012ea:	f016 f98e 	bl	801760a <memcpy>
 80012ee:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 80012f2:	f000 fb7b 	bl	80019ec <readPressureSensor>
	Process_ADC_Data(adc_buffer, sensor_averages);
 80012f6:	4914      	ldr	r1, [pc, #80]	@ (8001348 <StartMainTask+0xe0>)
 80012f8:	4814      	ldr	r0, [pc, #80]	@ (800134c <StartMainTask+0xe4>)
 80012fa:	f000 fbd9 	bl	8001ab0 <Process_ADC_Data>

	dma_position = get_dma_position(hdma_adc1);
 80012fe:	4c14      	ldr	r4, [pc, #80]	@ (8001350 <StartMainTask+0xe8>)
 8001300:	4668      	mov	r0, sp
 8001302:	f104 0310 	add.w	r3, r4, #16
 8001306:	2268      	movs	r2, #104	@ 0x68
 8001308:	4619      	mov	r1, r3
 800130a:	f016 f97e 	bl	801760a <memcpy>
 800130e:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8001312:	f000 fc1d 	bl	8001b50 <get_dma_position>
 8001316:	4603      	mov	r3, r0
 8001318:	461a      	mov	r2, r3
 800131a:	4b0e      	ldr	r3, [pc, #56]	@ (8001354 <StartMainTask+0xec>)
 800131c:	601a      	str	r2, [r3, #0]

	prev_hand_state = state;
 800131e:	4b04      	ldr	r3, [pc, #16]	@ (8001330 <StartMainTask+0xc8>)
 8001320:	781b      	ldrb	r3, [r3, #0]
 8001322:	f887 308f 	strb.w	r3, [r7, #143]	@ 0x8f

	osDelay(50);
 8001326:	2032      	movs	r0, #50	@ 0x32
 8001328:	f00b fc62 	bl	800cbf0 <osDelay>
  {
 800132c:	e7b8      	b.n	80012a0 <StartMainTask+0x38>
 800132e:	bf00      	nop
 8001330:	24001324 	.word	0x24001324
 8001334:	080183ac 	.word	0x080183ac
 8001338:	24000ed8 	.word	0x24000ed8
 800133c:	080183b4 	.word	0x080183b4
 8001340:	24000e38 	.word	0x24000e38
 8001344:	24001320 	.word	0x24001320
 8001348:	24001314 	.word	0x24001314
 800134c:	24000ff0 	.word	0x24000ff0
 8001350:	24000dc0 	.word	0x24000dc0
 8001354:	2400131c 	.word	0x2400131c

08001358 <startControllerTask>:
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_startControllerTask */
void startControllerTask(void *argument)
{
 8001358:	b580      	push	{r7, lr}
 800135a:	b084      	sub	sp, #16
 800135c:	af00      	add	r7, sp, #0
 800135e:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN startControllerTask */
  float p = 110.0;
 8001360:	4b0b      	ldr	r3, [pc, #44]	@ (8001390 <startControllerTask+0x38>)
 8001362:	60bb      	str	r3, [r7, #8]
  float target = 120.0;
 8001364:	4b0b      	ldr	r3, [pc, #44]	@ (8001394 <startControllerTask+0x3c>)
 8001366:	60fb      	str	r3, [r7, #12]
  /* Infinite loop */
  for(;;)
  {
	pressureController(&p, target, state);
 8001368:	edd7 7a03 	vldr	s15, [r7, #12]
 800136c:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
 8001370:	4b09      	ldr	r3, [pc, #36]	@ (8001398 <startControllerTask+0x40>)
 8001372:	781b      	ldrb	r3, [r3, #0]
 8001374:	461a      	mov	r2, r3
 8001376:	f107 0308 	add.w	r3, r7, #8
 800137a:	4611      	mov	r1, r2
 800137c:	eeb0 0b47 	vmov.f64	d0, d7
 8001380:	4618      	mov	r0, r3
 8001382:	f7ff fb51 	bl	8000a28 <pressureController>
    osDelay(25);
 8001386:	2019      	movs	r0, #25
 8001388:	f00b fc32 	bl	800cbf0 <osDelay>
  {
 800138c:	bf00      	nop
 800138e:	e7eb      	b.n	8001368 <startControllerTask+0x10>
 8001390:	42dc0000 	.word	0x42dc0000
 8001394:	42f00000 	.word	0x42f00000
 8001398:	24001324 	.word	0x24001324

0800139c <startPredictionTask>:
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_startPredictionTask */
void startPredictionTask(void *argument)
{
 800139c:	b580      	push	{r7, lr}
 800139e:	b082      	sub	sp, #8
 80013a0:	af00      	add	r7, sp, #0
 80013a2:	6078      	str	r0, [r7, #4]
		state = OPEN;
    osDelay(10);
  }*/
	for(;;)
	{
		MX_X_CUBE_AI_Process();
 80013a4:	f00e fcee 	bl	800fd84 <MX_X_CUBE_AI_Process>
		osDelay(50);
 80013a8:	2032      	movs	r0, #50	@ 0x32
 80013aa:	f00b fc21 	bl	800cbf0 <osDelay>
		MX_X_CUBE_AI_Process();
 80013ae:	bf00      	nop
 80013b0:	e7f8      	b.n	80013a4 <startPredictionTask+0x8>
	...

080013b4 <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 80013b4:	b580      	push	{r7, lr}
 80013b6:	b082      	sub	sp, #8
 80013b8:	af00      	add	r7, sp, #0
 80013ba:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM6) {
 80013bc:	687b      	ldr	r3, [r7, #4]
 80013be:	681b      	ldr	r3, [r3, #0]
 80013c0:	4a04      	ldr	r2, [pc, #16]	@ (80013d4 <HAL_TIM_PeriodElapsedCallback+0x20>)
 80013c2:	4293      	cmp	r3, r2
 80013c4:	d101      	bne.n	80013ca <HAL_TIM_PeriodElapsedCallback+0x16>
    HAL_IncTick();
 80013c6:	f000 fdc1 	bl	8001f4c <HAL_IncTick>
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 80013ca:	bf00      	nop
 80013cc:	3708      	adds	r7, #8
 80013ce:	46bd      	mov	sp, r7
 80013d0:	bd80      	pop	{r7, pc}
 80013d2:	bf00      	nop
 80013d4:	40001000 	.word	0x40001000

080013d8 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 80013d8:	b480      	push	{r7}
 80013da:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
 80013dc:	b672      	cpsid	i
}
 80013de:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 80013e0:	bf00      	nop
 80013e2:	e7fd      	b.n	80013e0 <Error_Handler+0x8>

080013e4 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 80013e4:	b580      	push	{r7, lr}
 80013e6:	b082      	sub	sp, #8
 80013e8:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80013ea:	4b0c      	ldr	r3, [pc, #48]	@ (800141c <HAL_MspInit+0x38>)
 80013ec:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 80013f0:	4a0a      	ldr	r2, [pc, #40]	@ (800141c <HAL_MspInit+0x38>)
 80013f2:	f043 0302 	orr.w	r3, r3, #2
 80013f6:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
 80013fa:	4b08      	ldr	r3, [pc, #32]	@ (800141c <HAL_MspInit+0x38>)
 80013fc:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8001400:	f003 0302 	and.w	r3, r3, #2
 8001404:	607b      	str	r3, [r7, #4]
 8001406:	687b      	ldr	r3, [r7, #4]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8001408:	2200      	movs	r2, #0
 800140a:	210f      	movs	r1, #15
 800140c:	f06f 0001 	mvn.w	r0, #1
 8001410:	f002 fcf2 	bl	8003df8 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8001414:	bf00      	nop
 8001416:	3708      	adds	r7, #8
 8001418:	46bd      	mov	sp, r7
 800141a:	bd80      	pop	{r7, pc}
 800141c:	58024400 	.word	0x58024400

08001420 <HAL_ADC_MspInit>:
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 8001420:	b580      	push	{r7, lr}
 8001422:	b0bc      	sub	sp, #240	@ 0xf0
 8001424:	af00      	add	r7, sp, #0
 8001426:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8001428:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 800142c:	2200      	movs	r2, #0
 800142e:	601a      	str	r2, [r3, #0]
 8001430:	605a      	str	r2, [r3, #4]
 8001432:	609a      	str	r2, [r3, #8]
 8001434:	60da      	str	r2, [r3, #12]
 8001436:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 8001438:	f107 0318 	add.w	r3, r7, #24
 800143c:	22c0      	movs	r2, #192	@ 0xc0
 800143e:	2100      	movs	r1, #0
 8001440:	4618      	mov	r0, r3
 8001442:	f016 f857 	bl	80174f4 <memset>
  if(hadc->Instance==ADC1)
 8001446:	687b      	ldr	r3, [r7, #4]
 8001448:	681b      	ldr	r3, [r3, #0]
 800144a:	4a57      	ldr	r2, [pc, #348]	@ (80015a8 <HAL_ADC_MspInit+0x188>)
 800144c:	4293      	cmp	r3, r2
 800144e:	f040 80a7 	bne.w	80015a0 <HAL_ADC_MspInit+0x180>

  /* USER CODE END ADC1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_ADC;
 8001452:	f44f 2200 	mov.w	r2, #524288	@ 0x80000
 8001456:	f04f 0300 	mov.w	r3, #0
 800145a:	e9c7 2306 	strd	r2, r3, [r7, #24]
    PeriphClkInitStruct.PLL2.PLL2M = 4;
 800145e:	2304      	movs	r3, #4
 8001460:	623b      	str	r3, [r7, #32]
    PeriphClkInitStruct.PLL2.PLL2N = 16;
 8001462:	2310      	movs	r3, #16
 8001464:	627b      	str	r3, [r7, #36]	@ 0x24
    PeriphClkInitStruct.PLL2.PLL2P = 10;
 8001466:	230a      	movs	r3, #10
 8001468:	62bb      	str	r3, [r7, #40]	@ 0x28
    PeriphClkInitStruct.PLL2.PLL2Q = 2;
 800146a:	2302      	movs	r3, #2
 800146c:	62fb      	str	r3, [r7, #44]	@ 0x2c
    PeriphClkInitStruct.PLL2.PLL2R = 2;
 800146e:	2302      	movs	r3, #2
 8001470:	633b      	str	r3, [r7, #48]	@ 0x30
    PeriphClkInitStruct.PLL2.PLL2RGE = RCC_PLL2VCIRANGE_3;
 8001472:	23c0      	movs	r3, #192	@ 0xc0
 8001474:	637b      	str	r3, [r7, #52]	@ 0x34
    PeriphClkInitStruct.PLL2.PLL2VCOSEL = RCC_PLL2VCOWIDE;
 8001476:	2300      	movs	r3, #0
 8001478:	63bb      	str	r3, [r7, #56]	@ 0x38
    PeriphClkInitStruct.PLL2.PLL2FRACN = 0;
 800147a:	2300      	movs	r3, #0
 800147c:	63fb      	str	r3, [r7, #60]	@ 0x3c
    PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLL2;
 800147e:	2300      	movs	r3, #0
 8001480:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8001484:	f107 0318 	add.w	r3, r7, #24
 8001488:	4618      	mov	r0, r3
 800148a:	f006 fed7 	bl	800823c <HAL_RCCEx_PeriphCLKConfig>
 800148e:	4603      	mov	r3, r0
 8001490:	2b00      	cmp	r3, #0
 8001492:	d001      	beq.n	8001498 <HAL_ADC_MspInit+0x78>
    {
      Error_Handler();
 8001494:	f7ff ffa0 	bl	80013d8 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_ADC12_CLK_ENABLE();
 8001498:	4b44      	ldr	r3, [pc, #272]	@ (80015ac <HAL_ADC_MspInit+0x18c>)
 800149a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 800149e:	4a43      	ldr	r2, [pc, #268]	@ (80015ac <HAL_ADC_MspInit+0x18c>)
 80014a0:	f043 0320 	orr.w	r3, r3, #32
 80014a4:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
 80014a8:	4b40      	ldr	r3, [pc, #256]	@ (80015ac <HAL_ADC_MspInit+0x18c>)
 80014aa:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 80014ae:	f003 0320 	and.w	r3, r3, #32
 80014b2:	617b      	str	r3, [r7, #20]
 80014b4:	697b      	ldr	r3, [r7, #20]

    __HAL_RCC_GPIOC_CLK_ENABLE();
 80014b6:	4b3d      	ldr	r3, [pc, #244]	@ (80015ac <HAL_ADC_MspInit+0x18c>)
 80014b8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80014bc:	4a3b      	ldr	r2, [pc, #236]	@ (80015ac <HAL_ADC_MspInit+0x18c>)
 80014be:	f043 0304 	orr.w	r3, r3, #4
 80014c2:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 80014c6:	4b39      	ldr	r3, [pc, #228]	@ (80015ac <HAL_ADC_MspInit+0x18c>)
 80014c8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80014cc:	f003 0304 	and.w	r3, r3, #4
 80014d0:	613b      	str	r3, [r7, #16]
 80014d2:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80014d4:	4b35      	ldr	r3, [pc, #212]	@ (80015ac <HAL_ADC_MspInit+0x18c>)
 80014d6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80014da:	4a34      	ldr	r2, [pc, #208]	@ (80015ac <HAL_ADC_MspInit+0x18c>)
 80014dc:	f043 0301 	orr.w	r3, r3, #1
 80014e0:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 80014e4:	4b31      	ldr	r3, [pc, #196]	@ (80015ac <HAL_ADC_MspInit+0x18c>)
 80014e6:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 80014ea:	f003 0301 	and.w	r3, r3, #1
 80014ee:	60fb      	str	r3, [r7, #12]
 80014f0:	68fb      	ldr	r3, [r7, #12]
    /**ADC1 GPIO Configuration
    PC0     ------> ADC1_INP10
    PA3     ------> ADC1_INP15
    */
    GPIO_InitStruct.Pin = GPIO_PIN_0;
 80014f2:	2301      	movs	r3, #1
 80014f4:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80014f8:	2303      	movs	r3, #3
 80014fa:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80014fe:	2300      	movs	r3, #0
 8001500:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8001504:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 8001508:	4619      	mov	r1, r3
 800150a:	4829      	ldr	r0, [pc, #164]	@ (80015b0 <HAL_ADC_MspInit+0x190>)
 800150c:	f004 fdf8 	bl	8006100 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_3;
 8001510:	2308      	movs	r3, #8
 8001512:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8001516:	2303      	movs	r3, #3
 8001518:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800151c:	2300      	movs	r3, #0
 800151e:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001522:	f107 03dc 	add.w	r3, r7, #220	@ 0xdc
 8001526:	4619      	mov	r1, r3
 8001528:	4822      	ldr	r0, [pc, #136]	@ (80015b4 <HAL_ADC_MspInit+0x194>)
 800152a:	f004 fde9 	bl	8006100 <HAL_GPIO_Init>

    /* ADC1 DMA Init */
    /* ADC1 Init */
    hdma_adc1.Instance = DMA1_Stream0;
 800152e:	4b22      	ldr	r3, [pc, #136]	@ (80015b8 <HAL_ADC_MspInit+0x198>)
 8001530:	4a22      	ldr	r2, [pc, #136]	@ (80015bc <HAL_ADC_MspInit+0x19c>)
 8001532:	601a      	str	r2, [r3, #0]
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
 8001534:	4b20      	ldr	r3, [pc, #128]	@ (80015b8 <HAL_ADC_MspInit+0x198>)
 8001536:	2209      	movs	r2, #9
 8001538:	605a      	str	r2, [r3, #4]
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
 800153a:	4b1f      	ldr	r3, [pc, #124]	@ (80015b8 <HAL_ADC_MspInit+0x198>)
 800153c:	2200      	movs	r2, #0
 800153e:	609a      	str	r2, [r3, #8]
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
 8001540:	4b1d      	ldr	r3, [pc, #116]	@ (80015b8 <HAL_ADC_MspInit+0x198>)
 8001542:	2200      	movs	r2, #0
 8001544:	60da      	str	r2, [r3, #12]
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
 8001546:	4b1c      	ldr	r3, [pc, #112]	@ (80015b8 <HAL_ADC_MspInit+0x198>)
 8001548:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 800154c:	611a      	str	r2, [r3, #16]
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 800154e:	4b1a      	ldr	r3, [pc, #104]	@ (80015b8 <HAL_ADC_MspInit+0x198>)
 8001550:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8001554:	615a      	str	r2, [r3, #20]
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 8001556:	4b18      	ldr	r3, [pc, #96]	@ (80015b8 <HAL_ADC_MspInit+0x198>)
 8001558:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 800155c:	619a      	str	r2, [r3, #24]
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
 800155e:	4b16      	ldr	r3, [pc, #88]	@ (80015b8 <HAL_ADC_MspInit+0x198>)
 8001560:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8001564:	61da      	str	r2, [r3, #28]
    hdma_adc1.Init.Priority = DMA_PRIORITY_HIGH;
 8001566:	4b14      	ldr	r3, [pc, #80]	@ (80015b8 <HAL_ADC_MspInit+0x198>)
 8001568:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
 800156c:	621a      	str	r2, [r3, #32]
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 800156e:	4b12      	ldr	r3, [pc, #72]	@ (80015b8 <HAL_ADC_MspInit+0x198>)
 8001570:	2200      	movs	r2, #0
 8001572:	625a      	str	r2, [r3, #36]	@ 0x24
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
 8001574:	4810      	ldr	r0, [pc, #64]	@ (80015b8 <HAL_ADC_MspInit+0x198>)
 8001576:	f002 fc7b 	bl	8003e70 <HAL_DMA_Init>
 800157a:	4603      	mov	r3, r0
 800157c:	2b00      	cmp	r3, #0
 800157e:	d001      	beq.n	8001584 <HAL_ADC_MspInit+0x164>
    {
      Error_Handler();
 8001580:	f7ff ff2a 	bl	80013d8 <Error_Handler>
    }

    __HAL_LINKDMA(hadc,DMA_Handle,hdma_adc1);
 8001584:	687b      	ldr	r3, [r7, #4]
 8001586:	4a0c      	ldr	r2, [pc, #48]	@ (80015b8 <HAL_ADC_MspInit+0x198>)
 8001588:	64da      	str	r2, [r3, #76]	@ 0x4c
 800158a:	4a0b      	ldr	r2, [pc, #44]	@ (80015b8 <HAL_ADC_MspInit+0x198>)
 800158c:	687b      	ldr	r3, [r7, #4]
 800158e:	6393      	str	r3, [r2, #56]	@ 0x38

    /* ADC1 interrupt Init */
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
 8001590:	2200      	movs	r2, #0
 8001592:	2105      	movs	r1, #5
 8001594:	2012      	movs	r0, #18
 8001596:	f002 fc2f 	bl	8003df8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC_IRQn);
 800159a:	2012      	movs	r0, #18
 800159c:	f002 fc46 	bl	8003e2c <HAL_NVIC_EnableIRQ>

  /* USER CODE END ADC1_MspInit 1 */

  }

}
 80015a0:	bf00      	nop
 80015a2:	37f0      	adds	r7, #240	@ 0xf0
 80015a4:	46bd      	mov	sp, r7
 80015a6:	bd80      	pop	{r7, pc}
 80015a8:	40022000 	.word	0x40022000
 80015ac:	58024400 	.word	0x58024400
 80015b0:	58020800 	.word	0x58020800
 80015b4:	58020000 	.word	0x58020000
 80015b8:	24000dc0 	.word	0x24000dc0
 80015bc:	40020010 	.word	0x40020010

080015c0 <HAL_I2C_MspInit>:
* This function configures the hardware resources used in this example
* @param hi2c: I2C handle pointer
* @retval None
*/
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 80015c0:	b580      	push	{r7, lr}
 80015c2:	b0ba      	sub	sp, #232	@ 0xe8
 80015c4:	af00      	add	r7, sp, #0
 80015c6:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80015c8:	f107 03d4 	add.w	r3, r7, #212	@ 0xd4
 80015cc:	2200      	movs	r2, #0
 80015ce:	601a      	str	r2, [r3, #0]
 80015d0:	605a      	str	r2, [r3, #4]
 80015d2:	609a      	str	r2, [r3, #8]
 80015d4:	60da      	str	r2, [r3, #12]
 80015d6:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 80015d8:	f107 0310 	add.w	r3, r7, #16
 80015dc:	22c0      	movs	r2, #192	@ 0xc0
 80015de:	2100      	movs	r1, #0
 80015e0:	4618      	mov	r0, r3
 80015e2:	f015 ff87 	bl	80174f4 <memset>
  if(hi2c->Instance==I2C1)
 80015e6:	687b      	ldr	r3, [r7, #4]
 80015e8:	681b      	ldr	r3, [r3, #0]
 80015ea:	4a27      	ldr	r2, [pc, #156]	@ (8001688 <HAL_I2C_MspInit+0xc8>)
 80015ec:	4293      	cmp	r3, r2
 80015ee:	d146      	bne.n	800167e <HAL_I2C_MspInit+0xbe>

  /* USER CODE END I2C1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
 80015f0:	f04f 0208 	mov.w	r2, #8
 80015f4:	f04f 0300 	mov.w	r3, #0
 80015f8:	e9c7 2304 	strd	r2, r3, [r7, #16]
    PeriphClkInitStruct.I2c123ClockSelection = RCC_I2C123CLKSOURCE_D2PCLK1;
 80015fc:	2300      	movs	r3, #0
 80015fe:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8001602:	f107 0310 	add.w	r3, r7, #16
 8001606:	4618      	mov	r0, r3
 8001608:	f006 fe18 	bl	800823c <HAL_RCCEx_PeriphCLKConfig>
 800160c:	4603      	mov	r3, r0
 800160e:	2b00      	cmp	r3, #0
 8001610:	d001      	beq.n	8001616 <HAL_I2C_MspInit+0x56>
    {
      Error_Handler();
 8001612:	f7ff fee1 	bl	80013d8 <Error_Handler>
    }

    __HAL_RCC_GPIOB_CLK_ENABLE();
 8001616:	4b1d      	ldr	r3, [pc, #116]	@ (800168c <HAL_I2C_MspInit+0xcc>)
 8001618:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800161c:	4a1b      	ldr	r2, [pc, #108]	@ (800168c <HAL_I2C_MspInit+0xcc>)
 800161e:	f043 0302 	orr.w	r3, r3, #2
 8001622:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8001626:	4b19      	ldr	r3, [pc, #100]	@ (800168c <HAL_I2C_MspInit+0xcc>)
 8001628:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 800162c:	f003 0302 	and.w	r3, r3, #2
 8001630:	60fb      	str	r3, [r7, #12]
 8001632:	68fb      	ldr	r3, [r7, #12]
    /**I2C1 GPIO Configuration
    PB8     ------> I2C1_SCL
    PB9     ------> I2C1_SDA
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
 8001634:	f44f 7340 	mov.w	r3, #768	@ 0x300
 8001638:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800163c:	2312      	movs	r3, #18
 800163e:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001642:	2300      	movs	r3, #0
 8001644:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001648:	2300      	movs	r3, #0
 800164a:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 800164e:	2304      	movs	r3, #4
 8001650:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8001654:	f107 03d4 	add.w	r3, r7, #212	@ 0xd4
 8001658:	4619      	mov	r1, r3
 800165a:	480d      	ldr	r0, [pc, #52]	@ (8001690 <HAL_I2C_MspInit+0xd0>)
 800165c:	f004 fd50 	bl	8006100 <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 8001660:	4b0a      	ldr	r3, [pc, #40]	@ (800168c <HAL_I2C_MspInit+0xcc>)
 8001662:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8001666:	4a09      	ldr	r2, [pc, #36]	@ (800168c <HAL_I2C_MspInit+0xcc>)
 8001668:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 800166c:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
 8001670:	4b06      	ldr	r3, [pc, #24]	@ (800168c <HAL_I2C_MspInit+0xcc>)
 8001672:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8001676:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 800167a:	60bb      	str	r3, [r7, #8]
 800167c:	68bb      	ldr	r3, [r7, #8]

  /* USER CODE END I2C1_MspInit 1 */

  }

}
 800167e:	bf00      	nop
 8001680:	37e8      	adds	r7, #232	@ 0xe8
 8001682:	46bd      	mov	sp, r7
 8001684:	bd80      	pop	{r7, pc}
 8001686:	bf00      	nop
 8001688:	40005400 	.word	0x40005400
 800168c:	58024400 	.word	0x58024400
 8001690:	58020400 	.word	0x58020400

08001694 <HAL_TIM_Base_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 8001694:	b480      	push	{r7}
 8001696:	b085      	sub	sp, #20
 8001698:	af00      	add	r7, sp, #0
 800169a:	6078      	str	r0, [r7, #4]
  if(htim_base->Instance==TIM3)
 800169c:	687b      	ldr	r3, [r7, #4]
 800169e:	681b      	ldr	r3, [r3, #0]
 80016a0:	4a0b      	ldr	r2, [pc, #44]	@ (80016d0 <HAL_TIM_Base_MspInit+0x3c>)
 80016a2:	4293      	cmp	r3, r2
 80016a4:	d10e      	bne.n	80016c4 <HAL_TIM_Base_MspInit+0x30>
  {
  /* USER CODE BEGIN TIM3_MspInit 0 */

  /* USER CODE END TIM3_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM3_CLK_ENABLE();
 80016a6:	4b0b      	ldr	r3, [pc, #44]	@ (80016d4 <HAL_TIM_Base_MspInit+0x40>)
 80016a8:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 80016ac:	4a09      	ldr	r2, [pc, #36]	@ (80016d4 <HAL_TIM_Base_MspInit+0x40>)
 80016ae:	f043 0302 	orr.w	r3, r3, #2
 80016b2:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
 80016b6:	4b07      	ldr	r3, [pc, #28]	@ (80016d4 <HAL_TIM_Base_MspInit+0x40>)
 80016b8:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 80016bc:	f003 0302 	and.w	r3, r3, #2
 80016c0:	60fb      	str	r3, [r7, #12]
 80016c2:	68fb      	ldr	r3, [r7, #12]

  /* USER CODE END TIM3_MspInit 1 */

  }

}
 80016c4:	bf00      	nop
 80016c6:	3714      	adds	r7, #20
 80016c8:	46bd      	mov	sp, r7
 80016ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80016ce:	4770      	bx	lr
 80016d0:	40000400 	.word	0x40000400
 80016d4:	58024400 	.word	0x58024400

080016d8 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 80016d8:	b580      	push	{r7, lr}
 80016da:	b0ba      	sub	sp, #232	@ 0xe8
 80016dc:	af00      	add	r7, sp, #0
 80016de:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80016e0:	f107 03d4 	add.w	r3, r7, #212	@ 0xd4
 80016e4:	2200      	movs	r2, #0
 80016e6:	601a      	str	r2, [r3, #0]
 80016e8:	605a      	str	r2, [r3, #4]
 80016ea:	609a      	str	r2, [r3, #8]
 80016ec:	60da      	str	r2, [r3, #12]
 80016ee:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 80016f0:	f107 0310 	add.w	r3, r7, #16
 80016f4:	22c0      	movs	r2, #192	@ 0xc0
 80016f6:	2100      	movs	r1, #0
 80016f8:	4618      	mov	r0, r3
 80016fa:	f015 fefb 	bl	80174f4 <memset>
  if(huart->Instance==USART3)
 80016fe:	687b      	ldr	r3, [r7, #4]
 8001700:	681b      	ldr	r3, [r3, #0]
 8001702:	4a3e      	ldr	r2, [pc, #248]	@ (80017fc <HAL_UART_MspInit+0x124>)
 8001704:	4293      	cmp	r3, r2
 8001706:	d175      	bne.n	80017f4 <HAL_UART_MspInit+0x11c>

  /* USER CODE END USART3_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3;
 8001708:	f04f 0202 	mov.w	r2, #2
 800170c:	f04f 0300 	mov.w	r3, #0
 8001710:	e9c7 2304 	strd	r2, r3, [r7, #16]
    PeriphClkInitStruct.Usart234578ClockSelection = RCC_USART234578CLKSOURCE_D2PCLK1;
 8001714:	2300      	movs	r3, #0
 8001716:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800171a:	f107 0310 	add.w	r3, r7, #16
 800171e:	4618      	mov	r0, r3
 8001720:	f006 fd8c 	bl	800823c <HAL_RCCEx_PeriphCLKConfig>
 8001724:	4603      	mov	r3, r0
 8001726:	2b00      	cmp	r3, #0
 8001728:	d001      	beq.n	800172e <HAL_UART_MspInit+0x56>
    {
      Error_Handler();
 800172a:	f7ff fe55 	bl	80013d8 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_USART3_CLK_ENABLE();
 800172e:	4b34      	ldr	r3, [pc, #208]	@ (8001800 <HAL_UART_MspInit+0x128>)
 8001730:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8001734:	4a32      	ldr	r2, [pc, #200]	@ (8001800 <HAL_UART_MspInit+0x128>)
 8001736:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 800173a:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
 800173e:	4b30      	ldr	r3, [pc, #192]	@ (8001800 <HAL_UART_MspInit+0x128>)
 8001740:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8001744:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8001748:	60fb      	str	r3, [r7, #12]
 800174a:	68fb      	ldr	r3, [r7, #12]

    __HAL_RCC_GPIOD_CLK_ENABLE();
 800174c:	4b2c      	ldr	r3, [pc, #176]	@ (8001800 <HAL_UART_MspInit+0x128>)
 800174e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001752:	4a2b      	ldr	r2, [pc, #172]	@ (8001800 <HAL_UART_MspInit+0x128>)
 8001754:	f043 0308 	orr.w	r3, r3, #8
 8001758:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 800175c:	4b28      	ldr	r3, [pc, #160]	@ (8001800 <HAL_UART_MspInit+0x128>)
 800175e:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001762:	f003 0308 	and.w	r3, r3, #8
 8001766:	60bb      	str	r3, [r7, #8]
 8001768:	68bb      	ldr	r3, [r7, #8]
    /**USART3 GPIO Configuration
    PD8     ------> USART3_TX
    PD9     ------> USART3_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
 800176a:	f44f 7340 	mov.w	r3, #768	@ 0x300
 800176e:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8001772:	2302      	movs	r3, #2
 8001774:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8001778:	2300      	movs	r3, #0
 800177a:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800177e:	2300      	movs	r3, #0
 8001780:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
 8001784:	2307      	movs	r3, #7
 8001786:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800178a:	f107 03d4 	add.w	r3, r7, #212	@ 0xd4
 800178e:	4619      	mov	r1, r3
 8001790:	481c      	ldr	r0, [pc, #112]	@ (8001804 <HAL_UART_MspInit+0x12c>)
 8001792:	f004 fcb5 	bl	8006100 <HAL_GPIO_Init>

    /* USART3 DMA Init */
    /* USART3_TX Init */
    hdma_usart3_tx.Instance = DMA1_Stream1;
 8001796:	4b1c      	ldr	r3, [pc, #112]	@ (8001808 <HAL_UART_MspInit+0x130>)
 8001798:	4a1c      	ldr	r2, [pc, #112]	@ (800180c <HAL_UART_MspInit+0x134>)
 800179a:	601a      	str	r2, [r3, #0]
    hdma_usart3_tx.Init.Request = DMA_REQUEST_USART3_TX;
 800179c:	4b1a      	ldr	r3, [pc, #104]	@ (8001808 <HAL_UART_MspInit+0x130>)
 800179e:	222e      	movs	r2, #46	@ 0x2e
 80017a0:	605a      	str	r2, [r3, #4]
    hdma_usart3_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80017a2:	4b19      	ldr	r3, [pc, #100]	@ (8001808 <HAL_UART_MspInit+0x130>)
 80017a4:	2240      	movs	r2, #64	@ 0x40
 80017a6:	609a      	str	r2, [r3, #8]
    hdma_usart3_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 80017a8:	4b17      	ldr	r3, [pc, #92]	@ (8001808 <HAL_UART_MspInit+0x130>)
 80017aa:	2200      	movs	r2, #0
 80017ac:	60da      	str	r2, [r3, #12]
    hdma_usart3_tx.Init.MemInc = DMA_MINC_ENABLE;
 80017ae:	4b16      	ldr	r3, [pc, #88]	@ (8001808 <HAL_UART_MspInit+0x130>)
 80017b0:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 80017b4:	611a      	str	r2, [r3, #16]
    hdma_usart3_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 80017b6:	4b14      	ldr	r3, [pc, #80]	@ (8001808 <HAL_UART_MspInit+0x130>)
 80017b8:	2200      	movs	r2, #0
 80017ba:	615a      	str	r2, [r3, #20]
    hdma_usart3_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 80017bc:	4b12      	ldr	r3, [pc, #72]	@ (8001808 <HAL_UART_MspInit+0x130>)
 80017be:	2200      	movs	r2, #0
 80017c0:	619a      	str	r2, [r3, #24]
    hdma_usart3_tx.Init.Mode = DMA_CIRCULAR;
 80017c2:	4b11      	ldr	r3, [pc, #68]	@ (8001808 <HAL_UART_MspInit+0x130>)
 80017c4:	f44f 7280 	mov.w	r2, #256	@ 0x100
 80017c8:	61da      	str	r2, [r3, #28]
    hdma_usart3_tx.Init.Priority = DMA_PRIORITY_HIGH;
 80017ca:	4b0f      	ldr	r3, [pc, #60]	@ (8001808 <HAL_UART_MspInit+0x130>)
 80017cc:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
 80017d0:	621a      	str	r2, [r3, #32]
    hdma_usart3_tx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
 80017d2:	4b0d      	ldr	r3, [pc, #52]	@ (8001808 <HAL_UART_MspInit+0x130>)
 80017d4:	2200      	movs	r2, #0
 80017d6:	625a      	str	r2, [r3, #36]	@ 0x24
    if (HAL_DMA_Init(&hdma_usart3_tx) != HAL_OK)
 80017d8:	480b      	ldr	r0, [pc, #44]	@ (8001808 <HAL_UART_MspInit+0x130>)
 80017da:	f002 fb49 	bl	8003e70 <HAL_DMA_Init>
 80017de:	4603      	mov	r3, r0
 80017e0:	2b00      	cmp	r3, #0
 80017e2:	d001      	beq.n	80017e8 <HAL_UART_MspInit+0x110>
    {
      Error_Handler();
 80017e4:	f7ff fdf8 	bl	80013d8 <Error_Handler>
    }

    __HAL_LINKDMA(huart,hdmatx,hdma_usart3_tx);
 80017e8:	687b      	ldr	r3, [r7, #4]
 80017ea:	4a07      	ldr	r2, [pc, #28]	@ (8001808 <HAL_UART_MspInit+0x130>)
 80017ec:	67da      	str	r2, [r3, #124]	@ 0x7c
 80017ee:	4a06      	ldr	r2, [pc, #24]	@ (8001808 <HAL_UART_MspInit+0x130>)
 80017f0:	687b      	ldr	r3, [r7, #4]
 80017f2:	6393      	str	r3, [r2, #56]	@ 0x38

  /* USER CODE END USART3_MspInit 1 */

  }

}
 80017f4:	bf00      	nop
 80017f6:	37e8      	adds	r7, #232	@ 0xe8
 80017f8:	46bd      	mov	sp, r7
 80017fa:	bd80      	pop	{r7, pc}
 80017fc:	40004800 	.word	0x40004800
 8001800:	58024400 	.word	0x58024400
 8001804:	58020c00 	.word	0x58020c00
 8001808:	24000f6c 	.word	0x24000f6c
 800180c:	40020028 	.word	0x40020028

08001810 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001810:	b580      	push	{r7, lr}
 8001812:	b090      	sub	sp, #64	@ 0x40
 8001814:	af00      	add	r7, sp, #0
 8001816:	6078      	str	r0, [r7, #4]
  uint32_t              uwTimclock, uwAPB1Prescaler;
  uint32_t              uwPrescalerValue;
  uint32_t              pFLatency;

  /*Configure the TIM6 IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8001818:	687b      	ldr	r3, [r7, #4]
 800181a:	2b0f      	cmp	r3, #15
 800181c:	d827      	bhi.n	800186e <HAL_InitTick+0x5e>
   {
     HAL_NVIC_SetPriority(TIM6_DAC_IRQn, TickPriority ,0);
 800181e:	2200      	movs	r2, #0
 8001820:	6879      	ldr	r1, [r7, #4]
 8001822:	2036      	movs	r0, #54	@ 0x36
 8001824:	f002 fae8 	bl	8003df8 <HAL_NVIC_SetPriority>

     /* Enable the TIM6 global Interrupt */
     HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn);
 8001828:	2036      	movs	r0, #54	@ 0x36
 800182a:	f002 faff 	bl	8003e2c <HAL_NVIC_EnableIRQ>
     uwTickPrio = TickPriority;
 800182e:	4a29      	ldr	r2, [pc, #164]	@ (80018d4 <HAL_InitTick+0xc4>)
 8001830:	687b      	ldr	r3, [r7, #4]
 8001832:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Enable TIM6 clock */
  __HAL_RCC_TIM6_CLK_ENABLE();
 8001834:	4b28      	ldr	r3, [pc, #160]	@ (80018d8 <HAL_InitTick+0xc8>)
 8001836:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 800183a:	4a27      	ldr	r2, [pc, #156]	@ (80018d8 <HAL_InitTick+0xc8>)
 800183c:	f043 0310 	orr.w	r3, r3, #16
 8001840:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
 8001844:	4b24      	ldr	r3, [pc, #144]	@ (80018d8 <HAL_InitTick+0xc8>)
 8001846:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 800184a:	f003 0310 	and.w	r3, r3, #16
 800184e:	60fb      	str	r3, [r7, #12]
 8001850:	68fb      	ldr	r3, [r7, #12]

/* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8001852:	f107 0210 	add.w	r2, r7, #16
 8001856:	f107 0314 	add.w	r3, r7, #20
 800185a:	4611      	mov	r1, r2
 800185c:	4618      	mov	r0, r3
 800185e:	f006 fcab 	bl	80081b8 <HAL_RCC_GetClockConfig>

  /* Get APB1 prescaler */
  uwAPB1Prescaler = clkconfig.APB1CLKDivider;
 8001862:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8001864:	63bb      	str	r3, [r7, #56]	@ 0x38
  /* Compute TIM6 clock */
  if (uwAPB1Prescaler == RCC_HCLK_DIV1)
 8001866:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8001868:	2b00      	cmp	r3, #0
 800186a:	d106      	bne.n	800187a <HAL_InitTick+0x6a>
 800186c:	e001      	b.n	8001872 <HAL_InitTick+0x62>
    return HAL_ERROR;
 800186e:	2301      	movs	r3, #1
 8001870:	e02b      	b.n	80018ca <HAL_InitTick+0xba>
  {
    uwTimclock = HAL_RCC_GetPCLK1Freq();
 8001872:	f006 fc75 	bl	8008160 <HAL_RCC_GetPCLK1Freq>
 8001876:	63f8      	str	r0, [r7, #60]	@ 0x3c
 8001878:	e004      	b.n	8001884 <HAL_InitTick+0x74>
  }
  else
  {
    uwTimclock = 2UL * HAL_RCC_GetPCLK1Freq();
 800187a:	f006 fc71 	bl	8008160 <HAL_RCC_GetPCLK1Freq>
 800187e:	4603      	mov	r3, r0
 8001880:	005b      	lsls	r3, r3, #1
 8001882:	63fb      	str	r3, [r7, #60]	@ 0x3c
  }

  /* Compute the prescaler value to have TIM6 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 8001884:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 8001886:	4a15      	ldr	r2, [pc, #84]	@ (80018dc <HAL_InitTick+0xcc>)
 8001888:	fba2 2303 	umull	r2, r3, r2, r3
 800188c:	0c9b      	lsrs	r3, r3, #18
 800188e:	3b01      	subs	r3, #1
 8001890:	637b      	str	r3, [r7, #52]	@ 0x34

  /* Initialize TIM6 */
  htim6.Instance = TIM6;
 8001892:	4b13      	ldr	r3, [pc, #76]	@ (80018e0 <HAL_InitTick+0xd0>)
 8001894:	4a13      	ldr	r2, [pc, #76]	@ (80018e4 <HAL_InitTick+0xd4>)
 8001896:	601a      	str	r2, [r3, #0]
  + Period = [(TIM6CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim6.Init.Period = (1000000U / 1000U) - 1U;
 8001898:	4b11      	ldr	r3, [pc, #68]	@ (80018e0 <HAL_InitTick+0xd0>)
 800189a:	f240 32e7 	movw	r2, #999	@ 0x3e7
 800189e:	60da      	str	r2, [r3, #12]
  htim6.Init.Prescaler = uwPrescalerValue;
 80018a0:	4a0f      	ldr	r2, [pc, #60]	@ (80018e0 <HAL_InitTick+0xd0>)
 80018a2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80018a4:	6053      	str	r3, [r2, #4]
  htim6.Init.ClockDivision = 0;
 80018a6:	4b0e      	ldr	r3, [pc, #56]	@ (80018e0 <HAL_InitTick+0xd0>)
 80018a8:	2200      	movs	r2, #0
 80018aa:	611a      	str	r2, [r3, #16]
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
 80018ac:	4b0c      	ldr	r3, [pc, #48]	@ (80018e0 <HAL_InitTick+0xd0>)
 80018ae:	2200      	movs	r2, #0
 80018b0:	609a      	str	r2, [r3, #8]

  if(HAL_TIM_Base_Init(&htim6) == HAL_OK)
 80018b2:	480b      	ldr	r0, [pc, #44]	@ (80018e0 <HAL_InitTick+0xd0>)
 80018b4:	f009 f9c0 	bl	800ac38 <HAL_TIM_Base_Init>
 80018b8:	4603      	mov	r3, r0
 80018ba:	2b00      	cmp	r3, #0
 80018bc:	d104      	bne.n	80018c8 <HAL_InitTick+0xb8>
  {
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim6);
 80018be:	4808      	ldr	r0, [pc, #32]	@ (80018e0 <HAL_InitTick+0xd0>)
 80018c0:	f009 fa82 	bl	800adc8 <HAL_TIM_Base_Start_IT>
 80018c4:	4603      	mov	r3, r0
 80018c6:	e000      	b.n	80018ca <HAL_InitTick+0xba>
  }

  /* Return function status */
  return HAL_ERROR;
 80018c8:	2301      	movs	r3, #1
}
 80018ca:	4618      	mov	r0, r3
 80018cc:	3740      	adds	r7, #64	@ 0x40
 80018ce:	46bd      	mov	sp, r7
 80018d0:	bd80      	pop	{r7, pc}
 80018d2:	bf00      	nop
 80018d4:	24000020 	.word	0x24000020
 80018d8:	58024400 	.word	0x58024400
 80018dc:	431bde83 	.word	0x431bde83
 80018e0:	24001328 	.word	0x24001328
 80018e4:	40001000 	.word	0x40001000

080018e8 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 80018e8:	b480      	push	{r7}
 80018ea:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 80018ec:	bf00      	nop
 80018ee:	e7fd      	b.n	80018ec <NMI_Handler+0x4>

080018f0 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 80018f0:	b480      	push	{r7}
 80018f2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 80018f4:	bf00      	nop
 80018f6:	e7fd      	b.n	80018f4 <HardFault_Handler+0x4>

080018f8 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 80018f8:	b480      	push	{r7}
 80018fa:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 80018fc:	bf00      	nop
 80018fe:	e7fd      	b.n	80018fc <MemManage_Handler+0x4>

08001900 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8001900:	b480      	push	{r7}
 8001902:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8001904:	bf00      	nop
 8001906:	e7fd      	b.n	8001904 <BusFault_Handler+0x4>

08001908 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8001908:	b480      	push	{r7}
 800190a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 800190c:	bf00      	nop
 800190e:	e7fd      	b.n	800190c <UsageFault_Handler+0x4>

08001910 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8001910:	b480      	push	{r7}
 8001912:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8001914:	bf00      	nop
 8001916:	46bd      	mov	sp, r7
 8001918:	f85d 7b04 	ldr.w	r7, [sp], #4
 800191c:	4770      	bx	lr
	...

08001920 <DMA1_Stream0_IRQHandler>:

/**
  * @brief This function handles DMA1 stream0 global interrupt.
  */
void DMA1_Stream0_IRQHandler(void)
{
 8001920:	b580      	push	{r7, lr}
 8001922:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Stream0_IRQn 0 */

  /* USER CODE END DMA1_Stream0_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc1);
 8001924:	4802      	ldr	r0, [pc, #8]	@ (8001930 <DMA1_Stream0_IRQHandler+0x10>)
 8001926:	f003 f869 	bl	80049fc <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Stream0_IRQn 1 */

  /* USER CODE END DMA1_Stream0_IRQn 1 */
}
 800192a:	bf00      	nop
 800192c:	bd80      	pop	{r7, pc}
 800192e:	bf00      	nop
 8001930:	24000dc0 	.word	0x24000dc0

08001934 <DMA1_Stream1_IRQHandler>:

/**
  * @brief This function handles DMA1 stream1 global interrupt.
  */
void DMA1_Stream1_IRQHandler(void)
{
 8001934:	b580      	push	{r7, lr}
 8001936:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Stream1_IRQn 0 */

  /* USER CODE END DMA1_Stream1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_usart3_tx);
 8001938:	4802      	ldr	r0, [pc, #8]	@ (8001944 <DMA1_Stream1_IRQHandler+0x10>)
 800193a:	f003 f85f 	bl	80049fc <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Stream1_IRQn 1 */

  /* USER CODE END DMA1_Stream1_IRQn 1 */
}
 800193e:	bf00      	nop
 8001940:	bd80      	pop	{r7, pc}
 8001942:	bf00      	nop
 8001944:	24000f6c 	.word	0x24000f6c

08001948 <ADC_IRQHandler>:

/**
  * @brief This function handles ADC1 and ADC2 global interrupts.
  */
void ADC_IRQHandler(void)
{
 8001948:	b580      	push	{r7, lr}
 800194a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN ADC_IRQn 0 */

  /* USER CODE END ADC_IRQn 0 */
  HAL_ADC_IRQHandler(&hadc1);
 800194c:	4802      	ldr	r0, [pc, #8]	@ (8001958 <ADC_IRQHandler+0x10>)
 800194e:	f000 fff1 	bl	8002934 <HAL_ADC_IRQHandler>
  /* USER CODE BEGIN ADC_IRQn 1 */

  /* USER CODE END ADC_IRQn 1 */
}
 8001952:	bf00      	nop
 8001954:	bd80      	pop	{r7, pc}
 8001956:	bf00      	nop
 8001958:	24000d5c 	.word	0x24000d5c

0800195c <EXTI15_10_IRQHandler>:

/**
  * @brief This function handles EXTI line[15:10] interrupts.
  */
void EXTI15_10_IRQHandler(void)
{
 800195c:	b580      	push	{r7, lr}
 800195e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI15_10_IRQn 0 */

  /* USER CODE END EXTI15_10_IRQn 0 */
  BSP_PB_IRQHandler(BUTTON_USER);
 8001960:	2000      	movs	r0, #0
 8001962:	f000 fa93 	bl	8001e8c <BSP_PB_IRQHandler>
  /* USER CODE BEGIN EXTI15_10_IRQn 1 */

  /* USER CODE END EXTI15_10_IRQn 1 */
}
 8001966:	bf00      	nop
 8001968:	bd80      	pop	{r7, pc}
	...

0800196c <TIM6_DAC_IRQHandler>:

/**
  * @brief This function handles TIM6 global interrupt, DAC1_CH1 and DAC1_CH2 underrun error interrupts.
  */
void TIM6_DAC_IRQHandler(void)
{
 800196c:	b580      	push	{r7, lr}
 800196e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM6_DAC_IRQn 0 */

  /* USER CODE END TIM6_DAC_IRQn 0 */
  HAL_TIM_IRQHandler(&htim6);
 8001970:	4802      	ldr	r0, [pc, #8]	@ (800197c <TIM6_DAC_IRQHandler+0x10>)
 8001972:	f009 faa1 	bl	800aeb8 <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM6_DAC_IRQn 1 */

  /* USER CODE END TIM6_DAC_IRQn 1 */
}
 8001976:	bf00      	nop
 8001978:	bd80      	pop	{r7, pc}
 800197a:	bf00      	nop
 800197c:	24001328 	.word	0x24001328

08001980 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8001980:	b580      	push	{r7, lr}
 8001982:	b086      	sub	sp, #24
 8001984:	af00      	add	r7, sp, #0
 8001986:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8001988:	4a14      	ldr	r2, [pc, #80]	@ (80019dc <_sbrk+0x5c>)
 800198a:	4b15      	ldr	r3, [pc, #84]	@ (80019e0 <_sbrk+0x60>)
 800198c:	1ad3      	subs	r3, r2, r3
 800198e:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 8001990:	697b      	ldr	r3, [r7, #20]
 8001992:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8001994:	4b13      	ldr	r3, [pc, #76]	@ (80019e4 <_sbrk+0x64>)
 8001996:	681b      	ldr	r3, [r3, #0]
 8001998:	2b00      	cmp	r3, #0
 800199a:	d102      	bne.n	80019a2 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 800199c:	4b11      	ldr	r3, [pc, #68]	@ (80019e4 <_sbrk+0x64>)
 800199e:	4a12      	ldr	r2, [pc, #72]	@ (80019e8 <_sbrk+0x68>)
 80019a0:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 80019a2:	4b10      	ldr	r3, [pc, #64]	@ (80019e4 <_sbrk+0x64>)
 80019a4:	681a      	ldr	r2, [r3, #0]
 80019a6:	687b      	ldr	r3, [r7, #4]
 80019a8:	4413      	add	r3, r2
 80019aa:	693a      	ldr	r2, [r7, #16]
 80019ac:	429a      	cmp	r2, r3
 80019ae:	d207      	bcs.n	80019c0 <_sbrk+0x40>
  {
    errno = ENOMEM;
 80019b0:	f015 fdfe 	bl	80175b0 <__errno>
 80019b4:	4603      	mov	r3, r0
 80019b6:	220c      	movs	r2, #12
 80019b8:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 80019ba:	f04f 33ff 	mov.w	r3, #4294967295
 80019be:	e009      	b.n	80019d4 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 80019c0:	4b08      	ldr	r3, [pc, #32]	@ (80019e4 <_sbrk+0x64>)
 80019c2:	681b      	ldr	r3, [r3, #0]
 80019c4:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 80019c6:	4b07      	ldr	r3, [pc, #28]	@ (80019e4 <_sbrk+0x64>)
 80019c8:	681a      	ldr	r2, [r3, #0]
 80019ca:	687b      	ldr	r3, [r7, #4]
 80019cc:	4413      	add	r3, r2
 80019ce:	4a05      	ldr	r2, [pc, #20]	@ (80019e4 <_sbrk+0x64>)
 80019d0:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 80019d2:	68fb      	ldr	r3, [r7, #12]
}
 80019d4:	4618      	mov	r0, r3
 80019d6:	3718      	adds	r7, #24
 80019d8:	46bd      	mov	sp, r7
 80019da:	bd80      	pop	{r7, pc}
 80019dc:	24080000 	.word	0x24080000
 80019e0:	00000800 	.word	0x00000800
 80019e4:	24001374 	.word	0x24001374
 80019e8:	20000000 	.word	0x20000000

080019ec <readPressureSensor>:
#include "utilities.h"

HAL_StatusTypeDef readPressureSensor(I2C_HandleTypeDef hi2c, float* pressure) {
 80019ec:	b084      	sub	sp, #16
 80019ee:	b580      	push	{r7, lr}
 80019f0:	b088      	sub	sp, #32
 80019f2:	af04      	add	r7, sp, #16
 80019f4:	f107 0c18 	add.w	ip, r7, #24
 80019f8:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}
	HAL_StatusTypeDef status;
	uint8_t buf[3] = {0};
 80019fc:	4b2b      	ldr	r3, [pc, #172]	@ (8001aac <readPressureSensor+0xc0>)
 80019fe:	881b      	ldrh	r3, [r3, #0]
 8001a00:	813b      	strh	r3, [r7, #8]
 8001a02:	2300      	movs	r3, #0
 8001a04:	72bb      	strb	r3, [r7, #10]
	uint8_t cmd = CONVERSION_CMD;
 8001a06:	230a      	movs	r3, #10
 8001a08:	71fb      	strb	r3, [r7, #7]
	int32_t rawPressure;

	// Send command to command register to prepare for data read
	status = HAL_I2C_Mem_Write(&hi2c, XGZP6857D_I2C_ADDR, REG_CMD, I2C_MEMADD_SIZE_8BIT, &cmd, 1, 100);
 8001a0a:	2364      	movs	r3, #100	@ 0x64
 8001a0c:	9302      	str	r3, [sp, #8]
 8001a0e:	2301      	movs	r3, #1
 8001a10:	9301      	str	r3, [sp, #4]
 8001a12:	1dfb      	adds	r3, r7, #7
 8001a14:	9300      	str	r3, [sp, #0]
 8001a16:	2301      	movs	r3, #1
 8001a18:	2230      	movs	r2, #48	@ 0x30
 8001a1a:	21da      	movs	r1, #218	@ 0xda
 8001a1c:	f107 0018 	add.w	r0, r7, #24
 8001a20:	f004 fe02 	bl	8006628 <HAL_I2C_Mem_Write>
 8001a24:	4603      	mov	r3, r0
 8001a26:	72fb      	strb	r3, [r7, #11]
	if (status != HAL_OK) {
 8001a28:	7afb      	ldrb	r3, [r7, #11]
 8001a2a:	2b00      	cmp	r3, #0
 8001a2c:	d001      	beq.n	8001a32 <readPressureSensor+0x46>
		return status;
 8001a2e:	7afb      	ldrb	r3, [r7, #11]
 8001a30:	e035      	b.n	8001a9e <readPressureSensor+0xb2>
	}

	osDelay(CONVERSION_TIME_MS);
 8001a32:	2014      	movs	r0, #20
 8001a34:	f00b f8dc 	bl	800cbf0 <osDelay>

	// Read in data from pressure registers
	status = HAL_I2C_Mem_Read(&hi2c, XGZP6857D_I2C_ADDR, REG_PRESSURE_MSB, I2C_MEMADD_SIZE_8BIT, buf, 3, 100);
 8001a38:	2364      	movs	r3, #100	@ 0x64
 8001a3a:	9302      	str	r3, [sp, #8]
 8001a3c:	2303      	movs	r3, #3
 8001a3e:	9301      	str	r3, [sp, #4]
 8001a40:	f107 0308 	add.w	r3, r7, #8
 8001a44:	9300      	str	r3, [sp, #0]
 8001a46:	2301      	movs	r3, #1
 8001a48:	2206      	movs	r2, #6
 8001a4a:	21da      	movs	r1, #218	@ 0xda
 8001a4c:	f107 0018 	add.w	r0, r7, #24
 8001a50:	f004 fefe 	bl	8006850 <HAL_I2C_Mem_Read>
 8001a54:	4603      	mov	r3, r0
 8001a56:	72fb      	strb	r3, [r7, #11]
	if (status != HAL_OK) {
 8001a58:	7afb      	ldrb	r3, [r7, #11]
 8001a5a:	2b00      	cmp	r3, #0
 8001a5c:	d001      	beq.n	8001a62 <readPressureSensor+0x76>
		return status;
 8001a5e:	7afb      	ldrb	r3, [r7, #11]
 8001a60:	e01d      	b.n	8001a9e <readPressureSensor+0xb2>
	}

	// Combine pressure data from different bytes
	rawPressure = (buf[0] << 16) | (buf[1] << 8) | buf[2];
 8001a62:	7a3b      	ldrb	r3, [r7, #8]
 8001a64:	041a      	lsls	r2, r3, #16
 8001a66:	7a7b      	ldrb	r3, [r7, #9]
 8001a68:	021b      	lsls	r3, r3, #8
 8001a6a:	4313      	orrs	r3, r2
 8001a6c:	7aba      	ldrb	r2, [r7, #10]
 8001a6e:	4313      	orrs	r3, r2
 8001a70:	60fb      	str	r3, [r7, #12]

	// Check if pressure value is negative
	if (rawPressure & 0x800000) {
 8001a72:	68fb      	ldr	r3, [r7, #12]
 8001a74:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 8001a78:	2b00      	cmp	r3, #0
 8001a7a:	d003      	beq.n	8001a84 <readPressureSensor+0x98>
		rawPressure -= (1 << 24);
 8001a7c:	68fb      	ldr	r3, [r7, #12]
 8001a7e:	f103 437f 	add.w	r3, r3, #4278190080	@ 0xff000000
 8001a82:	60fb      	str	r3, [r7, #12]
	}

	*pressure = (float)rawPressure/K_FACTOR;
 8001a84:	68fb      	ldr	r3, [r7, #12]
 8001a86:	ee07 3a90 	vmov	s15, r3
 8001a8a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8001a8e:	eef3 6a00 	vmov.f32	s13, #48	@ 0x41800000  16.0
 8001a92:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8001a96:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8001a98:	edc3 7a00 	vstr	s15, [r3]
	return status;
 8001a9c:	7afb      	ldrb	r3, [r7, #11]
}
 8001a9e:	4618      	mov	r0, r3
 8001aa0:	3710      	adds	r7, #16
 8001aa2:	46bd      	mov	sp, r7
 8001aa4:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8001aa8:	b004      	add	sp, #16
 8001aaa:	4770      	bx	lr
 8001aac:	080183c0 	.word	0x080183c0

08001ab0 <Process_ADC_Data>:

void Process_ADC_Data(uint16_t* adc_buffer, uint16_t* sensor_averages)
{
 8001ab0:	b480      	push	{r7}
 8001ab2:	b08b      	sub	sp, #44	@ 0x2c
 8001ab4:	af00      	add	r7, sp, #0
 8001ab6:	6078      	str	r0, [r7, #4]
 8001ab8:	6039      	str	r1, [r7, #0]
    uint32_t sensor_sums[NUM_ADC_CHANNELS] = {0}; // To store sums for each channel
 8001aba:	f107 030c 	add.w	r3, r7, #12
 8001abe:	2200      	movs	r2, #0
 8001ac0:	601a      	str	r2, [r3, #0]
 8001ac2:	605a      	str	r2, [r3, #4]
 8001ac4:	609a      	str	r2, [r3, #8]
 8001ac6:	60da      	str	r2, [r3, #12]

    // Traverse the last 50ms worth of data in the circular buffer
    for (uint16_t i = 0; i < TOTAL_SAMPLES; i++)
 8001ac8:	2300      	movs	r3, #0
 8001aca:	84fb      	strh	r3, [r7, #38]	@ 0x26
 8001acc:	e01a      	b.n	8001b04 <Process_ADC_Data+0x54>
    {
		// Calculate the buffer index for each sample and channel
    	int channel = i % 4;
 8001ace:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8001ad0:	f003 0303 	and.w	r3, r3, #3
 8001ad4:	623b      	str	r3, [r7, #32]
    	uint16_t adc_value = adc_buffer[i];
 8001ad6:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8001ad8:	005b      	lsls	r3, r3, #1
 8001ada:	687a      	ldr	r2, [r7, #4]
 8001adc:	4413      	add	r3, r2
 8001ade:	881b      	ldrh	r3, [r3, #0]
 8001ae0:	83fb      	strh	r3, [r7, #30]
		sensor_sums[channel] += adc_value;
 8001ae2:	6a3b      	ldr	r3, [r7, #32]
 8001ae4:	009b      	lsls	r3, r3, #2
 8001ae6:	3328      	adds	r3, #40	@ 0x28
 8001ae8:	443b      	add	r3, r7
 8001aea:	f853 2c1c 	ldr.w	r2, [r3, #-28]
 8001aee:	8bfb      	ldrh	r3, [r7, #30]
 8001af0:	441a      	add	r2, r3
 8001af2:	6a3b      	ldr	r3, [r7, #32]
 8001af4:	009b      	lsls	r3, r3, #2
 8001af6:	3328      	adds	r3, #40	@ 0x28
 8001af8:	443b      	add	r3, r7
 8001afa:	f843 2c1c 	str.w	r2, [r3, #-28]
    for (uint16_t i = 0; i < TOTAL_SAMPLES; i++)
 8001afe:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8001b00:	3301      	adds	r3, #1
 8001b02:	84fb      	strh	r3, [r7, #38]	@ 0x26
 8001b04:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8001b06:	f5b3 7f48 	cmp.w	r3, #800	@ 0x320
 8001b0a:	d3e0      	bcc.n	8001ace <Process_ADC_Data+0x1e>
    }

    // Calculate averages for each channel
    for (uint16_t channel = 0; channel < NUM_ADC_CHANNELS; channel++)
 8001b0c:	2300      	movs	r3, #0
 8001b0e:	84bb      	strh	r3, [r7, #36]	@ 0x24
 8001b10:	e012      	b.n	8001b38 <Process_ADC_Data+0x88>
    {
        sensor_averages[channel] = sensor_sums[channel] / SAMPLES_PER_CHANNEL;
 8001b12:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8001b14:	009b      	lsls	r3, r3, #2
 8001b16:	3328      	adds	r3, #40	@ 0x28
 8001b18:	443b      	add	r3, r7
 8001b1a:	f853 3c1c 	ldr.w	r3, [r3, #-28]
 8001b1e:	4a0b      	ldr	r2, [pc, #44]	@ (8001b4c <Process_ADC_Data+0x9c>)
 8001b20:	fba2 2303 	umull	r2, r3, r2, r3
 8001b24:	0999      	lsrs	r1, r3, #6
 8001b26:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8001b28:	005b      	lsls	r3, r3, #1
 8001b2a:	683a      	ldr	r2, [r7, #0]
 8001b2c:	4413      	add	r3, r2
 8001b2e:	b28a      	uxth	r2, r1
 8001b30:	801a      	strh	r2, [r3, #0]
    for (uint16_t channel = 0; channel < NUM_ADC_CHANNELS; channel++)
 8001b32:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8001b34:	3301      	adds	r3, #1
 8001b36:	84bb      	strh	r3, [r7, #36]	@ 0x24
 8001b38:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8001b3a:	2b03      	cmp	r3, #3
 8001b3c:	d9e9      	bls.n	8001b12 <Process_ADC_Data+0x62>
    }
}
 8001b3e:	bf00      	nop
 8001b40:	bf00      	nop
 8001b42:	372c      	adds	r7, #44	@ 0x2c
 8001b44:	46bd      	mov	sp, r7
 8001b46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b4a:	4770      	bx	lr
 8001b4c:	51eb851f 	.word	0x51eb851f

08001b50 <get_dma_position>:

uint32_t get_dma_position(DMA_HandleTypeDef hdma_adc1) {
 8001b50:	b084      	sub	sp, #16
 8001b52:	b490      	push	{r4, r7}
 8001b54:	af00      	add	r7, sp, #0
 8001b56:	f107 0408 	add.w	r4, r7, #8
 8001b5a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    return (TOTAL_SAMPLES - __HAL_DMA_GET_COUNTER(&hdma_adc1)) % TOTAL_SAMPLES;
 8001b5e:	68bb      	ldr	r3, [r7, #8]
 8001b60:	4a2f      	ldr	r2, [pc, #188]	@ (8001c20 <get_dma_position+0xd0>)
 8001b62:	4293      	cmp	r3, r2
 8001b64:	d03b      	beq.n	8001bde <get_dma_position+0x8e>
 8001b66:	68bb      	ldr	r3, [r7, #8]
 8001b68:	4a2e      	ldr	r2, [pc, #184]	@ (8001c24 <get_dma_position+0xd4>)
 8001b6a:	4293      	cmp	r3, r2
 8001b6c:	d037      	beq.n	8001bde <get_dma_position+0x8e>
 8001b6e:	68bb      	ldr	r3, [r7, #8]
 8001b70:	4a2d      	ldr	r2, [pc, #180]	@ (8001c28 <get_dma_position+0xd8>)
 8001b72:	4293      	cmp	r3, r2
 8001b74:	d033      	beq.n	8001bde <get_dma_position+0x8e>
 8001b76:	68bb      	ldr	r3, [r7, #8]
 8001b78:	4a2c      	ldr	r2, [pc, #176]	@ (8001c2c <get_dma_position+0xdc>)
 8001b7a:	4293      	cmp	r3, r2
 8001b7c:	d02f      	beq.n	8001bde <get_dma_position+0x8e>
 8001b7e:	68bb      	ldr	r3, [r7, #8]
 8001b80:	4a2b      	ldr	r2, [pc, #172]	@ (8001c30 <get_dma_position+0xe0>)
 8001b82:	4293      	cmp	r3, r2
 8001b84:	d02b      	beq.n	8001bde <get_dma_position+0x8e>
 8001b86:	68bb      	ldr	r3, [r7, #8]
 8001b88:	4a2a      	ldr	r2, [pc, #168]	@ (8001c34 <get_dma_position+0xe4>)
 8001b8a:	4293      	cmp	r3, r2
 8001b8c:	d027      	beq.n	8001bde <get_dma_position+0x8e>
 8001b8e:	68bb      	ldr	r3, [r7, #8]
 8001b90:	4a29      	ldr	r2, [pc, #164]	@ (8001c38 <get_dma_position+0xe8>)
 8001b92:	4293      	cmp	r3, r2
 8001b94:	d023      	beq.n	8001bde <get_dma_position+0x8e>
 8001b96:	68bb      	ldr	r3, [r7, #8]
 8001b98:	4a28      	ldr	r2, [pc, #160]	@ (8001c3c <get_dma_position+0xec>)
 8001b9a:	4293      	cmp	r3, r2
 8001b9c:	d01f      	beq.n	8001bde <get_dma_position+0x8e>
 8001b9e:	68bb      	ldr	r3, [r7, #8]
 8001ba0:	4a27      	ldr	r2, [pc, #156]	@ (8001c40 <get_dma_position+0xf0>)
 8001ba2:	4293      	cmp	r3, r2
 8001ba4:	d01b      	beq.n	8001bde <get_dma_position+0x8e>
 8001ba6:	68bb      	ldr	r3, [r7, #8]
 8001ba8:	4a26      	ldr	r2, [pc, #152]	@ (8001c44 <get_dma_position+0xf4>)
 8001baa:	4293      	cmp	r3, r2
 8001bac:	d017      	beq.n	8001bde <get_dma_position+0x8e>
 8001bae:	68bb      	ldr	r3, [r7, #8]
 8001bb0:	4a25      	ldr	r2, [pc, #148]	@ (8001c48 <get_dma_position+0xf8>)
 8001bb2:	4293      	cmp	r3, r2
 8001bb4:	d013      	beq.n	8001bde <get_dma_position+0x8e>
 8001bb6:	68bb      	ldr	r3, [r7, #8]
 8001bb8:	4a24      	ldr	r2, [pc, #144]	@ (8001c4c <get_dma_position+0xfc>)
 8001bba:	4293      	cmp	r3, r2
 8001bbc:	d00f      	beq.n	8001bde <get_dma_position+0x8e>
 8001bbe:	68bb      	ldr	r3, [r7, #8]
 8001bc0:	4a23      	ldr	r2, [pc, #140]	@ (8001c50 <get_dma_position+0x100>)
 8001bc2:	4293      	cmp	r3, r2
 8001bc4:	d00b      	beq.n	8001bde <get_dma_position+0x8e>
 8001bc6:	68bb      	ldr	r3, [r7, #8]
 8001bc8:	4a22      	ldr	r2, [pc, #136]	@ (8001c54 <get_dma_position+0x104>)
 8001bca:	4293      	cmp	r3, r2
 8001bcc:	d007      	beq.n	8001bde <get_dma_position+0x8e>
 8001bce:	68bb      	ldr	r3, [r7, #8]
 8001bd0:	4a21      	ldr	r2, [pc, #132]	@ (8001c58 <get_dma_position+0x108>)
 8001bd2:	4293      	cmp	r3, r2
 8001bd4:	d003      	beq.n	8001bde <get_dma_position+0x8e>
 8001bd6:	68bb      	ldr	r3, [r7, #8]
 8001bd8:	4a20      	ldr	r2, [pc, #128]	@ (8001c5c <get_dma_position+0x10c>)
 8001bda:	4293      	cmp	r3, r2
 8001bdc:	d10d      	bne.n	8001bfa <get_dma_position+0xaa>
 8001bde:	68bb      	ldr	r3, [r7, #8]
 8001be0:	685b      	ldr	r3, [r3, #4]
 8001be2:	f5c3 7248 	rsb	r2, r3, #800	@ 0x320
 8001be6:	4b1e      	ldr	r3, [pc, #120]	@ (8001c60 <get_dma_position+0x110>)
 8001be8:	fba3 1302 	umull	r1, r3, r3, r2
 8001bec:	0a1b      	lsrs	r3, r3, #8
 8001bee:	f44f 7148 	mov.w	r1, #800	@ 0x320
 8001bf2:	fb01 f303 	mul.w	r3, r1, r3
 8001bf6:	1ad3      	subs	r3, r2, r3
 8001bf8:	e00c      	b.n	8001c14 <get_dma_position+0xc4>
 8001bfa:	68bb      	ldr	r3, [r7, #8]
 8001bfc:	685b      	ldr	r3, [r3, #4]
 8001bfe:	f5c3 7248 	rsb	r2, r3, #800	@ 0x320
 8001c02:	4b17      	ldr	r3, [pc, #92]	@ (8001c60 <get_dma_position+0x110>)
 8001c04:	fba3 1302 	umull	r1, r3, r3, r2
 8001c08:	0a1b      	lsrs	r3, r3, #8
 8001c0a:	f44f 7148 	mov.w	r1, #800	@ 0x320
 8001c0e:	fb01 f303 	mul.w	r3, r1, r3
 8001c12:	1ad3      	subs	r3, r2, r3
}
 8001c14:	4618      	mov	r0, r3
 8001c16:	46bd      	mov	sp, r7
 8001c18:	bc90      	pop	{r4, r7}
 8001c1a:	b004      	add	sp, #16
 8001c1c:	4770      	bx	lr
 8001c1e:	bf00      	nop
 8001c20:	40020010 	.word	0x40020010
 8001c24:	40020028 	.word	0x40020028
 8001c28:	40020040 	.word	0x40020040
 8001c2c:	40020058 	.word	0x40020058
 8001c30:	40020070 	.word	0x40020070
 8001c34:	40020088 	.word	0x40020088
 8001c38:	400200a0 	.word	0x400200a0
 8001c3c:	400200b8 	.word	0x400200b8
 8001c40:	40020410 	.word	0x40020410
 8001c44:	40020428 	.word	0x40020428
 8001c48:	40020440 	.word	0x40020440
 8001c4c:	40020458 	.word	0x40020458
 8001c50:	40020470 	.word	0x40020470
 8001c54:	40020488 	.word	0x40020488
 8001c58:	400204a0 	.word	0x400204a0
 8001c5c:	400204b8 	.word	0x400204b8
 8001c60:	51eb851f 	.word	0x51eb851f

08001c64 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack      /* set stack pointer */
 8001c64:	f8df d038 	ldr.w	sp, [pc, #56]	@ 8001ca0 <LoopFillZerobss+0xe>

/* Call the ExitRun0Mode function to configure the power supply */
  bl  ExitRun0Mode
 8001c68:	f7fe fec6 	bl	80009f8 <ExitRun0Mode>
/* Call the clock system initialization function.*/
  bl  SystemInit
 8001c6c:	f7fe fe16 	bl	800089c <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8001c70:	480c      	ldr	r0, [pc, #48]	@ (8001ca4 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 8001c72:	490d      	ldr	r1, [pc, #52]	@ (8001ca8 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 8001c74:	4a0d      	ldr	r2, [pc, #52]	@ (8001cac <LoopFillZerobss+0x1a>)
  movs r3, #0
 8001c76:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001c78:	e002      	b.n	8001c80 <LoopCopyDataInit>

08001c7a <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8001c7a:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8001c7c:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8001c7e:	3304      	adds	r3, #4

08001c80 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001c80:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8001c82:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8001c84:	d3f9      	bcc.n	8001c7a <CopyDataInit>
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8001c86:	4a0a      	ldr	r2, [pc, #40]	@ (8001cb0 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8001c88:	4c0a      	ldr	r4, [pc, #40]	@ (8001cb4 <LoopFillZerobss+0x22>)
  movs r3, #0
 8001c8a:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001c8c:	e001      	b.n	8001c92 <LoopFillZerobss>

08001c8e <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8001c8e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001c90:	3204      	adds	r2, #4

08001c92 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8001c92:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8001c94:	d3fb      	bcc.n	8001c8e <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 8001c96:	f015 fc91 	bl	80175bc <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8001c9a:	f7fe ff13 	bl	8000ac4 <main>
  bx  lr
 8001c9e:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 8001ca0:	24080000 	.word	0x24080000
  ldr r0, =_sdata
 8001ca4:	24000000 	.word	0x24000000
  ldr r1, =_edata
 8001ca8:	24000d30 	.word	0x24000d30
  ldr r2, =_sidata
 8001cac:	080224e8 	.word	0x080224e8
  ldr r2, =_sbss
 8001cb0:	24000d40 	.word	0x24000d40
  ldr r4, =_ebss
 8001cb4:	24006234 	.word	0x24006234

08001cb8 <ADC3_IRQHandler>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8001cb8:	e7fe      	b.n	8001cb8 <ADC3_IRQHandler>
	...

08001cbc <BSP_LED_Init>:
  *     @arg  LED2
  *     @arg  LED3
  * @retval BSP status
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
 8001cbc:	b580      	push	{r7, lr}
 8001cbe:	b08c      	sub	sp, #48	@ 0x30
 8001cc0:	af00      	add	r7, sp, #0
 8001cc2:	4603      	mov	r3, r0
 8001cc4:	71fb      	strb	r3, [r7, #7]
  int32_t ret = BSP_ERROR_NONE;
 8001cc6:	2300      	movs	r3, #0
 8001cc8:	62fb      	str	r3, [r7, #44]	@ 0x2c
  GPIO_InitTypeDef  gpio_init_structure;

  if((Led != LED1) && (Led != LED2) && (Led != LED3))
 8001cca:	79fb      	ldrb	r3, [r7, #7]
 8001ccc:	2b00      	cmp	r3, #0
 8001cce:	d009      	beq.n	8001ce4 <BSP_LED_Init+0x28>
 8001cd0:	79fb      	ldrb	r3, [r7, #7]
 8001cd2:	2b01      	cmp	r3, #1
 8001cd4:	d006      	beq.n	8001ce4 <BSP_LED_Init+0x28>
 8001cd6:	79fb      	ldrb	r3, [r7, #7]
 8001cd8:	2b02      	cmp	r3, #2
 8001cda:	d003      	beq.n	8001ce4 <BSP_LED_Init+0x28>
  {
    ret = BSP_ERROR_WRONG_PARAM;
 8001cdc:	f06f 0301 	mvn.w	r3, #1
 8001ce0:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8001ce2:	e055      	b.n	8001d90 <BSP_LED_Init+0xd4>
  }
  else
  {
    /* Enable the GPIO LED Clock */
    if(Led == LED1)
 8001ce4:	79fb      	ldrb	r3, [r7, #7]
 8001ce6:	2b00      	cmp	r3, #0
 8001ce8:	d10f      	bne.n	8001d0a <BSP_LED_Init+0x4e>
    {
      LED1_GPIO_CLK_ENABLE();
 8001cea:	4b2c      	ldr	r3, [pc, #176]	@ (8001d9c <BSP_LED_Init+0xe0>)
 8001cec:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001cf0:	4a2a      	ldr	r2, [pc, #168]	@ (8001d9c <BSP_LED_Init+0xe0>)
 8001cf2:	f043 0302 	orr.w	r3, r3, #2
 8001cf6:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8001cfa:	4b28      	ldr	r3, [pc, #160]	@ (8001d9c <BSP_LED_Init+0xe0>)
 8001cfc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001d00:	f003 0302 	and.w	r3, r3, #2
 8001d04:	617b      	str	r3, [r7, #20]
 8001d06:	697b      	ldr	r3, [r7, #20]
 8001d08:	e021      	b.n	8001d4e <BSP_LED_Init+0x92>
    }
    else if(Led == LED2)
 8001d0a:	79fb      	ldrb	r3, [r7, #7]
 8001d0c:	2b01      	cmp	r3, #1
 8001d0e:	d10f      	bne.n	8001d30 <BSP_LED_Init+0x74>
    {
      LED2_GPIO_CLK_ENABLE();
 8001d10:	4b22      	ldr	r3, [pc, #136]	@ (8001d9c <BSP_LED_Init+0xe0>)
 8001d12:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001d16:	4a21      	ldr	r2, [pc, #132]	@ (8001d9c <BSP_LED_Init+0xe0>)
 8001d18:	f043 0310 	orr.w	r3, r3, #16
 8001d1c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8001d20:	4b1e      	ldr	r3, [pc, #120]	@ (8001d9c <BSP_LED_Init+0xe0>)
 8001d22:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001d26:	f003 0310 	and.w	r3, r3, #16
 8001d2a:	613b      	str	r3, [r7, #16]
 8001d2c:	693b      	ldr	r3, [r7, #16]
 8001d2e:	e00e      	b.n	8001d4e <BSP_LED_Init+0x92>
    }
    else
    {
      LED3_GPIO_CLK_ENABLE();
 8001d30:	4b1a      	ldr	r3, [pc, #104]	@ (8001d9c <BSP_LED_Init+0xe0>)
 8001d32:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001d36:	4a19      	ldr	r2, [pc, #100]	@ (8001d9c <BSP_LED_Init+0xe0>)
 8001d38:	f043 0302 	orr.w	r3, r3, #2
 8001d3c:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8001d40:	4b16      	ldr	r3, [pc, #88]	@ (8001d9c <BSP_LED_Init+0xe0>)
 8001d42:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001d46:	f003 0302 	and.w	r3, r3, #2
 8001d4a:	60fb      	str	r3, [r7, #12]
 8001d4c:	68fb      	ldr	r3, [r7, #12]
    }
    /* Configure the GPIO_LED pin */
    gpio_init_structure.Pin   = LED_PIN[Led];
 8001d4e:	79fb      	ldrb	r3, [r7, #7]
 8001d50:	4a13      	ldr	r2, [pc, #76]	@ (8001da0 <BSP_LED_Init+0xe4>)
 8001d52:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8001d56:	61bb      	str	r3, [r7, #24]
    gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
 8001d58:	2301      	movs	r3, #1
 8001d5a:	61fb      	str	r3, [r7, #28]
    gpio_init_structure.Pull  = GPIO_NOPULL;
 8001d5c:	2300      	movs	r3, #0
 8001d5e:	623b      	str	r3, [r7, #32]
    gpio_init_structure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8001d60:	2303      	movs	r3, #3
 8001d62:	627b      	str	r3, [r7, #36]	@ 0x24

    HAL_GPIO_Init(LED_PORT[Led], &gpio_init_structure);
 8001d64:	79fb      	ldrb	r3, [r7, #7]
 8001d66:	4a0f      	ldr	r2, [pc, #60]	@ (8001da4 <BSP_LED_Init+0xe8>)
 8001d68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8001d6c:	f107 0218 	add.w	r2, r7, #24
 8001d70:	4611      	mov	r1, r2
 8001d72:	4618      	mov	r0, r3
 8001d74:	f004 f9c4 	bl	8006100 <HAL_GPIO_Init>
    HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
 8001d78:	79fb      	ldrb	r3, [r7, #7]
 8001d7a:	4a0a      	ldr	r2, [pc, #40]	@ (8001da4 <BSP_LED_Init+0xe8>)
 8001d7c:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 8001d80:	79fb      	ldrb	r3, [r7, #7]
 8001d82:	4a07      	ldr	r2, [pc, #28]	@ (8001da0 <BSP_LED_Init+0xe4>)
 8001d84:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8001d88:	2200      	movs	r2, #0
 8001d8a:	4619      	mov	r1, r3
 8001d8c:	f004 fb68 	bl	8006460 <HAL_GPIO_WritePin>
  }

  return ret;
 8001d90:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
}
 8001d92:	4618      	mov	r0, r3
 8001d94:	3730      	adds	r7, #48	@ 0x30
 8001d96:	46bd      	mov	sp, r7
 8001d98:	bd80      	pop	{r7, pc}
 8001d9a:	bf00      	nop
 8001d9c:	58024400 	.word	0x58024400
 8001da0:	08018688 	.word	0x08018688
 8001da4:	24000008 	.word	0x24000008

08001da8 <BSP_PB_Init>:
  *            @arg  BUTTON_MODE_GPIO: Button will be used as simple IO
  *            @arg  BUTTON_MODE_EXTI: Button will be connected to EXTI line
  *                                    with interrupt generation capability
  */
int32_t BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
 8001da8:	b580      	push	{r7, lr}
 8001daa:	b088      	sub	sp, #32
 8001dac:	af00      	add	r7, sp, #0
 8001dae:	4603      	mov	r3, r0
 8001db0:	460a      	mov	r2, r1
 8001db2:	71fb      	strb	r3, [r7, #7]
 8001db4:	4613      	mov	r3, r2
 8001db6:	71bb      	strb	r3, [r7, #6]
  static BSP_EXTI_LineCallback ButtonCallback[BUTTONn] = {BUTTON_USER_EXTI_Callback};
  static uint32_t  BSP_BUTTON_PRIO [BUTTONn] = {BSP_BUTTON_USER_IT_PRIORITY};
  static const uint32_t BUTTON_EXTI_LINE[BUTTONn] = {BUTTON_USER_EXTI_LINE};

  /* Enable the BUTTON clock */
  BUTTON_USER_GPIO_CLK_ENABLE();
 8001db8:	4b2e      	ldr	r3, [pc, #184]	@ (8001e74 <BSP_PB_Init+0xcc>)
 8001dba:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001dbe:	4a2d      	ldr	r2, [pc, #180]	@ (8001e74 <BSP_PB_Init+0xcc>)
 8001dc0:	f043 0304 	orr.w	r3, r3, #4
 8001dc4:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8001dc8:	4b2a      	ldr	r3, [pc, #168]	@ (8001e74 <BSP_PB_Init+0xcc>)
 8001dca:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8001dce:	f003 0304 	and.w	r3, r3, #4
 8001dd2:	60bb      	str	r3, [r7, #8]
 8001dd4:	68bb      	ldr	r3, [r7, #8]

  gpio_init_structure.Pin = BUTTON_PIN [Button];
 8001dd6:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
 8001dda:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Pull = GPIO_PULLDOWN;
 8001ddc:	2302      	movs	r3, #2
 8001dde:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Speed = GPIO_SPEED_FREQ_HIGH;
 8001de0:	2302      	movs	r3, #2
 8001de2:	61bb      	str	r3, [r7, #24]

  if(ButtonMode == BUTTON_MODE_GPIO)
 8001de4:	79bb      	ldrb	r3, [r7, #6]
 8001de6:	2b00      	cmp	r3, #0
 8001de8:	d10c      	bne.n	8001e04 <BSP_PB_Init+0x5c>
  {
    /* Configure Button pin as input */
    gpio_init_structure.Mode = GPIO_MODE_INPUT;
 8001dea:	2300      	movs	r3, #0
 8001dec:	613b      	str	r3, [r7, #16]
    HAL_GPIO_Init(BUTTON_PORT [Button], &gpio_init_structure);
 8001dee:	79fb      	ldrb	r3, [r7, #7]
 8001df0:	4a21      	ldr	r2, [pc, #132]	@ (8001e78 <BSP_PB_Init+0xd0>)
 8001df2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8001df6:	f107 020c 	add.w	r2, r7, #12
 8001dfa:	4611      	mov	r1, r2
 8001dfc:	4618      	mov	r0, r3
 8001dfe:	f004 f97f 	bl	8006100 <HAL_GPIO_Init>
 8001e02:	e031      	b.n	8001e68 <BSP_PB_Init+0xc0>
  }
  else /* (ButtonMode == BUTTON_MODE_EXTI) */
  {
    /* Configure Button pin as input with External interrupt */
    gpio_init_structure.Mode = GPIO_MODE_IT_RISING;
 8001e04:	f44f 1388 	mov.w	r3, #1114112	@ 0x110000
 8001e08:	613b      	str	r3, [r7, #16]

    HAL_GPIO_Init(BUTTON_PORT[Button], &gpio_init_structure);
 8001e0a:	79fb      	ldrb	r3, [r7, #7]
 8001e0c:	4a1a      	ldr	r2, [pc, #104]	@ (8001e78 <BSP_PB_Init+0xd0>)
 8001e0e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8001e12:	f107 020c 	add.w	r2, r7, #12
 8001e16:	4611      	mov	r1, r2
 8001e18:	4618      	mov	r0, r3
 8001e1a:	f004 f971 	bl	8006100 <HAL_GPIO_Init>

    (void)HAL_EXTI_GetHandle(&hpb_exti[Button], BUTTON_EXTI_LINE[Button]);
 8001e1e:	79fb      	ldrb	r3, [r7, #7]
 8001e20:	00db      	lsls	r3, r3, #3
 8001e22:	4a16      	ldr	r2, [pc, #88]	@ (8001e7c <BSP_PB_Init+0xd4>)
 8001e24:	441a      	add	r2, r3
 8001e26:	79fb      	ldrb	r3, [r7, #7]
 8001e28:	4915      	ldr	r1, [pc, #84]	@ (8001e80 <BSP_PB_Init+0xd8>)
 8001e2a:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8001e2e:	4619      	mov	r1, r3
 8001e30:	4610      	mov	r0, r2
 8001e32:	f004 f914 	bl	800605e <HAL_EXTI_GetHandle>
    (void)HAL_EXTI_RegisterCallback(&hpb_exti[Button],  HAL_EXTI_COMMON_CB_ID, ButtonCallback[Button]);
 8001e36:	79fb      	ldrb	r3, [r7, #7]
 8001e38:	00db      	lsls	r3, r3, #3
 8001e3a:	4a10      	ldr	r2, [pc, #64]	@ (8001e7c <BSP_PB_Init+0xd4>)
 8001e3c:	1898      	adds	r0, r3, r2
 8001e3e:	79fb      	ldrb	r3, [r7, #7]
 8001e40:	4a10      	ldr	r2, [pc, #64]	@ (8001e84 <BSP_PB_Init+0xdc>)
 8001e42:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8001e46:	461a      	mov	r2, r3
 8001e48:	2100      	movs	r1, #0
 8001e4a:	f004 f8e9 	bl	8006020 <HAL_EXTI_RegisterCallback>

    /* Enable and set Button EXTI Interrupt to the lowest priority */
    HAL_NVIC_SetPriority((BUTTON_IRQn[Button]), BSP_BUTTON_PRIO[Button], 0x00);
 8001e4e:	2028      	movs	r0, #40	@ 0x28
 8001e50:	79fb      	ldrb	r3, [r7, #7]
 8001e52:	4a0d      	ldr	r2, [pc, #52]	@ (8001e88 <BSP_PB_Init+0xe0>)
 8001e54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8001e58:	2200      	movs	r2, #0
 8001e5a:	4619      	mov	r1, r3
 8001e5c:	f001 ffcc 	bl	8003df8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ((BUTTON_IRQn[Button]));
 8001e60:	2328      	movs	r3, #40	@ 0x28
 8001e62:	4618      	mov	r0, r3
 8001e64:	f001 ffe2 	bl	8003e2c <HAL_NVIC_EnableIRQ>
  }

  return BSP_ERROR_NONE;
 8001e68:	2300      	movs	r3, #0
}
 8001e6a:	4618      	mov	r0, r3
 8001e6c:	3720      	adds	r7, #32
 8001e6e:	46bd      	mov	sp, r7
 8001e70:	bd80      	pop	{r7, pc}
 8001e72:	bf00      	nop
 8001e74:	58024400 	.word	0x58024400
 8001e78:	24000014 	.word	0x24000014
 8001e7c:	24001378 	.word	0x24001378
 8001e80:	08018690 	.word	0x08018690
 8001e84:	24000018 	.word	0x24000018
 8001e88:	2400001c 	.word	0x2400001c

08001e8c <BSP_PB_IRQHandler>:
  * @brief  BSP Button IRQ handler
  * @param  Button Can only be BUTTON_USER
  * @retval None
  */
void BSP_PB_IRQHandler(Button_TypeDef Button)
{
 8001e8c:	b580      	push	{r7, lr}
 8001e8e:	b082      	sub	sp, #8
 8001e90:	af00      	add	r7, sp, #0
 8001e92:	4603      	mov	r3, r0
 8001e94:	71fb      	strb	r3, [r7, #7]
  HAL_EXTI_IRQHandler(&hpb_exti[Button]);
 8001e96:	79fb      	ldrb	r3, [r7, #7]
 8001e98:	00db      	lsls	r3, r3, #3
 8001e9a:	4a04      	ldr	r2, [pc, #16]	@ (8001eac <BSP_PB_IRQHandler+0x20>)
 8001e9c:	4413      	add	r3, r2
 8001e9e:	4618      	mov	r0, r3
 8001ea0:	f004 f8f2 	bl	8006088 <HAL_EXTI_IRQHandler>
}
 8001ea4:	bf00      	nop
 8001ea6:	3708      	adds	r7, #8
 8001ea8:	46bd      	mov	sp, r7
 8001eaa:	bd80      	pop	{r7, pc}
 8001eac:	24001378 	.word	0x24001378

08001eb0 <BSP_PB_Callback>:
  * @brief  BSP Push Button callback
  * @param  Button Specifies the pin connected EXTI line
  * @retval None
  */
__weak void BSP_PB_Callback(Button_TypeDef Button)
{
 8001eb0:	b480      	push	{r7}
 8001eb2:	b083      	sub	sp, #12
 8001eb4:	af00      	add	r7, sp, #0
 8001eb6:	4603      	mov	r3, r0
 8001eb8:	71fb      	strb	r3, [r7, #7]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Button);

  /* This function should be implemented by the user application.
     It is called into this driver when an event on Button is triggered. */
}
 8001eba:	bf00      	nop
 8001ebc:	370c      	adds	r7, #12
 8001ebe:	46bd      	mov	sp, r7
 8001ec0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001ec4:	4770      	bx	lr

08001ec6 <BUTTON_USER_EXTI_Callback>:
/**
  * @brief  Key EXTI line detection callbacks.
  * @retval BSP status
  */
static void BUTTON_USER_EXTI_Callback(void)
{
 8001ec6:	b580      	push	{r7, lr}
 8001ec8:	af00      	add	r7, sp, #0
  BSP_PB_Callback(BUTTON_USER);
 8001eca:	2000      	movs	r0, #0
 8001ecc:	f7ff fff0 	bl	8001eb0 <BSP_PB_Callback>
}
 8001ed0:	bf00      	nop
 8001ed2:	bd80      	pop	{r7, pc}

08001ed4 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001ed4:	b580      	push	{r7, lr}
 8001ed6:	b082      	sub	sp, #8
 8001ed8:	af00      	add	r7, sp, #0
   __HAL_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  /* Configure the Cortex-M4 ART Base address to the Flash Bank 2 : */
   __HAL_ART_ENABLE();                           /* Enable the Cortex-M4 ART */
#endif /* DUAL_CORE &&  CORE_CM4 */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001eda:	2003      	movs	r0, #3
 8001edc:	f001 ff81 	bl	8003de2 <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8001ee0:	f005 ff94 	bl	8007e0c <HAL_RCC_GetSysClockFreq>
 8001ee4:	4602      	mov	r2, r0
 8001ee6:	4b15      	ldr	r3, [pc, #84]	@ (8001f3c <HAL_Init+0x68>)
 8001ee8:	699b      	ldr	r3, [r3, #24]
 8001eea:	0a1b      	lsrs	r3, r3, #8
 8001eec:	f003 030f 	and.w	r3, r3, #15
 8001ef0:	4913      	ldr	r1, [pc, #76]	@ (8001f40 <HAL_Init+0x6c>)
 8001ef2:	5ccb      	ldrb	r3, [r1, r3]
 8001ef4:	f003 031f 	and.w	r3, r3, #31
 8001ef8:	fa22 f303 	lsr.w	r3, r2, r3
 8001efc:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8001efe:	4b0f      	ldr	r3, [pc, #60]	@ (8001f3c <HAL_Init+0x68>)
 8001f00:	699b      	ldr	r3, [r3, #24]
 8001f02:	f003 030f 	and.w	r3, r3, #15
 8001f06:	4a0e      	ldr	r2, [pc, #56]	@ (8001f40 <HAL_Init+0x6c>)
 8001f08:	5cd3      	ldrb	r3, [r2, r3]
 8001f0a:	f003 031f 	and.w	r3, r3, #31
 8001f0e:	687a      	ldr	r2, [r7, #4]
 8001f10:	fa22 f303 	lsr.w	r3, r2, r3
 8001f14:	4a0b      	ldr	r2, [pc, #44]	@ (8001f44 <HAL_Init+0x70>)
 8001f16:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 8001f18:	4a0b      	ldr	r2, [pc, #44]	@ (8001f48 <HAL_Init+0x74>)
 8001f1a:	687b      	ldr	r3, [r7, #4]
 8001f1c:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8001f1e:	200f      	movs	r0, #15
 8001f20:	f7ff fc76 	bl	8001810 <HAL_InitTick>
 8001f24:	4603      	mov	r3, r0
 8001f26:	2b00      	cmp	r3, #0
 8001f28:	d001      	beq.n	8001f2e <HAL_Init+0x5a>
  {
    return HAL_ERROR;
 8001f2a:	2301      	movs	r3, #1
 8001f2c:	e002      	b.n	8001f34 <HAL_Init+0x60>
  }

  /* Init the low level hardware */
  HAL_MspInit();
 8001f2e:	f7ff fa59 	bl	80013e4 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 8001f32:	2300      	movs	r3, #0
}
 8001f34:	4618      	mov	r0, r3
 8001f36:	3708      	adds	r7, #8
 8001f38:	46bd      	mov	sp, r7
 8001f3a:	bd80      	pop	{r7, pc}
 8001f3c:	58024400 	.word	0x58024400
 8001f40:	0801860c 	.word	0x0801860c
 8001f44:	24000004 	.word	0x24000004
 8001f48:	24000000 	.word	0x24000000

08001f4c <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8001f4c:	b480      	push	{r7}
 8001f4e:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 8001f50:	4b06      	ldr	r3, [pc, #24]	@ (8001f6c <HAL_IncTick+0x20>)
 8001f52:	781b      	ldrb	r3, [r3, #0]
 8001f54:	461a      	mov	r2, r3
 8001f56:	4b06      	ldr	r3, [pc, #24]	@ (8001f70 <HAL_IncTick+0x24>)
 8001f58:	681b      	ldr	r3, [r3, #0]
 8001f5a:	4413      	add	r3, r2
 8001f5c:	4a04      	ldr	r2, [pc, #16]	@ (8001f70 <HAL_IncTick+0x24>)
 8001f5e:	6013      	str	r3, [r2, #0]
}
 8001f60:	bf00      	nop
 8001f62:	46bd      	mov	sp, r7
 8001f64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f68:	4770      	bx	lr
 8001f6a:	bf00      	nop
 8001f6c:	24000024 	.word	0x24000024
 8001f70:	24001380 	.word	0x24001380

08001f74 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8001f74:	b480      	push	{r7}
 8001f76:	af00      	add	r7, sp, #0
  return uwTick;
 8001f78:	4b03      	ldr	r3, [pc, #12]	@ (8001f88 <HAL_GetTick+0x14>)
 8001f7a:	681b      	ldr	r3, [r3, #0]
}
 8001f7c:	4618      	mov	r0, r3
 8001f7e:	46bd      	mov	sp, r7
 8001f80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f84:	4770      	bx	lr
 8001f86:	bf00      	nop
 8001f88:	24001380 	.word	0x24001380

08001f8c <HAL_GetREVID>:
/**
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
 8001f8c:	b480      	push	{r7}
 8001f8e:	af00      	add	r7, sp, #0
   return((DBGMCU->IDCODE) >> 16);
 8001f90:	4b03      	ldr	r3, [pc, #12]	@ (8001fa0 <HAL_GetREVID+0x14>)
 8001f92:	681b      	ldr	r3, [r3, #0]
 8001f94:	0c1b      	lsrs	r3, r3, #16
}
 8001f96:	4618      	mov	r0, r3
 8001f98:	46bd      	mov	sp, r7
 8001f9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f9e:	4770      	bx	lr
 8001fa0:	5c001000 	.word	0x5c001000

08001fa4 <LL_ADC_SetCommonClock>:
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV128
  *         @arg @ref LL_ADC_CLOCK_ASYNC_DIV256
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonClock(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t CommonClock)
{
 8001fa4:	b480      	push	{r7}
 8001fa6:	b083      	sub	sp, #12
 8001fa8:	af00      	add	r7, sp, #0
 8001faa:	6078      	str	r0, [r7, #4]
 8001fac:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 8001fae:	687b      	ldr	r3, [r7, #4]
 8001fb0:	689b      	ldr	r3, [r3, #8]
 8001fb2:	f423 127c 	bic.w	r2, r3, #4128768	@ 0x3f0000
 8001fb6:	683b      	ldr	r3, [r7, #0]
 8001fb8:	431a      	orrs	r2, r3
 8001fba:	687b      	ldr	r3, [r7, #4]
 8001fbc:	609a      	str	r2, [r3, #8]
}
 8001fbe:	bf00      	nop
 8001fc0:	370c      	adds	r7, #12
 8001fc2:	46bd      	mov	sp, r7
 8001fc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001fc8:	4770      	bx	lr

08001fca <LL_ADC_SetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetCommonPathInternalCh(ADC_Common_TypeDef *ADCxy_COMMON, uint32_t PathInternal)
{
 8001fca:	b480      	push	{r7}
 8001fcc:	b083      	sub	sp, #12
 8001fce:	af00      	add	r7, sp, #0
 8001fd0:	6078      	str	r0, [r7, #4]
 8001fd2:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 8001fd4:	687b      	ldr	r3, [r7, #4]
 8001fd6:	689b      	ldr	r3, [r3, #8]
 8001fd8:	f023 72e0 	bic.w	r2, r3, #29360128	@ 0x1c00000
 8001fdc:	683b      	ldr	r3, [r7, #0]
 8001fde:	431a      	orrs	r2, r3
 8001fe0:	687b      	ldr	r3, [r7, #4]
 8001fe2:	609a      	str	r2, [r3, #8]
}
 8001fe4:	bf00      	nop
 8001fe6:	370c      	adds	r7, #12
 8001fe8:	46bd      	mov	sp, r7
 8001fea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001fee:	4770      	bx	lr

08001ff0 <LL_ADC_GetCommonPathInternalCh>:
  *         @arg @ref LL_ADC_PATH_INTERNAL_VREFINT
  *         @arg @ref LL_ADC_PATH_INTERNAL_TEMPSENSOR
  *         @arg @ref LL_ADC_PATH_INTERNAL_VBAT
  */
__STATIC_INLINE uint32_t LL_ADC_GetCommonPathInternalCh(const ADC_Common_TypeDef *ADCxy_COMMON)
{
 8001ff0:	b480      	push	{r7}
 8001ff2:	b083      	sub	sp, #12
 8001ff4:	af00      	add	r7, sp, #0
 8001ff6:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8001ff8:	687b      	ldr	r3, [r7, #4]
 8001ffa:	689b      	ldr	r3, [r3, #8]
 8001ffc:	f003 73e0 	and.w	r3, r3, #29360128	@ 0x1c00000
}
 8002000:	4618      	mov	r0, r3
 8002002:	370c      	adds	r7, #12
 8002004:	46bd      	mov	sp, r7
 8002006:	f85d 7b04 	ldr.w	r7, [sp], #4
 800200a:	4770      	bx	lr

0800200c <LL_ADC_SetChannelPreselection>:
  *         @arg @ref LL_ADC_CHANNEL_18
  *         @arg @ref LL_ADC_CHANNEL_19
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelPreselection(ADC_TypeDef *ADCx, uint32_t Channel)
{
 800200c:	b480      	push	{r7}
 800200e:	b087      	sub	sp, #28
 8002010:	af00      	add	r7, sp, #0
 8002012:	6078      	str	r0, [r7, #4]
 8002014:	6039      	str	r1, [r7, #0]
      /* ADC channels preselection */
      ADCx->PCSEL_RES0 |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB(Channel) & 0x1FUL));
    }
#else
    /* ADC channels preselection */
    ADCx->PCSEL |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB(Channel) & 0x1FUL));
 8002016:	683b      	ldr	r3, [r7, #0]
 8002018:	f3c3 0313 	ubfx	r3, r3, #0, #20
 800201c:	2b00      	cmp	r3, #0
 800201e:	d107      	bne.n	8002030 <LL_ADC_SetChannelPreselection+0x24>
 8002020:	683b      	ldr	r3, [r7, #0]
 8002022:	0e9b      	lsrs	r3, r3, #26
 8002024:	f003 031f 	and.w	r3, r3, #31
 8002028:	2201      	movs	r2, #1
 800202a:	fa02 f303 	lsl.w	r3, r2, r3
 800202e:	e015      	b.n	800205c <LL_ADC_SetChannelPreselection+0x50>
 8002030:	683b      	ldr	r3, [r7, #0]
 8002032:	613b      	str	r3, [r7, #16]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002034:	693b      	ldr	r3, [r7, #16]
 8002036:	fa93 f3a3 	rbit	r3, r3
 800203a:	60fb      	str	r3, [r7, #12]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return result;
 800203c:	68fb      	ldr	r3, [r7, #12]
 800203e:	617b      	str	r3, [r7, #20]
     optimisations using the logic "value was passed to __builtin_clz, so it
     is non-zero".
     ARM GCC 7.3 and possibly earlier will optimise this test away, leaving a
     single CLZ instruction.
   */
  if (value == 0U)
 8002040:	697b      	ldr	r3, [r7, #20]
 8002042:	2b00      	cmp	r3, #0
 8002044:	d101      	bne.n	800204a <LL_ADC_SetChannelPreselection+0x3e>
  {
    return 32U;
 8002046:	2320      	movs	r3, #32
 8002048:	e003      	b.n	8002052 <LL_ADC_SetChannelPreselection+0x46>
  }
  return __builtin_clz(value);
 800204a:	697b      	ldr	r3, [r7, #20]
 800204c:	fab3 f383 	clz	r3, r3
 8002050:	b2db      	uxtb	r3, r3
 8002052:	f003 031f 	and.w	r3, r3, #31
 8002056:	2201      	movs	r2, #1
 8002058:	fa02 f303 	lsl.w	r3, r2, r3
 800205c:	687a      	ldr	r2, [r7, #4]
 800205e:	69d2      	ldr	r2, [r2, #28]
 8002060:	431a      	orrs	r2, r3
 8002062:	687b      	ldr	r3, [r7, #4]
 8002064:	61da      	str	r2, [r3, #28]
#endif /* ADC_VER_V5_V90 */
}
 8002066:	bf00      	nop
 8002068:	371c      	adds	r7, #28
 800206a:	46bd      	mov	sp, r7
 800206c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002070:	4770      	bx	lr

08002072 <LL_ADC_SetOffset>:
  *             Other channels are slow channels (conversion rate: refer to reference manual).
  * @param  OffsetLevel Value between Min_Data=0x000 and Max_Data=0x3FFFFFF
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetOffset(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t Channel, uint32_t OffsetLevel)
{
 8002072:	b480      	push	{r7}
 8002074:	b087      	sub	sp, #28
 8002076:	af00      	add	r7, sp, #0
 8002078:	60f8      	str	r0, [r7, #12]
 800207a:	60b9      	str	r1, [r7, #8]
 800207c:	607a      	str	r2, [r7, #4]
 800207e:	603b      	str	r3, [r7, #0]
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8002080:	68fb      	ldr	r3, [r7, #12]
 8002082:	3360      	adds	r3, #96	@ 0x60
 8002084:	461a      	mov	r2, r3
 8002086:	68bb      	ldr	r3, [r7, #8]
 8002088:	009b      	lsls	r3, r3, #2
 800208a:	4413      	add	r3, r2
 800208c:	617b      	str	r3, [r7, #20]
               ADC3_OFR1_OFFSET1_EN | (Channel & ADC_CHANNEL_ID_NUMBER_MASK) | OffsetLevel);
  }
  else
#endif /* ADC_VER_V5_V90 */
  {
    MODIFY_REG(*preg,
 800208e:	697b      	ldr	r3, [r7, #20]
 8002090:	681b      	ldr	r3, [r3, #0]
 8002092:	f003 4200 	and.w	r2, r3, #2147483648	@ 0x80000000
 8002096:	687b      	ldr	r3, [r7, #4]
 8002098:	f003 41f8 	and.w	r1, r3, #2080374784	@ 0x7c000000
 800209c:	683b      	ldr	r3, [r7, #0]
 800209e:	430b      	orrs	r3, r1
 80020a0:	431a      	orrs	r2, r3
 80020a2:	697b      	ldr	r3, [r7, #20]
 80020a4:	601a      	str	r2, [r3, #0]
               ADC_OFR1_OFFSET1_CH | ADC_OFR1_OFFSET1,
               (Channel & ADC_CHANNEL_ID_NUMBER_MASK) | OffsetLevel);
  }
}
 80020a6:	bf00      	nop
 80020a8:	371c      	adds	r7, #28
 80020aa:	46bd      	mov	sp, r7
 80020ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80020b0:	4770      	bx	lr

080020b2 <LL_ADC_SetDataRightShift>:
  *         @arg @ref LL_ADC_OFFSET_RSHIFT_ENABLE
  *         @arg @ref LL_ADC_OFFSET_RSHIFT_DISABLE
  * @retval Returned None
  */
__STATIC_INLINE void LL_ADC_SetDataRightShift(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t RigthShift)
{
 80020b2:	b480      	push	{r7}
 80020b4:	b085      	sub	sp, #20
 80020b6:	af00      	add	r7, sp, #0
 80020b8:	60f8      	str	r0, [r7, #12]
 80020ba:	60b9      	str	r1, [r7, #8]
 80020bc:	607a      	str	r2, [r7, #4]
  MODIFY_REG(ADCx->CFGR2, (ADC_CFGR2_RSHIFT1 | ADC_CFGR2_RSHIFT2 | ADC_CFGR2_RSHIFT3 | ADC_CFGR2_RSHIFT4), RigthShift << (Offsety & 0x1FUL));
 80020be:	68fb      	ldr	r3, [r7, #12]
 80020c0:	691b      	ldr	r3, [r3, #16]
 80020c2:	f423 42f0 	bic.w	r2, r3, #30720	@ 0x7800
 80020c6:	68bb      	ldr	r3, [r7, #8]
 80020c8:	f003 031f 	and.w	r3, r3, #31
 80020cc:	6879      	ldr	r1, [r7, #4]
 80020ce:	fa01 f303 	lsl.w	r3, r1, r3
 80020d2:	431a      	orrs	r2, r3
 80020d4:	68fb      	ldr	r3, [r7, #12]
 80020d6:	611a      	str	r2, [r3, #16]
}
 80020d8:	bf00      	nop
 80020da:	3714      	adds	r7, #20
 80020dc:	46bd      	mov	sp, r7
 80020de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80020e2:	4770      	bx	lr

080020e4 <LL_ADC_SetOffsetSignedSaturation>:
  *         @arg @ref LL_ADC_OFFSET_SIGNED_SATURATION_ENABLE
  *         @arg @ref LL_ADC_OFFSET_SIGNED_SATURATION_DISABLE
  * @retval Returned None
  */
__STATIC_INLINE void LL_ADC_SetOffsetSignedSaturation(ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetSignedSaturation)
{
 80020e4:	b480      	push	{r7}
 80020e6:	b087      	sub	sp, #28
 80020e8:	af00      	add	r7, sp, #0
 80020ea:	60f8      	str	r0, [r7, #12]
 80020ec:	60b9      	str	r1, [r7, #8]
 80020ee:	607a      	str	r2, [r7, #4]
    /* Function not available on this instance */
  }
  else
#endif  /* ADC_VER_V5_V90 */
  {
    __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80020f0:	68fb      	ldr	r3, [r7, #12]
 80020f2:	3360      	adds	r3, #96	@ 0x60
 80020f4:	461a      	mov	r2, r3
 80020f6:	68bb      	ldr	r3, [r7, #8]
 80020f8:	009b      	lsls	r3, r3, #2
 80020fa:	4413      	add	r3, r2
 80020fc:	617b      	str	r3, [r7, #20]
    MODIFY_REG(*preg, ADC_OFR1_SSATE, OffsetSignedSaturation);
 80020fe:	697b      	ldr	r3, [r7, #20]
 8002100:	681b      	ldr	r3, [r3, #0]
 8002102:	f023 4200 	bic.w	r2, r3, #2147483648	@ 0x80000000
 8002106:	687b      	ldr	r3, [r7, #4]
 8002108:	431a      	orrs	r2, r3
 800210a:	697b      	ldr	r3, [r7, #20]
 800210c:	601a      	str	r2, [r3, #0]
  }
}
 800210e:	bf00      	nop
 8002110:	371c      	adds	r7, #28
 8002112:	46bd      	mov	sp, r7
 8002114:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002118:	4770      	bx	lr

0800211a <LL_ADC_REG_IsTriggerSourceSWStart>:
  * @param  ADCx ADC instance
  * @retval Value "0" if trigger source external trigger
  *         Value "1" if trigger source SW start.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsTriggerSourceSWStart(const ADC_TypeDef *ADCx)
{
 800211a:	b480      	push	{r7}
 800211c:	b083      	sub	sp, #12
 800211e:	af00      	add	r7, sp, #0
 8002120:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
 8002122:	687b      	ldr	r3, [r7, #4]
 8002124:	68db      	ldr	r3, [r3, #12]
 8002126:	f403 6340 	and.w	r3, r3, #3072	@ 0xc00
 800212a:	2b00      	cmp	r3, #0
 800212c:	d101      	bne.n	8002132 <LL_ADC_REG_IsTriggerSourceSWStart+0x18>
 800212e:	2301      	movs	r3, #1
 8002130:	e000      	b.n	8002134 <LL_ADC_REG_IsTriggerSourceSWStart+0x1a>
 8002132:	2300      	movs	r3, #0
}
 8002134:	4618      	mov	r0, r3
 8002136:	370c      	adds	r7, #12
 8002138:	46bd      	mov	sp, r7
 800213a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800213e:	4770      	bx	lr

08002140 <LL_ADC_REG_SetSequencerRanks>:
  *         (3) On STM32H7, fast channel (0.125 us for 14-bit resolution (ADC conversion rate up to 8 Ms/s)).
  *             Other channels are slow channels (conversion rate: refer to reference manual).
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetSequencerRanks(ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)
{
 8002140:	b480      	push	{r7}
 8002142:	b087      	sub	sp, #28
 8002144:	af00      	add	r7, sp, #0
 8002146:	60f8      	str	r0, [r7, #12]
 8002148:	60b9      	str	r1, [r7, #8]
 800214a:	607a      	str	r2, [r7, #4]
  /* Set bits with content of parameter "Channel" with bits position          */
  /* in register and register position depending on parameter "Rank".         */
  /* Parameters "Rank" and "Channel" are used with masks because containing   */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 800214c:	68fb      	ldr	r3, [r7, #12]
 800214e:	3330      	adds	r3, #48	@ 0x30
 8002150:	461a      	mov	r2, r3
 8002152:	68bb      	ldr	r3, [r7, #8]
 8002154:	0a1b      	lsrs	r3, r3, #8
 8002156:	009b      	lsls	r3, r3, #2
 8002158:	f003 030c 	and.w	r3, r3, #12
 800215c:	4413      	add	r3, r2
 800215e:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 8002160:	697b      	ldr	r3, [r7, #20]
 8002162:	681a      	ldr	r2, [r3, #0]
 8002164:	68bb      	ldr	r3, [r7, #8]
 8002166:	f003 031f 	and.w	r3, r3, #31
 800216a:	211f      	movs	r1, #31
 800216c:	fa01 f303 	lsl.w	r3, r1, r3
 8002170:	43db      	mvns	r3, r3
 8002172:	401a      	ands	r2, r3
 8002174:	687b      	ldr	r3, [r7, #4]
 8002176:	0e9b      	lsrs	r3, r3, #26
 8002178:	f003 011f 	and.w	r1, r3, #31
 800217c:	68bb      	ldr	r3, [r7, #8]
 800217e:	f003 031f 	and.w	r3, r3, #31
 8002182:	fa01 f303 	lsl.w	r3, r1, r3
 8002186:	431a      	orrs	r2, r3
 8002188:	697b      	ldr	r3, [r7, #20]
 800218a:	601a      	str	r2, [r3, #0]
             ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0 << (Rank & ADC_REG_RANK_ID_SQRX_MASK),
             ((Channel & ADC_CHANNEL_ID_NUMBER_MASK) >> ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) << (Rank & ADC_REG_RANK_ID_SQRX_MASK));
}
 800218c:	bf00      	nop
 800218e:	371c      	adds	r7, #28
 8002190:	46bd      	mov	sp, r7
 8002192:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002196:	4770      	bx	lr

08002198 <LL_ADC_REG_SetDataTransferMode>:
  * @param  ADCx ADC instance
  * @param  DataTransferMode Select Data Management configuration
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_SetDataTransferMode(ADC_TypeDef *ADCx, uint32_t DataTransferMode)
{
 8002198:	b480      	push	{r7}
 800219a:	b083      	sub	sp, #12
 800219c:	af00      	add	r7, sp, #0
 800219e:	6078      	str	r0, [r7, #4]
 80021a0:	6039      	str	r1, [r7, #0]
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_DMNGT, DataTransferMode);
 80021a2:	687b      	ldr	r3, [r7, #4]
 80021a4:	68db      	ldr	r3, [r3, #12]
 80021a6:	f023 0203 	bic.w	r2, r3, #3
 80021aa:	683b      	ldr	r3, [r7, #0]
 80021ac:	431a      	orrs	r2, r3
 80021ae:	687b      	ldr	r3, [r7, #4]
 80021b0:	60da      	str	r2, [r3, #12]
}
 80021b2:	bf00      	nop
 80021b4:	370c      	adds	r7, #12
 80021b6:	46bd      	mov	sp, r7
 80021b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80021bc:	4770      	bx	lr

080021be <LL_ADC_INJ_IsTriggerSourceSWStart>:
  * @param  ADCx ADC instance
  * @retval Value "0" if trigger source external trigger
  *         Value "1" if trigger source SW start.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsTriggerSourceSWStart(const ADC_TypeDef *ADCx)
{
 80021be:	b480      	push	{r7}
 80021c0:	b083      	sub	sp, #12
 80021c2:	af00      	add	r7, sp, #0
 80021c4:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->JSQR, ADC_JSQR_JEXTEN) == (LL_ADC_INJ_TRIG_SOFTWARE & ADC_JSQR_JEXTEN)) ? 1UL : 0UL);
 80021c6:	687b      	ldr	r3, [r7, #4]
 80021c8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80021ca:	f403 73c0 	and.w	r3, r3, #384	@ 0x180
 80021ce:	2b00      	cmp	r3, #0
 80021d0:	d101      	bne.n	80021d6 <LL_ADC_INJ_IsTriggerSourceSWStart+0x18>
 80021d2:	2301      	movs	r3, #1
 80021d4:	e000      	b.n	80021d8 <LL_ADC_INJ_IsTriggerSourceSWStart+0x1a>
 80021d6:	2300      	movs	r3, #0
}
 80021d8:	4618      	mov	r0, r3
 80021da:	370c      	adds	r7, #12
 80021dc:	46bd      	mov	sp, r7
 80021de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80021e2:	4770      	bx	lr

080021e4 <LL_ADC_SetChannelSamplingTime>:
  *         @arg @ref LL_ADC_SAMPLINGTIME_387CYCLES_5
  *         @arg @ref LL_ADC_SAMPLINGTIME_810CYCLES_5
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
{
 80021e4:	b480      	push	{r7}
 80021e6:	b087      	sub	sp, #28
 80021e8:	af00      	add	r7, sp, #0
 80021ea:	60f8      	str	r0, [r7, #12]
 80021ec:	60b9      	str	r1, [r7, #8]
 80021ee:	607a      	str	r2, [r7, #4]
  /* Set bits with content of parameter "SamplingTime" with bits position     */
  /* in register and register position depending on parameter "Channel".      */
  /* Parameter "Channel" is used with masks because containing                */
  /* other bits reserved for other purpose.                                   */
  __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 80021f0:	68fb      	ldr	r3, [r7, #12]
 80021f2:	3314      	adds	r3, #20
 80021f4:	461a      	mov	r2, r3
 80021f6:	68bb      	ldr	r3, [r7, #8]
 80021f8:	0e5b      	lsrs	r3, r3, #25
 80021fa:	009b      	lsls	r3, r3, #2
 80021fc:	f003 0304 	and.w	r3, r3, #4
 8002200:	4413      	add	r3, r2
 8002202:	617b      	str	r3, [r7, #20]

  MODIFY_REG(*preg,
 8002204:	697b      	ldr	r3, [r7, #20]
 8002206:	681a      	ldr	r2, [r3, #0]
 8002208:	68bb      	ldr	r3, [r7, #8]
 800220a:	0d1b      	lsrs	r3, r3, #20
 800220c:	f003 031f 	and.w	r3, r3, #31
 8002210:	2107      	movs	r1, #7
 8002212:	fa01 f303 	lsl.w	r3, r1, r3
 8002216:	43db      	mvns	r3, r3
 8002218:	401a      	ands	r2, r3
 800221a:	68bb      	ldr	r3, [r7, #8]
 800221c:	0d1b      	lsrs	r3, r3, #20
 800221e:	f003 031f 	and.w	r3, r3, #31
 8002222:	6879      	ldr	r1, [r7, #4]
 8002224:	fa01 f303 	lsl.w	r3, r1, r3
 8002228:	431a      	orrs	r2, r3
 800222a:	697b      	ldr	r3, [r7, #20]
 800222c:	601a      	str	r2, [r3, #0]
             ADC_SMPR1_SMP0 << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS),
             SamplingTime   << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS));
}
 800222e:	bf00      	nop
 8002230:	371c      	adds	r7, #28
 8002232:	46bd      	mov	sp, r7
 8002234:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002238:	4770      	bx	lr
	...

0800223c <LL_ADC_SetChannelSingleDiff>:
  *         @arg @ref LL_ADC_SINGLE_ENDED
  *         @arg @ref LL_ADC_DIFFERENTIAL_ENDED
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSingleDiff(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SingleDiff)
{
 800223c:	b480      	push	{r7}
 800223e:	b085      	sub	sp, #20
 8002240:	af00      	add	r7, sp, #0
 8002242:	60f8      	str	r0, [r7, #12]
 8002244:	60b9      	str	r1, [r7, #8]
 8002246:	607a      	str	r2, [r7, #4]
  }
#else  /* ADC_VER_V5_V90 */
  /* Bits of channels in single or differential mode are set only for         */
  /* differential mode (for single mode, mask of bits allowed to be set is    */
  /* shifted out of range of bits of channels in single or differential mode. */
  MODIFY_REG(ADCx->DIFSEL,
 8002248:	68fb      	ldr	r3, [r7, #12]
 800224a:	f8d3 20c0 	ldr.w	r2, [r3, #192]	@ 0xc0
 800224e:	68bb      	ldr	r3, [r7, #8]
 8002250:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8002254:	43db      	mvns	r3, r3
 8002256:	401a      	ands	r2, r3
 8002258:	687b      	ldr	r3, [r7, #4]
 800225a:	f003 0318 	and.w	r3, r3, #24
 800225e:	4908      	ldr	r1, [pc, #32]	@ (8002280 <LL_ADC_SetChannelSingleDiff+0x44>)
 8002260:	40d9      	lsrs	r1, r3
 8002262:	68bb      	ldr	r3, [r7, #8]
 8002264:	400b      	ands	r3, r1
 8002266:	f3c3 0313 	ubfx	r3, r3, #0, #20
 800226a:	431a      	orrs	r2, r3
 800226c:	68fb      	ldr	r3, [r7, #12]
 800226e:	f8c3 20c0 	str.w	r2, [r3, #192]	@ 0xc0
             Channel & ADC_SINGLEDIFF_CHANNEL_MASK,
             (Channel & ADC_SINGLEDIFF_CHANNEL_MASK) & (ADC_DIFSEL_DIFSEL >> (SingleDiff & ADC_SINGLEDIFF_CHANNEL_SHIFT_MASK)));
#endif /* ADC_VER_V5_V90 */
}
 8002272:	bf00      	nop
 8002274:	3714      	adds	r7, #20
 8002276:	46bd      	mov	sp, r7
 8002278:	f85d 7b04 	ldr.w	r7, [sp], #4
 800227c:	4770      	bx	lr
 800227e:	bf00      	nop
 8002280:	000fffff 	.word	0x000fffff

08002284 <LL_ADC_GetMultimode>:
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_SIM
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM
  */
__STATIC_INLINE uint32_t LL_ADC_GetMultimode(const ADC_Common_TypeDef *ADCxy_COMMON)
{
 8002284:	b480      	push	{r7}
 8002286:	b083      	sub	sp, #12
 8002288:	af00      	add	r7, sp, #0
 800228a:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
 800228c:	687b      	ldr	r3, [r7, #4]
 800228e:	689b      	ldr	r3, [r3, #8]
 8002290:	f003 031f 	and.w	r3, r3, #31
}
 8002294:	4618      	mov	r0, r3
 8002296:	370c      	adds	r7, #12
 8002298:	46bd      	mov	sp, r7
 800229a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800229e:	4770      	bx	lr

080022a0 <LL_ADC_GetMultiDMATransfer>:
  *         @arg @ref LL_ADC_MULTI_REG_DMA_EACH_ADC
  *         @arg @ref LL_ADC_MULTI_REG_DMA_RES_32_10B
  *         @arg @ref LL_ADC_MULTI_REG_DMA_RES_8B
  */
__STATIC_INLINE uint32_t LL_ADC_GetMultiDMATransfer(const ADC_Common_TypeDef *ADCxy_COMMON)
{
 80022a0:	b480      	push	{r7}
 80022a2:	b083      	sub	sp, #12
 80022a4:	af00      	add	r7, sp, #0
 80022a6:	6078      	str	r0, [r7, #4]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DAMDF));
 80022a8:	687b      	ldr	r3, [r7, #4]
 80022aa:	689b      	ldr	r3, [r3, #8]
 80022ac:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
}
 80022b0:	4618      	mov	r0, r3
 80022b2:	370c      	adds	r7, #12
 80022b4:	46bd      	mov	sp, r7
 80022b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80022ba:	4770      	bx	lr

080022bc <LL_ADC_DisableDeepPowerDown>:
  * @rmtoll CR       DEEPPWD        LL_ADC_DisableDeepPowerDown
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_DisableDeepPowerDown(ADC_TypeDef *ADCx)
{
 80022bc:	b480      	push	{r7}
 80022be:	b083      	sub	sp, #12
 80022c0:	af00      	add	r7, sp, #0
 80022c2:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 80022c4:	687b      	ldr	r3, [r7, #4]
 80022c6:	689a      	ldr	r2, [r3, #8]
 80022c8:	4b04      	ldr	r3, [pc, #16]	@ (80022dc <LL_ADC_DisableDeepPowerDown+0x20>)
 80022ca:	4013      	ands	r3, r2
 80022cc:	687a      	ldr	r2, [r7, #4]
 80022ce:	6093      	str	r3, [r2, #8]
}
 80022d0:	bf00      	nop
 80022d2:	370c      	adds	r7, #12
 80022d4:	46bd      	mov	sp, r7
 80022d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80022da:	4770      	bx	lr
 80022dc:	5fffffc0 	.word	0x5fffffc0

080022e0 <LL_ADC_IsDeepPowerDownEnabled>:
  * @rmtoll CR       DEEPPWD        LL_ADC_IsDeepPowerDownEnabled
  * @param  ADCx ADC instance
  * @retval 0: deep power down is disabled, 1: deep power down is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDeepPowerDownEnabled(const ADC_TypeDef *ADCx)
{
 80022e0:	b480      	push	{r7}
 80022e2:	b083      	sub	sp, #12
 80022e4:	af00      	add	r7, sp, #0
 80022e6:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 80022e8:	687b      	ldr	r3, [r7, #4]
 80022ea:	689b      	ldr	r3, [r3, #8]
 80022ec:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 80022f0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 80022f4:	d101      	bne.n	80022fa <LL_ADC_IsDeepPowerDownEnabled+0x1a>
 80022f6:	2301      	movs	r3, #1
 80022f8:	e000      	b.n	80022fc <LL_ADC_IsDeepPowerDownEnabled+0x1c>
 80022fa:	2300      	movs	r3, #0
}
 80022fc:	4618      	mov	r0, r3
 80022fe:	370c      	adds	r7, #12
 8002300:	46bd      	mov	sp, r7
 8002302:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002306:	4770      	bx	lr

08002308 <LL_ADC_EnableInternalRegulator>:
  * @rmtoll CR       ADVREGEN       LL_ADC_EnableInternalRegulator
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_EnableInternalRegulator(ADC_TypeDef *ADCx)
{
 8002308:	b480      	push	{r7}
 800230a:	b083      	sub	sp, #12
 800230c:	af00      	add	r7, sp, #0
 800230e:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
 8002310:	687b      	ldr	r3, [r7, #4]
 8002312:	689a      	ldr	r2, [r3, #8]
 8002314:	4b05      	ldr	r3, [pc, #20]	@ (800232c <LL_ADC_EnableInternalRegulator+0x24>)
 8002316:	4013      	ands	r3, r2
 8002318:	f043 5280 	orr.w	r2, r3, #268435456	@ 0x10000000
 800231c:	687b      	ldr	r3, [r7, #4]
 800231e:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADVREGEN);
}
 8002320:	bf00      	nop
 8002322:	370c      	adds	r7, #12
 8002324:	46bd      	mov	sp, r7
 8002326:	f85d 7b04 	ldr.w	r7, [sp], #4
 800232a:	4770      	bx	lr
 800232c:	6fffffc0 	.word	0x6fffffc0

08002330 <LL_ADC_IsInternalRegulatorEnabled>:
  * @rmtoll CR       ADVREGEN       LL_ADC_IsInternalRegulatorEnabled
  * @param  ADCx ADC instance
  * @retval 0: internal regulator is disabled, 1: internal regulator is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsInternalRegulatorEnabled(const ADC_TypeDef *ADCx)
{
 8002330:	b480      	push	{r7}
 8002332:	b083      	sub	sp, #12
 8002334:	af00      	add	r7, sp, #0
 8002336:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8002338:	687b      	ldr	r3, [r7, #4]
 800233a:	689b      	ldr	r3, [r3, #8]
 800233c:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8002340:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8002344:	d101      	bne.n	800234a <LL_ADC_IsInternalRegulatorEnabled+0x1a>
 8002346:	2301      	movs	r3, #1
 8002348:	e000      	b.n	800234c <LL_ADC_IsInternalRegulatorEnabled+0x1c>
 800234a:	2300      	movs	r3, #0
}
 800234c:	4618      	mov	r0, r3
 800234e:	370c      	adds	r7, #12
 8002350:	46bd      	mov	sp, r7
 8002352:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002356:	4770      	bx	lr

08002358 <LL_ADC_Enable>:
  * @rmtoll CR       ADEN           LL_ADC_Enable
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_Enable(ADC_TypeDef *ADCx)
{
 8002358:	b480      	push	{r7}
 800235a:	b083      	sub	sp, #12
 800235c:	af00      	add	r7, sp, #0
 800235e:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
 8002360:	687b      	ldr	r3, [r7, #4]
 8002362:	689a      	ldr	r2, [r3, #8]
 8002364:	4b05      	ldr	r3, [pc, #20]	@ (800237c <LL_ADC_Enable+0x24>)
 8002366:	4013      	ands	r3, r2
 8002368:	f043 0201 	orr.w	r2, r3, #1
 800236c:	687b      	ldr	r3, [r7, #4]
 800236e:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADEN);
}
 8002370:	bf00      	nop
 8002372:	370c      	adds	r7, #12
 8002374:	46bd      	mov	sp, r7
 8002376:	f85d 7b04 	ldr.w	r7, [sp], #4
 800237a:	4770      	bx	lr
 800237c:	7fffffc0 	.word	0x7fffffc0

08002380 <LL_ADC_Disable>:
  * @rmtoll CR       ADDIS          LL_ADC_Disable
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_Disable(ADC_TypeDef *ADCx)
{
 8002380:	b480      	push	{r7}
 8002382:	b083      	sub	sp, #12
 8002384:	af00      	add	r7, sp, #0
 8002386:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
 8002388:	687b      	ldr	r3, [r7, #4]
 800238a:	689a      	ldr	r2, [r3, #8]
 800238c:	4b05      	ldr	r3, [pc, #20]	@ (80023a4 <LL_ADC_Disable+0x24>)
 800238e:	4013      	ands	r3, r2
 8002390:	f043 0202 	orr.w	r2, r3, #2
 8002394:	687b      	ldr	r3, [r7, #4]
 8002396:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADDIS);
}
 8002398:	bf00      	nop
 800239a:	370c      	adds	r7, #12
 800239c:	46bd      	mov	sp, r7
 800239e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80023a2:	4770      	bx	lr
 80023a4:	7fffffc0 	.word	0x7fffffc0

080023a8 <LL_ADC_IsEnabled>:
  * @rmtoll CR       ADEN           LL_ADC_IsEnabled
  * @param  ADCx ADC instance
  * @retval 0: ADC is disabled, 1: ADC is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsEnabled(const ADC_TypeDef *ADCx)
{
 80023a8:	b480      	push	{r7}
 80023aa:	b083      	sub	sp, #12
 80023ac:	af00      	add	r7, sp, #0
 80023ae:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80023b0:	687b      	ldr	r3, [r7, #4]
 80023b2:	689b      	ldr	r3, [r3, #8]
 80023b4:	f003 0301 	and.w	r3, r3, #1
 80023b8:	2b01      	cmp	r3, #1
 80023ba:	d101      	bne.n	80023c0 <LL_ADC_IsEnabled+0x18>
 80023bc:	2301      	movs	r3, #1
 80023be:	e000      	b.n	80023c2 <LL_ADC_IsEnabled+0x1a>
 80023c0:	2300      	movs	r3, #0
}
 80023c2:	4618      	mov	r0, r3
 80023c4:	370c      	adds	r7, #12
 80023c6:	46bd      	mov	sp, r7
 80023c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80023cc:	4770      	bx	lr

080023ce <LL_ADC_IsDisableOngoing>:
  * @rmtoll CR       ADDIS          LL_ADC_IsDisableOngoing
  * @param  ADCx ADC instance
  * @retval 0: no ADC disable command on going.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDisableOngoing(const ADC_TypeDef *ADCx)
{
 80023ce:	b480      	push	{r7}
 80023d0:	b083      	sub	sp, #12
 80023d2:	af00      	add	r7, sp, #0
 80023d4:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 80023d6:	687b      	ldr	r3, [r7, #4]
 80023d8:	689b      	ldr	r3, [r3, #8]
 80023da:	f003 0302 	and.w	r3, r3, #2
 80023de:	2b02      	cmp	r3, #2
 80023e0:	d101      	bne.n	80023e6 <LL_ADC_IsDisableOngoing+0x18>
 80023e2:	2301      	movs	r3, #1
 80023e4:	e000      	b.n	80023e8 <LL_ADC_IsDisableOngoing+0x1a>
 80023e6:	2300      	movs	r3, #0
}
 80023e8:	4618      	mov	r0, r3
 80023ea:	370c      	adds	r7, #12
 80023ec:	46bd      	mov	sp, r7
 80023ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80023f2:	4770      	bx	lr

080023f4 <LL_ADC_REG_StartConversion>:
  * @rmtoll CR       ADSTART        LL_ADC_REG_StartConversion
  * @param  ADCx ADC instance
  * @retval None
  */
__STATIC_INLINE void LL_ADC_REG_StartConversion(ADC_TypeDef *ADCx)
{
 80023f4:	b480      	push	{r7}
 80023f6:	b083      	sub	sp, #12
 80023f8:	af00      	add	r7, sp, #0
 80023fa:	6078      	str	r0, [r7, #4]
  /* Note: Write register with some additional bits forced to state reset     */
  /*       instead of modifying only the selected bit for this function,      */
  /*       to not interfere with bits with HW property "rs".                  */
  MODIFY_REG(ADCx->CR,
 80023fc:	687b      	ldr	r3, [r7, #4]
 80023fe:	689a      	ldr	r2, [r3, #8]
 8002400:	4b05      	ldr	r3, [pc, #20]	@ (8002418 <LL_ADC_REG_StartConversion+0x24>)
 8002402:	4013      	ands	r3, r2
 8002404:	f043 0204 	orr.w	r2, r3, #4
 8002408:	687b      	ldr	r3, [r7, #4]
 800240a:	609a      	str	r2, [r3, #8]
             ADC_CR_BITS_PROPERTY_RS,
             ADC_CR_ADSTART);
}
 800240c:	bf00      	nop
 800240e:	370c      	adds	r7, #12
 8002410:	46bd      	mov	sp, r7
 8002412:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002416:	4770      	bx	lr
 8002418:	7fffffc0 	.word	0x7fffffc0

0800241c <LL_ADC_REG_IsConversionOngoing>:
  * @rmtoll CR       ADSTART        LL_ADC_REG_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(const ADC_TypeDef *ADCx)
{
 800241c:	b480      	push	{r7}
 800241e:	b083      	sub	sp, #12
 8002420:	af00      	add	r7, sp, #0
 8002422:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8002424:	687b      	ldr	r3, [r7, #4]
 8002426:	689b      	ldr	r3, [r3, #8]
 8002428:	f003 0304 	and.w	r3, r3, #4
 800242c:	2b04      	cmp	r3, #4
 800242e:	d101      	bne.n	8002434 <LL_ADC_REG_IsConversionOngoing+0x18>
 8002430:	2301      	movs	r3, #1
 8002432:	e000      	b.n	8002436 <LL_ADC_REG_IsConversionOngoing+0x1a>
 8002434:	2300      	movs	r3, #0
}
 8002436:	4618      	mov	r0, r3
 8002438:	370c      	adds	r7, #12
 800243a:	46bd      	mov	sp, r7
 800243c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002440:	4770      	bx	lr

08002442 <LL_ADC_INJ_IsConversionOngoing>:
  * @rmtoll CR       JADSTART       LL_ADC_INJ_IsConversionOngoing
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(const ADC_TypeDef *ADCx)
{
 8002442:	b480      	push	{r7}
 8002444:	b083      	sub	sp, #12
 8002446:	af00      	add	r7, sp, #0
 8002448:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 800244a:	687b      	ldr	r3, [r7, #4]
 800244c:	689b      	ldr	r3, [r3, #8]
 800244e:	f003 0308 	and.w	r3, r3, #8
 8002452:	2b08      	cmp	r3, #8
 8002454:	d101      	bne.n	800245a <LL_ADC_INJ_IsConversionOngoing+0x18>
 8002456:	2301      	movs	r3, #1
 8002458:	e000      	b.n	800245c <LL_ADC_INJ_IsConversionOngoing+0x1a>
 800245a:	2300      	movs	r3, #0
}
 800245c:	4618      	mov	r0, r3
 800245e:	370c      	adds	r7, #12
 8002460:	46bd      	mov	sp, r7
 8002462:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002466:	4770      	bx	lr

08002468 <HAL_ADC_Init>:
  *         without  disabling the other ADCs.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef *hadc)
{
 8002468:	b590      	push	{r4, r7, lr}
 800246a:	b089      	sub	sp, #36	@ 0x24
 800246c:	af00      	add	r7, sp, #0
 800246e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8002470:	2300      	movs	r3, #0
 8002472:	77fb      	strb	r3, [r7, #31]
  uint32_t tmpCFGR;
  uint32_t tmp_adc_reg_is_conversion_on_going;
  __IO uint32_t wait_loop_index = 0UL;
 8002474:	2300      	movs	r3, #0
 8002476:	60bb      	str	r3, [r7, #8]
  uint32_t tmp_adc_is_conversion_on_going_regular;
  uint32_t tmp_adc_is_conversion_on_going_injected;

  /* Check ADC handle */
  if (hadc == NULL)
 8002478:	687b      	ldr	r3, [r7, #4]
 800247a:	2b00      	cmp	r3, #0
 800247c:	d101      	bne.n	8002482 <HAL_ADC_Init+0x1a>
  {
    return HAL_ERROR;
 800247e:	2301      	movs	r3, #1
 8002480:	e18f      	b.n	80027a2 <HAL_ADC_Init+0x33a>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));

  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 8002482:	687b      	ldr	r3, [r7, #4]
 8002484:	68db      	ldr	r3, [r3, #12]
 8002486:	2b00      	cmp	r3, #0
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));

  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if (hadc->State == HAL_ADC_STATE_RESET)
 8002488:	687b      	ldr	r3, [r7, #4]
 800248a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800248c:	2b00      	cmp	r3, #0
 800248e:	d109      	bne.n	80024a4 <HAL_ADC_Init+0x3c>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8002490:	6878      	ldr	r0, [r7, #4]
 8002492:	f7fe ffc5 	bl	8001420 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 8002496:	687b      	ldr	r3, [r7, #4]
 8002498:	2200      	movs	r2, #0
 800249a:	659a      	str	r2, [r3, #88]	@ 0x58

    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 800249c:	687b      	ldr	r3, [r7, #4]
 800249e:	2200      	movs	r2, #0
 80024a0:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
  }

  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 80024a4:	687b      	ldr	r3, [r7, #4]
 80024a6:	681b      	ldr	r3, [r3, #0]
 80024a8:	4618      	mov	r0, r3
 80024aa:	f7ff ff19 	bl	80022e0 <LL_ADC_IsDeepPowerDownEnabled>
 80024ae:	4603      	mov	r3, r0
 80024b0:	2b00      	cmp	r3, #0
 80024b2:	d004      	beq.n	80024be <HAL_ADC_Init+0x56>
  {
    /* Disable ADC deep power down mode */
    LL_ADC_DisableDeepPowerDown(hadc->Instance);
 80024b4:	687b      	ldr	r3, [r7, #4]
 80024b6:	681b      	ldr	r3, [r3, #0]
 80024b8:	4618      	mov	r0, r3
 80024ba:	f7ff feff 	bl	80022bc <LL_ADC_DisableDeepPowerDown>
    /* System was in deep power down mode, calibration must
     be relaunched or a previously saved calibration factor
     re-applied once the ADC voltage regulator is enabled */
  }

  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 80024be:	687b      	ldr	r3, [r7, #4]
 80024c0:	681b      	ldr	r3, [r3, #0]
 80024c2:	4618      	mov	r0, r3
 80024c4:	f7ff ff34 	bl	8002330 <LL_ADC_IsInternalRegulatorEnabled>
 80024c8:	4603      	mov	r3, r0
 80024ca:	2b00      	cmp	r3, #0
 80024cc:	d114      	bne.n	80024f8 <HAL_ADC_Init+0x90>
  {
    /* Enable ADC internal voltage regulator */
    LL_ADC_EnableInternalRegulator(hadc->Instance);
 80024ce:	687b      	ldr	r3, [r7, #4]
 80024d0:	681b      	ldr	r3, [r3, #0]
 80024d2:	4618      	mov	r0, r3
 80024d4:	f7ff ff18 	bl	8002308 <LL_ADC_EnableInternalRegulator>

    /* Note: Variable divided by 2 to compensate partially              */
    /*       CPU processing cycles, scaling in us split to not          */
    /*       exceed 32 bits register capacity and handle low frequency. */
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 80024d8:	4b87      	ldr	r3, [pc, #540]	@ (80026f8 <HAL_ADC_Init+0x290>)
 80024da:	681b      	ldr	r3, [r3, #0]
 80024dc:	099b      	lsrs	r3, r3, #6
 80024de:	4a87      	ldr	r2, [pc, #540]	@ (80026fc <HAL_ADC_Init+0x294>)
 80024e0:	fba2 2303 	umull	r2, r3, r2, r3
 80024e4:	099b      	lsrs	r3, r3, #6
 80024e6:	3301      	adds	r3, #1
 80024e8:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 80024ea:	e002      	b.n	80024f2 <HAL_ADC_Init+0x8a>
    {
      wait_loop_index--;
 80024ec:	68bb      	ldr	r3, [r7, #8]
 80024ee:	3b01      	subs	r3, #1
 80024f0:	60bb      	str	r3, [r7, #8]
    while (wait_loop_index != 0UL)
 80024f2:	68bb      	ldr	r3, [r7, #8]
 80024f4:	2b00      	cmp	r3, #0
 80024f6:	d1f9      	bne.n	80024ec <HAL_ADC_Init+0x84>
  }

  /* Verification that ADC voltage regulator is correctly enabled, whether    */
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 80024f8:	687b      	ldr	r3, [r7, #4]
 80024fa:	681b      	ldr	r3, [r3, #0]
 80024fc:	4618      	mov	r0, r3
 80024fe:	f7ff ff17 	bl	8002330 <LL_ADC_IsInternalRegulatorEnabled>
 8002502:	4603      	mov	r3, r0
 8002504:	2b00      	cmp	r3, #0
 8002506:	d10d      	bne.n	8002524 <HAL_ADC_Init+0xbc>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8002508:	687b      	ldr	r3, [r7, #4]
 800250a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800250c:	f043 0210 	orr.w	r2, r3, #16
 8002510:	687b      	ldr	r3, [r7, #4]
 8002512:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Set ADC error code to ADC peripheral internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8002514:	687b      	ldr	r3, [r7, #4]
 8002516:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8002518:	f043 0201 	orr.w	r2, r3, #1
 800251c:	687b      	ldr	r3, [r7, #4]
 800251e:	659a      	str	r2, [r3, #88]	@ 0x58

    tmp_hal_status = HAL_ERROR;
 8002520:	2301      	movs	r3, #1
 8002522:	77fb      	strb	r3, [r7, #31]

  /* Configuration of ADC parameters if previous preliminary actions are      */
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  tmp_adc_reg_is_conversion_on_going = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8002524:	687b      	ldr	r3, [r7, #4]
 8002526:	681b      	ldr	r3, [r3, #0]
 8002528:	4618      	mov	r0, r3
 800252a:	f7ff ff77 	bl	800241c <LL_ADC_REG_IsConversionOngoing>
 800252e:	6178      	str	r0, [r7, #20]

  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8002530:	687b      	ldr	r3, [r7, #4]
 8002532:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002534:	f003 0310 	and.w	r3, r3, #16
 8002538:	2b00      	cmp	r3, #0
 800253a:	f040 8129 	bne.w	8002790 <HAL_ADC_Init+0x328>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
 800253e:	697b      	ldr	r3, [r7, #20]
 8002540:	2b00      	cmp	r3, #0
 8002542:	f040 8125 	bne.w	8002790 <HAL_ADC_Init+0x328>
     )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8002546:	687b      	ldr	r3, [r7, #4]
 8002548:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800254a:	f423 7381 	bic.w	r3, r3, #258	@ 0x102
 800254e:	f043 0202 	orr.w	r2, r3, #2
 8002552:	687b      	ldr	r3, [r7, #4]
 8002554:	655a      	str	r2, [r3, #84]	@ 0x54
    /* Configuration of common ADC parameters                                 */

    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - clock configuration                                                 */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8002556:	687b      	ldr	r3, [r7, #4]
 8002558:	681b      	ldr	r3, [r3, #0]
 800255a:	4618      	mov	r0, r3
 800255c:	f7ff ff24 	bl	80023a8 <LL_ADC_IsEnabled>
 8002560:	4603      	mov	r3, r0
 8002562:	2b00      	cmp	r3, #0
 8002564:	d136      	bne.n	80025d4 <HAL_ADC_Init+0x16c>
    {
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8002566:	687b      	ldr	r3, [r7, #4]
 8002568:	681b      	ldr	r3, [r3, #0]
 800256a:	4a65      	ldr	r2, [pc, #404]	@ (8002700 <HAL_ADC_Init+0x298>)
 800256c:	4293      	cmp	r3, r2
 800256e:	d004      	beq.n	800257a <HAL_ADC_Init+0x112>
 8002570:	687b      	ldr	r3, [r7, #4]
 8002572:	681b      	ldr	r3, [r3, #0]
 8002574:	4a63      	ldr	r2, [pc, #396]	@ (8002704 <HAL_ADC_Init+0x29c>)
 8002576:	4293      	cmp	r3, r2
 8002578:	d10e      	bne.n	8002598 <HAL_ADC_Init+0x130>
 800257a:	4861      	ldr	r0, [pc, #388]	@ (8002700 <HAL_ADC_Init+0x298>)
 800257c:	f7ff ff14 	bl	80023a8 <LL_ADC_IsEnabled>
 8002580:	4604      	mov	r4, r0
 8002582:	4860      	ldr	r0, [pc, #384]	@ (8002704 <HAL_ADC_Init+0x29c>)
 8002584:	f7ff ff10 	bl	80023a8 <LL_ADC_IsEnabled>
 8002588:	4603      	mov	r3, r0
 800258a:	4323      	orrs	r3, r4
 800258c:	2b00      	cmp	r3, #0
 800258e:	bf0c      	ite	eq
 8002590:	2301      	moveq	r3, #1
 8002592:	2300      	movne	r3, #0
 8002594:	b2db      	uxtb	r3, r3
 8002596:	e008      	b.n	80025aa <HAL_ADC_Init+0x142>
 8002598:	485b      	ldr	r0, [pc, #364]	@ (8002708 <HAL_ADC_Init+0x2a0>)
 800259a:	f7ff ff05 	bl	80023a8 <LL_ADC_IsEnabled>
 800259e:	4603      	mov	r3, r0
 80025a0:	2b00      	cmp	r3, #0
 80025a2:	bf0c      	ite	eq
 80025a4:	2301      	moveq	r3, #1
 80025a6:	2300      	movne	r3, #0
 80025a8:	b2db      	uxtb	r3, r3
 80025aa:	2b00      	cmp	r3, #0
 80025ac:	d012      	beq.n	80025d4 <HAL_ADC_Init+0x16c>
        /*     parameters: MDMA, DMACFG, DELAY, DUAL (set by API                */
        /*     HAL_ADCEx_MultiModeConfigChannel() )                             */
        /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
        /*     (set into HAL_ADC_ConfigChannel() or                             */
        /*     HAL_ADCEx_InjectedConfigChannel() )                              */
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 80025ae:	687b      	ldr	r3, [r7, #4]
 80025b0:	681b      	ldr	r3, [r3, #0]
 80025b2:	4a53      	ldr	r2, [pc, #332]	@ (8002700 <HAL_ADC_Init+0x298>)
 80025b4:	4293      	cmp	r3, r2
 80025b6:	d004      	beq.n	80025c2 <HAL_ADC_Init+0x15a>
 80025b8:	687b      	ldr	r3, [r7, #4]
 80025ba:	681b      	ldr	r3, [r3, #0]
 80025bc:	4a51      	ldr	r2, [pc, #324]	@ (8002704 <HAL_ADC_Init+0x29c>)
 80025be:	4293      	cmp	r3, r2
 80025c0:	d101      	bne.n	80025c6 <HAL_ADC_Init+0x15e>
 80025c2:	4a52      	ldr	r2, [pc, #328]	@ (800270c <HAL_ADC_Init+0x2a4>)
 80025c4:	e000      	b.n	80025c8 <HAL_ADC_Init+0x160>
 80025c6:	4a52      	ldr	r2, [pc, #328]	@ (8002710 <HAL_ADC_Init+0x2a8>)
 80025c8:	687b      	ldr	r3, [r7, #4]
 80025ca:	685b      	ldr	r3, [r3, #4]
 80025cc:	4619      	mov	r1, r3
 80025ce:	4610      	mov	r0, r2
 80025d0:	f7ff fce8 	bl	8001fa4 <LL_ADC_SetCommonClock>
                  ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
    }

#else

    if ((HAL_GetREVID() > REV_ID_Y) && (ADC_RESOLUTION_8B == hadc->Init.Resolution))
 80025d4:	f7ff fcda 	bl	8001f8c <HAL_GetREVID>
 80025d8:	4603      	mov	r3, r0
 80025da:	f241 0203 	movw	r2, #4099	@ 0x1003
 80025de:	4293      	cmp	r3, r2
 80025e0:	d914      	bls.n	800260c <HAL_ADC_Init+0x1a4>
 80025e2:	687b      	ldr	r3, [r7, #4]
 80025e4:	689b      	ldr	r3, [r3, #8]
 80025e6:	2b10      	cmp	r3, #16
 80025e8:	d110      	bne.n	800260c <HAL_ADC_Init+0x1a4>
    {
      /* for STM32H7 silicon rev.B and above , ADC_CFGR_RES value for 8bits resolution is : b111 */
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
 80025ea:	687b      	ldr	r3, [r7, #4]
 80025ec:	7d5b      	ldrb	r3, [r3, #21]
 80025ee:	035a      	lsls	r2, r3, #13
                  hadc->Init.Overrun                                                    |
 80025f0:	687b      	ldr	r3, [r7, #4]
 80025f2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
 80025f4:	431a      	orrs	r2, r3
                  hadc->Init.Resolution | (ADC_CFGR_RES_1 | ADC_CFGR_RES_0)                |
 80025f6:	687b      	ldr	r3, [r7, #4]
 80025f8:	689b      	ldr	r3, [r3, #8]
                  hadc->Init.Overrun                                                    |
 80025fa:	431a      	orrs	r2, r3
                  ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 80025fc:	687b      	ldr	r3, [r7, #4]
 80025fe:	7f1b      	ldrb	r3, [r3, #28]
 8002600:	041b      	lsls	r3, r3, #16
                  hadc->Init.Resolution | (ADC_CFGR_RES_1 | ADC_CFGR_RES_0)                |
 8002602:	4313      	orrs	r3, r2
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
 8002604:	f043 030c 	orr.w	r3, r3, #12
 8002608:	61bb      	str	r3, [r7, #24]
 800260a:	e00d      	b.n	8002628 <HAL_ADC_Init+0x1c0>
    }
    else
    {

      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
 800260c:	687b      	ldr	r3, [r7, #4]
 800260e:	7d5b      	ldrb	r3, [r3, #21]
 8002610:	035a      	lsls	r2, r3, #13
                  hadc->Init.Overrun                                                    |
 8002612:	687b      	ldr	r3, [r7, #4]
 8002614:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
 8002616:	431a      	orrs	r2, r3
                  hadc->Init.Resolution                                                 |
 8002618:	687b      	ldr	r3, [r7, #4]
 800261a:	689b      	ldr	r3, [r3, #8]
                  hadc->Init.Overrun                                                    |
 800261c:	431a      	orrs	r2, r3
                  ADC_CFGR_REG_DISCONTINUOUS((uint32_t)hadc->Init.DiscontinuousConvMode));
 800261e:	687b      	ldr	r3, [r7, #4]
 8002620:	7f1b      	ldrb	r3, [r3, #28]
 8002622:	041b      	lsls	r3, r3, #16
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
 8002624:	4313      	orrs	r3, r2
 8002626:	61bb      	str	r3, [r7, #24]
    }

#endif /* ADC_VER_V5_3 */

    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8002628:	687b      	ldr	r3, [r7, #4]
 800262a:	7f1b      	ldrb	r3, [r3, #28]
 800262c:	2b01      	cmp	r3, #1
 800262e:	d106      	bne.n	800263e <HAL_ADC_Init+0x1d6>
    {
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 8002630:	687b      	ldr	r3, [r7, #4]
 8002632:	6a1b      	ldr	r3, [r3, #32]
 8002634:	3b01      	subs	r3, #1
 8002636:	045b      	lsls	r3, r3, #17
 8002638:	69ba      	ldr	r2, [r7, #24]
 800263a:	4313      	orrs	r3, r2
 800263c:	61bb      	str	r3, [r7, #24]
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 800263e:	687b      	ldr	r3, [r7, #4]
 8002640:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8002642:	2b00      	cmp	r3, #0
 8002644:	d009      	beq.n	800265a <HAL_ADC_Init+0x1f2>
    {
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8002646:	687b      	ldr	r3, [r7, #4]
 8002648:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800264a:	f403 7278 	and.w	r2, r3, #992	@ 0x3e0
                  | hadc->Init.ExternalTrigConvEdge
 800264e:	687b      	ldr	r3, [r7, #4]
 8002650:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8002652:	4313      	orrs	r3, r2
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8002654:	69ba      	ldr	r2, [r7, #24]
 8002656:	4313      	orrs	r3, r2
 8002658:	61bb      	str	r3, [r7, #24]
      /* Update Configuration Register CFGR */
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
    }
#else
    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
 800265a:	687b      	ldr	r3, [r7, #4]
 800265c:	681b      	ldr	r3, [r3, #0]
 800265e:	68da      	ldr	r2, [r3, #12]
 8002660:	4b2c      	ldr	r3, [pc, #176]	@ (8002714 <HAL_ADC_Init+0x2ac>)
 8002662:	4013      	ands	r3, r2
 8002664:	687a      	ldr	r2, [r7, #4]
 8002666:	6812      	ldr	r2, [r2, #0]
 8002668:	69b9      	ldr	r1, [r7, #24]
 800266a:	430b      	orrs	r3, r1
 800266c:	60d3      	str	r3, [r2, #12]
    /* Parameters that can be updated when ADC is disabled or enabled without */
    /* conversion on going on regular and injected groups:                    */
    /*  - Conversion data management      Init.ConversionDataManagement       */
    /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
    /*  - Oversampling parameters         Init.Oversampling                   */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 800266e:	687b      	ldr	r3, [r7, #4]
 8002670:	681b      	ldr	r3, [r3, #0]
 8002672:	4618      	mov	r0, r3
 8002674:	f7ff fed2 	bl	800241c <LL_ADC_REG_IsConversionOngoing>
 8002678:	6138      	str	r0, [r7, #16]
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 800267a:	687b      	ldr	r3, [r7, #4]
 800267c:	681b      	ldr	r3, [r3, #0]
 800267e:	4618      	mov	r0, r3
 8002680:	f7ff fedf 	bl	8002442 <LL_ADC_INJ_IsConversionOngoing>
 8002684:	60f8      	str	r0, [r7, #12]
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 8002686:	693b      	ldr	r3, [r7, #16]
 8002688:	2b00      	cmp	r3, #0
 800268a:	d15f      	bne.n	800274c <HAL_ADC_Init+0x2e4>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 800268c:	68fb      	ldr	r3, [r7, #12]
 800268e:	2b00      	cmp	r3, #0
 8002690:	d15c      	bne.n	800274c <HAL_ADC_Init+0x2e4>
                    ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
                    ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.ConversionDataManagement));
      }
#else
      tmpCFGR = (
                  ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 8002692:	687b      	ldr	r3, [r7, #4]
 8002694:	7d1b      	ldrb	r3, [r3, #20]
 8002696:	039a      	lsls	r2, r3, #14
                  ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.ConversionDataManagement));
 8002698:	687b      	ldr	r3, [r7, #4]
 800269a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
      tmpCFGR = (
 800269c:	4313      	orrs	r3, r2
 800269e:	61bb      	str	r3, [r7, #24]
#endif

      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 80026a0:	687b      	ldr	r3, [r7, #4]
 80026a2:	681b      	ldr	r3, [r3, #0]
 80026a4:	68da      	ldr	r2, [r3, #12]
 80026a6:	4b1c      	ldr	r3, [pc, #112]	@ (8002718 <HAL_ADC_Init+0x2b0>)
 80026a8:	4013      	ands	r3, r2
 80026aa:	687a      	ldr	r2, [r7, #4]
 80026ac:	6812      	ldr	r2, [r2, #0]
 80026ae:	69b9      	ldr	r1, [r7, #24]
 80026b0:	430b      	orrs	r3, r1
 80026b2:	60d3      	str	r3, [r2, #12]

      if (hadc->Init.OversamplingMode == ENABLE)
 80026b4:	687b      	ldr	r3, [r7, #4]
 80026b6:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
 80026ba:	2b01      	cmp	r3, #1
 80026bc:	d130      	bne.n	8002720 <HAL_ADC_Init+0x2b8>
#endif
        assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversampling.RightBitShift));
        assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
        assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));

        if ((hadc->Init.ExternalTrigConv == ADC_SOFTWARE_START)
 80026be:	687b      	ldr	r3, [r7, #4]
 80026c0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80026c2:	2b00      	cmp	r3, #0
        /*  - Oversampling Ratio                                               */
        /*  - Right bit shift                                                  */
        /*  - Left bit shift                                                   */
        /*  - Triggered mode                                                   */
        /*  - Oversampling mode (continued/resumed)                            */
        MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_FIELDS,
 80026c4:	687b      	ldr	r3, [r7, #4]
 80026c6:	681b      	ldr	r3, [r3, #0]
 80026c8:	691a      	ldr	r2, [r3, #16]
 80026ca:	4b14      	ldr	r3, [pc, #80]	@ (800271c <HAL_ADC_Init+0x2b4>)
 80026cc:	4013      	ands	r3, r2
 80026ce:	687a      	ldr	r2, [r7, #4]
 80026d0:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
 80026d2:	3a01      	subs	r2, #1
 80026d4:	0411      	lsls	r1, r2, #16
 80026d6:	687a      	ldr	r2, [r7, #4]
 80026d8:	6c12      	ldr	r2, [r2, #64]	@ 0x40
 80026da:	4311      	orrs	r1, r2
 80026dc:	687a      	ldr	r2, [r7, #4]
 80026de:	6c52      	ldr	r2, [r2, #68]	@ 0x44
 80026e0:	4311      	orrs	r1, r2
 80026e2:	687a      	ldr	r2, [r7, #4]
 80026e4:	6c92      	ldr	r2, [r2, #72]	@ 0x48
 80026e6:	430a      	orrs	r2, r1
 80026e8:	431a      	orrs	r2, r3
 80026ea:	687b      	ldr	r3, [r7, #4]
 80026ec:	681b      	ldr	r3, [r3, #0]
 80026ee:	f042 0201 	orr.w	r2, r2, #1
 80026f2:	611a      	str	r2, [r3, #16]
 80026f4:	e01c      	b.n	8002730 <HAL_ADC_Init+0x2c8>
 80026f6:	bf00      	nop
 80026f8:	24000000 	.word	0x24000000
 80026fc:	053e2d63 	.word	0x053e2d63
 8002700:	40022000 	.word	0x40022000
 8002704:	40022100 	.word	0x40022100
 8002708:	58026000 	.word	0x58026000
 800270c:	40022300 	.word	0x40022300
 8002710:	58026300 	.word	0x58026300
 8002714:	fff0c003 	.word	0xfff0c003
 8002718:	ffffbffc 	.word	0xffffbffc
 800271c:	fc00f81e 	.word	0xfc00f81e

      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 8002720:	687b      	ldr	r3, [r7, #4]
 8002722:	681b      	ldr	r3, [r3, #0]
 8002724:	691a      	ldr	r2, [r3, #16]
 8002726:	687b      	ldr	r3, [r7, #4]
 8002728:	681b      	ldr	r3, [r3, #0]
 800272a:	f022 0201 	bic.w	r2, r2, #1
 800272e:	611a      	str	r2, [r3, #16]
      }

      /* Set the LeftShift parameter: it is applied to the final result with or without oversampling */
      MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_LSHIFT, hadc->Init.LeftBitShift);
 8002730:	687b      	ldr	r3, [r7, #4]
 8002732:	681b      	ldr	r3, [r3, #0]
 8002734:	691b      	ldr	r3, [r3, #16]
 8002736:	f023 4170 	bic.w	r1, r3, #4026531840	@ 0xf0000000
 800273a:	687b      	ldr	r3, [r7, #4]
 800273c:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800273e:	687b      	ldr	r3, [r7, #4]
 8002740:	681b      	ldr	r3, [r3, #0]
 8002742:	430a      	orrs	r2, r1
 8002744:	611a      	str	r2, [r3, #16]
        /* Configure the BOOST Mode */
        ADC_ConfigureBoostMode(hadc);
      }
#else
      /* Configure the BOOST Mode */
      ADC_ConfigureBoostMode(hadc);
 8002746:	6878      	ldr	r0, [r7, #4]
 8002748:	f000 ffc4 	bl	80036d4 <ADC_ConfigureBoostMode>
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 800274c:	687b      	ldr	r3, [r7, #4]
 800274e:	68db      	ldr	r3, [r3, #12]
 8002750:	2b01      	cmp	r3, #1
 8002752:	d10c      	bne.n	800276e <HAL_ADC_Init+0x306>
    {
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 8002754:	687b      	ldr	r3, [r7, #4]
 8002756:	681b      	ldr	r3, [r3, #0]
 8002758:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800275a:	f023 010f 	bic.w	r1, r3, #15
 800275e:	687b      	ldr	r3, [r7, #4]
 8002760:	699b      	ldr	r3, [r3, #24]
 8002762:	1e5a      	subs	r2, r3, #1
 8002764:	687b      	ldr	r3, [r7, #4]
 8002766:	681b      	ldr	r3, [r3, #0]
 8002768:	430a      	orrs	r2, r1
 800276a:	631a      	str	r2, [r3, #48]	@ 0x30
 800276c:	e007      	b.n	800277e <HAL_ADC_Init+0x316>
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 800276e:	687b      	ldr	r3, [r7, #4]
 8002770:	681b      	ldr	r3, [r3, #0]
 8002772:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 8002774:	687b      	ldr	r3, [r7, #4]
 8002776:	681b      	ldr	r3, [r3, #0]
 8002778:	f022 020f 	bic.w	r2, r2, #15
 800277c:	631a      	str	r2, [r3, #48]	@ 0x30
    }

    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 800277e:	687b      	ldr	r3, [r7, #4]
 8002780:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002782:	f023 0303 	bic.w	r3, r3, #3
 8002786:	f043 0201 	orr.w	r2, r3, #1
 800278a:	687b      	ldr	r3, [r7, #4]
 800278c:	655a      	str	r2, [r3, #84]	@ 0x54
 800278e:	e007      	b.n	80027a0 <HAL_ADC_Init+0x338>
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8002790:	687b      	ldr	r3, [r7, #4]
 8002792:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002794:	f043 0210 	orr.w	r2, r3, #16
 8002798:	687b      	ldr	r3, [r7, #4]
 800279a:	655a      	str	r2, [r3, #84]	@ 0x54

    tmp_hal_status = HAL_ERROR;
 800279c:	2301      	movs	r3, #1
 800279e:	77fb      	strb	r3, [r7, #31]
  }

  /* Return function status */
  return tmp_hal_status;
 80027a0:	7ffb      	ldrb	r3, [r7, #31]
}
 80027a2:	4618      	mov	r0, r3
 80027a4:	3724      	adds	r7, #36	@ 0x24
 80027a6:	46bd      	mov	sp, r7
 80027a8:	bd90      	pop	{r4, r7, pc}
 80027aa:	bf00      	nop

080027ac <HAL_ADC_Start_DMA>:
  * @param pData Destination Buffer address.
  * @param Length Number of data to be transferred from ADC peripheral to memory
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef *hadc, uint32_t *pData, uint32_t Length)
{
 80027ac:	b580      	push	{r7, lr}
 80027ae:	b086      	sub	sp, #24
 80027b0:	af00      	add	r7, sp, #0
 80027b2:	60f8      	str	r0, [r7, #12]
 80027b4:	60b9      	str	r1, [r7, #8]
 80027b6:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status;
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 80027b8:	68fb      	ldr	r3, [r7, #12]
 80027ba:	681b      	ldr	r3, [r3, #0]
 80027bc:	4a55      	ldr	r2, [pc, #340]	@ (8002914 <HAL_ADC_Start_DMA+0x168>)
 80027be:	4293      	cmp	r3, r2
 80027c0:	d004      	beq.n	80027cc <HAL_ADC_Start_DMA+0x20>
 80027c2:	68fb      	ldr	r3, [r7, #12]
 80027c4:	681b      	ldr	r3, [r3, #0]
 80027c6:	4a54      	ldr	r2, [pc, #336]	@ (8002918 <HAL_ADC_Start_DMA+0x16c>)
 80027c8:	4293      	cmp	r3, r2
 80027ca:	d101      	bne.n	80027d0 <HAL_ADC_Start_DMA+0x24>
 80027cc:	4b53      	ldr	r3, [pc, #332]	@ (800291c <HAL_ADC_Start_DMA+0x170>)
 80027ce:	e000      	b.n	80027d2 <HAL_ADC_Start_DMA+0x26>
 80027d0:	4b53      	ldr	r3, [pc, #332]	@ (8002920 <HAL_ADC_Start_DMA+0x174>)
 80027d2:	4618      	mov	r0, r3
 80027d4:	f7ff fd56 	bl	8002284 <LL_ADC_GetMultimode>
 80027d8:	6138      	str	r0, [r7, #16]

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Perform ADC enable and conversion start if no conversion is on going */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 80027da:	68fb      	ldr	r3, [r7, #12]
 80027dc:	681b      	ldr	r3, [r3, #0]
 80027de:	4618      	mov	r0, r3
 80027e0:	f7ff fe1c 	bl	800241c <LL_ADC_REG_IsConversionOngoing>
 80027e4:	4603      	mov	r3, r0
 80027e6:	2b00      	cmp	r3, #0
 80027e8:	f040 808c 	bne.w	8002904 <HAL_ADC_Start_DMA+0x158>
  {
    /* Process locked */
    __HAL_LOCK(hadc);
 80027ec:	68fb      	ldr	r3, [r7, #12]
 80027ee:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 80027f2:	2b01      	cmp	r3, #1
 80027f4:	d101      	bne.n	80027fa <HAL_ADC_Start_DMA+0x4e>
 80027f6:	2302      	movs	r3, #2
 80027f8:	e087      	b.n	800290a <HAL_ADC_Start_DMA+0x15e>
 80027fa:	68fb      	ldr	r3, [r7, #12]
 80027fc:	2201      	movs	r2, #1
 80027fe:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

    /* Ensure that multimode regular conversions are not enabled.   */
    /* Otherwise, dedicated API HAL_ADCEx_MultiModeStart_DMA() must be used.  */
    if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8002802:	693b      	ldr	r3, [r7, #16]
 8002804:	2b00      	cmp	r3, #0
 8002806:	d005      	beq.n	8002814 <HAL_ADC_Start_DMA+0x68>
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
 8002808:	693b      	ldr	r3, [r7, #16]
 800280a:	2b05      	cmp	r3, #5
 800280c:	d002      	beq.n	8002814 <HAL_ADC_Start_DMA+0x68>
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
 800280e:	693b      	ldr	r3, [r7, #16]
 8002810:	2b09      	cmp	r3, #9
 8002812:	d170      	bne.n	80028f6 <HAL_ADC_Start_DMA+0x14a>
       )
    {
      /* Enable the ADC peripheral */
      tmp_hal_status = ADC_Enable(hadc);
 8002814:	68f8      	ldr	r0, [r7, #12]
 8002816:	f000 fddf 	bl	80033d8 <ADC_Enable>
 800281a:	4603      	mov	r3, r0
 800281c:	75fb      	strb	r3, [r7, #23]

      /* Start conversion if ADC is effectively enabled */
      if (tmp_hal_status == HAL_OK)
 800281e:	7dfb      	ldrb	r3, [r7, #23]
 8002820:	2b00      	cmp	r3, #0
 8002822:	d163      	bne.n	80028ec <HAL_ADC_Start_DMA+0x140>
      {
        /* Set ADC state                                                        */
        /* - Clear state bitfield related to regular group conversion results   */
        /* - Set state bitfield related to regular operation                    */
        ADC_STATE_CLR_SET(hadc->State,
 8002824:	68fb      	ldr	r3, [r7, #12]
 8002826:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 8002828:	4b3e      	ldr	r3, [pc, #248]	@ (8002924 <HAL_ADC_Start_DMA+0x178>)
 800282a:	4013      	ands	r3, r2
 800282c:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
 8002830:	68fb      	ldr	r3, [r7, #12]
 8002832:	655a      	str	r2, [r3, #84]	@ 0x54
                          HAL_ADC_STATE_REG_BUSY);

        /* Reset HAL_ADC_STATE_MULTIMODE_SLAVE bit
          - if ADC instance is master or if multimode feature is not available
          - if multimode setting is disabled (ADC instance slave in independent mode) */
        if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 8002834:	68fb      	ldr	r3, [r7, #12]
 8002836:	681b      	ldr	r3, [r3, #0]
 8002838:	4a37      	ldr	r2, [pc, #220]	@ (8002918 <HAL_ADC_Start_DMA+0x16c>)
 800283a:	4293      	cmp	r3, r2
 800283c:	d002      	beq.n	8002844 <HAL_ADC_Start_DMA+0x98>
 800283e:	68fb      	ldr	r3, [r7, #12]
 8002840:	681b      	ldr	r3, [r3, #0]
 8002842:	e000      	b.n	8002846 <HAL_ADC_Start_DMA+0x9a>
 8002844:	4b33      	ldr	r3, [pc, #204]	@ (8002914 <HAL_ADC_Start_DMA+0x168>)
 8002846:	68fa      	ldr	r2, [r7, #12]
 8002848:	6812      	ldr	r2, [r2, #0]
 800284a:	4293      	cmp	r3, r2
 800284c:	d002      	beq.n	8002854 <HAL_ADC_Start_DMA+0xa8>
            || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 800284e:	693b      	ldr	r3, [r7, #16]
 8002850:	2b00      	cmp	r3, #0
 8002852:	d105      	bne.n	8002860 <HAL_ADC_Start_DMA+0xb4>
           )
        {
          CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 8002854:	68fb      	ldr	r3, [r7, #12]
 8002856:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002858:	f423 1280 	bic.w	r2, r3, #1048576	@ 0x100000
 800285c:	68fb      	ldr	r3, [r7, #12]
 800285e:	655a      	str	r2, [r3, #84]	@ 0x54
        }

        /* Check if a conversion is on going on ADC group injected */
        if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) != 0UL)
 8002860:	68fb      	ldr	r3, [r7, #12]
 8002862:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002864:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8002868:	2b00      	cmp	r3, #0
 800286a:	d006      	beq.n	800287a <HAL_ADC_Start_DMA+0xce>
        {
          /* Reset ADC error code fields related to regular conversions only */
          CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
 800286c:	68fb      	ldr	r3, [r7, #12]
 800286e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8002870:	f023 0206 	bic.w	r2, r3, #6
 8002874:	68fb      	ldr	r3, [r7, #12]
 8002876:	659a      	str	r2, [r3, #88]	@ 0x58
 8002878:	e002      	b.n	8002880 <HAL_ADC_Start_DMA+0xd4>
        }
        else
        {
          /* Reset all ADC error code fields */
          ADC_CLEAR_ERRORCODE(hadc);
 800287a:	68fb      	ldr	r3, [r7, #12]
 800287c:	2200      	movs	r2, #0
 800287e:	659a      	str	r2, [r3, #88]	@ 0x58
        }

        /* Set the DMA transfer complete callback */
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 8002880:	68fb      	ldr	r3, [r7, #12]
 8002882:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8002884:	4a28      	ldr	r2, [pc, #160]	@ (8002928 <HAL_ADC_Start_DMA+0x17c>)
 8002886:	63da      	str	r2, [r3, #60]	@ 0x3c

        /* Set the DMA half transfer complete callback */
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 8002888:	68fb      	ldr	r3, [r7, #12]
 800288a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800288c:	4a27      	ldr	r2, [pc, #156]	@ (800292c <HAL_ADC_Start_DMA+0x180>)
 800288e:	641a      	str	r2, [r3, #64]	@ 0x40

        /* Set the DMA error callback */
        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
 8002890:	68fb      	ldr	r3, [r7, #12]
 8002892:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8002894:	4a26      	ldr	r2, [pc, #152]	@ (8002930 <HAL_ADC_Start_DMA+0x184>)
 8002896:	64da      	str	r2, [r3, #76]	@ 0x4c
        /* ADC start (in case of SW start):                                   */

        /* Clear regular group conversion flag and overrun flag               */
        /* (To ensure of no unknown state from potential previous ADC         */
        /* operations)                                                        */
        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8002898:	68fb      	ldr	r3, [r7, #12]
 800289a:	681b      	ldr	r3, [r3, #0]
 800289c:	221c      	movs	r2, #28
 800289e:	601a      	str	r2, [r3, #0]

        /* Process unlocked */
        /* Unlock before starting ADC conversions: in case of potential         */
        /* interruption, to let the process to ADC IRQ Handler.                 */
        __HAL_UNLOCK(hadc);
 80028a0:	68fb      	ldr	r3, [r7, #12]
 80028a2:	2200      	movs	r2, #0
 80028a4:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

        /* With DMA, overrun event is always considered as an error even if
           hadc->Init.Overrun is set to ADC_OVR_DATA_OVERWRITTEN. Therefore,
           ADC_IT_OVR is enabled. */
        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 80028a8:	68fb      	ldr	r3, [r7, #12]
 80028aa:	681b      	ldr	r3, [r3, #0]
 80028ac:	685a      	ldr	r2, [r3, #4]
 80028ae:	68fb      	ldr	r3, [r7, #12]
 80028b0:	681b      	ldr	r3, [r3, #0]
 80028b2:	f042 0210 	orr.w	r2, r2, #16
 80028b6:	605a      	str	r2, [r3, #4]
        {
          LL_ADC_REG_SetDataTransferMode(hadc->Instance, ADC_CFGR_DMACONTREQ((uint32_t)hadc->Init.ConversionDataManagement));
        }

#else
        LL_ADC_REG_SetDataTransferMode(hadc->Instance, (uint32_t)hadc->Init.ConversionDataManagement);
 80028b8:	68fb      	ldr	r3, [r7, #12]
 80028ba:	681a      	ldr	r2, [r3, #0]
 80028bc:	68fb      	ldr	r3, [r7, #12]
 80028be:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80028c0:	4619      	mov	r1, r3
 80028c2:	4610      	mov	r0, r2
 80028c4:	f7ff fc68 	bl	8002198 <LL_ADC_REG_SetDataTransferMode>
#endif


        /* Start the DMA channel */
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 80028c8:	68fb      	ldr	r3, [r7, #12]
 80028ca:	6cd8      	ldr	r0, [r3, #76]	@ 0x4c
 80028cc:	68fb      	ldr	r3, [r7, #12]
 80028ce:	681b      	ldr	r3, [r3, #0]
 80028d0:	3340      	adds	r3, #64	@ 0x40
 80028d2:	4619      	mov	r1, r3
 80028d4:	68ba      	ldr	r2, [r7, #8]
 80028d6:	687b      	ldr	r3, [r7, #4]
 80028d8:	f001 fe26 	bl	8004528 <HAL_DMA_Start_IT>
 80028dc:	4603      	mov	r3, r0
 80028de:	75fb      	strb	r3, [r7, #23]
        /* Enable conversion of regular group.                                  */
        /* If software start has been selected, conversion starts immediately.  */
        /* If external trigger has been selected, conversion will start at next */
        /* trigger event.                                                       */
        /* Start ADC group regular conversion */
        LL_ADC_REG_StartConversion(hadc->Instance);
 80028e0:	68fb      	ldr	r3, [r7, #12]
 80028e2:	681b      	ldr	r3, [r3, #0]
 80028e4:	4618      	mov	r0, r3
 80028e6:	f7ff fd85 	bl	80023f4 <LL_ADC_REG_StartConversion>
      if (tmp_hal_status == HAL_OK)
 80028ea:	e00d      	b.n	8002908 <HAL_ADC_Start_DMA+0x15c>
      }
      else
      {
        /* Process unlocked */
        __HAL_UNLOCK(hadc);
 80028ec:	68fb      	ldr	r3, [r7, #12]
 80028ee:	2200      	movs	r2, #0
 80028f0:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
      if (tmp_hal_status == HAL_OK)
 80028f4:	e008      	b.n	8002908 <HAL_ADC_Start_DMA+0x15c>
      }

    }
    else
    {
      tmp_hal_status = HAL_ERROR;
 80028f6:	2301      	movs	r3, #1
 80028f8:	75fb      	strb	r3, [r7, #23]
      /* Process unlocked */
      __HAL_UNLOCK(hadc);
 80028fa:	68fb      	ldr	r3, [r7, #12]
 80028fc:	2200      	movs	r2, #0
 80028fe:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
 8002902:	e001      	b.n	8002908 <HAL_ADC_Start_DMA+0x15c>
    }
  }
  else
  {
    tmp_hal_status = HAL_BUSY;
 8002904:	2302      	movs	r3, #2
 8002906:	75fb      	strb	r3, [r7, #23]
  }

  /* Return function status */
  return tmp_hal_status;
 8002908:	7dfb      	ldrb	r3, [r7, #23]
}
 800290a:	4618      	mov	r0, r3
 800290c:	3718      	adds	r7, #24
 800290e:	46bd      	mov	sp, r7
 8002910:	bd80      	pop	{r7, pc}
 8002912:	bf00      	nop
 8002914:	40022000 	.word	0x40022000
 8002918:	40022100 	.word	0x40022100
 800291c:	40022300 	.word	0x40022300
 8002920:	58026300 	.word	0x58026300
 8002924:	fffff0fe 	.word	0xfffff0fe
 8002928:	080035ab 	.word	0x080035ab
 800292c:	08003683 	.word	0x08003683
 8002930:	0800369f 	.word	0x0800369f

08002934 <HAL_ADC_IRQHandler>:
  * @brief  Handle ADC interrupt request.
  * @param hadc ADC handle
  * @retval None
  */
void HAL_ADC_IRQHandler(ADC_HandleTypeDef *hadc)
{
 8002934:	b580      	push	{r7, lr}
 8002936:	b08a      	sub	sp, #40	@ 0x28
 8002938:	af00      	add	r7, sp, #0
 800293a:	6078      	str	r0, [r7, #4]
  uint32_t overrun_error = 0UL; /* flag set if overrun occurrence has to be considered as an error */
 800293c:	2300      	movs	r3, #0
 800293e:	627b      	str	r3, [r7, #36]	@ 0x24
  uint32_t tmp_isr = hadc->Instance->ISR;
 8002940:	687b      	ldr	r3, [r7, #4]
 8002942:	681b      	ldr	r3, [r3, #0]
 8002944:	681b      	ldr	r3, [r3, #0]
 8002946:	61fb      	str	r3, [r7, #28]
  uint32_t tmp_ier = hadc->Instance->IER;
 8002948:	687b      	ldr	r3, [r7, #4]
 800294a:	681b      	ldr	r3, [r3, #0]
 800294c:	685b      	ldr	r3, [r3, #4]
 800294e:	61bb      	str	r3, [r7, #24]
  uint32_t tmp_adc_inj_is_trigger_source_sw_start;
  uint32_t tmp_adc_reg_is_trigger_source_sw_start;
  uint32_t tmp_cfgr;
  const ADC_TypeDef *tmpADC_Master;
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8002950:	687b      	ldr	r3, [r7, #4]
 8002952:	681b      	ldr	r3, [r3, #0]
 8002954:	4a87      	ldr	r2, [pc, #540]	@ (8002b74 <HAL_ADC_IRQHandler+0x240>)
 8002956:	4293      	cmp	r3, r2
 8002958:	d004      	beq.n	8002964 <HAL_ADC_IRQHandler+0x30>
 800295a:	687b      	ldr	r3, [r7, #4]
 800295c:	681b      	ldr	r3, [r3, #0]
 800295e:	4a86      	ldr	r2, [pc, #536]	@ (8002b78 <HAL_ADC_IRQHandler+0x244>)
 8002960:	4293      	cmp	r3, r2
 8002962:	d101      	bne.n	8002968 <HAL_ADC_IRQHandler+0x34>
 8002964:	4b85      	ldr	r3, [pc, #532]	@ (8002b7c <HAL_ADC_IRQHandler+0x248>)
 8002966:	e000      	b.n	800296a <HAL_ADC_IRQHandler+0x36>
 8002968:	4b85      	ldr	r3, [pc, #532]	@ (8002b80 <HAL_ADC_IRQHandler+0x24c>)
 800296a:	4618      	mov	r0, r3
 800296c:	f7ff fc8a 	bl	8002284 <LL_ADC_GetMultimode>
 8002970:	6178      	str	r0, [r7, #20]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));

  /* ========== Check End of Sampling flag for ADC group regular ========== */
  if (((tmp_isr & ADC_FLAG_EOSMP) == ADC_FLAG_EOSMP) && ((tmp_ier & ADC_IT_EOSMP) == ADC_IT_EOSMP))
 8002972:	69fb      	ldr	r3, [r7, #28]
 8002974:	f003 0302 	and.w	r3, r3, #2
 8002978:	2b00      	cmp	r3, #0
 800297a:	d017      	beq.n	80029ac <HAL_ADC_IRQHandler+0x78>
 800297c:	69bb      	ldr	r3, [r7, #24]
 800297e:	f003 0302 	and.w	r3, r3, #2
 8002982:	2b00      	cmp	r3, #0
 8002984:	d012      	beq.n	80029ac <HAL_ADC_IRQHandler+0x78>
  {
    /* Update state machine on end of sampling status if not in error state */
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8002986:	687b      	ldr	r3, [r7, #4]
 8002988:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800298a:	f003 0310 	and.w	r3, r3, #16
 800298e:	2b00      	cmp	r3, #0
 8002990:	d105      	bne.n	800299e <HAL_ADC_IRQHandler+0x6a>
    {
      /* Set ADC state */
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOSMP);
 8002992:	687b      	ldr	r3, [r7, #4]
 8002994:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002996:	f443 6200 	orr.w	r2, r3, #2048	@ 0x800
 800299a:	687b      	ldr	r3, [r7, #4]
 800299c:	655a      	str	r2, [r3, #84]	@ 0x54

    /* End Of Sampling callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->EndOfSamplingCallback(hadc);
#else
    HAL_ADCEx_EndOfSamplingCallback(hadc);
 800299e:	6878      	ldr	r0, [r7, #4]
 80029a0:	f001 f88a 	bl	8003ab8 <HAL_ADCEx_EndOfSamplingCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear regular group conversion flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOSMP);
 80029a4:	687b      	ldr	r3, [r7, #4]
 80029a6:	681b      	ldr	r3, [r3, #0]
 80029a8:	2202      	movs	r2, #2
 80029aa:	601a      	str	r2, [r3, #0]
  }

  /* ====== Check ADC group regular end of unitary conversion sequence conversions ===== */
  if ((((tmp_isr & ADC_FLAG_EOC) == ADC_FLAG_EOC) && ((tmp_ier & ADC_IT_EOC) == ADC_IT_EOC)) ||
 80029ac:	69fb      	ldr	r3, [r7, #28]
 80029ae:	f003 0304 	and.w	r3, r3, #4
 80029b2:	2b00      	cmp	r3, #0
 80029b4:	d004      	beq.n	80029c0 <HAL_ADC_IRQHandler+0x8c>
 80029b6:	69bb      	ldr	r3, [r7, #24]
 80029b8:	f003 0304 	and.w	r3, r3, #4
 80029bc:	2b00      	cmp	r3, #0
 80029be:	d10a      	bne.n	80029d6 <HAL_ADC_IRQHandler+0xa2>
      (((tmp_isr & ADC_FLAG_EOS) == ADC_FLAG_EOS) && ((tmp_ier & ADC_IT_EOS) == ADC_IT_EOS)))
 80029c0:	69fb      	ldr	r3, [r7, #28]
 80029c2:	f003 0308 	and.w	r3, r3, #8
  if ((((tmp_isr & ADC_FLAG_EOC) == ADC_FLAG_EOC) && ((tmp_ier & ADC_IT_EOC) == ADC_IT_EOC)) ||
 80029c6:	2b00      	cmp	r3, #0
 80029c8:	f000 8083 	beq.w	8002ad2 <HAL_ADC_IRQHandler+0x19e>
      (((tmp_isr & ADC_FLAG_EOS) == ADC_FLAG_EOS) && ((tmp_ier & ADC_IT_EOS) == ADC_IT_EOS)))
 80029cc:	69bb      	ldr	r3, [r7, #24]
 80029ce:	f003 0308 	and.w	r3, r3, #8
 80029d2:	2b00      	cmp	r3, #0
 80029d4:	d07d      	beq.n	8002ad2 <HAL_ADC_IRQHandler+0x19e>
  {
    /* Update state machine on conversion status if not in error state */
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 80029d6:	687b      	ldr	r3, [r7, #4]
 80029d8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80029da:	f003 0310 	and.w	r3, r3, #16
 80029de:	2b00      	cmp	r3, #0
 80029e0:	d105      	bne.n	80029ee <HAL_ADC_IRQHandler+0xba>
    {
      /* Set ADC state */
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 80029e2:	687b      	ldr	r3, [r7, #4]
 80029e4:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80029e6:	f443 7200 	orr.w	r2, r3, #512	@ 0x200
 80029ea:	687b      	ldr	r3, [r7, #4]
 80029ec:	655a      	str	r2, [r3, #84]	@ 0x54
    }

    /* Determine whether any further conversion upcoming on group regular     */
    /* by external trigger, continuous mode or scan sequence on going         */
    /* to disable interruption.                                               */
    if (LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance) != 0UL)
 80029ee:	687b      	ldr	r3, [r7, #4]
 80029f0:	681b      	ldr	r3, [r3, #0]
 80029f2:	4618      	mov	r0, r3
 80029f4:	f7ff fb91 	bl	800211a <LL_ADC_REG_IsTriggerSourceSWStart>
 80029f8:	4603      	mov	r3, r0
 80029fa:	2b00      	cmp	r3, #0
 80029fc:	d062      	beq.n	8002ac4 <HAL_ADC_IRQHandler+0x190>
    {
      /* Get relevant register CFGR in ADC instance of ADC master or slave    */
      /* in function of multimode state (for devices with multimode           */
      /* available).                                                          */
      if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 80029fe:	687b      	ldr	r3, [r7, #4]
 8002a00:	681b      	ldr	r3, [r3, #0]
 8002a02:	4a5d      	ldr	r2, [pc, #372]	@ (8002b78 <HAL_ADC_IRQHandler+0x244>)
 8002a04:	4293      	cmp	r3, r2
 8002a06:	d002      	beq.n	8002a0e <HAL_ADC_IRQHandler+0xda>
 8002a08:	687b      	ldr	r3, [r7, #4]
 8002a0a:	681b      	ldr	r3, [r3, #0]
 8002a0c:	e000      	b.n	8002a10 <HAL_ADC_IRQHandler+0xdc>
 8002a0e:	4b59      	ldr	r3, [pc, #356]	@ (8002b74 <HAL_ADC_IRQHandler+0x240>)
 8002a10:	687a      	ldr	r2, [r7, #4]
 8002a12:	6812      	ldr	r2, [r2, #0]
 8002a14:	4293      	cmp	r3, r2
 8002a16:	d008      	beq.n	8002a2a <HAL_ADC_IRQHandler+0xf6>
          || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8002a18:	697b      	ldr	r3, [r7, #20]
 8002a1a:	2b00      	cmp	r3, #0
 8002a1c:	d005      	beq.n	8002a2a <HAL_ADC_IRQHandler+0xf6>
          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_SIMULT)
 8002a1e:	697b      	ldr	r3, [r7, #20]
 8002a20:	2b05      	cmp	r3, #5
 8002a22:	d002      	beq.n	8002a2a <HAL_ADC_IRQHandler+0xf6>
          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
 8002a24:	697b      	ldr	r3, [r7, #20]
 8002a26:	2b09      	cmp	r3, #9
 8002a28:	d104      	bne.n	8002a34 <HAL_ADC_IRQHandler+0x100>
         )
      {
        /* check CONT bit directly in handle ADC CFGR register */
        tmp_cfgr = READ_REG(hadc->Instance->CFGR);
 8002a2a:	687b      	ldr	r3, [r7, #4]
 8002a2c:	681b      	ldr	r3, [r3, #0]
 8002a2e:	68db      	ldr	r3, [r3, #12]
 8002a30:	623b      	str	r3, [r7, #32]
 8002a32:	e00c      	b.n	8002a4e <HAL_ADC_IRQHandler+0x11a>
      }
      else
      {
        /* else need to check Master ADC CONT bit */
        tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
 8002a34:	687b      	ldr	r3, [r7, #4]
 8002a36:	681b      	ldr	r3, [r3, #0]
 8002a38:	4a4f      	ldr	r2, [pc, #316]	@ (8002b78 <HAL_ADC_IRQHandler+0x244>)
 8002a3a:	4293      	cmp	r3, r2
 8002a3c:	d002      	beq.n	8002a44 <HAL_ADC_IRQHandler+0x110>
 8002a3e:	687b      	ldr	r3, [r7, #4]
 8002a40:	681b      	ldr	r3, [r3, #0]
 8002a42:	e000      	b.n	8002a46 <HAL_ADC_IRQHandler+0x112>
 8002a44:	4b4b      	ldr	r3, [pc, #300]	@ (8002b74 <HAL_ADC_IRQHandler+0x240>)
 8002a46:	613b      	str	r3, [r7, #16]
        tmp_cfgr = READ_REG(tmpADC_Master->CFGR);
 8002a48:	693b      	ldr	r3, [r7, #16]
 8002a4a:	68db      	ldr	r3, [r3, #12]
 8002a4c:	623b      	str	r3, [r7, #32]
      }

      /* Carry on if continuous mode is disabled */
      if (READ_BIT(tmp_cfgr, ADC_CFGR_CONT) != ADC_CFGR_CONT)
 8002a4e:	6a3b      	ldr	r3, [r7, #32]
 8002a50:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8002a54:	2b00      	cmp	r3, #0
 8002a56:	d135      	bne.n	8002ac4 <HAL_ADC_IRQHandler+0x190>
      {
        /* If End of Sequence is reached, disable interrupts */
        if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS))
 8002a58:	687b      	ldr	r3, [r7, #4]
 8002a5a:	681b      	ldr	r3, [r3, #0]
 8002a5c:	681b      	ldr	r3, [r3, #0]
 8002a5e:	f003 0308 	and.w	r3, r3, #8
 8002a62:	2b08      	cmp	r3, #8
 8002a64:	d12e      	bne.n	8002ac4 <HAL_ADC_IRQHandler+0x190>
        {
          /* Allowed to modify bits ADC_IT_EOC/ADC_IT_EOS only if bit         */
          /* ADSTART==0 (no conversion on going)                              */
          if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8002a66:	687b      	ldr	r3, [r7, #4]
 8002a68:	681b      	ldr	r3, [r3, #0]
 8002a6a:	4618      	mov	r0, r3
 8002a6c:	f7ff fcd6 	bl	800241c <LL_ADC_REG_IsConversionOngoing>
 8002a70:	4603      	mov	r3, r0
 8002a72:	2b00      	cmp	r3, #0
 8002a74:	d11a      	bne.n	8002aac <HAL_ADC_IRQHandler+0x178>
          {
            /* Disable ADC end of sequence conversion interrupt */
            /* Note: Overrun interrupt was enabled with EOC interrupt in      */
            /* HAL_Start_IT(), but is not disabled here because can be used   */
            /* by overrun IRQ process below.                                  */
            __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 8002a76:	687b      	ldr	r3, [r7, #4]
 8002a78:	681b      	ldr	r3, [r3, #0]
 8002a7a:	685a      	ldr	r2, [r3, #4]
 8002a7c:	687b      	ldr	r3, [r7, #4]
 8002a7e:	681b      	ldr	r3, [r3, #0]
 8002a80:	f022 020c 	bic.w	r2, r2, #12
 8002a84:	605a      	str	r2, [r3, #4]

            /* Set ADC state */
            CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 8002a86:	687b      	ldr	r3, [r7, #4]
 8002a88:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002a8a:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
 8002a8e:	687b      	ldr	r3, [r7, #4]
 8002a90:	655a      	str	r2, [r3, #84]	@ 0x54

            if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
 8002a92:	687b      	ldr	r3, [r7, #4]
 8002a94:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002a96:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8002a9a:	2b00      	cmp	r3, #0
 8002a9c:	d112      	bne.n	8002ac4 <HAL_ADC_IRQHandler+0x190>
            {
              SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8002a9e:	687b      	ldr	r3, [r7, #4]
 8002aa0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002aa2:	f043 0201 	orr.w	r2, r3, #1
 8002aa6:	687b      	ldr	r3, [r7, #4]
 8002aa8:	655a      	str	r2, [r3, #84]	@ 0x54
 8002aaa:	e00b      	b.n	8002ac4 <HAL_ADC_IRQHandler+0x190>
            }
          }
          else
          {
            /* Change ADC state to error state */
            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8002aac:	687b      	ldr	r3, [r7, #4]
 8002aae:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002ab0:	f043 0210 	orr.w	r2, r3, #16
 8002ab4:	687b      	ldr	r3, [r7, #4]
 8002ab6:	655a      	str	r2, [r3, #84]	@ 0x54

            /* Set ADC error code to ADC peripheral internal error */
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8002ab8:	687b      	ldr	r3, [r7, #4]
 8002aba:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8002abc:	f043 0201 	orr.w	r2, r3, #1
 8002ac0:	687b      	ldr	r3, [r7, #4]
 8002ac2:	659a      	str	r2, [r3, #88]	@ 0x58
    /*       possibility to use:                                              */
    /*        " if( __HAL_ADC_GET_FLAG(&hadc, ADC_FLAG_EOS)) "                */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->ConvCpltCallback(hadc);
#else
    HAL_ADC_ConvCpltCallback(hadc);
 8002ac4:	6878      	ldr	r0, [r7, #4]
 8002ac6:	f000 f96f 	bl	8002da8 <HAL_ADC_ConvCpltCallback>
    /* Clear regular group conversion flag */
    /* Note: in case of overrun set to ADC_OVR_DATA_PRESERVED, end of         */
    /*       conversion flags clear induces the release of the preserved data.*/
    /*       Therefore, if the preserved data value is needed, it must be     */
    /*       read preliminarily into HAL_ADC_ConvCpltCallback().              */
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
 8002aca:	687b      	ldr	r3, [r7, #4]
 8002acc:	681b      	ldr	r3, [r3, #0]
 8002ace:	220c      	movs	r2, #12
 8002ad0:	601a      	str	r2, [r3, #0]
  }

  /* ====== Check ADC group injected end of unitary conversion sequence conversions ===== */
  if ((((tmp_isr & ADC_FLAG_JEOC) == ADC_FLAG_JEOC) && ((tmp_ier & ADC_IT_JEOC) == ADC_IT_JEOC)) ||
 8002ad2:	69fb      	ldr	r3, [r7, #28]
 8002ad4:	f003 0320 	and.w	r3, r3, #32
 8002ad8:	2b00      	cmp	r3, #0
 8002ada:	d004      	beq.n	8002ae6 <HAL_ADC_IRQHandler+0x1b2>
 8002adc:	69bb      	ldr	r3, [r7, #24]
 8002ade:	f003 0320 	and.w	r3, r3, #32
 8002ae2:	2b00      	cmp	r3, #0
 8002ae4:	d10b      	bne.n	8002afe <HAL_ADC_IRQHandler+0x1ca>
      (((tmp_isr & ADC_FLAG_JEOS) == ADC_FLAG_JEOS) && ((tmp_ier & ADC_IT_JEOS) == ADC_IT_JEOS)))
 8002ae6:	69fb      	ldr	r3, [r7, #28]
 8002ae8:	f003 0340 	and.w	r3, r3, #64	@ 0x40
  if ((((tmp_isr & ADC_FLAG_JEOC) == ADC_FLAG_JEOC) && ((tmp_ier & ADC_IT_JEOC) == ADC_IT_JEOC)) ||
 8002aec:	2b00      	cmp	r3, #0
 8002aee:	f000 80a0 	beq.w	8002c32 <HAL_ADC_IRQHandler+0x2fe>
      (((tmp_isr & ADC_FLAG_JEOS) == ADC_FLAG_JEOS) && ((tmp_ier & ADC_IT_JEOS) == ADC_IT_JEOS)))
 8002af2:	69bb      	ldr	r3, [r7, #24]
 8002af4:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002af8:	2b00      	cmp	r3, #0
 8002afa:	f000 809a 	beq.w	8002c32 <HAL_ADC_IRQHandler+0x2fe>
  {
    /* Update state machine on conversion status if not in error state */
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8002afe:	687b      	ldr	r3, [r7, #4]
 8002b00:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002b02:	f003 0310 	and.w	r3, r3, #16
 8002b06:	2b00      	cmp	r3, #0
 8002b08:	d105      	bne.n	8002b16 <HAL_ADC_IRQHandler+0x1e2>
    {
      /* Set ADC state */
      SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
 8002b0a:	687b      	ldr	r3, [r7, #4]
 8002b0c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002b0e:	f443 5200 	orr.w	r2, r3, #8192	@ 0x2000
 8002b12:	687b      	ldr	r3, [r7, #4]
 8002b14:	655a      	str	r2, [r3, #84]	@ 0x54
    }

    /* Retrieve ADC configuration */
    tmp_adc_inj_is_trigger_source_sw_start = LL_ADC_INJ_IsTriggerSourceSWStart(hadc->Instance);
 8002b16:	687b      	ldr	r3, [r7, #4]
 8002b18:	681b      	ldr	r3, [r3, #0]
 8002b1a:	4618      	mov	r0, r3
 8002b1c:	f7ff fb4f 	bl	80021be <LL_ADC_INJ_IsTriggerSourceSWStart>
 8002b20:	60f8      	str	r0, [r7, #12]
    tmp_adc_reg_is_trigger_source_sw_start = LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance);
 8002b22:	687b      	ldr	r3, [r7, #4]
 8002b24:	681b      	ldr	r3, [r3, #0]
 8002b26:	4618      	mov	r0, r3
 8002b28:	f7ff faf7 	bl	800211a <LL_ADC_REG_IsTriggerSourceSWStart>
 8002b2c:	60b8      	str	r0, [r7, #8]
    /* Get relevant register CFGR in ADC instance of ADC master or slave  */
    /* in function of multimode state (for devices with multimode         */
    /* available).                                                        */
    if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 8002b2e:	687b      	ldr	r3, [r7, #4]
 8002b30:	681b      	ldr	r3, [r3, #0]
 8002b32:	4a11      	ldr	r2, [pc, #68]	@ (8002b78 <HAL_ADC_IRQHandler+0x244>)
 8002b34:	4293      	cmp	r3, r2
 8002b36:	d002      	beq.n	8002b3e <HAL_ADC_IRQHandler+0x20a>
 8002b38:	687b      	ldr	r3, [r7, #4]
 8002b3a:	681b      	ldr	r3, [r3, #0]
 8002b3c:	e000      	b.n	8002b40 <HAL_ADC_IRQHandler+0x20c>
 8002b3e:	4b0d      	ldr	r3, [pc, #52]	@ (8002b74 <HAL_ADC_IRQHandler+0x240>)
 8002b40:	687a      	ldr	r2, [r7, #4]
 8002b42:	6812      	ldr	r2, [r2, #0]
 8002b44:	4293      	cmp	r3, r2
 8002b46:	d008      	beq.n	8002b5a <HAL_ADC_IRQHandler+0x226>
        || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8002b48:	697b      	ldr	r3, [r7, #20]
 8002b4a:	2b00      	cmp	r3, #0
 8002b4c:	d005      	beq.n	8002b5a <HAL_ADC_IRQHandler+0x226>
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_SIMULT)
 8002b4e:	697b      	ldr	r3, [r7, #20]
 8002b50:	2b06      	cmp	r3, #6
 8002b52:	d002      	beq.n	8002b5a <HAL_ADC_IRQHandler+0x226>
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_INTERL)
 8002b54:	697b      	ldr	r3, [r7, #20]
 8002b56:	2b07      	cmp	r3, #7
 8002b58:	d104      	bne.n	8002b64 <HAL_ADC_IRQHandler+0x230>
       )
    {
      tmp_cfgr = READ_REG(hadc->Instance->CFGR);
 8002b5a:	687b      	ldr	r3, [r7, #4]
 8002b5c:	681b      	ldr	r3, [r3, #0]
 8002b5e:	68db      	ldr	r3, [r3, #12]
 8002b60:	623b      	str	r3, [r7, #32]
 8002b62:	e014      	b.n	8002b8e <HAL_ADC_IRQHandler+0x25a>
    }
    else
    {
      tmpADC_Master = __LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance);
 8002b64:	687b      	ldr	r3, [r7, #4]
 8002b66:	681b      	ldr	r3, [r3, #0]
 8002b68:	4a03      	ldr	r2, [pc, #12]	@ (8002b78 <HAL_ADC_IRQHandler+0x244>)
 8002b6a:	4293      	cmp	r3, r2
 8002b6c:	d00a      	beq.n	8002b84 <HAL_ADC_IRQHandler+0x250>
 8002b6e:	687b      	ldr	r3, [r7, #4]
 8002b70:	681b      	ldr	r3, [r3, #0]
 8002b72:	e008      	b.n	8002b86 <HAL_ADC_IRQHandler+0x252>
 8002b74:	40022000 	.word	0x40022000
 8002b78:	40022100 	.word	0x40022100
 8002b7c:	40022300 	.word	0x40022300
 8002b80:	58026300 	.word	0x58026300
 8002b84:	4b84      	ldr	r3, [pc, #528]	@ (8002d98 <HAL_ADC_IRQHandler+0x464>)
 8002b86:	613b      	str	r3, [r7, #16]
      tmp_cfgr = READ_REG(tmpADC_Master->CFGR);
 8002b88:	693b      	ldr	r3, [r7, #16]
 8002b8a:	68db      	ldr	r3, [r3, #12]
 8002b8c:	623b      	str	r3, [r7, #32]
    /* Disable interruption if no further conversion upcoming by injected     */
    /* external trigger or by automatic injected conversion with regular      */
    /* group having no further conversion upcoming (same conditions as        */
    /* regular group interruption disabling above),                           */
    /* and if injected scan sequence is completed.                            */
    if (tmp_adc_inj_is_trigger_source_sw_start != 0UL)
 8002b8e:	68fb      	ldr	r3, [r7, #12]
 8002b90:	2b00      	cmp	r3, #0
 8002b92:	d047      	beq.n	8002c24 <HAL_ADC_IRQHandler+0x2f0>
    {
      if ((READ_BIT(tmp_cfgr, ADC_CFGR_JAUTO) == 0UL) ||
 8002b94:	6a3b      	ldr	r3, [r7, #32]
 8002b96:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8002b9a:	2b00      	cmp	r3, #0
 8002b9c:	d007      	beq.n	8002bae <HAL_ADC_IRQHandler+0x27a>
 8002b9e:	68bb      	ldr	r3, [r7, #8]
 8002ba0:	2b00      	cmp	r3, #0
 8002ba2:	d03f      	beq.n	8002c24 <HAL_ADC_IRQHandler+0x2f0>
          ((tmp_adc_reg_is_trigger_source_sw_start != 0UL) &&
           (READ_BIT(tmp_cfgr, ADC_CFGR_CONT) == 0UL)))
 8002ba4:	6a3b      	ldr	r3, [r7, #32]
 8002ba6:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
          ((tmp_adc_reg_is_trigger_source_sw_start != 0UL) &&
 8002baa:	2b00      	cmp	r3, #0
 8002bac:	d13a      	bne.n	8002c24 <HAL_ADC_IRQHandler+0x2f0>
      {
        /* If End of Sequence is reached, disable interrupts */
        if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS))
 8002bae:	687b      	ldr	r3, [r7, #4]
 8002bb0:	681b      	ldr	r3, [r3, #0]
 8002bb2:	681b      	ldr	r3, [r3, #0]
 8002bb4:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8002bb8:	2b40      	cmp	r3, #64	@ 0x40
 8002bba:	d133      	bne.n	8002c24 <HAL_ADC_IRQHandler+0x2f0>
          /* when the last context has been fully processed, JSQR is reset      */
          /* by the hardware. Even if no injected conversion is planned to come */
          /* (queue empty, triggers are ignored), it can start again            */
          /* immediately after setting a new context (JADSTART is still set).   */
          /* Therefore, state of HAL ADC injected group is kept to busy.        */
          if (READ_BIT(tmp_cfgr, ADC_CFGR_JQM) == 0UL)
 8002bbc:	6a3b      	ldr	r3, [r7, #32]
 8002bbe:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8002bc2:	2b00      	cmp	r3, #0
 8002bc4:	d12e      	bne.n	8002c24 <HAL_ADC_IRQHandler+0x2f0>
          {
            /* Allowed to modify bits ADC_IT_JEOC/ADC_IT_JEOS only if bit       */
            /* JADSTART==0 (no conversion on going)                             */
            if (LL_ADC_INJ_IsConversionOngoing(hadc->Instance) == 0UL)
 8002bc6:	687b      	ldr	r3, [r7, #4]
 8002bc8:	681b      	ldr	r3, [r3, #0]
 8002bca:	4618      	mov	r0, r3
 8002bcc:	f7ff fc39 	bl	8002442 <LL_ADC_INJ_IsConversionOngoing>
 8002bd0:	4603      	mov	r3, r0
 8002bd2:	2b00      	cmp	r3, #0
 8002bd4:	d11a      	bne.n	8002c0c <HAL_ADC_IRQHandler+0x2d8>
            {
              /* Disable ADC end of sequence conversion interrupt  */
              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC | ADC_IT_JEOS);
 8002bd6:	687b      	ldr	r3, [r7, #4]
 8002bd8:	681b      	ldr	r3, [r3, #0]
 8002bda:	685a      	ldr	r2, [r3, #4]
 8002bdc:	687b      	ldr	r3, [r7, #4]
 8002bde:	681b      	ldr	r3, [r3, #0]
 8002be0:	f022 0260 	bic.w	r2, r2, #96	@ 0x60
 8002be4:	605a      	str	r2, [r3, #4]

              /* Set ADC state */
              CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
 8002be6:	687b      	ldr	r3, [r7, #4]
 8002be8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002bea:	f423 5280 	bic.w	r2, r3, #4096	@ 0x1000
 8002bee:	687b      	ldr	r3, [r7, #4]
 8002bf0:	655a      	str	r2, [r3, #84]	@ 0x54

              if ((hadc->State & HAL_ADC_STATE_REG_BUSY) == 0UL)
 8002bf2:	687b      	ldr	r3, [r7, #4]
 8002bf4:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002bf6:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8002bfa:	2b00      	cmp	r3, #0
 8002bfc:	d112      	bne.n	8002c24 <HAL_ADC_IRQHandler+0x2f0>
              {
                SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8002bfe:	687b      	ldr	r3, [r7, #4]
 8002c00:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002c02:	f043 0201 	orr.w	r2, r3, #1
 8002c06:	687b      	ldr	r3, [r7, #4]
 8002c08:	655a      	str	r2, [r3, #84]	@ 0x54
 8002c0a:	e00b      	b.n	8002c24 <HAL_ADC_IRQHandler+0x2f0>
              }
            }
            else
            {
              /* Update ADC state machine to error */
              SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8002c0c:	687b      	ldr	r3, [r7, #4]
 8002c0e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002c10:	f043 0210 	orr.w	r2, r3, #16
 8002c14:	687b      	ldr	r3, [r7, #4]
 8002c16:	655a      	str	r2, [r3, #84]	@ 0x54

              /* Set ADC error code to ADC peripheral internal error */
              SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8002c18:	687b      	ldr	r3, [r7, #4]
 8002c1a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8002c1c:	f043 0201 	orr.w	r2, r3, #1
 8002c20:	687b      	ldr	r3, [r7, #4]
 8002c22:	659a      	str	r2, [r3, #88]	@ 0x58
              interruption has been triggered by end of conversion or end of
              sequence.    */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->InjectedConvCpltCallback(hadc);
#else
    HAL_ADCEx_InjectedConvCpltCallback(hadc);
 8002c24:	6878      	ldr	r0, [r7, #4]
 8002c26:	f000 ff1f 	bl	8003a68 <HAL_ADCEx_InjectedConvCpltCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear injected group conversion flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC | ADC_FLAG_JEOS);
 8002c2a:	687b      	ldr	r3, [r7, #4]
 8002c2c:	681b      	ldr	r3, [r3, #0]
 8002c2e:	2260      	movs	r2, #96	@ 0x60
 8002c30:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check Analog watchdog 1 flag ========== */
  if (((tmp_isr & ADC_FLAG_AWD1) == ADC_FLAG_AWD1) && ((tmp_ier & ADC_IT_AWD1) == ADC_IT_AWD1))
 8002c32:	69fb      	ldr	r3, [r7, #28]
 8002c34:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002c38:	2b00      	cmp	r3, #0
 8002c3a:	d011      	beq.n	8002c60 <HAL_ADC_IRQHandler+0x32c>
 8002c3c:	69bb      	ldr	r3, [r7, #24]
 8002c3e:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8002c42:	2b00      	cmp	r3, #0
 8002c44:	d00c      	beq.n	8002c60 <HAL_ADC_IRQHandler+0x32c>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
 8002c46:	687b      	ldr	r3, [r7, #4]
 8002c48:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002c4a:	f443 3280 	orr.w	r2, r3, #65536	@ 0x10000
 8002c4e:	687b      	ldr	r3, [r7, #4]
 8002c50:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Level out of window 1 callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->LevelOutOfWindowCallback(hadc);
#else
    HAL_ADC_LevelOutOfWindowCallback(hadc);
 8002c52:	6878      	ldr	r0, [r7, #4]
 8002c54:	f000 f8bc 	bl	8002dd0 <HAL_ADC_LevelOutOfWindowCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear ADC analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD1);
 8002c58:	687b      	ldr	r3, [r7, #4]
 8002c5a:	681b      	ldr	r3, [r3, #0]
 8002c5c:	2280      	movs	r2, #128	@ 0x80
 8002c5e:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check analog watchdog 2 flag ========== */
  if (((tmp_isr & ADC_FLAG_AWD2) == ADC_FLAG_AWD2) && ((tmp_ier & ADC_IT_AWD2) == ADC_IT_AWD2))
 8002c60:	69fb      	ldr	r3, [r7, #28]
 8002c62:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8002c66:	2b00      	cmp	r3, #0
 8002c68:	d012      	beq.n	8002c90 <HAL_ADC_IRQHandler+0x35c>
 8002c6a:	69bb      	ldr	r3, [r7, #24]
 8002c6c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8002c70:	2b00      	cmp	r3, #0
 8002c72:	d00d      	beq.n	8002c90 <HAL_ADC_IRQHandler+0x35c>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD2);
 8002c74:	687b      	ldr	r3, [r7, #4]
 8002c76:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002c78:	f443 3200 	orr.w	r2, r3, #131072	@ 0x20000
 8002c7c:	687b      	ldr	r3, [r7, #4]
 8002c7e:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Level out of window 2 callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->LevelOutOfWindow2Callback(hadc);
#else
    HAL_ADCEx_LevelOutOfWindow2Callback(hadc);
 8002c80:	6878      	ldr	r0, [r7, #4]
 8002c82:	f000 ff05 	bl	8003a90 <HAL_ADCEx_LevelOutOfWindow2Callback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear ADC analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD2);
 8002c86:	687b      	ldr	r3, [r7, #4]
 8002c88:	681b      	ldr	r3, [r3, #0]
 8002c8a:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8002c8e:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check analog watchdog 3 flag ========== */
  if (((tmp_isr & ADC_FLAG_AWD3) == ADC_FLAG_AWD3) && ((tmp_ier & ADC_IT_AWD3) == ADC_IT_AWD3))
 8002c90:	69fb      	ldr	r3, [r7, #28]
 8002c92:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8002c96:	2b00      	cmp	r3, #0
 8002c98:	d012      	beq.n	8002cc0 <HAL_ADC_IRQHandler+0x38c>
 8002c9a:	69bb      	ldr	r3, [r7, #24]
 8002c9c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8002ca0:	2b00      	cmp	r3, #0
 8002ca2:	d00d      	beq.n	8002cc0 <HAL_ADC_IRQHandler+0x38c>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD3);
 8002ca4:	687b      	ldr	r3, [r7, #4]
 8002ca6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002ca8:	f443 2280 	orr.w	r2, r3, #262144	@ 0x40000
 8002cac:	687b      	ldr	r3, [r7, #4]
 8002cae:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Level out of window 3 callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->LevelOutOfWindow3Callback(hadc);
#else
    HAL_ADCEx_LevelOutOfWindow3Callback(hadc);
 8002cb0:	6878      	ldr	r0, [r7, #4]
 8002cb2:	f000 fef7 	bl	8003aa4 <HAL_ADCEx_LevelOutOfWindow3Callback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Clear ADC analog watchdog flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD3);
 8002cb6:	687b      	ldr	r3, [r7, #4]
 8002cb8:	681b      	ldr	r3, [r3, #0]
 8002cba:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8002cbe:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check Overrun flag ========== */
  if (((tmp_isr & ADC_FLAG_OVR) == ADC_FLAG_OVR) && ((tmp_ier & ADC_IT_OVR) == ADC_IT_OVR))
 8002cc0:	69fb      	ldr	r3, [r7, #28]
 8002cc2:	f003 0310 	and.w	r3, r3, #16
 8002cc6:	2b00      	cmp	r3, #0
 8002cc8:	d043      	beq.n	8002d52 <HAL_ADC_IRQHandler+0x41e>
 8002cca:	69bb      	ldr	r3, [r7, #24]
 8002ccc:	f003 0310 	and.w	r3, r3, #16
 8002cd0:	2b00      	cmp	r3, #0
 8002cd2:	d03e      	beq.n	8002d52 <HAL_ADC_IRQHandler+0x41e>
    /* overrun event is not considered as an error.                           */
    /* (cf ref manual "Managing conversions without using the DMA and without */
    /* overrun ")                                                             */
    /* Exception for usage with DMA overrun event always considered as an     */
    /* error.                                                                 */
    if (hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)
 8002cd4:	687b      	ldr	r3, [r7, #4]
 8002cd6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8002cd8:	2b00      	cmp	r3, #0
 8002cda:	d102      	bne.n	8002ce2 <HAL_ADC_IRQHandler+0x3ae>
    {
      overrun_error = 1UL;
 8002cdc:	2301      	movs	r3, #1
 8002cde:	627b      	str	r3, [r7, #36]	@ 0x24
 8002ce0:	e021      	b.n	8002d26 <HAL_ADC_IRQHandler+0x3f2>
    }
    else
    {
      /* Check DMA configuration */
      if (tmp_multimode_config != LL_ADC_MULTI_INDEPENDENT)
 8002ce2:	697b      	ldr	r3, [r7, #20]
 8002ce4:	2b00      	cmp	r3, #0
 8002ce6:	d015      	beq.n	8002d14 <HAL_ADC_IRQHandler+0x3e0>
      {
        /* Multimode (when feature is available) is enabled,
           Common Control Register MDMA bits must be checked. */
        if (LL_ADC_GetMultiDMATransfer(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) != LL_ADC_MULTI_REG_DMA_EACH_ADC)
 8002ce8:	687b      	ldr	r3, [r7, #4]
 8002cea:	681b      	ldr	r3, [r3, #0]
 8002cec:	4a2a      	ldr	r2, [pc, #168]	@ (8002d98 <HAL_ADC_IRQHandler+0x464>)
 8002cee:	4293      	cmp	r3, r2
 8002cf0:	d004      	beq.n	8002cfc <HAL_ADC_IRQHandler+0x3c8>
 8002cf2:	687b      	ldr	r3, [r7, #4]
 8002cf4:	681b      	ldr	r3, [r3, #0]
 8002cf6:	4a29      	ldr	r2, [pc, #164]	@ (8002d9c <HAL_ADC_IRQHandler+0x468>)
 8002cf8:	4293      	cmp	r3, r2
 8002cfa:	d101      	bne.n	8002d00 <HAL_ADC_IRQHandler+0x3cc>
 8002cfc:	4b28      	ldr	r3, [pc, #160]	@ (8002da0 <HAL_ADC_IRQHandler+0x46c>)
 8002cfe:	e000      	b.n	8002d02 <HAL_ADC_IRQHandler+0x3ce>
 8002d00:	4b28      	ldr	r3, [pc, #160]	@ (8002da4 <HAL_ADC_IRQHandler+0x470>)
 8002d02:	4618      	mov	r0, r3
 8002d04:	f7ff facc 	bl	80022a0 <LL_ADC_GetMultiDMATransfer>
 8002d08:	4603      	mov	r3, r0
 8002d0a:	2b00      	cmp	r3, #0
 8002d0c:	d00b      	beq.n	8002d26 <HAL_ADC_IRQHandler+0x3f2>
        {
          overrun_error = 1UL;
 8002d0e:	2301      	movs	r3, #1
 8002d10:	627b      	str	r3, [r7, #36]	@ 0x24
 8002d12:	e008      	b.n	8002d26 <HAL_ADC_IRQHandler+0x3f2>
        }
      }
      else
      {
        /* Multimode not set or feature not available or ADC independent */
        if ((hadc->Instance->CFGR & ADC_CFGR_DMNGT) != 0UL)
 8002d14:	687b      	ldr	r3, [r7, #4]
 8002d16:	681b      	ldr	r3, [r3, #0]
 8002d18:	68db      	ldr	r3, [r3, #12]
 8002d1a:	f003 0303 	and.w	r3, r3, #3
 8002d1e:	2b00      	cmp	r3, #0
 8002d20:	d001      	beq.n	8002d26 <HAL_ADC_IRQHandler+0x3f2>
        {
          overrun_error = 1UL;
 8002d22:	2301      	movs	r3, #1
 8002d24:	627b      	str	r3, [r7, #36]	@ 0x24
        }
      }
    }

    if (overrun_error == 1UL)
 8002d26:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8002d28:	2b01      	cmp	r3, #1
 8002d2a:	d10e      	bne.n	8002d4a <HAL_ADC_IRQHandler+0x416>
    {
      /* Change ADC state to error state */
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);
 8002d2c:	687b      	ldr	r3, [r7, #4]
 8002d2e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002d30:	f443 6280 	orr.w	r2, r3, #1024	@ 0x400
 8002d34:	687b      	ldr	r3, [r7, #4]
 8002d36:	655a      	str	r2, [r3, #84]	@ 0x54

      /* Set ADC error code to overrun */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
 8002d38:	687b      	ldr	r3, [r7, #4]
 8002d3a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8002d3c:	f043 0202 	orr.w	r2, r3, #2
 8002d40:	687b      	ldr	r3, [r7, #4]
 8002d42:	659a      	str	r2, [r3, #88]	@ 0x58
      /*       Therefore, old ADC conversion data can be retrieved in         */
      /*       function "HAL_ADC_ErrorCallback()".                            */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
      hadc->ErrorCallback(hadc);
#else
      HAL_ADC_ErrorCallback(hadc);
 8002d44:	6878      	ldr	r0, [r7, #4]
 8002d46:	f000 f84d 	bl	8002de4 <HAL_ADC_ErrorCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
    }

    /* Clear ADC overrun flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
 8002d4a:	687b      	ldr	r3, [r7, #4]
 8002d4c:	681b      	ldr	r3, [r3, #0]
 8002d4e:	2210      	movs	r2, #16
 8002d50:	601a      	str	r2, [r3, #0]
  }

  /* ========== Check Injected context queue overflow flag ========== */
  if (((tmp_isr & ADC_FLAG_JQOVF) == ADC_FLAG_JQOVF) && ((tmp_ier & ADC_IT_JQOVF) == ADC_IT_JQOVF))
 8002d52:	69fb      	ldr	r3, [r7, #28]
 8002d54:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8002d58:	2b00      	cmp	r3, #0
 8002d5a:	d018      	beq.n	8002d8e <HAL_ADC_IRQHandler+0x45a>
 8002d5c:	69bb      	ldr	r3, [r7, #24]
 8002d5e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8002d62:	2b00      	cmp	r3, #0
 8002d64:	d013      	beq.n	8002d8e <HAL_ADC_IRQHandler+0x45a>
  {
    /* Change ADC state to overrun state */
    SET_BIT(hadc->State, HAL_ADC_STATE_INJ_JQOVF);
 8002d66:	687b      	ldr	r3, [r7, #4]
 8002d68:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8002d6a:	f443 4280 	orr.w	r2, r3, #16384	@ 0x4000
 8002d6e:	687b      	ldr	r3, [r7, #4]
 8002d70:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Set ADC error code to Injected context queue overflow */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_JQOVF);
 8002d72:	687b      	ldr	r3, [r7, #4]
 8002d74:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8002d76:	f043 0208 	orr.w	r2, r3, #8
 8002d7a:	687b      	ldr	r3, [r7, #4]
 8002d7c:	659a      	str	r2, [r3, #88]	@ 0x58

    /* Clear the Injected context queue overflow flag */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JQOVF);
 8002d7e:	687b      	ldr	r3, [r7, #4]
 8002d80:	681b      	ldr	r3, [r3, #0]
 8002d82:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8002d86:	601a      	str	r2, [r3, #0]

    /* Injected context queue overflow callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->InjectedQueueOverflowCallback(hadc);
#else
    HAL_ADCEx_InjectedQueueOverflowCallback(hadc);
 8002d88:	6878      	ldr	r0, [r7, #4]
 8002d8a:	f000 fe77 	bl	8003a7c <HAL_ADCEx_InjectedQueueOverflowCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
  }

}
 8002d8e:	bf00      	nop
 8002d90:	3728      	adds	r7, #40	@ 0x28
 8002d92:	46bd      	mov	sp, r7
 8002d94:	bd80      	pop	{r7, pc}
 8002d96:	bf00      	nop
 8002d98:	40022000 	.word	0x40022000
 8002d9c:	40022100 	.word	0x40022100
 8002da0:	40022300 	.word	0x40022300
 8002da4:	58026300 	.word	0x58026300

08002da8 <HAL_ADC_ConvCpltCallback>:
  * @brief  Conversion complete callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)
{
 8002da8:	b480      	push	{r7}
 8002daa:	b083      	sub	sp, #12
 8002dac:	af00      	add	r7, sp, #0
 8002dae:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_ConvCpltCallback must be implemented in the user file.
   */
}
 8002db0:	bf00      	nop
 8002db2:	370c      	adds	r7, #12
 8002db4:	46bd      	mov	sp, r7
 8002db6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002dba:	4770      	bx	lr

08002dbc <HAL_ADC_ConvHalfCpltCallback>:
  * @brief  Conversion DMA half-transfer callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef *hadc)
{
 8002dbc:	b480      	push	{r7}
 8002dbe:	b083      	sub	sp, #12
 8002dc0:	af00      	add	r7, sp, #0
 8002dc2:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_ConvHalfCpltCallback must be implemented in the user file.
  */
}
 8002dc4:	bf00      	nop
 8002dc6:	370c      	adds	r7, #12
 8002dc8:	46bd      	mov	sp, r7
 8002dca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002dce:	4770      	bx	lr

08002dd0 <HAL_ADC_LevelOutOfWindowCallback>:
  * @brief  Analog watchdog 1 callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef *hadc)
{
 8002dd0:	b480      	push	{r7}
 8002dd2:	b083      	sub	sp, #12
 8002dd4:	af00      	add	r7, sp, #0
 8002dd6:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_LevelOutOfWindowCallback must be implemented in the user file.
  */
}
 8002dd8:	bf00      	nop
 8002dda:	370c      	adds	r7, #12
 8002ddc:	46bd      	mov	sp, r7
 8002dde:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002de2:	4770      	bx	lr

08002de4 <HAL_ADC_ErrorCallback>:
  *           (this function is also clearing overrun flag)
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
{
 8002de4:	b480      	push	{r7}
 8002de6:	b083      	sub	sp, #12
 8002de8:	af00      	add	r7, sp, #0
 8002dea:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_ErrorCallback must be implemented in the user file.
  */
}
 8002dec:	bf00      	nop
 8002dee:	370c      	adds	r7, #12
 8002df0:	46bd      	mov	sp, r7
 8002df2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002df6:	4770      	bx	lr

08002df8 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *sConfig)
{
 8002df8:	b590      	push	{r4, r7, lr}
 8002dfa:	b08d      	sub	sp, #52	@ 0x34
 8002dfc:	af00      	add	r7, sp, #0
 8002dfe:	6078      	str	r0, [r7, #4]
 8002e00:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8002e02:	2300      	movs	r3, #0
 8002e04:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  uint32_t tmpOffsetShifted;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0;
 8002e08:	2300      	movs	r3, #0
 8002e0a:	60fb      	str	r3, [r7, #12]
  /* if ROVSE is set, the value of the OFFSETy_EN bit in ADCx_OFRy register is
     ignored (considered as reset) */
  assert_param(!((sConfig->OffsetNumber != ADC_OFFSET_NONE) && (hadc->Init.OversamplingMode == ENABLE)));

  /* Verification of channel number */
  if (sConfig->SingleDiff != ADC_DIFFERENTIAL_ENDED)
 8002e0c:	683b      	ldr	r3, [r7, #0]
 8002e0e:	68db      	ldr	r3, [r3, #12]
 8002e10:	4a65      	ldr	r2, [pc, #404]	@ (8002fa8 <HAL_ADC_ConfigChannel+0x1b0>)
 8002e12:	4293      	cmp	r3, r2
    }
#endif
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8002e14:	687b      	ldr	r3, [r7, #4]
 8002e16:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 8002e1a:	2b01      	cmp	r3, #1
 8002e1c:	d101      	bne.n	8002e22 <HAL_ADC_ConfigChannel+0x2a>
 8002e1e:	2302      	movs	r3, #2
 8002e20:	e2c7      	b.n	80033b2 <HAL_ADC_ConfigChannel+0x5ba>
 8002e22:	687b      	ldr	r3, [r7, #4]
 8002e24:	2201      	movs	r2, #1
 8002e26:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8002e2a:	687b      	ldr	r3, [r7, #4]
 8002e2c:	681b      	ldr	r3, [r3, #0]
 8002e2e:	4618      	mov	r0, r3
 8002e30:	f7ff faf4 	bl	800241c <LL_ADC_REG_IsConversionOngoing>
 8002e34:	4603      	mov	r3, r0
 8002e36:	2b00      	cmp	r3, #0
 8002e38:	f040 82ac 	bne.w	8003394 <HAL_ADC_ConfigChannel+0x59c>
  {
    if (!(__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel)))
 8002e3c:	683b      	ldr	r3, [r7, #0]
 8002e3e:	681b      	ldr	r3, [r3, #0]
 8002e40:	2b00      	cmp	r3, #0
 8002e42:	db2c      	blt.n	8002e9e <HAL_ADC_ConfigChannel+0xa6>
        /* ADC channels preselection */
        hadc->Instance->PCSEL_RES0 |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) & 0x1FUL));
      }
#else
      /* ADC channels preselection */
      hadc->Instance->PCSEL |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) & 0x1FUL));
 8002e44:	683b      	ldr	r3, [r7, #0]
 8002e46:	681b      	ldr	r3, [r3, #0]
 8002e48:	f3c3 0313 	ubfx	r3, r3, #0, #20
 8002e4c:	2b00      	cmp	r3, #0
 8002e4e:	d108      	bne.n	8002e62 <HAL_ADC_ConfigChannel+0x6a>
 8002e50:	683b      	ldr	r3, [r7, #0]
 8002e52:	681b      	ldr	r3, [r3, #0]
 8002e54:	0e9b      	lsrs	r3, r3, #26
 8002e56:	f003 031f 	and.w	r3, r3, #31
 8002e5a:	2201      	movs	r2, #1
 8002e5c:	fa02 f303 	lsl.w	r3, r2, r3
 8002e60:	e016      	b.n	8002e90 <HAL_ADC_ConfigChannel+0x98>
 8002e62:	683b      	ldr	r3, [r7, #0]
 8002e64:	681b      	ldr	r3, [r3, #0]
 8002e66:	617b      	str	r3, [r7, #20]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002e68:	697b      	ldr	r3, [r7, #20]
 8002e6a:	fa93 f3a3 	rbit	r3, r3
 8002e6e:	613b      	str	r3, [r7, #16]
  return result;
 8002e70:	693b      	ldr	r3, [r7, #16]
 8002e72:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
 8002e74:	69bb      	ldr	r3, [r7, #24]
 8002e76:	2b00      	cmp	r3, #0
 8002e78:	d101      	bne.n	8002e7e <HAL_ADC_ConfigChannel+0x86>
    return 32U;
 8002e7a:	2320      	movs	r3, #32
 8002e7c:	e003      	b.n	8002e86 <HAL_ADC_ConfigChannel+0x8e>
  return __builtin_clz(value);
 8002e7e:	69bb      	ldr	r3, [r7, #24]
 8002e80:	fab3 f383 	clz	r3, r3
 8002e84:	b2db      	uxtb	r3, r3
 8002e86:	f003 031f 	and.w	r3, r3, #31
 8002e8a:	2201      	movs	r2, #1
 8002e8c:	fa02 f303 	lsl.w	r3, r2, r3
 8002e90:	687a      	ldr	r2, [r7, #4]
 8002e92:	6812      	ldr	r2, [r2, #0]
 8002e94:	69d1      	ldr	r1, [r2, #28]
 8002e96:	687a      	ldr	r2, [r7, #4]
 8002e98:	6812      	ldr	r2, [r2, #0]
 8002e9a:	430b      	orrs	r3, r1
 8002e9c:	61d3      	str	r3, [r2, #28]
#endif /* ADC_VER_V5_V90 */
    }

    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 8002e9e:	687b      	ldr	r3, [r7, #4]
 8002ea0:	6818      	ldr	r0, [r3, #0]
 8002ea2:	683b      	ldr	r3, [r7, #0]
 8002ea4:	6859      	ldr	r1, [r3, #4]
 8002ea6:	683b      	ldr	r3, [r7, #0]
 8002ea8:	681b      	ldr	r3, [r3, #0]
 8002eaa:	461a      	mov	r2, r3
 8002eac:	f7ff f948 	bl	8002140 <LL_ADC_REG_SetSequencerRanks>
    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated when ADC is disabled or enabled without   */
    /* conversion on going on regular group:                                    */
    /*  - Channel sampling time                                                 */
    /*  - Channel offset                                                        */
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8002eb0:	687b      	ldr	r3, [r7, #4]
 8002eb2:	681b      	ldr	r3, [r3, #0]
 8002eb4:	4618      	mov	r0, r3
 8002eb6:	f7ff fab1 	bl	800241c <LL_ADC_REG_IsConversionOngoing>
 8002eba:	62b8      	str	r0, [r7, #40]	@ 0x28
    tmp_adc_is_conversion_on_going_injected = LL_ADC_INJ_IsConversionOngoing(hadc->Instance);
 8002ebc:	687b      	ldr	r3, [r7, #4]
 8002ebe:	681b      	ldr	r3, [r3, #0]
 8002ec0:	4618      	mov	r0, r3
 8002ec2:	f7ff fabe 	bl	8002442 <LL_ADC_INJ_IsConversionOngoing>
 8002ec6:	6278      	str	r0, [r7, #36]	@ 0x24
    if ((tmp_adc_is_conversion_on_going_regular == 0UL)
 8002ec8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8002eca:	2b00      	cmp	r3, #0
 8002ecc:	f040 80b8 	bne.w	8003040 <HAL_ADC_ConfigChannel+0x248>
        && (tmp_adc_is_conversion_on_going_injected == 0UL)
 8002ed0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8002ed2:	2b00      	cmp	r3, #0
 8002ed4:	f040 80b4 	bne.w	8003040 <HAL_ADC_ConfigChannel+0x248>
       )
    {
      /* Set sampling time of the selected ADC channel */
      LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 8002ed8:	687b      	ldr	r3, [r7, #4]
 8002eda:	6818      	ldr	r0, [r3, #0]
 8002edc:	683b      	ldr	r3, [r7, #0]
 8002ede:	6819      	ldr	r1, [r3, #0]
 8002ee0:	683b      	ldr	r3, [r7, #0]
 8002ee2:	689b      	ldr	r3, [r3, #8]
 8002ee4:	461a      	mov	r2, r3
 8002ee6:	f7ff f97d 	bl	80021e4 <LL_ADC_SetChannelSamplingTime>
        tmpOffsetShifted = ADC3_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
      }
      else
#endif /* ADC_VER_V5_V90 */
      {
        tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 8002eea:	4b30      	ldr	r3, [pc, #192]	@ (8002fac <HAL_ADC_ConfigChannel+0x1b4>)
 8002eec:	681b      	ldr	r3, [r3, #0]
 8002eee:	f003 4370 	and.w	r3, r3, #4026531840	@ 0xf0000000
 8002ef2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8002ef6:	d10b      	bne.n	8002f10 <HAL_ADC_ConfigChannel+0x118>
 8002ef8:	683b      	ldr	r3, [r7, #0]
 8002efa:	695a      	ldr	r2, [r3, #20]
 8002efc:	687b      	ldr	r3, [r7, #4]
 8002efe:	681b      	ldr	r3, [r3, #0]
 8002f00:	68db      	ldr	r3, [r3, #12]
 8002f02:	089b      	lsrs	r3, r3, #2
 8002f04:	f003 0307 	and.w	r3, r3, #7
 8002f08:	005b      	lsls	r3, r3, #1
 8002f0a:	fa02 f303 	lsl.w	r3, r2, r3
 8002f0e:	e01d      	b.n	8002f4c <HAL_ADC_ConfigChannel+0x154>
 8002f10:	687b      	ldr	r3, [r7, #4]
 8002f12:	681b      	ldr	r3, [r3, #0]
 8002f14:	68db      	ldr	r3, [r3, #12]
 8002f16:	f003 0310 	and.w	r3, r3, #16
 8002f1a:	2b00      	cmp	r3, #0
 8002f1c:	d10b      	bne.n	8002f36 <HAL_ADC_ConfigChannel+0x13e>
 8002f1e:	683b      	ldr	r3, [r7, #0]
 8002f20:	695a      	ldr	r2, [r3, #20]
 8002f22:	687b      	ldr	r3, [r7, #4]
 8002f24:	681b      	ldr	r3, [r3, #0]
 8002f26:	68db      	ldr	r3, [r3, #12]
 8002f28:	089b      	lsrs	r3, r3, #2
 8002f2a:	f003 0307 	and.w	r3, r3, #7
 8002f2e:	005b      	lsls	r3, r3, #1
 8002f30:	fa02 f303 	lsl.w	r3, r2, r3
 8002f34:	e00a      	b.n	8002f4c <HAL_ADC_ConfigChannel+0x154>
 8002f36:	683b      	ldr	r3, [r7, #0]
 8002f38:	695a      	ldr	r2, [r3, #20]
 8002f3a:	687b      	ldr	r3, [r7, #4]
 8002f3c:	681b      	ldr	r3, [r3, #0]
 8002f3e:	68db      	ldr	r3, [r3, #12]
 8002f40:	089b      	lsrs	r3, r3, #2
 8002f42:	f003 0304 	and.w	r3, r3, #4
 8002f46:	005b      	lsls	r3, r3, #1
 8002f48:	fa02 f303 	lsl.w	r3, r2, r3
 8002f4c:	623b      	str	r3, [r7, #32]
      }

      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
 8002f4e:	683b      	ldr	r3, [r7, #0]
 8002f50:	691b      	ldr	r3, [r3, #16]
 8002f52:	2b04      	cmp	r3, #4
 8002f54:	d02c      	beq.n	8002fb0 <HAL_ADC_ConfigChannel+0x1b8>
      {
        /* Set ADC selected offset number */
        LL_ADC_SetOffset(hadc->Instance, sConfig->OffsetNumber, sConfig->Channel, tmpOffsetShifted);
 8002f56:	687b      	ldr	r3, [r7, #4]
 8002f58:	6818      	ldr	r0, [r3, #0]
 8002f5a:	683b      	ldr	r3, [r7, #0]
 8002f5c:	6919      	ldr	r1, [r3, #16]
 8002f5e:	683b      	ldr	r3, [r7, #0]
 8002f60:	681a      	ldr	r2, [r3, #0]
 8002f62:	6a3b      	ldr	r3, [r7, #32]
 8002f64:	f7ff f885 	bl	8002072 <LL_ADC_SetOffset>
        else
#endif /* ADC_VER_V5_V90 */
        {
          assert_param(IS_FUNCTIONAL_STATE(sConfig->OffsetSignedSaturation));
          /* Set ADC selected offset signed saturation */
          LL_ADC_SetOffsetSignedSaturation(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetSignedSaturation == ENABLE) ? LL_ADC_OFFSET_SIGNED_SATURATION_ENABLE : LL_ADC_OFFSET_SIGNED_SATURATION_DISABLE);
 8002f68:	687b      	ldr	r3, [r7, #4]
 8002f6a:	6818      	ldr	r0, [r3, #0]
 8002f6c:	683b      	ldr	r3, [r7, #0]
 8002f6e:	6919      	ldr	r1, [r3, #16]
 8002f70:	683b      	ldr	r3, [r7, #0]
 8002f72:	7e5b      	ldrb	r3, [r3, #25]
 8002f74:	2b01      	cmp	r3, #1
 8002f76:	d102      	bne.n	8002f7e <HAL_ADC_ConfigChannel+0x186>
 8002f78:	f04f 4300 	mov.w	r3, #2147483648	@ 0x80000000
 8002f7c:	e000      	b.n	8002f80 <HAL_ADC_ConfigChannel+0x188>
 8002f7e:	2300      	movs	r3, #0
 8002f80:	461a      	mov	r2, r3
 8002f82:	f7ff f8af 	bl	80020e4 <LL_ADC_SetOffsetSignedSaturation>

          assert_param(IS_FUNCTIONAL_STATE(sConfig->OffsetRightShift));
          /* Set ADC selected offset right shift */
          LL_ADC_SetDataRightShift(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetRightShift == ENABLE) ? LL_ADC_OFFSET_RSHIFT_ENABLE : LL_ADC_OFFSET_RSHIFT_DISABLE);
 8002f86:	687b      	ldr	r3, [r7, #4]
 8002f88:	6818      	ldr	r0, [r3, #0]
 8002f8a:	683b      	ldr	r3, [r7, #0]
 8002f8c:	6919      	ldr	r1, [r3, #16]
 8002f8e:	683b      	ldr	r3, [r7, #0]
 8002f90:	7e1b      	ldrb	r3, [r3, #24]
 8002f92:	2b01      	cmp	r3, #1
 8002f94:	d102      	bne.n	8002f9c <HAL_ADC_ConfigChannel+0x1a4>
 8002f96:	f44f 6300 	mov.w	r3, #2048	@ 0x800
 8002f9a:	e000      	b.n	8002f9e <HAL_ADC_ConfigChannel+0x1a6>
 8002f9c:	2300      	movs	r3, #0
 8002f9e:	461a      	mov	r2, r3
 8002fa0:	f7ff f887 	bl	80020b2 <LL_ADC_SetDataRightShift>
 8002fa4:	e04c      	b.n	8003040 <HAL_ADC_ConfigChannel+0x248>
 8002fa6:	bf00      	nop
 8002fa8:	47ff0000 	.word	0x47ff0000
 8002fac:	5c001000 	.word	0x5c001000
          }
        }
        else
#endif /* ADC_VER_V5_V90 */
        {
          if (((hadc->Instance->OFR1) & ADC_OFR1_OFFSET1_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 8002fb0:	687b      	ldr	r3, [r7, #4]
 8002fb2:	681b      	ldr	r3, [r3, #0]
 8002fb4:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8002fb6:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
 8002fba:	683b      	ldr	r3, [r7, #0]
 8002fbc:	681b      	ldr	r3, [r3, #0]
 8002fbe:	069b      	lsls	r3, r3, #26
 8002fc0:	429a      	cmp	r2, r3
 8002fc2:	d107      	bne.n	8002fd4 <HAL_ADC_ConfigChannel+0x1dc>
          {
            CLEAR_BIT(hadc->Instance->OFR1, ADC_OFR1_SSATE);
 8002fc4:	687b      	ldr	r3, [r7, #4]
 8002fc6:	681b      	ldr	r3, [r3, #0]
 8002fc8:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 8002fca:	687b      	ldr	r3, [r7, #4]
 8002fcc:	681b      	ldr	r3, [r3, #0]
 8002fce:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
 8002fd2:	661a      	str	r2, [r3, #96]	@ 0x60
          }
          if (((hadc->Instance->OFR2) & ADC_OFR2_OFFSET2_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 8002fd4:	687b      	ldr	r3, [r7, #4]
 8002fd6:	681b      	ldr	r3, [r3, #0]
 8002fd8:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8002fda:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
 8002fde:	683b      	ldr	r3, [r7, #0]
 8002fe0:	681b      	ldr	r3, [r3, #0]
 8002fe2:	069b      	lsls	r3, r3, #26
 8002fe4:	429a      	cmp	r2, r3
 8002fe6:	d107      	bne.n	8002ff8 <HAL_ADC_ConfigChannel+0x200>
          {
            CLEAR_BIT(hadc->Instance->OFR2, ADC_OFR2_SSATE);
 8002fe8:	687b      	ldr	r3, [r7, #4]
 8002fea:	681b      	ldr	r3, [r3, #0]
 8002fec:	6e5a      	ldr	r2, [r3, #100]	@ 0x64
 8002fee:	687b      	ldr	r3, [r7, #4]
 8002ff0:	681b      	ldr	r3, [r3, #0]
 8002ff2:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
 8002ff6:	665a      	str	r2, [r3, #100]	@ 0x64
          }
          if (((hadc->Instance->OFR3) & ADC_OFR3_OFFSET3_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 8002ff8:	687b      	ldr	r3, [r7, #4]
 8002ffa:	681b      	ldr	r3, [r3, #0]
 8002ffc:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8002ffe:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
 8003002:	683b      	ldr	r3, [r7, #0]
 8003004:	681b      	ldr	r3, [r3, #0]
 8003006:	069b      	lsls	r3, r3, #26
 8003008:	429a      	cmp	r2, r3
 800300a:	d107      	bne.n	800301c <HAL_ADC_ConfigChannel+0x224>
          {
            CLEAR_BIT(hadc->Instance->OFR3, ADC_OFR3_SSATE);
 800300c:	687b      	ldr	r3, [r7, #4]
 800300e:	681b      	ldr	r3, [r3, #0]
 8003010:	6e9a      	ldr	r2, [r3, #104]	@ 0x68
 8003012:	687b      	ldr	r3, [r7, #4]
 8003014:	681b      	ldr	r3, [r3, #0]
 8003016:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
 800301a:	669a      	str	r2, [r3, #104]	@ 0x68
          }
          if (((hadc->Instance->OFR4) & ADC_OFR4_OFFSET4_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 800301c:	687b      	ldr	r3, [r7, #4]
 800301e:	681b      	ldr	r3, [r3, #0]
 8003020:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8003022:	f003 42f8 	and.w	r2, r3, #2080374784	@ 0x7c000000
 8003026:	683b      	ldr	r3, [r7, #0]
 8003028:	681b      	ldr	r3, [r3, #0]
 800302a:	069b      	lsls	r3, r3, #26
 800302c:	429a      	cmp	r2, r3
 800302e:	d107      	bne.n	8003040 <HAL_ADC_ConfigChannel+0x248>
          {
            CLEAR_BIT(hadc->Instance->OFR4, ADC_OFR4_SSATE);
 8003030:	687b      	ldr	r3, [r7, #4]
 8003032:	681b      	ldr	r3, [r3, #0]
 8003034:	6eda      	ldr	r2, [r3, #108]	@ 0x6c
 8003036:	687b      	ldr	r3, [r7, #4]
 8003038:	681b      	ldr	r3, [r3, #0]
 800303a:	f022 4200 	bic.w	r2, r2, #2147483648	@ 0x80000000
 800303e:	66da      	str	r2, [r3, #108]	@ 0x6c

    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    /*  - Internal measurement channels: Vbat/VrefInt/TempSensor                */
    if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8003040:	687b      	ldr	r3, [r7, #4]
 8003042:	681b      	ldr	r3, [r3, #0]
 8003044:	4618      	mov	r0, r3
 8003046:	f7ff f9af 	bl	80023a8 <LL_ADC_IsEnabled>
 800304a:	4603      	mov	r3, r0
 800304c:	2b00      	cmp	r3, #0
 800304e:	f040 81aa 	bne.w	80033a6 <HAL_ADC_ConfigChannel+0x5ae>
    {
      /* Set mode single-ended or differential input of the selected ADC channel */
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 8003052:	687b      	ldr	r3, [r7, #4]
 8003054:	6818      	ldr	r0, [r3, #0]
 8003056:	683b      	ldr	r3, [r7, #0]
 8003058:	6819      	ldr	r1, [r3, #0]
 800305a:	683b      	ldr	r3, [r7, #0]
 800305c:	68db      	ldr	r3, [r3, #12]
 800305e:	461a      	mov	r2, r3
 8003060:	f7ff f8ec 	bl	800223c <LL_ADC_SetChannelSingleDiff>

      /* Configuration of differential mode */
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 8003064:	683b      	ldr	r3, [r7, #0]
 8003066:	68db      	ldr	r3, [r3, #12]
 8003068:	4a87      	ldr	r2, [pc, #540]	@ (8003288 <HAL_ADC_ConfigChannel+0x490>)
 800306a:	4293      	cmp	r3, r2
 800306c:	f040 809a 	bne.w	80031a4 <HAL_ADC_ConfigChannel+0x3ac>
      {
        /* Set ADC channel preselection of corresponding negative channel */
        LL_ADC_SetChannelPreselection(hadc->Instance, ADC_CHANNEL_DIFF_NEG_INPUT(hadc, sConfig->Channel));
 8003070:	687b      	ldr	r3, [r7, #4]
 8003072:	681a      	ldr	r2, [r3, #0]
 8003074:	687b      	ldr	r3, [r7, #4]
 8003076:	681b      	ldr	r3, [r3, #0]
 8003078:	4984      	ldr	r1, [pc, #528]	@ (800328c <HAL_ADC_ConfigChannel+0x494>)
 800307a:	428b      	cmp	r3, r1
 800307c:	d147      	bne.n	800310e <HAL_ADC_ConfigChannel+0x316>
 800307e:	683b      	ldr	r3, [r7, #0]
 8003080:	681b      	ldr	r3, [r3, #0]
 8003082:	4983      	ldr	r1, [pc, #524]	@ (8003290 <HAL_ADC_ConfigChannel+0x498>)
 8003084:	428b      	cmp	r3, r1
 8003086:	d040      	beq.n	800310a <HAL_ADC_ConfigChannel+0x312>
 8003088:	683b      	ldr	r3, [r7, #0]
 800308a:	681b      	ldr	r3, [r3, #0]
 800308c:	4981      	ldr	r1, [pc, #516]	@ (8003294 <HAL_ADC_ConfigChannel+0x49c>)
 800308e:	428b      	cmp	r3, r1
 8003090:	d039      	beq.n	8003106 <HAL_ADC_ConfigChannel+0x30e>
 8003092:	683b      	ldr	r3, [r7, #0]
 8003094:	681b      	ldr	r3, [r3, #0]
 8003096:	4980      	ldr	r1, [pc, #512]	@ (8003298 <HAL_ADC_ConfigChannel+0x4a0>)
 8003098:	428b      	cmp	r3, r1
 800309a:	d032      	beq.n	8003102 <HAL_ADC_ConfigChannel+0x30a>
 800309c:	683b      	ldr	r3, [r7, #0]
 800309e:	681b      	ldr	r3, [r3, #0]
 80030a0:	497e      	ldr	r1, [pc, #504]	@ (800329c <HAL_ADC_ConfigChannel+0x4a4>)
 80030a2:	428b      	cmp	r3, r1
 80030a4:	d02b      	beq.n	80030fe <HAL_ADC_ConfigChannel+0x306>
 80030a6:	683b      	ldr	r3, [r7, #0]
 80030a8:	681b      	ldr	r3, [r3, #0]
 80030aa:	497d      	ldr	r1, [pc, #500]	@ (80032a0 <HAL_ADC_ConfigChannel+0x4a8>)
 80030ac:	428b      	cmp	r3, r1
 80030ae:	d024      	beq.n	80030fa <HAL_ADC_ConfigChannel+0x302>
 80030b0:	683b      	ldr	r3, [r7, #0]
 80030b2:	681b      	ldr	r3, [r3, #0]
 80030b4:	497b      	ldr	r1, [pc, #492]	@ (80032a4 <HAL_ADC_ConfigChannel+0x4ac>)
 80030b6:	428b      	cmp	r3, r1
 80030b8:	d01d      	beq.n	80030f6 <HAL_ADC_ConfigChannel+0x2fe>
 80030ba:	683b      	ldr	r3, [r7, #0]
 80030bc:	681b      	ldr	r3, [r3, #0]
 80030be:	497a      	ldr	r1, [pc, #488]	@ (80032a8 <HAL_ADC_ConfigChannel+0x4b0>)
 80030c0:	428b      	cmp	r3, r1
 80030c2:	d016      	beq.n	80030f2 <HAL_ADC_ConfigChannel+0x2fa>
 80030c4:	683b      	ldr	r3, [r7, #0]
 80030c6:	681b      	ldr	r3, [r3, #0]
 80030c8:	4978      	ldr	r1, [pc, #480]	@ (80032ac <HAL_ADC_ConfigChannel+0x4b4>)
 80030ca:	428b      	cmp	r3, r1
 80030cc:	d00f      	beq.n	80030ee <HAL_ADC_ConfigChannel+0x2f6>
 80030ce:	683b      	ldr	r3, [r7, #0]
 80030d0:	681b      	ldr	r3, [r3, #0]
 80030d2:	4977      	ldr	r1, [pc, #476]	@ (80032b0 <HAL_ADC_ConfigChannel+0x4b8>)
 80030d4:	428b      	cmp	r3, r1
 80030d6:	d008      	beq.n	80030ea <HAL_ADC_ConfigChannel+0x2f2>
 80030d8:	683b      	ldr	r3, [r7, #0]
 80030da:	681b      	ldr	r3, [r3, #0]
 80030dc:	4975      	ldr	r1, [pc, #468]	@ (80032b4 <HAL_ADC_ConfigChannel+0x4bc>)
 80030de:	428b      	cmp	r3, r1
 80030e0:	d101      	bne.n	80030e6 <HAL_ADC_ConfigChannel+0x2ee>
 80030e2:	4b75      	ldr	r3, [pc, #468]	@ (80032b8 <HAL_ADC_ConfigChannel+0x4c0>)
 80030e4:	e05a      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 80030e6:	2300      	movs	r3, #0
 80030e8:	e058      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 80030ea:	4b74      	ldr	r3, [pc, #464]	@ (80032bc <HAL_ADC_ConfigChannel+0x4c4>)
 80030ec:	e056      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 80030ee:	4b74      	ldr	r3, [pc, #464]	@ (80032c0 <HAL_ADC_ConfigChannel+0x4c8>)
 80030f0:	e054      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 80030f2:	4b6e      	ldr	r3, [pc, #440]	@ (80032ac <HAL_ADC_ConfigChannel+0x4b4>)
 80030f4:	e052      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 80030f6:	4b6c      	ldr	r3, [pc, #432]	@ (80032a8 <HAL_ADC_ConfigChannel+0x4b0>)
 80030f8:	e050      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 80030fa:	4b72      	ldr	r3, [pc, #456]	@ (80032c4 <HAL_ADC_ConfigChannel+0x4cc>)
 80030fc:	e04e      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 80030fe:	4b72      	ldr	r3, [pc, #456]	@ (80032c8 <HAL_ADC_ConfigChannel+0x4d0>)
 8003100:	e04c      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 8003102:	4b72      	ldr	r3, [pc, #456]	@ (80032cc <HAL_ADC_ConfigChannel+0x4d4>)
 8003104:	e04a      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 8003106:	4b72      	ldr	r3, [pc, #456]	@ (80032d0 <HAL_ADC_ConfigChannel+0x4d8>)
 8003108:	e048      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 800310a:	2301      	movs	r3, #1
 800310c:	e046      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 800310e:	687b      	ldr	r3, [r7, #4]
 8003110:	681b      	ldr	r3, [r3, #0]
 8003112:	4970      	ldr	r1, [pc, #448]	@ (80032d4 <HAL_ADC_ConfigChannel+0x4dc>)
 8003114:	428b      	cmp	r3, r1
 8003116:	d140      	bne.n	800319a <HAL_ADC_ConfigChannel+0x3a2>
 8003118:	683b      	ldr	r3, [r7, #0]
 800311a:	681b      	ldr	r3, [r3, #0]
 800311c:	495c      	ldr	r1, [pc, #368]	@ (8003290 <HAL_ADC_ConfigChannel+0x498>)
 800311e:	428b      	cmp	r3, r1
 8003120:	d039      	beq.n	8003196 <HAL_ADC_ConfigChannel+0x39e>
 8003122:	683b      	ldr	r3, [r7, #0]
 8003124:	681b      	ldr	r3, [r3, #0]
 8003126:	495b      	ldr	r1, [pc, #364]	@ (8003294 <HAL_ADC_ConfigChannel+0x49c>)
 8003128:	428b      	cmp	r3, r1
 800312a:	d032      	beq.n	8003192 <HAL_ADC_ConfigChannel+0x39a>
 800312c:	683b      	ldr	r3, [r7, #0]
 800312e:	681b      	ldr	r3, [r3, #0]
 8003130:	4959      	ldr	r1, [pc, #356]	@ (8003298 <HAL_ADC_ConfigChannel+0x4a0>)
 8003132:	428b      	cmp	r3, r1
 8003134:	d02b      	beq.n	800318e <HAL_ADC_ConfigChannel+0x396>
 8003136:	683b      	ldr	r3, [r7, #0]
 8003138:	681b      	ldr	r3, [r3, #0]
 800313a:	4958      	ldr	r1, [pc, #352]	@ (800329c <HAL_ADC_ConfigChannel+0x4a4>)
 800313c:	428b      	cmp	r3, r1
 800313e:	d024      	beq.n	800318a <HAL_ADC_ConfigChannel+0x392>
 8003140:	683b      	ldr	r3, [r7, #0]
 8003142:	681b      	ldr	r3, [r3, #0]
 8003144:	4956      	ldr	r1, [pc, #344]	@ (80032a0 <HAL_ADC_ConfigChannel+0x4a8>)
 8003146:	428b      	cmp	r3, r1
 8003148:	d01d      	beq.n	8003186 <HAL_ADC_ConfigChannel+0x38e>
 800314a:	683b      	ldr	r3, [r7, #0]
 800314c:	681b      	ldr	r3, [r3, #0]
 800314e:	4955      	ldr	r1, [pc, #340]	@ (80032a4 <HAL_ADC_ConfigChannel+0x4ac>)
 8003150:	428b      	cmp	r3, r1
 8003152:	d016      	beq.n	8003182 <HAL_ADC_ConfigChannel+0x38a>
 8003154:	683b      	ldr	r3, [r7, #0]
 8003156:	681b      	ldr	r3, [r3, #0]
 8003158:	4953      	ldr	r1, [pc, #332]	@ (80032a8 <HAL_ADC_ConfigChannel+0x4b0>)
 800315a:	428b      	cmp	r3, r1
 800315c:	d00f      	beq.n	800317e <HAL_ADC_ConfigChannel+0x386>
 800315e:	683b      	ldr	r3, [r7, #0]
 8003160:	681b      	ldr	r3, [r3, #0]
 8003162:	4952      	ldr	r1, [pc, #328]	@ (80032ac <HAL_ADC_ConfigChannel+0x4b4>)
 8003164:	428b      	cmp	r3, r1
 8003166:	d008      	beq.n	800317a <HAL_ADC_ConfigChannel+0x382>
 8003168:	683b      	ldr	r3, [r7, #0]
 800316a:	681b      	ldr	r3, [r3, #0]
 800316c:	4951      	ldr	r1, [pc, #324]	@ (80032b4 <HAL_ADC_ConfigChannel+0x4bc>)
 800316e:	428b      	cmp	r3, r1
 8003170:	d101      	bne.n	8003176 <HAL_ADC_ConfigChannel+0x37e>
 8003172:	4b51      	ldr	r3, [pc, #324]	@ (80032b8 <HAL_ADC_ConfigChannel+0x4c0>)
 8003174:	e012      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 8003176:	2300      	movs	r3, #0
 8003178:	e010      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 800317a:	4b51      	ldr	r3, [pc, #324]	@ (80032c0 <HAL_ADC_ConfigChannel+0x4c8>)
 800317c:	e00e      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 800317e:	4b4b      	ldr	r3, [pc, #300]	@ (80032ac <HAL_ADC_ConfigChannel+0x4b4>)
 8003180:	e00c      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 8003182:	4b49      	ldr	r3, [pc, #292]	@ (80032a8 <HAL_ADC_ConfigChannel+0x4b0>)
 8003184:	e00a      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 8003186:	4b4f      	ldr	r3, [pc, #316]	@ (80032c4 <HAL_ADC_ConfigChannel+0x4cc>)
 8003188:	e008      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 800318a:	4b4f      	ldr	r3, [pc, #316]	@ (80032c8 <HAL_ADC_ConfigChannel+0x4d0>)
 800318c:	e006      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 800318e:	4b4f      	ldr	r3, [pc, #316]	@ (80032cc <HAL_ADC_ConfigChannel+0x4d4>)
 8003190:	e004      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 8003192:	4b4f      	ldr	r3, [pc, #316]	@ (80032d0 <HAL_ADC_ConfigChannel+0x4d8>)
 8003194:	e002      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 8003196:	2301      	movs	r3, #1
 8003198:	e000      	b.n	800319c <HAL_ADC_ConfigChannel+0x3a4>
 800319a:	2300      	movs	r3, #0
 800319c:	4619      	mov	r1, r3
 800319e:	4610      	mov	r0, r2
 80031a0:	f7fe ff34 	bl	800200c <LL_ADC_SetChannelPreselection>
      /* If internal channel selected, enable dedicated internal buffers and    */
      /* paths.                                                                 */
      /* Note: these internal measurement paths can be disabled using           */
      /* HAL_ADC_DeInit().                                                      */

      if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 80031a4:	683b      	ldr	r3, [r7, #0]
 80031a6:	681b      	ldr	r3, [r3, #0]
 80031a8:	2b00      	cmp	r3, #0
 80031aa:	f280 80fc 	bge.w	80033a6 <HAL_ADC_ConfigChannel+0x5ae>
      {
        /* Configuration of common ADC parameters                                 */

        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 80031ae:	687b      	ldr	r3, [r7, #4]
 80031b0:	681b      	ldr	r3, [r3, #0]
 80031b2:	4a36      	ldr	r2, [pc, #216]	@ (800328c <HAL_ADC_ConfigChannel+0x494>)
 80031b4:	4293      	cmp	r3, r2
 80031b6:	d004      	beq.n	80031c2 <HAL_ADC_ConfigChannel+0x3ca>
 80031b8:	687b      	ldr	r3, [r7, #4]
 80031ba:	681b      	ldr	r3, [r3, #0]
 80031bc:	4a45      	ldr	r2, [pc, #276]	@ (80032d4 <HAL_ADC_ConfigChannel+0x4dc>)
 80031be:	4293      	cmp	r3, r2
 80031c0:	d101      	bne.n	80031c6 <HAL_ADC_ConfigChannel+0x3ce>
 80031c2:	4b45      	ldr	r3, [pc, #276]	@ (80032d8 <HAL_ADC_ConfigChannel+0x4e0>)
 80031c4:	e000      	b.n	80031c8 <HAL_ADC_ConfigChannel+0x3d0>
 80031c6:	4b45      	ldr	r3, [pc, #276]	@ (80032dc <HAL_ADC_ConfigChannel+0x4e4>)
 80031c8:	4618      	mov	r0, r3
 80031ca:	f7fe ff11 	bl	8001ff0 <LL_ADC_GetCommonPathInternalCh>
 80031ce:	61f8      	str	r0, [r7, #28]

        /* Software is allowed to change common parameters only when all ADCs   */
        /* of the common group are disabled.                                    */
        if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 80031d0:	687b      	ldr	r3, [r7, #4]
 80031d2:	681b      	ldr	r3, [r3, #0]
 80031d4:	4a2d      	ldr	r2, [pc, #180]	@ (800328c <HAL_ADC_ConfigChannel+0x494>)
 80031d6:	4293      	cmp	r3, r2
 80031d8:	d004      	beq.n	80031e4 <HAL_ADC_ConfigChannel+0x3ec>
 80031da:	687b      	ldr	r3, [r7, #4]
 80031dc:	681b      	ldr	r3, [r3, #0]
 80031de:	4a3d      	ldr	r2, [pc, #244]	@ (80032d4 <HAL_ADC_ConfigChannel+0x4dc>)
 80031e0:	4293      	cmp	r3, r2
 80031e2:	d10e      	bne.n	8003202 <HAL_ADC_ConfigChannel+0x40a>
 80031e4:	4829      	ldr	r0, [pc, #164]	@ (800328c <HAL_ADC_ConfigChannel+0x494>)
 80031e6:	f7ff f8df 	bl	80023a8 <LL_ADC_IsEnabled>
 80031ea:	4604      	mov	r4, r0
 80031ec:	4839      	ldr	r0, [pc, #228]	@ (80032d4 <HAL_ADC_ConfigChannel+0x4dc>)
 80031ee:	f7ff f8db 	bl	80023a8 <LL_ADC_IsEnabled>
 80031f2:	4603      	mov	r3, r0
 80031f4:	4323      	orrs	r3, r4
 80031f6:	2b00      	cmp	r3, #0
 80031f8:	bf0c      	ite	eq
 80031fa:	2301      	moveq	r3, #1
 80031fc:	2300      	movne	r3, #0
 80031fe:	b2db      	uxtb	r3, r3
 8003200:	e008      	b.n	8003214 <HAL_ADC_ConfigChannel+0x41c>
 8003202:	4837      	ldr	r0, [pc, #220]	@ (80032e0 <HAL_ADC_ConfigChannel+0x4e8>)
 8003204:	f7ff f8d0 	bl	80023a8 <LL_ADC_IsEnabled>
 8003208:	4603      	mov	r3, r0
 800320a:	2b00      	cmp	r3, #0
 800320c:	bf0c      	ite	eq
 800320e:	2301      	moveq	r3, #1
 8003210:	2300      	movne	r3, #0
 8003212:	b2db      	uxtb	r3, r3
 8003214:	2b00      	cmp	r3, #0
 8003216:	f000 80b3 	beq.w	8003380 <HAL_ADC_ConfigChannel+0x588>
        {
          /* If the requested internal measurement path has already been enabled, */
          /* bypass the configuration processing.                                 */
          if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 800321a:	683b      	ldr	r3, [r7, #0]
 800321c:	681b      	ldr	r3, [r3, #0]
 800321e:	4a31      	ldr	r2, [pc, #196]	@ (80032e4 <HAL_ADC_ConfigChannel+0x4ec>)
 8003220:	4293      	cmp	r3, r2
 8003222:	d165      	bne.n	80032f0 <HAL_ADC_ConfigChannel+0x4f8>
 8003224:	69fb      	ldr	r3, [r7, #28]
 8003226:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
 800322a:	2b00      	cmp	r3, #0
 800322c:	d160      	bne.n	80032f0 <HAL_ADC_ConfigChannel+0x4f8>
          {
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 800322e:	687b      	ldr	r3, [r7, #4]
 8003230:	681b      	ldr	r3, [r3, #0]
 8003232:	4a2b      	ldr	r2, [pc, #172]	@ (80032e0 <HAL_ADC_ConfigChannel+0x4e8>)
 8003234:	4293      	cmp	r3, r2
 8003236:	f040 80b6 	bne.w	80033a6 <HAL_ADC_ConfigChannel+0x5ae>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_TEMPSENSOR | tmp_config_internal_channel);
 800323a:	687b      	ldr	r3, [r7, #4]
 800323c:	681b      	ldr	r3, [r3, #0]
 800323e:	4a13      	ldr	r2, [pc, #76]	@ (800328c <HAL_ADC_ConfigChannel+0x494>)
 8003240:	4293      	cmp	r3, r2
 8003242:	d004      	beq.n	800324e <HAL_ADC_ConfigChannel+0x456>
 8003244:	687b      	ldr	r3, [r7, #4]
 8003246:	681b      	ldr	r3, [r3, #0]
 8003248:	4a22      	ldr	r2, [pc, #136]	@ (80032d4 <HAL_ADC_ConfigChannel+0x4dc>)
 800324a:	4293      	cmp	r3, r2
 800324c:	d101      	bne.n	8003252 <HAL_ADC_ConfigChannel+0x45a>
 800324e:	4a22      	ldr	r2, [pc, #136]	@ (80032d8 <HAL_ADC_ConfigChannel+0x4e0>)
 8003250:	e000      	b.n	8003254 <HAL_ADC_ConfigChannel+0x45c>
 8003252:	4a22      	ldr	r2, [pc, #136]	@ (80032dc <HAL_ADC_ConfigChannel+0x4e4>)
 8003254:	69fb      	ldr	r3, [r7, #28]
 8003256:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 800325a:	4619      	mov	r1, r3
 800325c:	4610      	mov	r0, r2
 800325e:	f7fe feb4 	bl	8001fca <LL_ADC_SetCommonPathInternalCh>
              /* Delay for temperature sensor stabilization time */
              /* Wait loop initialization and execution */
              /* Note: Variable divided by 2 to compensate partially              */
              /*       CPU processing cycles, scaling in us split to not          */
              /*       exceed 32 bits register capacity and handle low frequency. */
              wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * ((SystemCoreClock / (100000UL * 2UL)) + 1UL));
 8003262:	4b21      	ldr	r3, [pc, #132]	@ (80032e8 <HAL_ADC_ConfigChannel+0x4f0>)
 8003264:	681b      	ldr	r3, [r3, #0]
 8003266:	099b      	lsrs	r3, r3, #6
 8003268:	4a20      	ldr	r2, [pc, #128]	@ (80032ec <HAL_ADC_ConfigChannel+0x4f4>)
 800326a:	fba2 2303 	umull	r2, r3, r2, r3
 800326e:	099b      	lsrs	r3, r3, #6
 8003270:	3301      	adds	r3, #1
 8003272:	005b      	lsls	r3, r3, #1
 8003274:	60fb      	str	r3, [r7, #12]
              while (wait_loop_index != 0UL)
 8003276:	e002      	b.n	800327e <HAL_ADC_ConfigChannel+0x486>
              {
                wait_loop_index--;
 8003278:	68fb      	ldr	r3, [r7, #12]
 800327a:	3b01      	subs	r3, #1
 800327c:	60fb      	str	r3, [r7, #12]
              while (wait_loop_index != 0UL)
 800327e:	68fb      	ldr	r3, [r7, #12]
 8003280:	2b00      	cmp	r3, #0
 8003282:	d1f9      	bne.n	8003278 <HAL_ADC_ConfigChannel+0x480>
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 8003284:	e08f      	b.n	80033a6 <HAL_ADC_ConfigChannel+0x5ae>
 8003286:	bf00      	nop
 8003288:	47ff0000 	.word	0x47ff0000
 800328c:	40022000 	.word	0x40022000
 8003290:	04300002 	.word	0x04300002
 8003294:	08600004 	.word	0x08600004
 8003298:	0c900008 	.word	0x0c900008
 800329c:	10c00010 	.word	0x10c00010
 80032a0:	14f00020 	.word	0x14f00020
 80032a4:	2a000400 	.word	0x2a000400
 80032a8:	2e300800 	.word	0x2e300800
 80032ac:	32601000 	.word	0x32601000
 80032b0:	43210000 	.word	0x43210000
 80032b4:	4b840000 	.word	0x4b840000
 80032b8:	4fb80000 	.word	0x4fb80000
 80032bc:	47520000 	.word	0x47520000
 80032c0:	36902000 	.word	0x36902000
 80032c4:	25b00200 	.word	0x25b00200
 80032c8:	21800100 	.word	0x21800100
 80032cc:	1d500080 	.word	0x1d500080
 80032d0:	19200040 	.word	0x19200040
 80032d4:	40022100 	.word	0x40022100
 80032d8:	40022300 	.word	0x40022300
 80032dc:	58026300 	.word	0x58026300
 80032e0:	58026000 	.word	0x58026000
 80032e4:	cb840000 	.word	0xcb840000
 80032e8:	24000000 	.word	0x24000000
 80032ec:	053e2d63 	.word	0x053e2d63
              }
            }
          }
          else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 80032f0:	683b      	ldr	r3, [r7, #0]
 80032f2:	681b      	ldr	r3, [r3, #0]
 80032f4:	4a31      	ldr	r2, [pc, #196]	@ (80033bc <HAL_ADC_ConfigChannel+0x5c4>)
 80032f6:	4293      	cmp	r3, r2
 80032f8:	d11e      	bne.n	8003338 <HAL_ADC_ConfigChannel+0x540>
 80032fa:	69fb      	ldr	r3, [r7, #28]
 80032fc:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 8003300:	2b00      	cmp	r3, #0
 8003302:	d119      	bne.n	8003338 <HAL_ADC_ConfigChannel+0x540>
          {
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 8003304:	687b      	ldr	r3, [r7, #4]
 8003306:	681b      	ldr	r3, [r3, #0]
 8003308:	4a2d      	ldr	r2, [pc, #180]	@ (80033c0 <HAL_ADC_ConfigChannel+0x5c8>)
 800330a:	4293      	cmp	r3, r2
 800330c:	d14b      	bne.n	80033a6 <HAL_ADC_ConfigChannel+0x5ae>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
 800330e:	687b      	ldr	r3, [r7, #4]
 8003310:	681b      	ldr	r3, [r3, #0]
 8003312:	4a2c      	ldr	r2, [pc, #176]	@ (80033c4 <HAL_ADC_ConfigChannel+0x5cc>)
 8003314:	4293      	cmp	r3, r2
 8003316:	d004      	beq.n	8003322 <HAL_ADC_ConfigChannel+0x52a>
 8003318:	687b      	ldr	r3, [r7, #4]
 800331a:	681b      	ldr	r3, [r3, #0]
 800331c:	4a2a      	ldr	r2, [pc, #168]	@ (80033c8 <HAL_ADC_ConfigChannel+0x5d0>)
 800331e:	4293      	cmp	r3, r2
 8003320:	d101      	bne.n	8003326 <HAL_ADC_ConfigChannel+0x52e>
 8003322:	4a2a      	ldr	r2, [pc, #168]	@ (80033cc <HAL_ADC_ConfigChannel+0x5d4>)
 8003324:	e000      	b.n	8003328 <HAL_ADC_ConfigChannel+0x530>
 8003326:	4a2a      	ldr	r2, [pc, #168]	@ (80033d0 <HAL_ADC_ConfigChannel+0x5d8>)
 8003328:	69fb      	ldr	r3, [r7, #28]
 800332a:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 800332e:	4619      	mov	r1, r3
 8003330:	4610      	mov	r0, r2
 8003332:	f7fe fe4a 	bl	8001fca <LL_ADC_SetCommonPathInternalCh>
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 8003336:	e036      	b.n	80033a6 <HAL_ADC_ConfigChannel+0x5ae>
            }
          }
          else if ((sConfig->Channel == ADC_CHANNEL_VREFINT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 8003338:	683b      	ldr	r3, [r7, #0]
 800333a:	681b      	ldr	r3, [r3, #0]
 800333c:	4a25      	ldr	r2, [pc, #148]	@ (80033d4 <HAL_ADC_ConfigChannel+0x5dc>)
 800333e:	4293      	cmp	r3, r2
 8003340:	d131      	bne.n	80033a6 <HAL_ADC_ConfigChannel+0x5ae>
 8003342:	69fb      	ldr	r3, [r7, #28]
 8003344:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8003348:	2b00      	cmp	r3, #0
 800334a:	d12c      	bne.n	80033a6 <HAL_ADC_ConfigChannel+0x5ae>
          {
            if (ADC_VREFINT_INSTANCE(hadc))
 800334c:	687b      	ldr	r3, [r7, #4]
 800334e:	681b      	ldr	r3, [r3, #0]
 8003350:	4a1b      	ldr	r2, [pc, #108]	@ (80033c0 <HAL_ADC_ConfigChannel+0x5c8>)
 8003352:	4293      	cmp	r3, r2
 8003354:	d127      	bne.n	80033a6 <HAL_ADC_ConfigChannel+0x5ae>
            {
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_internal_channel);
 8003356:	687b      	ldr	r3, [r7, #4]
 8003358:	681b      	ldr	r3, [r3, #0]
 800335a:	4a1a      	ldr	r2, [pc, #104]	@ (80033c4 <HAL_ADC_ConfigChannel+0x5cc>)
 800335c:	4293      	cmp	r3, r2
 800335e:	d004      	beq.n	800336a <HAL_ADC_ConfigChannel+0x572>
 8003360:	687b      	ldr	r3, [r7, #4]
 8003362:	681b      	ldr	r3, [r3, #0]
 8003364:	4a18      	ldr	r2, [pc, #96]	@ (80033c8 <HAL_ADC_ConfigChannel+0x5d0>)
 8003366:	4293      	cmp	r3, r2
 8003368:	d101      	bne.n	800336e <HAL_ADC_ConfigChannel+0x576>
 800336a:	4a18      	ldr	r2, [pc, #96]	@ (80033cc <HAL_ADC_ConfigChannel+0x5d4>)
 800336c:	e000      	b.n	8003370 <HAL_ADC_ConfigChannel+0x578>
 800336e:	4a18      	ldr	r2, [pc, #96]	@ (80033d0 <HAL_ADC_ConfigChannel+0x5d8>)
 8003370:	69fb      	ldr	r3, [r7, #28]
 8003372:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 8003376:	4619      	mov	r1, r3
 8003378:	4610      	mov	r0, r2
 800337a:	f7fe fe26 	bl	8001fca <LL_ADC_SetCommonPathInternalCh>
 800337e:	e012      	b.n	80033a6 <HAL_ADC_ConfigChannel+0x5ae>
        /* enabled and other ADC of the common group are enabled, internal      */
        /* measurement paths cannot be enabled.                                 */
        else
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8003380:	687b      	ldr	r3, [r7, #4]
 8003382:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003384:	f043 0220 	orr.w	r2, r3, #32
 8003388:	687b      	ldr	r3, [r7, #4]
 800338a:	655a      	str	r2, [r3, #84]	@ 0x54

          tmp_hal_status = HAL_ERROR;
 800338c:	2301      	movs	r3, #1
 800338e:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
 8003392:	e008      	b.n	80033a6 <HAL_ADC_ConfigChannel+0x5ae>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8003394:	687b      	ldr	r3, [r7, #4]
 8003396:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003398:	f043 0220 	orr.w	r2, r3, #32
 800339c:	687b      	ldr	r3, [r7, #4]
 800339e:	655a      	str	r2, [r3, #84]	@ 0x54

    tmp_hal_status = HAL_ERROR;
 80033a0:	2301      	movs	r3, #1
 80033a2:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 80033a6:	687b      	ldr	r3, [r7, #4]
 80033a8:	2200      	movs	r2, #0
 80033aa:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

  /* Return function status */
  return tmp_hal_status;
 80033ae:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
}
 80033b2:	4618      	mov	r0, r3
 80033b4:	3734      	adds	r7, #52	@ 0x34
 80033b6:	46bd      	mov	sp, r7
 80033b8:	bd90      	pop	{r4, r7, pc}
 80033ba:	bf00      	nop
 80033bc:	c7520000 	.word	0xc7520000
 80033c0:	58026000 	.word	0x58026000
 80033c4:	40022000 	.word	0x40022000
 80033c8:	40022100 	.word	0x40022100
 80033cc:	40022300 	.word	0x40022300
 80033d0:	58026300 	.word	0x58026300
 80033d4:	cfb80000 	.word	0xcfb80000

080033d8 <ADC_Enable>:
  *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef *hadc)
{
 80033d8:	b580      	push	{r7, lr}
 80033da:	b084      	sub	sp, #16
 80033dc:	af00      	add	r7, sp, #0
 80033de:	6078      	str	r0, [r7, #4]

  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 80033e0:	687b      	ldr	r3, [r7, #4]
 80033e2:	681b      	ldr	r3, [r3, #0]
 80033e4:	4618      	mov	r0, r3
 80033e6:	f7fe ffdf 	bl	80023a8 <LL_ADC_IsEnabled>
 80033ea:	4603      	mov	r3, r0
 80033ec:	2b00      	cmp	r3, #0
 80033ee:	d16e      	bne.n	80034ce <ADC_Enable+0xf6>
  {
    /* Check if conditions to enable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_JADSTP | ADC_CR_ADSTP | ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
 80033f0:	687b      	ldr	r3, [r7, #4]
 80033f2:	681b      	ldr	r3, [r3, #0]
 80033f4:	689a      	ldr	r2, [r3, #8]
 80033f6:	4b38      	ldr	r3, [pc, #224]	@ (80034d8 <ADC_Enable+0x100>)
 80033f8:	4013      	ands	r3, r2
 80033fa:	2b00      	cmp	r3, #0
 80033fc:	d00d      	beq.n	800341a <ADC_Enable+0x42>
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80033fe:	687b      	ldr	r3, [r7, #4]
 8003400:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003402:	f043 0210 	orr.w	r2, r3, #16
 8003406:	687b      	ldr	r3, [r7, #4]
 8003408:	655a      	str	r2, [r3, #84]	@ 0x54

      /* Set ADC error code to ADC peripheral internal error */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800340a:	687b      	ldr	r3, [r7, #4]
 800340c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800340e:	f043 0201 	orr.w	r2, r3, #1
 8003412:	687b      	ldr	r3, [r7, #4]
 8003414:	659a      	str	r2, [r3, #88]	@ 0x58

      return HAL_ERROR;
 8003416:	2301      	movs	r3, #1
 8003418:	e05a      	b.n	80034d0 <ADC_Enable+0xf8>
    }

    /* Enable the ADC peripheral */
    LL_ADC_Enable(hadc->Instance);
 800341a:	687b      	ldr	r3, [r7, #4]
 800341c:	681b      	ldr	r3, [r3, #0]
 800341e:	4618      	mov	r0, r3
 8003420:	f7fe ff9a 	bl	8002358 <LL_ADC_Enable>

    /* Wait for ADC effectively enabled */
    tickstart = HAL_GetTick();
 8003424:	f7fe fda6 	bl	8001f74 <HAL_GetTick>
 8003428:	60f8      	str	r0, [r7, #12]

    /* Poll for ADC ready flag raised except case of multimode enabled
       and ADC slave selected. */
    uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 800342a:	687b      	ldr	r3, [r7, #4]
 800342c:	681b      	ldr	r3, [r3, #0]
 800342e:	4a2b      	ldr	r2, [pc, #172]	@ (80034dc <ADC_Enable+0x104>)
 8003430:	4293      	cmp	r3, r2
 8003432:	d004      	beq.n	800343e <ADC_Enable+0x66>
 8003434:	687b      	ldr	r3, [r7, #4]
 8003436:	681b      	ldr	r3, [r3, #0]
 8003438:	4a29      	ldr	r2, [pc, #164]	@ (80034e0 <ADC_Enable+0x108>)
 800343a:	4293      	cmp	r3, r2
 800343c:	d101      	bne.n	8003442 <ADC_Enable+0x6a>
 800343e:	4b29      	ldr	r3, [pc, #164]	@ (80034e4 <ADC_Enable+0x10c>)
 8003440:	e000      	b.n	8003444 <ADC_Enable+0x6c>
 8003442:	4b29      	ldr	r3, [pc, #164]	@ (80034e8 <ADC_Enable+0x110>)
 8003444:	4618      	mov	r0, r3
 8003446:	f7fe ff1d 	bl	8002284 <LL_ADC_GetMultimode>
 800344a:	60b8      	str	r0, [r7, #8]
    if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 800344c:	687b      	ldr	r3, [r7, #4]
 800344e:	681b      	ldr	r3, [r3, #0]
 8003450:	4a23      	ldr	r2, [pc, #140]	@ (80034e0 <ADC_Enable+0x108>)
 8003452:	4293      	cmp	r3, r2
 8003454:	d002      	beq.n	800345c <ADC_Enable+0x84>
 8003456:	687b      	ldr	r3, [r7, #4]
 8003458:	681b      	ldr	r3, [r3, #0]
 800345a:	e000      	b.n	800345e <ADC_Enable+0x86>
 800345c:	4b1f      	ldr	r3, [pc, #124]	@ (80034dc <ADC_Enable+0x104>)
 800345e:	687a      	ldr	r2, [r7, #4]
 8003460:	6812      	ldr	r2, [r2, #0]
 8003462:	4293      	cmp	r3, r2
 8003464:	d02c      	beq.n	80034c0 <ADC_Enable+0xe8>
        || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8003466:	68bb      	ldr	r3, [r7, #8]
 8003468:	2b00      	cmp	r3, #0
 800346a:	d130      	bne.n	80034ce <ADC_Enable+0xf6>
       )
    {
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 800346c:	e028      	b.n	80034c0 <ADC_Enable+0xe8>
            The workaround is to continue setting ADEN until ADRDY is becomes 1.
            Additionally, ADC_ENABLE_TIMEOUT is defined to encompass this
            4 ADC clock cycle duration */
        /* Note: Test of ADC enabled required due to hardware constraint to     */
        /*       not enable ADC if already enabled.                             */
        if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 800346e:	687b      	ldr	r3, [r7, #4]
 8003470:	681b      	ldr	r3, [r3, #0]
 8003472:	4618      	mov	r0, r3
 8003474:	f7fe ff98 	bl	80023a8 <LL_ADC_IsEnabled>
 8003478:	4603      	mov	r3, r0
 800347a:	2b00      	cmp	r3, #0
 800347c:	d104      	bne.n	8003488 <ADC_Enable+0xb0>
        {
          LL_ADC_Enable(hadc->Instance);
 800347e:	687b      	ldr	r3, [r7, #4]
 8003480:	681b      	ldr	r3, [r3, #0]
 8003482:	4618      	mov	r0, r3
 8003484:	f7fe ff68 	bl	8002358 <LL_ADC_Enable>
        }

        if ((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 8003488:	f7fe fd74 	bl	8001f74 <HAL_GetTick>
 800348c:	4602      	mov	r2, r0
 800348e:	68fb      	ldr	r3, [r7, #12]
 8003490:	1ad3      	subs	r3, r2, r3
 8003492:	2b02      	cmp	r3, #2
 8003494:	d914      	bls.n	80034c0 <ADC_Enable+0xe8>
        {
          /* New check to avoid false timeout detection in case of preemption */
          if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 8003496:	687b      	ldr	r3, [r7, #4]
 8003498:	681b      	ldr	r3, [r3, #0]
 800349a:	681b      	ldr	r3, [r3, #0]
 800349c:	f003 0301 	and.w	r3, r3, #1
 80034a0:	2b01      	cmp	r3, #1
 80034a2:	d00d      	beq.n	80034c0 <ADC_Enable+0xe8>
          {
            /* Update ADC state machine to error */
            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80034a4:	687b      	ldr	r3, [r7, #4]
 80034a6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80034a8:	f043 0210 	orr.w	r2, r3, #16
 80034ac:	687b      	ldr	r3, [r7, #4]
 80034ae:	655a      	str	r2, [r3, #84]	@ 0x54

            /* Set ADC error code to ADC peripheral internal error */
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80034b0:	687b      	ldr	r3, [r7, #4]
 80034b2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80034b4:	f043 0201 	orr.w	r2, r3, #1
 80034b8:	687b      	ldr	r3, [r7, #4]
 80034ba:	659a      	str	r2, [r3, #88]	@ 0x58

            return HAL_ERROR;
 80034bc:	2301      	movs	r3, #1
 80034be:	e007      	b.n	80034d0 <ADC_Enable+0xf8>
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 80034c0:	687b      	ldr	r3, [r7, #4]
 80034c2:	681b      	ldr	r3, [r3, #0]
 80034c4:	681b      	ldr	r3, [r3, #0]
 80034c6:	f003 0301 	and.w	r3, r3, #1
 80034ca:	2b01      	cmp	r3, #1
 80034cc:	d1cf      	bne.n	800346e <ADC_Enable+0x96>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 80034ce:	2300      	movs	r3, #0
}
 80034d0:	4618      	mov	r0, r3
 80034d2:	3710      	adds	r7, #16
 80034d4:	46bd      	mov	sp, r7
 80034d6:	bd80      	pop	{r7, pc}
 80034d8:	8000003f 	.word	0x8000003f
 80034dc:	40022000 	.word	0x40022000
 80034e0:	40022100 	.word	0x40022100
 80034e4:	40022300 	.word	0x40022300
 80034e8:	58026300 	.word	0x58026300

080034ec <ADC_Disable>:
  *         stopped.
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef *hadc)
{
 80034ec:	b580      	push	{r7, lr}
 80034ee:	b084      	sub	sp, #16
 80034f0:	af00      	add	r7, sp, #0
 80034f2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
 80034f4:	687b      	ldr	r3, [r7, #4]
 80034f6:	681b      	ldr	r3, [r3, #0]
 80034f8:	4618      	mov	r0, r3
 80034fa:	f7fe ff68 	bl	80023ce <LL_ADC_IsDisableOngoing>
 80034fe:	60f8      	str	r0, [r7, #12]

  /* Verification if ADC is not already disabled:                             */
  /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */
  /*       disabled.                                                          */
  if ((LL_ADC_IsEnabled(hadc->Instance) != 0UL)
 8003500:	687b      	ldr	r3, [r7, #4]
 8003502:	681b      	ldr	r3, [r3, #0]
 8003504:	4618      	mov	r0, r3
 8003506:	f7fe ff4f 	bl	80023a8 <LL_ADC_IsEnabled>
 800350a:	4603      	mov	r3, r0
 800350c:	2b00      	cmp	r3, #0
 800350e:	d047      	beq.n	80035a0 <ADC_Disable+0xb4>
      && (tmp_adc_is_disable_on_going == 0UL)
 8003510:	68fb      	ldr	r3, [r7, #12]
 8003512:	2b00      	cmp	r3, #0
 8003514:	d144      	bne.n	80035a0 <ADC_Disable+0xb4>
     )
  {
    /* Check if conditions to disable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
 8003516:	687b      	ldr	r3, [r7, #4]
 8003518:	681b      	ldr	r3, [r3, #0]
 800351a:	689b      	ldr	r3, [r3, #8]
 800351c:	f003 030d 	and.w	r3, r3, #13
 8003520:	2b01      	cmp	r3, #1
 8003522:	d10c      	bne.n	800353e <ADC_Disable+0x52>
    {
      /* Disable the ADC peripheral */
      LL_ADC_Disable(hadc->Instance);
 8003524:	687b      	ldr	r3, [r7, #4]
 8003526:	681b      	ldr	r3, [r3, #0]
 8003528:	4618      	mov	r0, r3
 800352a:	f7fe ff29 	bl	8002380 <LL_ADC_Disable>
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
 800352e:	687b      	ldr	r3, [r7, #4]
 8003530:	681b      	ldr	r3, [r3, #0]
 8003532:	2203      	movs	r2, #3
 8003534:	601a      	str	r2, [r3, #0]
      return HAL_ERROR;
    }

    /* Wait for ADC effectively disabled */
    /* Get tick count */
    tickstart = HAL_GetTick();
 8003536:	f7fe fd1d 	bl	8001f74 <HAL_GetTick>
 800353a:	60b8      	str	r0, [r7, #8]

    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 800353c:	e029      	b.n	8003592 <ADC_Disable+0xa6>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800353e:	687b      	ldr	r3, [r7, #4]
 8003540:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003542:	f043 0210 	orr.w	r2, r3, #16
 8003546:	687b      	ldr	r3, [r7, #4]
 8003548:	655a      	str	r2, [r3, #84]	@ 0x54
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800354a:	687b      	ldr	r3, [r7, #4]
 800354c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800354e:	f043 0201 	orr.w	r2, r3, #1
 8003552:	687b      	ldr	r3, [r7, #4]
 8003554:	659a      	str	r2, [r3, #88]	@ 0x58
      return HAL_ERROR;
 8003556:	2301      	movs	r3, #1
 8003558:	e023      	b.n	80035a2 <ADC_Disable+0xb6>
    {
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 800355a:	f7fe fd0b 	bl	8001f74 <HAL_GetTick>
 800355e:	4602      	mov	r2, r0
 8003560:	68bb      	ldr	r3, [r7, #8]
 8003562:	1ad3      	subs	r3, r2, r3
 8003564:	2b02      	cmp	r3, #2
 8003566:	d914      	bls.n	8003592 <ADC_Disable+0xa6>
      {
        /* New check to avoid false timeout detection in case of preemption */
        if ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 8003568:	687b      	ldr	r3, [r7, #4]
 800356a:	681b      	ldr	r3, [r3, #0]
 800356c:	689b      	ldr	r3, [r3, #8]
 800356e:	f003 0301 	and.w	r3, r3, #1
 8003572:	2b00      	cmp	r3, #0
 8003574:	d00d      	beq.n	8003592 <ADC_Disable+0xa6>
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8003576:	687b      	ldr	r3, [r7, #4]
 8003578:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800357a:	f043 0210 	orr.w	r2, r3, #16
 800357e:	687b      	ldr	r3, [r7, #4]
 8003580:	655a      	str	r2, [r3, #84]	@ 0x54

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8003582:	687b      	ldr	r3, [r7, #4]
 8003584:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8003586:	f043 0201 	orr.w	r2, r3, #1
 800358a:	687b      	ldr	r3, [r7, #4]
 800358c:	659a      	str	r2, [r3, #88]	@ 0x58

          return HAL_ERROR;
 800358e:	2301      	movs	r3, #1
 8003590:	e007      	b.n	80035a2 <ADC_Disable+0xb6>
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 8003592:	687b      	ldr	r3, [r7, #4]
 8003594:	681b      	ldr	r3, [r3, #0]
 8003596:	689b      	ldr	r3, [r3, #8]
 8003598:	f003 0301 	and.w	r3, r3, #1
 800359c:	2b00      	cmp	r3, #0
 800359e:	d1dc      	bne.n	800355a <ADC_Disable+0x6e>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 80035a0:	2300      	movs	r3, #0
}
 80035a2:	4618      	mov	r0, r3
 80035a4:	3710      	adds	r7, #16
 80035a6:	46bd      	mov	sp, r7
 80035a8:	bd80      	pop	{r7, pc}

080035aa <ADC_DMAConvCplt>:
  * @brief  DMA transfer complete callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)
{
 80035aa:	b580      	push	{r7, lr}
 80035ac:	b084      	sub	sp, #16
 80035ae:	af00      	add	r7, sp, #0
 80035b0:	6078      	str	r0, [r7, #4]
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80035b2:	687b      	ldr	r3, [r7, #4]
 80035b4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80035b6:	60fb      	str	r3, [r7, #12]

  /* Update state machine on conversion status if not in error state */
  if ((hadc->State & (HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA)) == 0UL)
 80035b8:	68fb      	ldr	r3, [r7, #12]
 80035ba:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80035bc:	f003 0350 	and.w	r3, r3, #80	@ 0x50
 80035c0:	2b00      	cmp	r3, #0
 80035c2:	d14b      	bne.n	800365c <ADC_DMAConvCplt+0xb2>
  {
    /* Set ADC state */
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 80035c4:	68fb      	ldr	r3, [r7, #12]
 80035c6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80035c8:	f443 7200 	orr.w	r2, r3, #512	@ 0x200
 80035cc:	68fb      	ldr	r3, [r7, #12]
 80035ce:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Determine whether any further conversion upcoming on group regular     */
    /* by external trigger, continuous mode or scan sequence on going         */
    /* to disable interruption.                                               */
    /* Is it the end of the regular sequence ? */
    if ((hadc->Instance->ISR & ADC_FLAG_EOS) != 0UL)
 80035d0:	68fb      	ldr	r3, [r7, #12]
 80035d2:	681b      	ldr	r3, [r3, #0]
 80035d4:	681b      	ldr	r3, [r3, #0]
 80035d6:	f003 0308 	and.w	r3, r3, #8
 80035da:	2b00      	cmp	r3, #0
 80035dc:	d021      	beq.n	8003622 <ADC_DMAConvCplt+0x78>
    {
      /* Are conversions software-triggered ? */
      if (LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance) != 0UL)
 80035de:	68fb      	ldr	r3, [r7, #12]
 80035e0:	681b      	ldr	r3, [r3, #0]
 80035e2:	4618      	mov	r0, r3
 80035e4:	f7fe fd99 	bl	800211a <LL_ADC_REG_IsTriggerSourceSWStart>
 80035e8:	4603      	mov	r3, r0
 80035ea:	2b00      	cmp	r3, #0
 80035ec:	d032      	beq.n	8003654 <ADC_DMAConvCplt+0xaa>
      {
        /* Is CONT bit set ? */
        if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_CONT) == 0UL)
 80035ee:	68fb      	ldr	r3, [r7, #12]
 80035f0:	681b      	ldr	r3, [r3, #0]
 80035f2:	68db      	ldr	r3, [r3, #12]
 80035f4:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 80035f8:	2b00      	cmp	r3, #0
 80035fa:	d12b      	bne.n	8003654 <ADC_DMAConvCplt+0xaa>
        {
          /* CONT bit is not set, no more conversions expected */
          CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 80035fc:	68fb      	ldr	r3, [r7, #12]
 80035fe:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003600:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
 8003604:	68fb      	ldr	r3, [r7, #12]
 8003606:	655a      	str	r2, [r3, #84]	@ 0x54
          if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
 8003608:	68fb      	ldr	r3, [r7, #12]
 800360a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800360c:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8003610:	2b00      	cmp	r3, #0
 8003612:	d11f      	bne.n	8003654 <ADC_DMAConvCplt+0xaa>
          {
            SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8003614:	68fb      	ldr	r3, [r7, #12]
 8003616:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003618:	f043 0201 	orr.w	r2, r3, #1
 800361c:	68fb      	ldr	r3, [r7, #12]
 800361e:	655a      	str	r2, [r3, #84]	@ 0x54
 8003620:	e018      	b.n	8003654 <ADC_DMAConvCplt+0xaa>
    }
    else
    {
      /* DMA End of Transfer interrupt was triggered but conversions sequence
         is not over. If DMACFG is set to 0, conversions are stopped. */
      if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_DMNGT) == 0UL)
 8003622:	68fb      	ldr	r3, [r7, #12]
 8003624:	681b      	ldr	r3, [r3, #0]
 8003626:	68db      	ldr	r3, [r3, #12]
 8003628:	f003 0303 	and.w	r3, r3, #3
 800362c:	2b00      	cmp	r3, #0
 800362e:	d111      	bne.n	8003654 <ADC_DMAConvCplt+0xaa>
      {
        /* DMACFG bit is not set, conversions are stopped. */
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 8003630:	68fb      	ldr	r3, [r7, #12]
 8003632:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003634:	f423 7280 	bic.w	r2, r3, #256	@ 0x100
 8003638:	68fb      	ldr	r3, [r7, #12]
 800363a:	655a      	str	r2, [r3, #84]	@ 0x54
        if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
 800363c:	68fb      	ldr	r3, [r7, #12]
 800363e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003640:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8003644:	2b00      	cmp	r3, #0
 8003646:	d105      	bne.n	8003654 <ADC_DMAConvCplt+0xaa>
        {
          SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8003648:	68fb      	ldr	r3, [r7, #12]
 800364a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800364c:	f043 0201 	orr.w	r2, r3, #1
 8003650:	68fb      	ldr	r3, [r7, #12]
 8003652:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Conversion complete callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
    hadc->ConvCpltCallback(hadc);
#else
    HAL_ADC_ConvCpltCallback(hadc);
 8003654:	68f8      	ldr	r0, [r7, #12]
 8003656:	f7ff fba7 	bl	8002da8 <HAL_ADC_ConvCpltCallback>
    {
      /* Call ADC DMA error callback */
      hadc->DMA_Handle->XferErrorCallback(hdma);
    }
  }
}
 800365a:	e00e      	b.n	800367a <ADC_DMAConvCplt+0xd0>
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) != 0UL)
 800365c:	68fb      	ldr	r3, [r7, #12]
 800365e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003660:	f003 0310 	and.w	r3, r3, #16
 8003664:	2b00      	cmp	r3, #0
 8003666:	d003      	beq.n	8003670 <ADC_DMAConvCplt+0xc6>
      HAL_ADC_ErrorCallback(hadc);
 8003668:	68f8      	ldr	r0, [r7, #12]
 800366a:	f7ff fbbb 	bl	8002de4 <HAL_ADC_ErrorCallback>
}
 800366e:	e004      	b.n	800367a <ADC_DMAConvCplt+0xd0>
      hadc->DMA_Handle->XferErrorCallback(hdma);
 8003670:	68fb      	ldr	r3, [r7, #12]
 8003672:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8003674:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8003676:	6878      	ldr	r0, [r7, #4]
 8003678:	4798      	blx	r3
}
 800367a:	bf00      	nop
 800367c:	3710      	adds	r7, #16
 800367e:	46bd      	mov	sp, r7
 8003680:	bd80      	pop	{r7, pc}

08003682 <ADC_DMAHalfConvCplt>:
  * @brief  DMA half transfer complete callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)
{
 8003682:	b580      	push	{r7, lr}
 8003684:	b084      	sub	sp, #16
 8003686:	af00      	add	r7, sp, #0
 8003688:	6078      	str	r0, [r7, #4]
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800368a:	687b      	ldr	r3, [r7, #4]
 800368c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800368e:	60fb      	str	r3, [r7, #12]

  /* Half conversion callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ConvHalfCpltCallback(hadc);
#else
  HAL_ADC_ConvHalfCpltCallback(hadc);
 8003690:	68f8      	ldr	r0, [r7, #12]
 8003692:	f7ff fb93 	bl	8002dbc <HAL_ADC_ConvHalfCpltCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
 8003696:	bf00      	nop
 8003698:	3710      	adds	r7, #16
 800369a:	46bd      	mov	sp, r7
 800369c:	bd80      	pop	{r7, pc}

0800369e <ADC_DMAError>:
  * @brief  DMA error callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAError(DMA_HandleTypeDef *hdma)
{
 800369e:	b580      	push	{r7, lr}
 80036a0:	b084      	sub	sp, #16
 80036a2:	af00      	add	r7, sp, #0
 80036a4:	6078      	str	r0, [r7, #4]
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 80036a6:	687b      	ldr	r3, [r7, #4]
 80036a8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80036aa:	60fb      	str	r3, [r7, #12]

  /* Set ADC state */
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 80036ac:	68fb      	ldr	r3, [r7, #12]
 80036ae:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80036b0:	f043 0240 	orr.w	r2, r3, #64	@ 0x40
 80036b4:	68fb      	ldr	r3, [r7, #12]
 80036b6:	655a      	str	r2, [r3, #84]	@ 0x54

  /* Set ADC error code to DMA error */
  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
 80036b8:	68fb      	ldr	r3, [r7, #12]
 80036ba:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80036bc:	f043 0204 	orr.w	r2, r3, #4
 80036c0:	68fb      	ldr	r3, [r7, #12]
 80036c2:	659a      	str	r2, [r3, #88]	@ 0x58

  /* Error callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ErrorCallback(hadc);
#else
  HAL_ADC_ErrorCallback(hadc);
 80036c4:	68f8      	ldr	r0, [r7, #12]
 80036c6:	f7ff fb8d 	bl	8002de4 <HAL_ADC_ErrorCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
 80036ca:	bf00      	nop
 80036cc:	3710      	adds	r7, #16
 80036ce:	46bd      	mov	sp, r7
 80036d0:	bd80      	pop	{r7, pc}
	...

080036d4 <ADC_ConfigureBoostMode>:
  *         stopped.
  * @param  hadc ADC handle
  * @retval None.
  */
void ADC_ConfigureBoostMode(ADC_HandleTypeDef *hadc)
{
 80036d4:	b580      	push	{r7, lr}
 80036d6:	b084      	sub	sp, #16
 80036d8:	af00      	add	r7, sp, #0
 80036da:	6078      	str	r0, [r7, #4]
  uint32_t freq;
  if (ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
 80036dc:	687b      	ldr	r3, [r7, #4]
 80036de:	681b      	ldr	r3, [r3, #0]
 80036e0:	4a7a      	ldr	r2, [pc, #488]	@ (80038cc <ADC_ConfigureBoostMode+0x1f8>)
 80036e2:	4293      	cmp	r3, r2
 80036e4:	d004      	beq.n	80036f0 <ADC_ConfigureBoostMode+0x1c>
 80036e6:	687b      	ldr	r3, [r7, #4]
 80036e8:	681b      	ldr	r3, [r3, #0]
 80036ea:	4a79      	ldr	r2, [pc, #484]	@ (80038d0 <ADC_ConfigureBoostMode+0x1fc>)
 80036ec:	4293      	cmp	r3, r2
 80036ee:	d109      	bne.n	8003704 <ADC_ConfigureBoostMode+0x30>
 80036f0:	4b78      	ldr	r3, [pc, #480]	@ (80038d4 <ADC_ConfigureBoostMode+0x200>)
 80036f2:	689b      	ldr	r3, [r3, #8]
 80036f4:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 80036f8:	2b00      	cmp	r3, #0
 80036fa:	bf14      	ite	ne
 80036fc:	2301      	movne	r3, #1
 80036fe:	2300      	moveq	r3, #0
 8003700:	b2db      	uxtb	r3, r3
 8003702:	e008      	b.n	8003716 <ADC_ConfigureBoostMode+0x42>
 8003704:	4b74      	ldr	r3, [pc, #464]	@ (80038d8 <ADC_ConfigureBoostMode+0x204>)
 8003706:	689b      	ldr	r3, [r3, #8]
 8003708:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 800370c:	2b00      	cmp	r3, #0
 800370e:	bf14      	ite	ne
 8003710:	2301      	movne	r3, #1
 8003712:	2300      	moveq	r3, #0
 8003714:	b2db      	uxtb	r3, r3
 8003716:	2b00      	cmp	r3, #0
 8003718:	d01c      	beq.n	8003754 <ADC_ConfigureBoostMode+0x80>
  {
    freq = HAL_RCC_GetHCLKFreq();
 800371a:	f004 fcf1 	bl	8008100 <HAL_RCC_GetHCLKFreq>
 800371e:	60f8      	str	r0, [r7, #12]
    switch (hadc->Init.ClockPrescaler)
 8003720:	687b      	ldr	r3, [r7, #4]
 8003722:	685b      	ldr	r3, [r3, #4]
 8003724:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8003728:	d010      	beq.n	800374c <ADC_ConfigureBoostMode+0x78>
 800372a:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 800372e:	d873      	bhi.n	8003818 <ADC_ConfigureBoostMode+0x144>
 8003730:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8003734:	d002      	beq.n	800373c <ADC_ConfigureBoostMode+0x68>
 8003736:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800373a:	d16d      	bne.n	8003818 <ADC_ConfigureBoostMode+0x144>
    {
      case ADC_CLOCK_SYNC_PCLK_DIV1:
      case ADC_CLOCK_SYNC_PCLK_DIV2:
        freq /= (hadc->Init.ClockPrescaler >> ADC_CCR_CKMODE_Pos);
 800373c:	687b      	ldr	r3, [r7, #4]
 800373e:	685b      	ldr	r3, [r3, #4]
 8003740:	0c1b      	lsrs	r3, r3, #16
 8003742:	68fa      	ldr	r2, [r7, #12]
 8003744:	fbb2 f3f3 	udiv	r3, r2, r3
 8003748:	60fb      	str	r3, [r7, #12]
        break;
 800374a:	e068      	b.n	800381e <ADC_ConfigureBoostMode+0x14a>
      case ADC_CLOCK_SYNC_PCLK_DIV4:
        freq /= 4UL;
 800374c:	68fb      	ldr	r3, [r7, #12]
 800374e:	089b      	lsrs	r3, r3, #2
 8003750:	60fb      	str	r3, [r7, #12]
        break;
 8003752:	e064      	b.n	800381e <ADC_ConfigureBoostMode+0x14a>
        break;
    }
  }
  else
  {
    freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC);
 8003754:	f44f 2000 	mov.w	r0, #524288	@ 0x80000
 8003758:	f04f 0100 	mov.w	r1, #0
 800375c:	f005 ff78 	bl	8009650 <HAL_RCCEx_GetPeriphCLKFreq>
 8003760:	60f8      	str	r0, [r7, #12]
    switch (hadc->Init.ClockPrescaler)
 8003762:	687b      	ldr	r3, [r7, #4]
 8003764:	685b      	ldr	r3, [r3, #4]
 8003766:	f5b3 1f30 	cmp.w	r3, #2883584	@ 0x2c0000
 800376a:	d051      	beq.n	8003810 <ADC_ConfigureBoostMode+0x13c>
 800376c:	f5b3 1f30 	cmp.w	r3, #2883584	@ 0x2c0000
 8003770:	d854      	bhi.n	800381c <ADC_ConfigureBoostMode+0x148>
 8003772:	f5b3 1f20 	cmp.w	r3, #2621440	@ 0x280000
 8003776:	d047      	beq.n	8003808 <ADC_ConfigureBoostMode+0x134>
 8003778:	f5b3 1f20 	cmp.w	r3, #2621440	@ 0x280000
 800377c:	d84e      	bhi.n	800381c <ADC_ConfigureBoostMode+0x148>
 800377e:	f5b3 1f10 	cmp.w	r3, #2359296	@ 0x240000
 8003782:	d03d      	beq.n	8003800 <ADC_ConfigureBoostMode+0x12c>
 8003784:	f5b3 1f10 	cmp.w	r3, #2359296	@ 0x240000
 8003788:	d848      	bhi.n	800381c <ADC_ConfigureBoostMode+0x148>
 800378a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 800378e:	d033      	beq.n	80037f8 <ADC_ConfigureBoostMode+0x124>
 8003790:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8003794:	d842      	bhi.n	800381c <ADC_ConfigureBoostMode+0x148>
 8003796:	f5b3 1fe0 	cmp.w	r3, #1835008	@ 0x1c0000
 800379a:	d029      	beq.n	80037f0 <ADC_ConfigureBoostMode+0x11c>
 800379c:	f5b3 1fe0 	cmp.w	r3, #1835008	@ 0x1c0000
 80037a0:	d83c      	bhi.n	800381c <ADC_ConfigureBoostMode+0x148>
 80037a2:	f5b3 1fc0 	cmp.w	r3, #1572864	@ 0x180000
 80037a6:	d01a      	beq.n	80037de <ADC_ConfigureBoostMode+0x10a>
 80037a8:	f5b3 1fc0 	cmp.w	r3, #1572864	@ 0x180000
 80037ac:	d836      	bhi.n	800381c <ADC_ConfigureBoostMode+0x148>
 80037ae:	f5b3 1fa0 	cmp.w	r3, #1310720	@ 0x140000
 80037b2:	d014      	beq.n	80037de <ADC_ConfigureBoostMode+0x10a>
 80037b4:	f5b3 1fa0 	cmp.w	r3, #1310720	@ 0x140000
 80037b8:	d830      	bhi.n	800381c <ADC_ConfigureBoostMode+0x148>
 80037ba:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 80037be:	d00e      	beq.n	80037de <ADC_ConfigureBoostMode+0x10a>
 80037c0:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 80037c4:	d82a      	bhi.n	800381c <ADC_ConfigureBoostMode+0x148>
 80037c6:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
 80037ca:	d008      	beq.n	80037de <ADC_ConfigureBoostMode+0x10a>
 80037cc:	f5b3 2f40 	cmp.w	r3, #786432	@ 0xc0000
 80037d0:	d824      	bhi.n	800381c <ADC_ConfigureBoostMode+0x148>
 80037d2:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 80037d6:	d002      	beq.n	80037de <ADC_ConfigureBoostMode+0x10a>
 80037d8:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
 80037dc:	d11e      	bne.n	800381c <ADC_ConfigureBoostMode+0x148>
      case ADC_CLOCK_ASYNC_DIV4:
      case ADC_CLOCK_ASYNC_DIV6:
      case ADC_CLOCK_ASYNC_DIV8:
      case ADC_CLOCK_ASYNC_DIV10:
      case ADC_CLOCK_ASYNC_DIV12:
        freq /= ((hadc->Init.ClockPrescaler >> ADC_CCR_PRESC_Pos) << 1UL);
 80037de:	687b      	ldr	r3, [r7, #4]
 80037e0:	685b      	ldr	r3, [r3, #4]
 80037e2:	0c9b      	lsrs	r3, r3, #18
 80037e4:	005b      	lsls	r3, r3, #1
 80037e6:	68fa      	ldr	r2, [r7, #12]
 80037e8:	fbb2 f3f3 	udiv	r3, r2, r3
 80037ec:	60fb      	str	r3, [r7, #12]
        break;
 80037ee:	e016      	b.n	800381e <ADC_ConfigureBoostMode+0x14a>
      case ADC_CLOCK_ASYNC_DIV16:
        freq /= 16UL;
 80037f0:	68fb      	ldr	r3, [r7, #12]
 80037f2:	091b      	lsrs	r3, r3, #4
 80037f4:	60fb      	str	r3, [r7, #12]
        break;
 80037f6:	e012      	b.n	800381e <ADC_ConfigureBoostMode+0x14a>
      case ADC_CLOCK_ASYNC_DIV32:
        freq /= 32UL;
 80037f8:	68fb      	ldr	r3, [r7, #12]
 80037fa:	095b      	lsrs	r3, r3, #5
 80037fc:	60fb      	str	r3, [r7, #12]
        break;
 80037fe:	e00e      	b.n	800381e <ADC_ConfigureBoostMode+0x14a>
      case ADC_CLOCK_ASYNC_DIV64:
        freq /= 64UL;
 8003800:	68fb      	ldr	r3, [r7, #12]
 8003802:	099b      	lsrs	r3, r3, #6
 8003804:	60fb      	str	r3, [r7, #12]
        break;
 8003806:	e00a      	b.n	800381e <ADC_ConfigureBoostMode+0x14a>
      case ADC_CLOCK_ASYNC_DIV128:
        freq /= 128UL;
 8003808:	68fb      	ldr	r3, [r7, #12]
 800380a:	09db      	lsrs	r3, r3, #7
 800380c:	60fb      	str	r3, [r7, #12]
        break;
 800380e:	e006      	b.n	800381e <ADC_ConfigureBoostMode+0x14a>
      case ADC_CLOCK_ASYNC_DIV256:
        freq /= 256UL;
 8003810:	68fb      	ldr	r3, [r7, #12]
 8003812:	0a1b      	lsrs	r3, r3, #8
 8003814:	60fb      	str	r3, [r7, #12]
        break;
 8003816:	e002      	b.n	800381e <ADC_ConfigureBoostMode+0x14a>
        break;
 8003818:	bf00      	nop
 800381a:	e000      	b.n	800381e <ADC_ConfigureBoostMode+0x14a>
      default:
        break;
 800381c:	bf00      	nop
  else /* if(freq > 25000000UL) */
  {
    MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
  }
#else
  if (HAL_GetREVID() <= REV_ID_Y) /* STM32H7 silicon Rev.Y */
 800381e:	f7fe fbb5 	bl	8001f8c <HAL_GetREVID>
 8003822:	4603      	mov	r3, r0
 8003824:	f241 0203 	movw	r2, #4099	@ 0x1003
 8003828:	4293      	cmp	r3, r2
 800382a:	d815      	bhi.n	8003858 <ADC_ConfigureBoostMode+0x184>
  {
    if (freq > 20000000UL)
 800382c:	68fb      	ldr	r3, [r7, #12]
 800382e:	4a2b      	ldr	r2, [pc, #172]	@ (80038dc <ADC_ConfigureBoostMode+0x208>)
 8003830:	4293      	cmp	r3, r2
 8003832:	d908      	bls.n	8003846 <ADC_ConfigureBoostMode+0x172>
    {
      SET_BIT(hadc->Instance->CR, ADC_CR_BOOST_0);
 8003834:	687b      	ldr	r3, [r7, #4]
 8003836:	681b      	ldr	r3, [r3, #0]
 8003838:	689a      	ldr	r2, [r3, #8]
 800383a:	687b      	ldr	r3, [r7, #4]
 800383c:	681b      	ldr	r3, [r3, #0]
 800383e:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8003842:	609a      	str	r2, [r3, #8]
    {
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
    }
  }
#endif /* ADC_VER_V5_3 */
}
 8003844:	e03e      	b.n	80038c4 <ADC_ConfigureBoostMode+0x1f0>
      CLEAR_BIT(hadc->Instance->CR, ADC_CR_BOOST_0);
 8003846:	687b      	ldr	r3, [r7, #4]
 8003848:	681b      	ldr	r3, [r3, #0]
 800384a:	689a      	ldr	r2, [r3, #8]
 800384c:	687b      	ldr	r3, [r7, #4]
 800384e:	681b      	ldr	r3, [r3, #0]
 8003850:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
 8003854:	609a      	str	r2, [r3, #8]
}
 8003856:	e035      	b.n	80038c4 <ADC_ConfigureBoostMode+0x1f0>
    freq /= 2U; /* divider by 2 for Rev.V */
 8003858:	68fb      	ldr	r3, [r7, #12]
 800385a:	085b      	lsrs	r3, r3, #1
 800385c:	60fb      	str	r3, [r7, #12]
    if (freq <= 6250000UL)
 800385e:	68fb      	ldr	r3, [r7, #12]
 8003860:	4a1f      	ldr	r2, [pc, #124]	@ (80038e0 <ADC_ConfigureBoostMode+0x20c>)
 8003862:	4293      	cmp	r3, r2
 8003864:	d808      	bhi.n	8003878 <ADC_ConfigureBoostMode+0x1a4>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, 0UL);
 8003866:	687b      	ldr	r3, [r7, #4]
 8003868:	681b      	ldr	r3, [r3, #0]
 800386a:	689a      	ldr	r2, [r3, #8]
 800386c:	687b      	ldr	r3, [r7, #4]
 800386e:	681b      	ldr	r3, [r3, #0]
 8003870:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 8003874:	609a      	str	r2, [r3, #8]
}
 8003876:	e025      	b.n	80038c4 <ADC_ConfigureBoostMode+0x1f0>
    else if (freq <= 12500000UL)
 8003878:	68fb      	ldr	r3, [r7, #12]
 800387a:	4a1a      	ldr	r2, [pc, #104]	@ (80038e4 <ADC_ConfigureBoostMode+0x210>)
 800387c:	4293      	cmp	r3, r2
 800387e:	d80a      	bhi.n	8003896 <ADC_ConfigureBoostMode+0x1c2>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_0);
 8003880:	687b      	ldr	r3, [r7, #4]
 8003882:	681b      	ldr	r3, [r3, #0]
 8003884:	689b      	ldr	r3, [r3, #8]
 8003886:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
 800388a:	687b      	ldr	r3, [r7, #4]
 800388c:	681b      	ldr	r3, [r3, #0]
 800388e:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 8003892:	609a      	str	r2, [r3, #8]
}
 8003894:	e016      	b.n	80038c4 <ADC_ConfigureBoostMode+0x1f0>
    else if (freq <= 25000000UL)
 8003896:	68fb      	ldr	r3, [r7, #12]
 8003898:	4a13      	ldr	r2, [pc, #76]	@ (80038e8 <ADC_ConfigureBoostMode+0x214>)
 800389a:	4293      	cmp	r3, r2
 800389c:	d80a      	bhi.n	80038b4 <ADC_ConfigureBoostMode+0x1e0>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1);
 800389e:	687b      	ldr	r3, [r7, #4]
 80038a0:	681b      	ldr	r3, [r3, #0]
 80038a2:	689b      	ldr	r3, [r3, #8]
 80038a4:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
 80038a8:	687b      	ldr	r3, [r7, #4]
 80038aa:	681b      	ldr	r3, [r3, #0]
 80038ac:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80038b0:	609a      	str	r2, [r3, #8]
}
 80038b2:	e007      	b.n	80038c4 <ADC_ConfigureBoostMode+0x1f0>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
 80038b4:	687b      	ldr	r3, [r7, #4]
 80038b6:	681b      	ldr	r3, [r3, #0]
 80038b8:	689a      	ldr	r2, [r3, #8]
 80038ba:	687b      	ldr	r3, [r7, #4]
 80038bc:	681b      	ldr	r3, [r3, #0]
 80038be:	f442 7240 	orr.w	r2, r2, #768	@ 0x300
 80038c2:	609a      	str	r2, [r3, #8]
}
 80038c4:	bf00      	nop
 80038c6:	3710      	adds	r7, #16
 80038c8:	46bd      	mov	sp, r7
 80038ca:	bd80      	pop	{r7, pc}
 80038cc:	40022000 	.word	0x40022000
 80038d0:	40022100 	.word	0x40022100
 80038d4:	40022300 	.word	0x40022300
 80038d8:	58026300 	.word	0x58026300
 80038dc:	01312d00 	.word	0x01312d00
 80038e0:	005f5e10 	.word	0x005f5e10
 80038e4:	00bebc20 	.word	0x00bebc20
 80038e8:	017d7840 	.word	0x017d7840

080038ec <LL_ADC_IsEnabled>:
{
 80038ec:	b480      	push	{r7}
 80038ee:	b083      	sub	sp, #12
 80038f0:	af00      	add	r7, sp, #0
 80038f2:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80038f4:	687b      	ldr	r3, [r7, #4]
 80038f6:	689b      	ldr	r3, [r3, #8]
 80038f8:	f003 0301 	and.w	r3, r3, #1
 80038fc:	2b01      	cmp	r3, #1
 80038fe:	d101      	bne.n	8003904 <LL_ADC_IsEnabled+0x18>
 8003900:	2301      	movs	r3, #1
 8003902:	e000      	b.n	8003906 <LL_ADC_IsEnabled+0x1a>
 8003904:	2300      	movs	r3, #0
}
 8003906:	4618      	mov	r0, r3
 8003908:	370c      	adds	r7, #12
 800390a:	46bd      	mov	sp, r7
 800390c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003910:	4770      	bx	lr
	...

08003914 <LL_ADC_StartCalibration>:
{
 8003914:	b480      	push	{r7}
 8003916:	b085      	sub	sp, #20
 8003918:	af00      	add	r7, sp, #0
 800391a:	60f8      	str	r0, [r7, #12]
 800391c:	60b9      	str	r1, [r7, #8]
 800391e:	607a      	str	r2, [r7, #4]
  MODIFY_REG(ADCx->CR,
 8003920:	68fb      	ldr	r3, [r7, #12]
 8003922:	689a      	ldr	r2, [r3, #8]
 8003924:	4b09      	ldr	r3, [pc, #36]	@ (800394c <LL_ADC_StartCalibration+0x38>)
 8003926:	4013      	ands	r3, r2
 8003928:	68ba      	ldr	r2, [r7, #8]
 800392a:	f402 3180 	and.w	r1, r2, #65536	@ 0x10000
 800392e:	687a      	ldr	r2, [r7, #4]
 8003930:	f002 4280 	and.w	r2, r2, #1073741824	@ 0x40000000
 8003934:	430a      	orrs	r2, r1
 8003936:	4313      	orrs	r3, r2
 8003938:	f043 4200 	orr.w	r2, r3, #2147483648	@ 0x80000000
 800393c:	68fb      	ldr	r3, [r7, #12]
 800393e:	609a      	str	r2, [r3, #8]
}
 8003940:	bf00      	nop
 8003942:	3714      	adds	r7, #20
 8003944:	46bd      	mov	sp, r7
 8003946:	f85d 7b04 	ldr.w	r7, [sp], #4
 800394a:	4770      	bx	lr
 800394c:	3ffeffc0 	.word	0x3ffeffc0

08003950 <LL_ADC_IsCalibrationOnGoing>:
{
 8003950:	b480      	push	{r7}
 8003952:	b083      	sub	sp, #12
 8003954:	af00      	add	r7, sp, #0
 8003956:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 8003958:	687b      	ldr	r3, [r7, #4]
 800395a:	689b      	ldr	r3, [r3, #8]
 800395c:	f003 4300 	and.w	r3, r3, #2147483648	@ 0x80000000
 8003960:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
 8003964:	d101      	bne.n	800396a <LL_ADC_IsCalibrationOnGoing+0x1a>
 8003966:	2301      	movs	r3, #1
 8003968:	e000      	b.n	800396c <LL_ADC_IsCalibrationOnGoing+0x1c>
 800396a:	2300      	movs	r3, #0
}
 800396c:	4618      	mov	r0, r3
 800396e:	370c      	adds	r7, #12
 8003970:	46bd      	mov	sp, r7
 8003972:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003976:	4770      	bx	lr

08003978 <LL_ADC_REG_IsConversionOngoing>:
{
 8003978:	b480      	push	{r7}
 800397a:	b083      	sub	sp, #12
 800397c:	af00      	add	r7, sp, #0
 800397e:	6078      	str	r0, [r7, #4]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8003980:	687b      	ldr	r3, [r7, #4]
 8003982:	689b      	ldr	r3, [r3, #8]
 8003984:	f003 0304 	and.w	r3, r3, #4
 8003988:	2b04      	cmp	r3, #4
 800398a:	d101      	bne.n	8003990 <LL_ADC_REG_IsConversionOngoing+0x18>
 800398c:	2301      	movs	r3, #1
 800398e:	e000      	b.n	8003992 <LL_ADC_REG_IsConversionOngoing+0x1a>
 8003990:	2300      	movs	r3, #0
}
 8003992:	4618      	mov	r0, r3
 8003994:	370c      	adds	r7, #12
 8003996:	46bd      	mov	sp, r7
 8003998:	f85d 7b04 	ldr.w	r7, [sp], #4
 800399c:	4770      	bx	lr
	...

080039a0 <HAL_ADCEx_Calibration_Start>:
  *           @arg @ref ADC_SINGLE_ENDED       Channel in mode input single ended
  *           @arg @ref ADC_DIFFERENTIAL_ENDED Channel in mode input differential ended
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc, uint32_t CalibrationMode, uint32_t SingleDiff)
{
 80039a0:	b580      	push	{r7, lr}
 80039a2:	b086      	sub	sp, #24
 80039a4:	af00      	add	r7, sp, #0
 80039a6:	60f8      	str	r0, [r7, #12]
 80039a8:	60b9      	str	r1, [r7, #8]
 80039aa:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status;
  __IO uint32_t wait_loop_index = 0UL;
 80039ac:	2300      	movs	r3, #0
 80039ae:	613b      	str	r3, [r7, #16]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));

  /* Process locked */
  __HAL_LOCK(hadc);
 80039b0:	68fb      	ldr	r3, [r7, #12]
 80039b2:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 80039b6:	2b01      	cmp	r3, #1
 80039b8:	d101      	bne.n	80039be <HAL_ADCEx_Calibration_Start+0x1e>
 80039ba:	2302      	movs	r3, #2
 80039bc:	e04c      	b.n	8003a58 <HAL_ADCEx_Calibration_Start+0xb8>
 80039be:	68fb      	ldr	r3, [r7, #12]
 80039c0:	2201      	movs	r2, #1
 80039c2:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

  /* Calibration prerequisite: ADC must be disabled. */

  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
 80039c6:	68f8      	ldr	r0, [r7, #12]
 80039c8:	f7ff fd90 	bl	80034ec <ADC_Disable>
 80039cc:	4603      	mov	r3, r0
 80039ce:	75fb      	strb	r3, [r7, #23]

  /* Check if ADC is effectively disabled */
  if (tmp_hal_status == HAL_OK)
 80039d0:	7dfb      	ldrb	r3, [r7, #23]
 80039d2:	2b00      	cmp	r3, #0
 80039d4:	d135      	bne.n	8003a42 <HAL_ADCEx_Calibration_Start+0xa2>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 80039d6:	68fb      	ldr	r3, [r7, #12]
 80039d8:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 80039da:	4b21      	ldr	r3, [pc, #132]	@ (8003a60 <HAL_ADCEx_Calibration_Start+0xc0>)
 80039dc:	4013      	ands	r3, r2
 80039de:	f043 0202 	orr.w	r2, r3, #2
 80039e2:	68fb      	ldr	r3, [r7, #12]
 80039e4:	655a      	str	r2, [r3, #84]	@ 0x54
                      HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
                      HAL_ADC_STATE_BUSY_INTERNAL);

    /* Start ADC calibration in mode single-ended or differential */
    LL_ADC_StartCalibration(hadc->Instance, CalibrationMode, SingleDiff);
 80039e6:	68fb      	ldr	r3, [r7, #12]
 80039e8:	681b      	ldr	r3, [r3, #0]
 80039ea:	687a      	ldr	r2, [r7, #4]
 80039ec:	68b9      	ldr	r1, [r7, #8]
 80039ee:	4618      	mov	r0, r3
 80039f0:	f7ff ff90 	bl	8003914 <LL_ADC_StartCalibration>

    /* Wait for calibration completion */
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
 80039f4:	e014      	b.n	8003a20 <HAL_ADCEx_Calibration_Start+0x80>
    {
      wait_loop_index++;
 80039f6:	693b      	ldr	r3, [r7, #16]
 80039f8:	3301      	adds	r3, #1
 80039fa:	613b      	str	r3, [r7, #16]
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 80039fc:	693b      	ldr	r3, [r7, #16]
 80039fe:	4a19      	ldr	r2, [pc, #100]	@ (8003a64 <HAL_ADCEx_Calibration_Start+0xc4>)
 8003a00:	4293      	cmp	r3, r2
 8003a02:	d30d      	bcc.n	8003a20 <HAL_ADCEx_Calibration_Start+0x80>
      {
        /* Update ADC state machine to error */
        ADC_STATE_CLR_SET(hadc->State,
 8003a04:	68fb      	ldr	r3, [r7, #12]
 8003a06:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003a08:	f023 0312 	bic.w	r3, r3, #18
 8003a0c:	f043 0210 	orr.w	r2, r3, #16
 8003a10:	68fb      	ldr	r3, [r7, #12]
 8003a12:	655a      	str	r2, [r3, #84]	@ 0x54
                          HAL_ADC_STATE_BUSY_INTERNAL,
                          HAL_ADC_STATE_ERROR_INTERNAL);

        /* Process unlocked */
        __HAL_UNLOCK(hadc);
 8003a14:	68fb      	ldr	r3, [r7, #12]
 8003a16:	2200      	movs	r2, #0
 8003a18:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

        return HAL_ERROR;
 8003a1c:	2301      	movs	r3, #1
 8003a1e:	e01b      	b.n	8003a58 <HAL_ADCEx_Calibration_Start+0xb8>
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
 8003a20:	68fb      	ldr	r3, [r7, #12]
 8003a22:	681b      	ldr	r3, [r3, #0]
 8003a24:	4618      	mov	r0, r3
 8003a26:	f7ff ff93 	bl	8003950 <LL_ADC_IsCalibrationOnGoing>
 8003a2a:	4603      	mov	r3, r0
 8003a2c:	2b00      	cmp	r3, #0
 8003a2e:	d1e2      	bne.n	80039f6 <HAL_ADCEx_Calibration_Start+0x56>
      }
    }

    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8003a30:	68fb      	ldr	r3, [r7, #12]
 8003a32:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003a34:	f023 0303 	bic.w	r3, r3, #3
 8003a38:	f043 0201 	orr.w	r2, r3, #1
 8003a3c:	68fb      	ldr	r3, [r7, #12]
 8003a3e:	655a      	str	r2, [r3, #84]	@ 0x54
 8003a40:	e005      	b.n	8003a4e <HAL_ADCEx_Calibration_Start+0xae>
                      HAL_ADC_STATE_BUSY_INTERNAL,
                      HAL_ADC_STATE_READY);
  }
  else
  {
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8003a42:	68fb      	ldr	r3, [r7, #12]
 8003a44:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003a46:	f043 0210 	orr.w	r2, r3, #16
 8003a4a:	68fb      	ldr	r3, [r7, #12]
 8003a4c:	655a      	str	r2, [r3, #84]	@ 0x54
    /* Note: No need to update variable "tmp_hal_status" here: already set    */
    /*       to state "HAL_ERROR" by function disabling the ADC.              */
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8003a4e:	68fb      	ldr	r3, [r7, #12]
 8003a50:	2200      	movs	r2, #0
 8003a52:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

  /* Return function status */
  return tmp_hal_status;
 8003a56:	7dfb      	ldrb	r3, [r7, #23]
}
 8003a58:	4618      	mov	r0, r3
 8003a5a:	3718      	adds	r7, #24
 8003a5c:	46bd      	mov	sp, r7
 8003a5e:	bd80      	pop	{r7, pc}
 8003a60:	ffffeefd 	.word	0xffffeefd
 8003a64:	25c3f800 	.word	0x25c3f800

08003a68 <HAL_ADCEx_InjectedConvCpltCallback>:
  * @brief  Injected conversion complete callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef *hadc)
{
 8003a68:	b480      	push	{r7}
 8003a6a:	b083      	sub	sp, #12
 8003a6c:	af00      	add	r7, sp, #0
 8003a6e:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_InjectedConvCpltCallback must be implemented in the user file.
  */
}
 8003a70:	bf00      	nop
 8003a72:	370c      	adds	r7, #12
 8003a74:	46bd      	mov	sp, r7
 8003a76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003a7a:	4770      	bx	lr

08003a7c <HAL_ADCEx_InjectedQueueOverflowCallback>:
            contexts).
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_InjectedQueueOverflowCallback(ADC_HandleTypeDef *hadc)
{
 8003a7c:	b480      	push	{r7}
 8003a7e:	b083      	sub	sp, #12
 8003a80:	af00      	add	r7, sp, #0
 8003a82:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_InjectedQueueOverflowCallback must be implemented in the user file.
  */
}
 8003a84:	bf00      	nop
 8003a86:	370c      	adds	r7, #12
 8003a88:	46bd      	mov	sp, r7
 8003a8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003a8e:	4770      	bx	lr

08003a90 <HAL_ADCEx_LevelOutOfWindow2Callback>:
  * @brief  Analog watchdog 2 callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_LevelOutOfWindow2Callback(ADC_HandleTypeDef *hadc)
{
 8003a90:	b480      	push	{r7}
 8003a92:	b083      	sub	sp, #12
 8003a94:	af00      	add	r7, sp, #0
 8003a96:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_LevelOutOfWindow2Callback must be implemented in the user file.
  */
}
 8003a98:	bf00      	nop
 8003a9a:	370c      	adds	r7, #12
 8003a9c:	46bd      	mov	sp, r7
 8003a9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003aa2:	4770      	bx	lr

08003aa4 <HAL_ADCEx_LevelOutOfWindow3Callback>:
  * @brief  Analog watchdog 3 callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_LevelOutOfWindow3Callback(ADC_HandleTypeDef *hadc)
{
 8003aa4:	b480      	push	{r7}
 8003aa6:	b083      	sub	sp, #12
 8003aa8:	af00      	add	r7, sp, #0
 8003aaa:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_LevelOutOfWindow3Callback must be implemented in the user file.
  */
}
 8003aac:	bf00      	nop
 8003aae:	370c      	adds	r7, #12
 8003ab0:	46bd      	mov	sp, r7
 8003ab2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003ab6:	4770      	bx	lr

08003ab8 <HAL_ADCEx_EndOfSamplingCallback>:
  * @brief  End Of Sampling callback in non-blocking mode.
  * @param hadc ADC handle
  * @retval None
  */
__weak void HAL_ADCEx_EndOfSamplingCallback(ADC_HandleTypeDef *hadc)
{
 8003ab8:	b480      	push	{r7}
 8003aba:	b083      	sub	sp, #12
 8003abc:	af00      	add	r7, sp, #0
 8003abe:	6078      	str	r0, [r7, #4]
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_EndOfSamplingCallback must be implemented in the user file.
  */
}
 8003ac0:	bf00      	nop
 8003ac2:	370c      	adds	r7, #12
 8003ac4:	46bd      	mov	sp, r7
 8003ac6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003aca:	4770      	bx	lr

08003acc <HAL_ADCEx_MultiModeConfigChannel>:
  * @param hadc Master ADC handle
  * @param multimode Structure of ADC multimode configuration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_MultiModeConfigChannel(ADC_HandleTypeDef *hadc, ADC_MultiModeTypeDef *multimode)
{
 8003acc:	b590      	push	{r4, r7, lr}
 8003ace:	b09f      	sub	sp, #124	@ 0x7c
 8003ad0:	af00      	add	r7, sp, #0
 8003ad2:	6078      	str	r0, [r7, #4]
 8003ad4:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8003ad6:	2300      	movs	r3, #0
 8003ad8:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
    assert_param(IS_ADC_DUAL_DATA_MODE(multimode->DualModeData));
    assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8003adc:	687b      	ldr	r3, [r7, #4]
 8003ade:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
 8003ae2:	2b01      	cmp	r3, #1
 8003ae4:	d101      	bne.n	8003aea <HAL_ADCEx_MultiModeConfigChannel+0x1e>
 8003ae6:	2302      	movs	r3, #2
 8003ae8:	e0be      	b.n	8003c68 <HAL_ADCEx_MultiModeConfigChannel+0x19c>
 8003aea:	687b      	ldr	r3, [r7, #4]
 8003aec:	2201      	movs	r2, #1
 8003aee:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

  tmphadcSlave.State = HAL_ADC_STATE_RESET;
 8003af2:	2300      	movs	r3, #0
 8003af4:	65fb      	str	r3, [r7, #92]	@ 0x5c
  tmphadcSlave.ErrorCode = HAL_ADC_ERROR_NONE;
 8003af6:	2300      	movs	r3, #0
 8003af8:	663b      	str	r3, [r7, #96]	@ 0x60

  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 8003afa:	687b      	ldr	r3, [r7, #4]
 8003afc:	681b      	ldr	r3, [r3, #0]
 8003afe:	4a5c      	ldr	r2, [pc, #368]	@ (8003c70 <HAL_ADCEx_MultiModeConfigChannel+0x1a4>)
 8003b00:	4293      	cmp	r3, r2
 8003b02:	d102      	bne.n	8003b0a <HAL_ADCEx_MultiModeConfigChannel+0x3e>
 8003b04:	4b5b      	ldr	r3, [pc, #364]	@ (8003c74 <HAL_ADCEx_MultiModeConfigChannel+0x1a8>)
 8003b06:	60bb      	str	r3, [r7, #8]
 8003b08:	e001      	b.n	8003b0e <HAL_ADCEx_MultiModeConfigChannel+0x42>
 8003b0a:	2300      	movs	r3, #0
 8003b0c:	60bb      	str	r3, [r7, #8]

  if (tmphadcSlave.Instance == NULL)
 8003b0e:	68bb      	ldr	r3, [r7, #8]
 8003b10:	2b00      	cmp	r3, #0
 8003b12:	d10b      	bne.n	8003b2c <HAL_ADCEx_MultiModeConfigChannel+0x60>
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8003b14:	687b      	ldr	r3, [r7, #4]
 8003b16:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003b18:	f043 0220 	orr.w	r2, r3, #32
 8003b1c:	687b      	ldr	r3, [r7, #4]
 8003b1e:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 8003b20:	687b      	ldr	r3, [r7, #4]
 8003b22:	2200      	movs	r2, #0
 8003b24:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

    return HAL_ERROR;
 8003b28:	2301      	movs	r3, #1
 8003b2a:	e09d      	b.n	8003c68 <HAL_ADCEx_MultiModeConfigChannel+0x19c>

  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Multimode DATA Format configuration                                   */
  tmphadcSlave_conversion_on_going = LL_ADC_REG_IsConversionOngoing((&tmphadcSlave)->Instance);
 8003b2c:	68bb      	ldr	r3, [r7, #8]
 8003b2e:	4618      	mov	r0, r3
 8003b30:	f7ff ff22 	bl	8003978 <LL_ADC_REG_IsConversionOngoing>
 8003b34:	6738      	str	r0, [r7, #112]	@ 0x70
  if ((LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8003b36:	687b      	ldr	r3, [r7, #4]
 8003b38:	681b      	ldr	r3, [r3, #0]
 8003b3a:	4618      	mov	r0, r3
 8003b3c:	f7ff ff1c 	bl	8003978 <LL_ADC_REG_IsConversionOngoing>
 8003b40:	4603      	mov	r3, r0
 8003b42:	2b00      	cmp	r3, #0
 8003b44:	d17f      	bne.n	8003c46 <HAL_ADCEx_MultiModeConfigChannel+0x17a>
      && (tmphadcSlave_conversion_on_going == 0UL))
 8003b46:	6f3b      	ldr	r3, [r7, #112]	@ 0x70
 8003b48:	2b00      	cmp	r3, #0
 8003b4a:	d17c      	bne.n	8003c46 <HAL_ADCEx_MultiModeConfigChannel+0x17a>
  {
    /* Pointer to the common control register */
    tmpADC_Common = __LL_ADC_COMMON_INSTANCE(hadc->Instance);
 8003b4c:	687b      	ldr	r3, [r7, #4]
 8003b4e:	681b      	ldr	r3, [r3, #0]
 8003b50:	4a47      	ldr	r2, [pc, #284]	@ (8003c70 <HAL_ADCEx_MultiModeConfigChannel+0x1a4>)
 8003b52:	4293      	cmp	r3, r2
 8003b54:	d004      	beq.n	8003b60 <HAL_ADCEx_MultiModeConfigChannel+0x94>
 8003b56:	687b      	ldr	r3, [r7, #4]
 8003b58:	681b      	ldr	r3, [r3, #0]
 8003b5a:	4a46      	ldr	r2, [pc, #280]	@ (8003c74 <HAL_ADCEx_MultiModeConfigChannel+0x1a8>)
 8003b5c:	4293      	cmp	r3, r2
 8003b5e:	d101      	bne.n	8003b64 <HAL_ADCEx_MultiModeConfigChannel+0x98>
 8003b60:	4b45      	ldr	r3, [pc, #276]	@ (8003c78 <HAL_ADCEx_MultiModeConfigChannel+0x1ac>)
 8003b62:	e000      	b.n	8003b66 <HAL_ADCEx_MultiModeConfigChannel+0x9a>
 8003b64:	4b45      	ldr	r3, [pc, #276]	@ (8003c7c <HAL_ADCEx_MultiModeConfigChannel+0x1b0>)
 8003b66:	66fb      	str	r3, [r7, #108]	@ 0x6c

    /* If multimode is selected, configure all multimode parameters.          */
    /* Otherwise, reset multimode parameters (can be used in case of          */
    /* transition from multimode to independent mode).                        */
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 8003b68:	683b      	ldr	r3, [r7, #0]
 8003b6a:	681b      	ldr	r3, [r3, #0]
 8003b6c:	2b00      	cmp	r3, #0
 8003b6e:	d039      	beq.n	8003be4 <HAL_ADCEx_MultiModeConfigChannel+0x118>
    {
      MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_DAMDF, multimode->DualModeData);
 8003b70:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8003b72:	689b      	ldr	r3, [r3, #8]
 8003b74:	f423 4240 	bic.w	r2, r3, #49152	@ 0xc000
 8003b78:	683b      	ldr	r3, [r7, #0]
 8003b7a:	685b      	ldr	r3, [r3, #4]
 8003b7c:	431a      	orrs	r2, r3
 8003b7e:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8003b80:	609a      	str	r2, [r3, #8]
      /*      from 1 to 8 clock cycles for 12 bits                              */
      /*      from 1 to 6 clock cycles for 10 and 8 bits                        */
      /*    If a higher delay is selected, it will be clipped to maximum delay  */
      /*    range                                                               */

      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8003b82:	687b      	ldr	r3, [r7, #4]
 8003b84:	681b      	ldr	r3, [r3, #0]
 8003b86:	4a3a      	ldr	r2, [pc, #232]	@ (8003c70 <HAL_ADCEx_MultiModeConfigChannel+0x1a4>)
 8003b88:	4293      	cmp	r3, r2
 8003b8a:	d004      	beq.n	8003b96 <HAL_ADCEx_MultiModeConfigChannel+0xca>
 8003b8c:	687b      	ldr	r3, [r7, #4]
 8003b8e:	681b      	ldr	r3, [r3, #0]
 8003b90:	4a38      	ldr	r2, [pc, #224]	@ (8003c74 <HAL_ADCEx_MultiModeConfigChannel+0x1a8>)
 8003b92:	4293      	cmp	r3, r2
 8003b94:	d10e      	bne.n	8003bb4 <HAL_ADCEx_MultiModeConfigChannel+0xe8>
 8003b96:	4836      	ldr	r0, [pc, #216]	@ (8003c70 <HAL_ADCEx_MultiModeConfigChannel+0x1a4>)
 8003b98:	f7ff fea8 	bl	80038ec <LL_ADC_IsEnabled>
 8003b9c:	4604      	mov	r4, r0
 8003b9e:	4835      	ldr	r0, [pc, #212]	@ (8003c74 <HAL_ADCEx_MultiModeConfigChannel+0x1a8>)
 8003ba0:	f7ff fea4 	bl	80038ec <LL_ADC_IsEnabled>
 8003ba4:	4603      	mov	r3, r0
 8003ba6:	4323      	orrs	r3, r4
 8003ba8:	2b00      	cmp	r3, #0
 8003baa:	bf0c      	ite	eq
 8003bac:	2301      	moveq	r3, #1
 8003bae:	2300      	movne	r3, #0
 8003bb0:	b2db      	uxtb	r3, r3
 8003bb2:	e008      	b.n	8003bc6 <HAL_ADCEx_MultiModeConfigChannel+0xfa>
 8003bb4:	4832      	ldr	r0, [pc, #200]	@ (8003c80 <HAL_ADCEx_MultiModeConfigChannel+0x1b4>)
 8003bb6:	f7ff fe99 	bl	80038ec <LL_ADC_IsEnabled>
 8003bba:	4603      	mov	r3, r0
 8003bbc:	2b00      	cmp	r3, #0
 8003bbe:	bf0c      	ite	eq
 8003bc0:	2301      	moveq	r3, #1
 8003bc2:	2300      	movne	r3, #0
 8003bc4:	b2db      	uxtb	r3, r3
 8003bc6:	2b00      	cmp	r3, #0
 8003bc8:	d047      	beq.n	8003c5a <HAL_ADCEx_MultiModeConfigChannel+0x18e>
      {
        MODIFY_REG(tmpADC_Common->CCR,
 8003bca:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8003bcc:	689a      	ldr	r2, [r3, #8]
 8003bce:	4b2d      	ldr	r3, [pc, #180]	@ (8003c84 <HAL_ADCEx_MultiModeConfigChannel+0x1b8>)
 8003bd0:	4013      	ands	r3, r2
 8003bd2:	683a      	ldr	r2, [r7, #0]
 8003bd4:	6811      	ldr	r1, [r2, #0]
 8003bd6:	683a      	ldr	r2, [r7, #0]
 8003bd8:	6892      	ldr	r2, [r2, #8]
 8003bda:	430a      	orrs	r2, r1
 8003bdc:	431a      	orrs	r2, r3
 8003bde:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8003be0:	609a      	str	r2, [r3, #8]
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 8003be2:	e03a      	b.n	8003c5a <HAL_ADCEx_MultiModeConfigChannel+0x18e>
                  );
      }
    }
    else /* ADC_MODE_INDEPENDENT */
    {
      CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DAMDF);
 8003be4:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8003be6:	689b      	ldr	r3, [r3, #8]
 8003be8:	f423 4240 	bic.w	r2, r3, #49152	@ 0xc000
 8003bec:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8003bee:	609a      	str	r2, [r3, #8]

      /* Parameters that can be updated only when ADC is disabled:                */
      /*  - Multimode mode selection                                              */
      /*  - Multimode delay                                                       */
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8003bf0:	687b      	ldr	r3, [r7, #4]
 8003bf2:	681b      	ldr	r3, [r3, #0]
 8003bf4:	4a1e      	ldr	r2, [pc, #120]	@ (8003c70 <HAL_ADCEx_MultiModeConfigChannel+0x1a4>)
 8003bf6:	4293      	cmp	r3, r2
 8003bf8:	d004      	beq.n	8003c04 <HAL_ADCEx_MultiModeConfigChannel+0x138>
 8003bfa:	687b      	ldr	r3, [r7, #4]
 8003bfc:	681b      	ldr	r3, [r3, #0]
 8003bfe:	4a1d      	ldr	r2, [pc, #116]	@ (8003c74 <HAL_ADCEx_MultiModeConfigChannel+0x1a8>)
 8003c00:	4293      	cmp	r3, r2
 8003c02:	d10e      	bne.n	8003c22 <HAL_ADCEx_MultiModeConfigChannel+0x156>
 8003c04:	481a      	ldr	r0, [pc, #104]	@ (8003c70 <HAL_ADCEx_MultiModeConfigChannel+0x1a4>)
 8003c06:	f7ff fe71 	bl	80038ec <LL_ADC_IsEnabled>
 8003c0a:	4604      	mov	r4, r0
 8003c0c:	4819      	ldr	r0, [pc, #100]	@ (8003c74 <HAL_ADCEx_MultiModeConfigChannel+0x1a8>)
 8003c0e:	f7ff fe6d 	bl	80038ec <LL_ADC_IsEnabled>
 8003c12:	4603      	mov	r3, r0
 8003c14:	4323      	orrs	r3, r4
 8003c16:	2b00      	cmp	r3, #0
 8003c18:	bf0c      	ite	eq
 8003c1a:	2301      	moveq	r3, #1
 8003c1c:	2300      	movne	r3, #0
 8003c1e:	b2db      	uxtb	r3, r3
 8003c20:	e008      	b.n	8003c34 <HAL_ADCEx_MultiModeConfigChannel+0x168>
 8003c22:	4817      	ldr	r0, [pc, #92]	@ (8003c80 <HAL_ADCEx_MultiModeConfigChannel+0x1b4>)
 8003c24:	f7ff fe62 	bl	80038ec <LL_ADC_IsEnabled>
 8003c28:	4603      	mov	r3, r0
 8003c2a:	2b00      	cmp	r3, #0
 8003c2c:	bf0c      	ite	eq
 8003c2e:	2301      	moveq	r3, #1
 8003c30:	2300      	movne	r3, #0
 8003c32:	b2db      	uxtb	r3, r3
 8003c34:	2b00      	cmp	r3, #0
 8003c36:	d010      	beq.n	8003c5a <HAL_ADCEx_MultiModeConfigChannel+0x18e>
      {
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
 8003c38:	6efb      	ldr	r3, [r7, #108]	@ 0x6c
 8003c3a:	689a      	ldr	r2, [r3, #8]
 8003c3c:	4b11      	ldr	r3, [pc, #68]	@ (8003c84 <HAL_ADCEx_MultiModeConfigChannel+0x1b8>)
 8003c3e:	4013      	ands	r3, r2
 8003c40:	6efa      	ldr	r2, [r7, #108]	@ 0x6c
 8003c42:	6093      	str	r3, [r2, #8]
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 8003c44:	e009      	b.n	8003c5a <HAL_ADCEx_MultiModeConfigChannel+0x18e>
  /* If one of the ADC sharing the same common group is enabled, no update    */
  /* could be done on neither of the multimode structure parameters.          */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8003c46:	687b      	ldr	r3, [r7, #4]
 8003c48:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8003c4a:	f043 0220 	orr.w	r2, r3, #32
 8003c4e:	687b      	ldr	r3, [r7, #4]
 8003c50:	655a      	str	r2, [r3, #84]	@ 0x54

    tmp_hal_status = HAL_ERROR;
 8003c52:	2301      	movs	r3, #1
 8003c54:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
 8003c58:	e000      	b.n	8003c5c <HAL_ADCEx_MultiModeConfigChannel+0x190>
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 8003c5a:	bf00      	nop
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8003c5c:	687b      	ldr	r3, [r7, #4]
 8003c5e:	2200      	movs	r2, #0
 8003c60:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50

  /* Return function status */
  return tmp_hal_status;
 8003c64:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
}
 8003c68:	4618      	mov	r0, r3
 8003c6a:	377c      	adds	r7, #124	@ 0x7c
 8003c6c:	46bd      	mov	sp, r7
 8003c6e:	bd90      	pop	{r4, r7, pc}
 8003c70:	40022000 	.word	0x40022000
 8003c74:	40022100 	.word	0x40022100
 8003c78:	40022300 	.word	0x40022300
 8003c7c:	58026300 	.word	0x58026300
 8003c80:	58026000 	.word	0x58026000
 8003c84:	fffff0e0 	.word	0xfffff0e0

08003c88 <__NVIC_SetPriorityGrouping>:
{
 8003c88:	b480      	push	{r7}
 8003c8a:	b085      	sub	sp, #20
 8003c8c:	af00      	add	r7, sp, #0
 8003c8e:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8003c90:	687b      	ldr	r3, [r7, #4]
 8003c92:	f003 0307 	and.w	r3, r3, #7
 8003c96:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8003c98:	4b0b      	ldr	r3, [pc, #44]	@ (8003cc8 <__NVIC_SetPriorityGrouping+0x40>)
 8003c9a:	68db      	ldr	r3, [r3, #12]
 8003c9c:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8003c9e:	68ba      	ldr	r2, [r7, #8]
 8003ca0:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 8003ca4:	4013      	ands	r3, r2
 8003ca6:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8003ca8:	68fb      	ldr	r3, [r7, #12]
 8003caa:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8003cac:	68bb      	ldr	r3, [r7, #8]
 8003cae:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
 8003cb0:	4b06      	ldr	r3, [pc, #24]	@ (8003ccc <__NVIC_SetPriorityGrouping+0x44>)
 8003cb2:	4313      	orrs	r3, r2
 8003cb4:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8003cb6:	4a04      	ldr	r2, [pc, #16]	@ (8003cc8 <__NVIC_SetPriorityGrouping+0x40>)
 8003cb8:	68bb      	ldr	r3, [r7, #8]
 8003cba:	60d3      	str	r3, [r2, #12]
}
 8003cbc:	bf00      	nop
 8003cbe:	3714      	adds	r7, #20
 8003cc0:	46bd      	mov	sp, r7
 8003cc2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003cc6:	4770      	bx	lr
 8003cc8:	e000ed00 	.word	0xe000ed00
 8003ccc:	05fa0000 	.word	0x05fa0000

08003cd0 <__NVIC_GetPriorityGrouping>:
{
 8003cd0:	b480      	push	{r7}
 8003cd2:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8003cd4:	4b04      	ldr	r3, [pc, #16]	@ (8003ce8 <__NVIC_GetPriorityGrouping+0x18>)
 8003cd6:	68db      	ldr	r3, [r3, #12]
 8003cd8:	0a1b      	lsrs	r3, r3, #8
 8003cda:	f003 0307 	and.w	r3, r3, #7
}
 8003cde:	4618      	mov	r0, r3
 8003ce0:	46bd      	mov	sp, r7
 8003ce2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003ce6:	4770      	bx	lr
 8003ce8:	e000ed00 	.word	0xe000ed00

08003cec <__NVIC_EnableIRQ>:
{
 8003cec:	b480      	push	{r7}
 8003cee:	b083      	sub	sp, #12
 8003cf0:	af00      	add	r7, sp, #0
 8003cf2:	4603      	mov	r3, r0
 8003cf4:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 8003cf6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003cfa:	2b00      	cmp	r3, #0
 8003cfc:	db0b      	blt.n	8003d16 <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8003cfe:	88fb      	ldrh	r3, [r7, #6]
 8003d00:	f003 021f 	and.w	r2, r3, #31
 8003d04:	4907      	ldr	r1, [pc, #28]	@ (8003d24 <__NVIC_EnableIRQ+0x38>)
 8003d06:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003d0a:	095b      	lsrs	r3, r3, #5
 8003d0c:	2001      	movs	r0, #1
 8003d0e:	fa00 f202 	lsl.w	r2, r0, r2
 8003d12:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8003d16:	bf00      	nop
 8003d18:	370c      	adds	r7, #12
 8003d1a:	46bd      	mov	sp, r7
 8003d1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d20:	4770      	bx	lr
 8003d22:	bf00      	nop
 8003d24:	e000e100 	.word	0xe000e100

08003d28 <__NVIC_SetPriority>:
{
 8003d28:	b480      	push	{r7}
 8003d2a:	b083      	sub	sp, #12
 8003d2c:	af00      	add	r7, sp, #0
 8003d2e:	4603      	mov	r3, r0
 8003d30:	6039      	str	r1, [r7, #0]
 8003d32:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 8003d34:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003d38:	2b00      	cmp	r3, #0
 8003d3a:	db0a      	blt.n	8003d52 <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003d3c:	683b      	ldr	r3, [r7, #0]
 8003d3e:	b2da      	uxtb	r2, r3
 8003d40:	490c      	ldr	r1, [pc, #48]	@ (8003d74 <__NVIC_SetPriority+0x4c>)
 8003d42:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003d46:	0112      	lsls	r2, r2, #4
 8003d48:	b2d2      	uxtb	r2, r2
 8003d4a:	440b      	add	r3, r1
 8003d4c:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
}
 8003d50:	e00a      	b.n	8003d68 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003d52:	683b      	ldr	r3, [r7, #0]
 8003d54:	b2da      	uxtb	r2, r3
 8003d56:	4908      	ldr	r1, [pc, #32]	@ (8003d78 <__NVIC_SetPriority+0x50>)
 8003d58:	88fb      	ldrh	r3, [r7, #6]
 8003d5a:	f003 030f 	and.w	r3, r3, #15
 8003d5e:	3b04      	subs	r3, #4
 8003d60:	0112      	lsls	r2, r2, #4
 8003d62:	b2d2      	uxtb	r2, r2
 8003d64:	440b      	add	r3, r1
 8003d66:	761a      	strb	r2, [r3, #24]
}
 8003d68:	bf00      	nop
 8003d6a:	370c      	adds	r7, #12
 8003d6c:	46bd      	mov	sp, r7
 8003d6e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d72:	4770      	bx	lr
 8003d74:	e000e100 	.word	0xe000e100
 8003d78:	e000ed00 	.word	0xe000ed00

08003d7c <NVIC_EncodePriority>:
{
 8003d7c:	b480      	push	{r7}
 8003d7e:	b089      	sub	sp, #36	@ 0x24
 8003d80:	af00      	add	r7, sp, #0
 8003d82:	60f8      	str	r0, [r7, #12]
 8003d84:	60b9      	str	r1, [r7, #8]
 8003d86:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8003d88:	68fb      	ldr	r3, [r7, #12]
 8003d8a:	f003 0307 	and.w	r3, r3, #7
 8003d8e:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8003d90:	69fb      	ldr	r3, [r7, #28]
 8003d92:	f1c3 0307 	rsb	r3, r3, #7
 8003d96:	2b04      	cmp	r3, #4
 8003d98:	bf28      	it	cs
 8003d9a:	2304      	movcs	r3, #4
 8003d9c:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8003d9e:	69fb      	ldr	r3, [r7, #28]
 8003da0:	3304      	adds	r3, #4
 8003da2:	2b06      	cmp	r3, #6
 8003da4:	d902      	bls.n	8003dac <NVIC_EncodePriority+0x30>
 8003da6:	69fb      	ldr	r3, [r7, #28]
 8003da8:	3b03      	subs	r3, #3
 8003daa:	e000      	b.n	8003dae <NVIC_EncodePriority+0x32>
 8003dac:	2300      	movs	r3, #0
 8003dae:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8003db0:	f04f 32ff 	mov.w	r2, #4294967295
 8003db4:	69bb      	ldr	r3, [r7, #24]
 8003db6:	fa02 f303 	lsl.w	r3, r2, r3
 8003dba:	43da      	mvns	r2, r3
 8003dbc:	68bb      	ldr	r3, [r7, #8]
 8003dbe:	401a      	ands	r2, r3
 8003dc0:	697b      	ldr	r3, [r7, #20]
 8003dc2:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8003dc4:	f04f 31ff 	mov.w	r1, #4294967295
 8003dc8:	697b      	ldr	r3, [r7, #20]
 8003dca:	fa01 f303 	lsl.w	r3, r1, r3
 8003dce:	43d9      	mvns	r1, r3
 8003dd0:	687b      	ldr	r3, [r7, #4]
 8003dd2:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8003dd4:	4313      	orrs	r3, r2
}
 8003dd6:	4618      	mov	r0, r3
 8003dd8:	3724      	adds	r7, #36	@ 0x24
 8003dda:	46bd      	mov	sp, r7
 8003ddc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003de0:	4770      	bx	lr

08003de2 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8003de2:	b580      	push	{r7, lr}
 8003de4:	b082      	sub	sp, #8
 8003de6:	af00      	add	r7, sp, #0
 8003de8:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8003dea:	6878      	ldr	r0, [r7, #4]
 8003dec:	f7ff ff4c 	bl	8003c88 <__NVIC_SetPriorityGrouping>
}
 8003df0:	bf00      	nop
 8003df2:	3708      	adds	r7, #8
 8003df4:	46bd      	mov	sp, r7
 8003df6:	bd80      	pop	{r7, pc}

08003df8 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8003df8:	b580      	push	{r7, lr}
 8003dfa:	b086      	sub	sp, #24
 8003dfc:	af00      	add	r7, sp, #0
 8003dfe:	4603      	mov	r3, r0
 8003e00:	60b9      	str	r1, [r7, #8]
 8003e02:	607a      	str	r2, [r7, #4]
 8003e04:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 8003e06:	f7ff ff63 	bl	8003cd0 <__NVIC_GetPriorityGrouping>
 8003e0a:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8003e0c:	687a      	ldr	r2, [r7, #4]
 8003e0e:	68b9      	ldr	r1, [r7, #8]
 8003e10:	6978      	ldr	r0, [r7, #20]
 8003e12:	f7ff ffb3 	bl	8003d7c <NVIC_EncodePriority>
 8003e16:	4602      	mov	r2, r0
 8003e18:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8003e1c:	4611      	mov	r1, r2
 8003e1e:	4618      	mov	r0, r3
 8003e20:	f7ff ff82 	bl	8003d28 <__NVIC_SetPriority>
}
 8003e24:	bf00      	nop
 8003e26:	3718      	adds	r7, #24
 8003e28:	46bd      	mov	sp, r7
 8003e2a:	bd80      	pop	{r7, pc}

08003e2c <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8003e2c:	b580      	push	{r7, lr}
 8003e2e:	b082      	sub	sp, #8
 8003e30:	af00      	add	r7, sp, #0
 8003e32:	4603      	mov	r3, r0
 8003e34:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8003e36:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003e3a:	4618      	mov	r0, r3
 8003e3c:	f7ff ff56 	bl	8003cec <__NVIC_EnableIRQ>
}
 8003e40:	bf00      	nop
 8003e42:	3708      	adds	r7, #8
 8003e44:	46bd      	mov	sp, r7
 8003e46:	bd80      	pop	{r7, pc}

08003e48 <HAL_GetCurrentCPUID>:
/**
  * @brief  Returns the current CPU ID.
  * @retval CPU identifier
  */
uint32_t HAL_GetCurrentCPUID(void)
{
 8003e48:	b480      	push	{r7}
 8003e4a:	af00      	add	r7, sp, #0
  if (((SCB->CPUID & 0x000000F0U) >> 4 )== 0x7U)
 8003e4c:	4b07      	ldr	r3, [pc, #28]	@ (8003e6c <HAL_GetCurrentCPUID+0x24>)
 8003e4e:	681b      	ldr	r3, [r3, #0]
 8003e50:	091b      	lsrs	r3, r3, #4
 8003e52:	f003 030f 	and.w	r3, r3, #15
 8003e56:	2b07      	cmp	r3, #7
 8003e58:	d101      	bne.n	8003e5e <HAL_GetCurrentCPUID+0x16>
  {
    return  CM7_CPUID;
 8003e5a:	2303      	movs	r3, #3
 8003e5c:	e000      	b.n	8003e60 <HAL_GetCurrentCPUID+0x18>
  }
  else
  {
    return CM4_CPUID;
 8003e5e:	2301      	movs	r3, #1
  }
}
 8003e60:	4618      	mov	r0, r3
 8003e62:	46bd      	mov	sp, r7
 8003e64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003e68:	4770      	bx	lr
 8003e6a:	bf00      	nop
 8003e6c:	e000ed00 	.word	0xe000ed00

08003e70 <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 8003e70:	b580      	push	{r7, lr}
 8003e72:	b086      	sub	sp, #24
 8003e74:	af00      	add	r7, sp, #0
 8003e76:	6078      	str	r0, [r7, #4]
  uint32_t registerValue;
  uint32_t tickstart = HAL_GetTick();
 8003e78:	f7fe f87c 	bl	8001f74 <HAL_GetTick>
 8003e7c:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs_dma;
  BDMA_Base_Registers *regs_bdma;

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
 8003e7e:	687b      	ldr	r3, [r7, #4]
 8003e80:	2b00      	cmp	r3, #0
 8003e82:	d101      	bne.n	8003e88 <HAL_DMA_Init+0x18>
  {
    return HAL_ERROR;
 8003e84:	2301      	movs	r3, #1
 8003e86:	e316      	b.n	80044b6 <HAL_DMA_Init+0x646>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8003e88:	687b      	ldr	r3, [r7, #4]
 8003e8a:	681b      	ldr	r3, [r3, #0]
 8003e8c:	4a66      	ldr	r2, [pc, #408]	@ (8004028 <HAL_DMA_Init+0x1b8>)
 8003e8e:	4293      	cmp	r3, r2
 8003e90:	d04a      	beq.n	8003f28 <HAL_DMA_Init+0xb8>
 8003e92:	687b      	ldr	r3, [r7, #4]
 8003e94:	681b      	ldr	r3, [r3, #0]
 8003e96:	4a65      	ldr	r2, [pc, #404]	@ (800402c <HAL_DMA_Init+0x1bc>)
 8003e98:	4293      	cmp	r3, r2
 8003e9a:	d045      	beq.n	8003f28 <HAL_DMA_Init+0xb8>
 8003e9c:	687b      	ldr	r3, [r7, #4]
 8003e9e:	681b      	ldr	r3, [r3, #0]
 8003ea0:	4a63      	ldr	r2, [pc, #396]	@ (8004030 <HAL_DMA_Init+0x1c0>)
 8003ea2:	4293      	cmp	r3, r2
 8003ea4:	d040      	beq.n	8003f28 <HAL_DMA_Init+0xb8>
 8003ea6:	687b      	ldr	r3, [r7, #4]
 8003ea8:	681b      	ldr	r3, [r3, #0]
 8003eaa:	4a62      	ldr	r2, [pc, #392]	@ (8004034 <HAL_DMA_Init+0x1c4>)
 8003eac:	4293      	cmp	r3, r2
 8003eae:	d03b      	beq.n	8003f28 <HAL_DMA_Init+0xb8>
 8003eb0:	687b      	ldr	r3, [r7, #4]
 8003eb2:	681b      	ldr	r3, [r3, #0]
 8003eb4:	4a60      	ldr	r2, [pc, #384]	@ (8004038 <HAL_DMA_Init+0x1c8>)
 8003eb6:	4293      	cmp	r3, r2
 8003eb8:	d036      	beq.n	8003f28 <HAL_DMA_Init+0xb8>
 8003eba:	687b      	ldr	r3, [r7, #4]
 8003ebc:	681b      	ldr	r3, [r3, #0]
 8003ebe:	4a5f      	ldr	r2, [pc, #380]	@ (800403c <HAL_DMA_Init+0x1cc>)
 8003ec0:	4293      	cmp	r3, r2
 8003ec2:	d031      	beq.n	8003f28 <HAL_DMA_Init+0xb8>
 8003ec4:	687b      	ldr	r3, [r7, #4]
 8003ec6:	681b      	ldr	r3, [r3, #0]
 8003ec8:	4a5d      	ldr	r2, [pc, #372]	@ (8004040 <HAL_DMA_Init+0x1d0>)
 8003eca:	4293      	cmp	r3, r2
 8003ecc:	d02c      	beq.n	8003f28 <HAL_DMA_Init+0xb8>
 8003ece:	687b      	ldr	r3, [r7, #4]
 8003ed0:	681b      	ldr	r3, [r3, #0]
 8003ed2:	4a5c      	ldr	r2, [pc, #368]	@ (8004044 <HAL_DMA_Init+0x1d4>)
 8003ed4:	4293      	cmp	r3, r2
 8003ed6:	d027      	beq.n	8003f28 <HAL_DMA_Init+0xb8>
 8003ed8:	687b      	ldr	r3, [r7, #4]
 8003eda:	681b      	ldr	r3, [r3, #0]
 8003edc:	4a5a      	ldr	r2, [pc, #360]	@ (8004048 <HAL_DMA_Init+0x1d8>)
 8003ede:	4293      	cmp	r3, r2
 8003ee0:	d022      	beq.n	8003f28 <HAL_DMA_Init+0xb8>
 8003ee2:	687b      	ldr	r3, [r7, #4]
 8003ee4:	681b      	ldr	r3, [r3, #0]
 8003ee6:	4a59      	ldr	r2, [pc, #356]	@ (800404c <HAL_DMA_Init+0x1dc>)
 8003ee8:	4293      	cmp	r3, r2
 8003eea:	d01d      	beq.n	8003f28 <HAL_DMA_Init+0xb8>
 8003eec:	687b      	ldr	r3, [r7, #4]
 8003eee:	681b      	ldr	r3, [r3, #0]
 8003ef0:	4a57      	ldr	r2, [pc, #348]	@ (8004050 <HAL_DMA_Init+0x1e0>)
 8003ef2:	4293      	cmp	r3, r2
 8003ef4:	d018      	beq.n	8003f28 <HAL_DMA_Init+0xb8>
 8003ef6:	687b      	ldr	r3, [r7, #4]
 8003ef8:	681b      	ldr	r3, [r3, #0]
 8003efa:	4a56      	ldr	r2, [pc, #344]	@ (8004054 <HAL_DMA_Init+0x1e4>)
 8003efc:	4293      	cmp	r3, r2
 8003efe:	d013      	beq.n	8003f28 <HAL_DMA_Init+0xb8>
 8003f00:	687b      	ldr	r3, [r7, #4]
 8003f02:	681b      	ldr	r3, [r3, #0]
 8003f04:	4a54      	ldr	r2, [pc, #336]	@ (8004058 <HAL_DMA_Init+0x1e8>)
 8003f06:	4293      	cmp	r3, r2
 8003f08:	d00e      	beq.n	8003f28 <HAL_DMA_Init+0xb8>
 8003f0a:	687b      	ldr	r3, [r7, #4]
 8003f0c:	681b      	ldr	r3, [r3, #0]
 8003f0e:	4a53      	ldr	r2, [pc, #332]	@ (800405c <HAL_DMA_Init+0x1ec>)
 8003f10:	4293      	cmp	r3, r2
 8003f12:	d009      	beq.n	8003f28 <HAL_DMA_Init+0xb8>
 8003f14:	687b      	ldr	r3, [r7, #4]
 8003f16:	681b      	ldr	r3, [r3, #0]
 8003f18:	4a51      	ldr	r2, [pc, #324]	@ (8004060 <HAL_DMA_Init+0x1f0>)
 8003f1a:	4293      	cmp	r3, r2
 8003f1c:	d004      	beq.n	8003f28 <HAL_DMA_Init+0xb8>
 8003f1e:	687b      	ldr	r3, [r7, #4]
 8003f20:	681b      	ldr	r3, [r3, #0]
 8003f22:	4a50      	ldr	r2, [pc, #320]	@ (8004064 <HAL_DMA_Init+0x1f4>)
 8003f24:	4293      	cmp	r3, r2
 8003f26:	d101      	bne.n	8003f2c <HAL_DMA_Init+0xbc>
 8003f28:	2301      	movs	r3, #1
 8003f2a:	e000      	b.n	8003f2e <HAL_DMA_Init+0xbe>
 8003f2c:	2300      	movs	r3, #0
 8003f2e:	2b00      	cmp	r3, #0
 8003f30:	f000 813b 	beq.w	80041aa <HAL_DMA_Init+0x33a>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
    }

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 8003f34:	687b      	ldr	r3, [r7, #4]
 8003f36:	2202      	movs	r2, #2
 8003f38:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
 8003f3c:	687b      	ldr	r3, [r7, #4]
 8003f3e:	2200      	movs	r2, #0
 8003f40:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
 8003f44:	687b      	ldr	r3, [r7, #4]
 8003f46:	681b      	ldr	r3, [r3, #0]
 8003f48:	4a37      	ldr	r2, [pc, #220]	@ (8004028 <HAL_DMA_Init+0x1b8>)
 8003f4a:	4293      	cmp	r3, r2
 8003f4c:	d04a      	beq.n	8003fe4 <HAL_DMA_Init+0x174>
 8003f4e:	687b      	ldr	r3, [r7, #4]
 8003f50:	681b      	ldr	r3, [r3, #0]
 8003f52:	4a36      	ldr	r2, [pc, #216]	@ (800402c <HAL_DMA_Init+0x1bc>)
 8003f54:	4293      	cmp	r3, r2
 8003f56:	d045      	beq.n	8003fe4 <HAL_DMA_Init+0x174>
 8003f58:	687b      	ldr	r3, [r7, #4]
 8003f5a:	681b      	ldr	r3, [r3, #0]
 8003f5c:	4a34      	ldr	r2, [pc, #208]	@ (8004030 <HAL_DMA_Init+0x1c0>)
 8003f5e:	4293      	cmp	r3, r2
 8003f60:	d040      	beq.n	8003fe4 <HAL_DMA_Init+0x174>
 8003f62:	687b      	ldr	r3, [r7, #4]
 8003f64:	681b      	ldr	r3, [r3, #0]
 8003f66:	4a33      	ldr	r2, [pc, #204]	@ (8004034 <HAL_DMA_Init+0x1c4>)
 8003f68:	4293      	cmp	r3, r2
 8003f6a:	d03b      	beq.n	8003fe4 <HAL_DMA_Init+0x174>
 8003f6c:	687b      	ldr	r3, [r7, #4]
 8003f6e:	681b      	ldr	r3, [r3, #0]
 8003f70:	4a31      	ldr	r2, [pc, #196]	@ (8004038 <HAL_DMA_Init+0x1c8>)
 8003f72:	4293      	cmp	r3, r2
 8003f74:	d036      	beq.n	8003fe4 <HAL_DMA_Init+0x174>
 8003f76:	687b      	ldr	r3, [r7, #4]
 8003f78:	681b      	ldr	r3, [r3, #0]
 8003f7a:	4a30      	ldr	r2, [pc, #192]	@ (800403c <HAL_DMA_Init+0x1cc>)
 8003f7c:	4293      	cmp	r3, r2
 8003f7e:	d031      	beq.n	8003fe4 <HAL_DMA_Init+0x174>
 8003f80:	687b      	ldr	r3, [r7, #4]
 8003f82:	681b      	ldr	r3, [r3, #0]
 8003f84:	4a2e      	ldr	r2, [pc, #184]	@ (8004040 <HAL_DMA_Init+0x1d0>)
 8003f86:	4293      	cmp	r3, r2
 8003f88:	d02c      	beq.n	8003fe4 <HAL_DMA_Init+0x174>
 8003f8a:	687b      	ldr	r3, [r7, #4]
 8003f8c:	681b      	ldr	r3, [r3, #0]
 8003f8e:	4a2d      	ldr	r2, [pc, #180]	@ (8004044 <HAL_DMA_Init+0x1d4>)
 8003f90:	4293      	cmp	r3, r2
 8003f92:	d027      	beq.n	8003fe4 <HAL_DMA_Init+0x174>
 8003f94:	687b      	ldr	r3, [r7, #4]
 8003f96:	681b      	ldr	r3, [r3, #0]
 8003f98:	4a2b      	ldr	r2, [pc, #172]	@ (8004048 <HAL_DMA_Init+0x1d8>)
 8003f9a:	4293      	cmp	r3, r2
 8003f9c:	d022      	beq.n	8003fe4 <HAL_DMA_Init+0x174>
 8003f9e:	687b      	ldr	r3, [r7, #4]
 8003fa0:	681b      	ldr	r3, [r3, #0]
 8003fa2:	4a2a      	ldr	r2, [pc, #168]	@ (800404c <HAL_DMA_Init+0x1dc>)
 8003fa4:	4293      	cmp	r3, r2
 8003fa6:	d01d      	beq.n	8003fe4 <HAL_DMA_Init+0x174>
 8003fa8:	687b      	ldr	r3, [r7, #4]
 8003faa:	681b      	ldr	r3, [r3, #0]
 8003fac:	4a28      	ldr	r2, [pc, #160]	@ (8004050 <HAL_DMA_Init+0x1e0>)
 8003fae:	4293      	cmp	r3, r2
 8003fb0:	d018      	beq.n	8003fe4 <HAL_DMA_Init+0x174>
 8003fb2:	687b      	ldr	r3, [r7, #4]
 8003fb4:	681b      	ldr	r3, [r3, #0]
 8003fb6:	4a27      	ldr	r2, [pc, #156]	@ (8004054 <HAL_DMA_Init+0x1e4>)
 8003fb8:	4293      	cmp	r3, r2
 8003fba:	d013      	beq.n	8003fe4 <HAL_DMA_Init+0x174>
 8003fbc:	687b      	ldr	r3, [r7, #4]
 8003fbe:	681b      	ldr	r3, [r3, #0]
 8003fc0:	4a25      	ldr	r2, [pc, #148]	@ (8004058 <HAL_DMA_Init+0x1e8>)
 8003fc2:	4293      	cmp	r3, r2
 8003fc4:	d00e      	beq.n	8003fe4 <HAL_DMA_Init+0x174>
 8003fc6:	687b      	ldr	r3, [r7, #4]
 8003fc8:	681b      	ldr	r3, [r3, #0]
 8003fca:	4a24      	ldr	r2, [pc, #144]	@ (800405c <HAL_DMA_Init+0x1ec>)
 8003fcc:	4293      	cmp	r3, r2
 8003fce:	d009      	beq.n	8003fe4 <HAL_DMA_Init+0x174>
 8003fd0:	687b      	ldr	r3, [r7, #4]
 8003fd2:	681b      	ldr	r3, [r3, #0]
 8003fd4:	4a22      	ldr	r2, [pc, #136]	@ (8004060 <HAL_DMA_Init+0x1f0>)
 8003fd6:	4293      	cmp	r3, r2
 8003fd8:	d004      	beq.n	8003fe4 <HAL_DMA_Init+0x174>
 8003fda:	687b      	ldr	r3, [r7, #4]
 8003fdc:	681b      	ldr	r3, [r3, #0]
 8003fde:	4a21      	ldr	r2, [pc, #132]	@ (8004064 <HAL_DMA_Init+0x1f4>)
 8003fe0:	4293      	cmp	r3, r2
 8003fe2:	d108      	bne.n	8003ff6 <HAL_DMA_Init+0x186>
 8003fe4:	687b      	ldr	r3, [r7, #4]
 8003fe6:	681b      	ldr	r3, [r3, #0]
 8003fe8:	681a      	ldr	r2, [r3, #0]
 8003fea:	687b      	ldr	r3, [r7, #4]
 8003fec:	681b      	ldr	r3, [r3, #0]
 8003fee:	f022 0201 	bic.w	r2, r2, #1
 8003ff2:	601a      	str	r2, [r3, #0]
 8003ff4:	e007      	b.n	8004006 <HAL_DMA_Init+0x196>
 8003ff6:	687b      	ldr	r3, [r7, #4]
 8003ff8:	681b      	ldr	r3, [r3, #0]
 8003ffa:	681a      	ldr	r2, [r3, #0]
 8003ffc:	687b      	ldr	r3, [r7, #4]
 8003ffe:	681b      	ldr	r3, [r3, #0]
 8004000:	f022 0201 	bic.w	r2, r2, #1
 8004004:	601a      	str	r2, [r3, #0]

    /* Check if the DMA Stream is effectively disabled */
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
 8004006:	e02f      	b.n	8004068 <HAL_DMA_Init+0x1f8>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8004008:	f7fd ffb4 	bl	8001f74 <HAL_GetTick>
 800400c:	4602      	mov	r2, r0
 800400e:	693b      	ldr	r3, [r7, #16]
 8004010:	1ad3      	subs	r3, r2, r3
 8004012:	2b05      	cmp	r3, #5
 8004014:	d928      	bls.n	8004068 <HAL_DMA_Init+0x1f8>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8004016:	687b      	ldr	r3, [r7, #4]
 8004018:	2220      	movs	r2, #32
 800401a:	655a      	str	r2, [r3, #84]	@ 0x54

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_ERROR;
 800401c:	687b      	ldr	r3, [r7, #4]
 800401e:	2203      	movs	r2, #3
 8004020:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

        return HAL_ERROR;
 8004024:	2301      	movs	r3, #1
 8004026:	e246      	b.n	80044b6 <HAL_DMA_Init+0x646>
 8004028:	40020010 	.word	0x40020010
 800402c:	40020028 	.word	0x40020028
 8004030:	40020040 	.word	0x40020040
 8004034:	40020058 	.word	0x40020058
 8004038:	40020070 	.word	0x40020070
 800403c:	40020088 	.word	0x40020088
 8004040:	400200a0 	.word	0x400200a0
 8004044:	400200b8 	.word	0x400200b8
 8004048:	40020410 	.word	0x40020410
 800404c:	40020428 	.word	0x40020428
 8004050:	40020440 	.word	0x40020440
 8004054:	40020458 	.word	0x40020458
 8004058:	40020470 	.word	0x40020470
 800405c:	40020488 	.word	0x40020488
 8004060:	400204a0 	.word	0x400204a0
 8004064:	400204b8 	.word	0x400204b8
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
 8004068:	687b      	ldr	r3, [r7, #4]
 800406a:	681b      	ldr	r3, [r3, #0]
 800406c:	681b      	ldr	r3, [r3, #0]
 800406e:	f003 0301 	and.w	r3, r3, #1
 8004072:	2b00      	cmp	r3, #0
 8004074:	d1c8      	bne.n	8004008 <HAL_DMA_Init+0x198>
      }
    }

    /* Get the CR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;
 8004076:	687b      	ldr	r3, [r7, #4]
 8004078:	681b      	ldr	r3, [r3, #0]
 800407a:	681b      	ldr	r3, [r3, #0]
 800407c:	617b      	str	r3, [r7, #20]

    /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 800407e:	697a      	ldr	r2, [r7, #20]
 8004080:	4b83      	ldr	r3, [pc, #524]	@ (8004290 <HAL_DMA_Init+0x420>)
 8004082:	4013      	ands	r3, r2
 8004084:	617b      	str	r3, [r7, #20]
                        DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                        DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                        DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

    /* Prepare the DMA Stream configuration */
    registerValue |=  hdma->Init.Direction           |
 8004086:	687b      	ldr	r3, [r7, #4]
 8004088:	689a      	ldr	r2, [r3, #8]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800408a:	687b      	ldr	r3, [r7, #4]
 800408c:	68db      	ldr	r3, [r3, #12]
    registerValue |=  hdma->Init.Direction           |
 800408e:	431a      	orrs	r2, r3
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8004090:	687b      	ldr	r3, [r7, #4]
 8004092:	691b      	ldr	r3, [r3, #16]
 8004094:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8004096:	687b      	ldr	r3, [r7, #4]
 8004098:	695b      	ldr	r3, [r3, #20]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 800409a:	431a      	orrs	r2, r3
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 800409c:	687b      	ldr	r3, [r7, #4]
 800409e:	699b      	ldr	r3, [r3, #24]
 80040a0:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
 80040a2:	687b      	ldr	r3, [r7, #4]
 80040a4:	69db      	ldr	r3, [r3, #28]
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 80040a6:	431a      	orrs	r2, r3
            hdma->Init.Mode                | hdma->Init.Priority;
 80040a8:	687b      	ldr	r3, [r7, #4]
 80040aa:	6a1b      	ldr	r3, [r3, #32]
 80040ac:	4313      	orrs	r3, r2
    registerValue |=  hdma->Init.Direction           |
 80040ae:	697a      	ldr	r2, [r7, #20]
 80040b0:	4313      	orrs	r3, r2
 80040b2:	617b      	str	r3, [r7, #20]

    /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 80040b4:	687b      	ldr	r3, [r7, #4]
 80040b6:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80040b8:	2b04      	cmp	r3, #4
 80040ba:	d107      	bne.n	80040cc <HAL_DMA_Init+0x25c>
    {
      /* Get memory burst and peripheral burst */
      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 80040bc:	687b      	ldr	r3, [r7, #4]
 80040be:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 80040c0:	687b      	ldr	r3, [r7, #4]
 80040c2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80040c4:	4313      	orrs	r3, r2
 80040c6:	697a      	ldr	r2, [r7, #20]
 80040c8:	4313      	orrs	r3, r2
 80040ca:	617b      	str	r3, [r7, #20]
    }

    /* Work around for Errata 2.22: UART/USART- DMA transfer lock: DMA stream could be
                                    lock when transferring data to/from USART/UART */
#if (STM32H7_DEV_ID == 0x450UL)
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
 80040cc:	4b71      	ldr	r3, [pc, #452]	@ (8004294 <HAL_DMA_Init+0x424>)
 80040ce:	681a      	ldr	r2, [r3, #0]
 80040d0:	4b71      	ldr	r3, [pc, #452]	@ (8004298 <HAL_DMA_Init+0x428>)
 80040d2:	4013      	ands	r3, r2
 80040d4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 80040d8:	d328      	bcc.n	800412c <HAL_DMA_Init+0x2bc>
    {
#endif /* STM32H7_DEV_ID == 0x450UL */
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
 80040da:	687b      	ldr	r3, [r7, #4]
 80040dc:	685b      	ldr	r3, [r3, #4]
 80040de:	2b28      	cmp	r3, #40	@ 0x28
 80040e0:	d903      	bls.n	80040ea <HAL_DMA_Init+0x27a>
 80040e2:	687b      	ldr	r3, [r7, #4]
 80040e4:	685b      	ldr	r3, [r3, #4]
 80040e6:	2b2e      	cmp	r3, #46	@ 0x2e
 80040e8:	d917      	bls.n	800411a <HAL_DMA_Init+0x2aa>
 80040ea:	687b      	ldr	r3, [r7, #4]
 80040ec:	685b      	ldr	r3, [r3, #4]
 80040ee:	2b3e      	cmp	r3, #62	@ 0x3e
 80040f0:	d903      	bls.n	80040fa <HAL_DMA_Init+0x28a>
 80040f2:	687b      	ldr	r3, [r7, #4]
 80040f4:	685b      	ldr	r3, [r3, #4]
 80040f6:	2b42      	cmp	r3, #66	@ 0x42
 80040f8:	d90f      	bls.n	800411a <HAL_DMA_Init+0x2aa>
 80040fa:	687b      	ldr	r3, [r7, #4]
 80040fc:	685b      	ldr	r3, [r3, #4]
 80040fe:	2b46      	cmp	r3, #70	@ 0x46
 8004100:	d903      	bls.n	800410a <HAL_DMA_Init+0x29a>
 8004102:	687b      	ldr	r3, [r7, #4]
 8004104:	685b      	ldr	r3, [r3, #4]
 8004106:	2b48      	cmp	r3, #72	@ 0x48
 8004108:	d907      	bls.n	800411a <HAL_DMA_Init+0x2aa>
 800410a:	687b      	ldr	r3, [r7, #4]
 800410c:	685b      	ldr	r3, [r3, #4]
 800410e:	2b4e      	cmp	r3, #78	@ 0x4e
 8004110:	d905      	bls.n	800411e <HAL_DMA_Init+0x2ae>
 8004112:	687b      	ldr	r3, [r7, #4]
 8004114:	685b      	ldr	r3, [r3, #4]
 8004116:	2b52      	cmp	r3, #82	@ 0x52
 8004118:	d801      	bhi.n	800411e <HAL_DMA_Init+0x2ae>
 800411a:	2301      	movs	r3, #1
 800411c:	e000      	b.n	8004120 <HAL_DMA_Init+0x2b0>
 800411e:	2300      	movs	r3, #0
 8004120:	2b00      	cmp	r3, #0
 8004122:	d003      	beq.n	800412c <HAL_DMA_Init+0x2bc>
      {
        registerValue |= DMA_SxCR_TRBUFF;
 8004124:	697b      	ldr	r3, [r7, #20]
 8004126:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 800412a:	617b      	str	r3, [r7, #20]
#if (STM32H7_DEV_ID == 0x450UL)
    }
#endif /* STM32H7_DEV_ID == 0x450UL */

    /* Write to DMA Stream CR register */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
 800412c:	687b      	ldr	r3, [r7, #4]
 800412e:	681b      	ldr	r3, [r3, #0]
 8004130:	697a      	ldr	r2, [r7, #20]
 8004132:	601a      	str	r2, [r3, #0]

    /* Get the FCR register value */
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
 8004134:	687b      	ldr	r3, [r7, #4]
 8004136:	681b      	ldr	r3, [r3, #0]
 8004138:	695b      	ldr	r3, [r3, #20]
 800413a:	617b      	str	r3, [r7, #20]

    /* Clear Direct mode and FIFO threshold bits */
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 800413c:	697b      	ldr	r3, [r7, #20]
 800413e:	f023 0307 	bic.w	r3, r3, #7
 8004142:	617b      	str	r3, [r7, #20]

    /* Prepare the DMA Stream FIFO configuration */
    registerValue |= hdma->Init.FIFOMode;
 8004144:	687b      	ldr	r3, [r7, #4]
 8004146:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8004148:	697a      	ldr	r2, [r7, #20]
 800414a:	4313      	orrs	r3, r2
 800414c:	617b      	str	r3, [r7, #20]

    /* the FIFO threshold is not used when the FIFO mode is disabled */
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 800414e:	687b      	ldr	r3, [r7, #4]
 8004150:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8004152:	2b04      	cmp	r3, #4
 8004154:	d117      	bne.n	8004186 <HAL_DMA_Init+0x316>
    {
      /* Get the FIFO threshold */
      registerValue |= hdma->Init.FIFOThreshold;
 8004156:	687b      	ldr	r3, [r7, #4]
 8004158:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800415a:	697a      	ldr	r2, [r7, #20]
 800415c:	4313      	orrs	r3, r2
 800415e:	617b      	str	r3, [r7, #20]

      /* Check compatibility between FIFO threshold level and size of the memory burst */
      /* for INCR4, INCR8, INCR16 */
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8004160:	687b      	ldr	r3, [r7, #4]
 8004162:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8004164:	2b00      	cmp	r3, #0
 8004166:	d00e      	beq.n	8004186 <HAL_DMA_Init+0x316>
      {
        if (DMA_CheckFifoParam(hdma) != HAL_OK)
 8004168:	6878      	ldr	r0, [r7, #4]
 800416a:	f001 fdcf 	bl	8005d0c <DMA_CheckFifoParam>
 800416e:	4603      	mov	r3, r0
 8004170:	2b00      	cmp	r3, #0
 8004172:	d008      	beq.n	8004186 <HAL_DMA_Init+0x316>
        {
          /* Update error code */
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8004174:	687b      	ldr	r3, [r7, #4]
 8004176:	2240      	movs	r2, #64	@ 0x40
 8004178:	655a      	str	r2, [r3, #84]	@ 0x54

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 800417a:	687b      	ldr	r3, [r7, #4]
 800417c:	2201      	movs	r2, #1
 800417e:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

          return HAL_ERROR;
 8004182:	2301      	movs	r3, #1
 8004184:	e197      	b.n	80044b6 <HAL_DMA_Init+0x646>
        }
      }
    }

    /* Write to DMA Stream FCR */
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;
 8004186:	687b      	ldr	r3, [r7, #4]
 8004188:	681b      	ldr	r3, [r3, #0]
 800418a:	697a      	ldr	r2, [r7, #20]
 800418c:	615a      	str	r2, [r3, #20]

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
       DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 800418e:	6878      	ldr	r0, [r7, #4]
 8004190:	f001 fd0a 	bl	8005ba8 <DMA_CalcBaseAndBitshift>
 8004194:	4603      	mov	r3, r0
 8004196:	60bb      	str	r3, [r7, #8]

    /* Clear all interrupt flags */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 8004198:	687b      	ldr	r3, [r7, #4]
 800419a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800419c:	f003 031f 	and.w	r3, r3, #31
 80041a0:	223f      	movs	r2, #63	@ 0x3f
 80041a2:	409a      	lsls	r2, r3
 80041a4:	68bb      	ldr	r3, [r7, #8]
 80041a6:	609a      	str	r2, [r3, #8]
 80041a8:	e0cd      	b.n	8004346 <HAL_DMA_Init+0x4d6>
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 80041aa:	687b      	ldr	r3, [r7, #4]
 80041ac:	681b      	ldr	r3, [r3, #0]
 80041ae:	4a3b      	ldr	r2, [pc, #236]	@ (800429c <HAL_DMA_Init+0x42c>)
 80041b0:	4293      	cmp	r3, r2
 80041b2:	d022      	beq.n	80041fa <HAL_DMA_Init+0x38a>
 80041b4:	687b      	ldr	r3, [r7, #4]
 80041b6:	681b      	ldr	r3, [r3, #0]
 80041b8:	4a39      	ldr	r2, [pc, #228]	@ (80042a0 <HAL_DMA_Init+0x430>)
 80041ba:	4293      	cmp	r3, r2
 80041bc:	d01d      	beq.n	80041fa <HAL_DMA_Init+0x38a>
 80041be:	687b      	ldr	r3, [r7, #4]
 80041c0:	681b      	ldr	r3, [r3, #0]
 80041c2:	4a38      	ldr	r2, [pc, #224]	@ (80042a4 <HAL_DMA_Init+0x434>)
 80041c4:	4293      	cmp	r3, r2
 80041c6:	d018      	beq.n	80041fa <HAL_DMA_Init+0x38a>
 80041c8:	687b      	ldr	r3, [r7, #4]
 80041ca:	681b      	ldr	r3, [r3, #0]
 80041cc:	4a36      	ldr	r2, [pc, #216]	@ (80042a8 <HAL_DMA_Init+0x438>)
 80041ce:	4293      	cmp	r3, r2
 80041d0:	d013      	beq.n	80041fa <HAL_DMA_Init+0x38a>
 80041d2:	687b      	ldr	r3, [r7, #4]
 80041d4:	681b      	ldr	r3, [r3, #0]
 80041d6:	4a35      	ldr	r2, [pc, #212]	@ (80042ac <HAL_DMA_Init+0x43c>)
 80041d8:	4293      	cmp	r3, r2
 80041da:	d00e      	beq.n	80041fa <HAL_DMA_Init+0x38a>
 80041dc:	687b      	ldr	r3, [r7, #4]
 80041de:	681b      	ldr	r3, [r3, #0]
 80041e0:	4a33      	ldr	r2, [pc, #204]	@ (80042b0 <HAL_DMA_Init+0x440>)
 80041e2:	4293      	cmp	r3, r2
 80041e4:	d009      	beq.n	80041fa <HAL_DMA_Init+0x38a>
 80041e6:	687b      	ldr	r3, [r7, #4]
 80041e8:	681b      	ldr	r3, [r3, #0]
 80041ea:	4a32      	ldr	r2, [pc, #200]	@ (80042b4 <HAL_DMA_Init+0x444>)
 80041ec:	4293      	cmp	r3, r2
 80041ee:	d004      	beq.n	80041fa <HAL_DMA_Init+0x38a>
 80041f0:	687b      	ldr	r3, [r7, #4]
 80041f2:	681b      	ldr	r3, [r3, #0]
 80041f4:	4a30      	ldr	r2, [pc, #192]	@ (80042b8 <HAL_DMA_Init+0x448>)
 80041f6:	4293      	cmp	r3, r2
 80041f8:	d101      	bne.n	80041fe <HAL_DMA_Init+0x38e>
 80041fa:	2301      	movs	r3, #1
 80041fc:	e000      	b.n	8004200 <HAL_DMA_Init+0x390>
 80041fe:	2300      	movs	r3, #0
 8004200:	2b00      	cmp	r3, #0
 8004202:	f000 8097 	beq.w	8004334 <HAL_DMA_Init+0x4c4>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 8004206:	687b      	ldr	r3, [r7, #4]
 8004208:	681b      	ldr	r3, [r3, #0]
 800420a:	4a24      	ldr	r2, [pc, #144]	@ (800429c <HAL_DMA_Init+0x42c>)
 800420c:	4293      	cmp	r3, r2
 800420e:	d021      	beq.n	8004254 <HAL_DMA_Init+0x3e4>
 8004210:	687b      	ldr	r3, [r7, #4]
 8004212:	681b      	ldr	r3, [r3, #0]
 8004214:	4a22      	ldr	r2, [pc, #136]	@ (80042a0 <HAL_DMA_Init+0x430>)
 8004216:	4293      	cmp	r3, r2
 8004218:	d01c      	beq.n	8004254 <HAL_DMA_Init+0x3e4>
 800421a:	687b      	ldr	r3, [r7, #4]
 800421c:	681b      	ldr	r3, [r3, #0]
 800421e:	4a21      	ldr	r2, [pc, #132]	@ (80042a4 <HAL_DMA_Init+0x434>)
 8004220:	4293      	cmp	r3, r2
 8004222:	d017      	beq.n	8004254 <HAL_DMA_Init+0x3e4>
 8004224:	687b      	ldr	r3, [r7, #4]
 8004226:	681b      	ldr	r3, [r3, #0]
 8004228:	4a1f      	ldr	r2, [pc, #124]	@ (80042a8 <HAL_DMA_Init+0x438>)
 800422a:	4293      	cmp	r3, r2
 800422c:	d012      	beq.n	8004254 <HAL_DMA_Init+0x3e4>
 800422e:	687b      	ldr	r3, [r7, #4]
 8004230:	681b      	ldr	r3, [r3, #0]
 8004232:	4a1e      	ldr	r2, [pc, #120]	@ (80042ac <HAL_DMA_Init+0x43c>)
 8004234:	4293      	cmp	r3, r2
 8004236:	d00d      	beq.n	8004254 <HAL_DMA_Init+0x3e4>
 8004238:	687b      	ldr	r3, [r7, #4]
 800423a:	681b      	ldr	r3, [r3, #0]
 800423c:	4a1c      	ldr	r2, [pc, #112]	@ (80042b0 <HAL_DMA_Init+0x440>)
 800423e:	4293      	cmp	r3, r2
 8004240:	d008      	beq.n	8004254 <HAL_DMA_Init+0x3e4>
 8004242:	687b      	ldr	r3, [r7, #4]
 8004244:	681b      	ldr	r3, [r3, #0]
 8004246:	4a1b      	ldr	r2, [pc, #108]	@ (80042b4 <HAL_DMA_Init+0x444>)
 8004248:	4293      	cmp	r3, r2
 800424a:	d003      	beq.n	8004254 <HAL_DMA_Init+0x3e4>
 800424c:	687b      	ldr	r3, [r7, #4]
 800424e:	681b      	ldr	r3, [r3, #0]
 8004250:	4a19      	ldr	r2, [pc, #100]	@ (80042b8 <HAL_DMA_Init+0x448>)
 8004252:	4293      	cmp	r3, r2
      /* Check the request parameter */
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
    }

    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 8004254:	687b      	ldr	r3, [r7, #4]
 8004256:	2202      	movs	r2, #2
 8004258:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

    /* Allocate lock resource */
    __HAL_UNLOCK(hdma);
 800425c:	687b      	ldr	r3, [r7, #4]
 800425e:	2200      	movs	r2, #0
 8004260:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

    /* Get the CR register value */
    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;
 8004264:	687b      	ldr	r3, [r7, #4]
 8004266:	681b      	ldr	r3, [r3, #0]
 8004268:	681b      	ldr	r3, [r3, #0]
 800426a:	617b      	str	r3, [r7, #20]

    /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, MEM2MEM, DBM and CT bits */
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
 800426c:	697a      	ldr	r2, [r7, #20]
 800426e:	4b13      	ldr	r3, [pc, #76]	@ (80042bc <HAL_DMA_Init+0x44c>)
 8004270:	4013      	ands	r3, r2
 8004272:	617b      	str	r3, [r7, #20]
                                  BDMA_CCR_MINC  | BDMA_CCR_PINC    | BDMA_CCR_CIRC   | \
                                  BDMA_CCR_DIR   | BDMA_CCR_MEM2MEM | BDMA_CCR_DBM    | \
                                  BDMA_CCR_CT));

    /* Prepare the DMA Channel configuration */
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 8004274:	687b      	ldr	r3, [r7, #4]
 8004276:	689b      	ldr	r3, [r3, #8]
 8004278:	2b40      	cmp	r3, #64	@ 0x40
 800427a:	d021      	beq.n	80042c0 <HAL_DMA_Init+0x450>
 800427c:	687b      	ldr	r3, [r7, #4]
 800427e:	689b      	ldr	r3, [r3, #8]
 8004280:	2b80      	cmp	r3, #128	@ 0x80
 8004282:	d102      	bne.n	800428a <HAL_DMA_Init+0x41a>
 8004284:	f44f 4380 	mov.w	r3, #16384	@ 0x4000
 8004288:	e01b      	b.n	80042c2 <HAL_DMA_Init+0x452>
 800428a:	2300      	movs	r3, #0
 800428c:	e019      	b.n	80042c2 <HAL_DMA_Init+0x452>
 800428e:	bf00      	nop
 8004290:	fe10803f 	.word	0xfe10803f
 8004294:	5c001000 	.word	0x5c001000
 8004298:	ffff0000 	.word	0xffff0000
 800429c:	58025408 	.word	0x58025408
 80042a0:	5802541c 	.word	0x5802541c
 80042a4:	58025430 	.word	0x58025430
 80042a8:	58025444 	.word	0x58025444
 80042ac:	58025458 	.word	0x58025458
 80042b0:	5802546c 	.word	0x5802546c
 80042b4:	58025480 	.word	0x58025480
 80042b8:	58025494 	.word	0x58025494
 80042bc:	fffe000f 	.word	0xfffe000f
 80042c0:	2310      	movs	r3, #16
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
 80042c2:	687a      	ldr	r2, [r7, #4]
 80042c4:	68d2      	ldr	r2, [r2, #12]
 80042c6:	08d2      	lsrs	r2, r2, #3
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 80042c8:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
 80042ca:	687b      	ldr	r3, [r7, #4]
 80042cc:	691b      	ldr	r3, [r3, #16]
 80042ce:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
 80042d0:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
 80042d2:	687b      	ldr	r3, [r7, #4]
 80042d4:	695b      	ldr	r3, [r3, #20]
 80042d6:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
 80042d8:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
 80042da:	687b      	ldr	r3, [r7, #4]
 80042dc:	699b      	ldr	r3, [r3, #24]
 80042de:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
 80042e0:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
 80042e2:	687b      	ldr	r3, [r7, #4]
 80042e4:	69db      	ldr	r3, [r3, #28]
 80042e6:	08db      	lsrs	r3, r3, #3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
 80042e8:	431a      	orrs	r2, r3
                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);
 80042ea:	687b      	ldr	r3, [r7, #4]
 80042ec:	6a1b      	ldr	r3, [r3, #32]
 80042ee:	091b      	lsrs	r3, r3, #4
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
 80042f0:	4313      	orrs	r3, r2
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 80042f2:	697a      	ldr	r2, [r7, #20]
 80042f4:	4313      	orrs	r3, r2
 80042f6:	617b      	str	r3, [r7, #20]

    /* Write to DMA Channel CR register */
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;
 80042f8:	687b      	ldr	r3, [r7, #4]
 80042fa:	681b      	ldr	r3, [r3, #0]
 80042fc:	697a      	ldr	r2, [r7, #20]
 80042fe:	601a      	str	r2, [r3, #0]

    /* calculation of the channel index */
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
 8004300:	687b      	ldr	r3, [r7, #4]
 8004302:	681b      	ldr	r3, [r3, #0]
 8004304:	461a      	mov	r2, r3
 8004306:	4b6e      	ldr	r3, [pc, #440]	@ (80044c0 <HAL_DMA_Init+0x650>)
 8004308:	4413      	add	r3, r2
 800430a:	4a6e      	ldr	r2, [pc, #440]	@ (80044c4 <HAL_DMA_Init+0x654>)
 800430c:	fba2 2303 	umull	r2, r3, r2, r3
 8004310:	091b      	lsrs	r3, r3, #4
 8004312:	009a      	lsls	r2, r3, #2
 8004314:	687b      	ldr	r3, [r7, #4]
 8004316:	65da      	str	r2, [r3, #92]	@ 0x5c

    /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
    DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8004318:	6878      	ldr	r0, [r7, #4]
 800431a:	f001 fc45 	bl	8005ba8 <DMA_CalcBaseAndBitshift>
 800431e:	4603      	mov	r3, r0
 8004320:	60fb      	str	r3, [r7, #12]

    /* Clear all interrupt flags */
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 8004322:	687b      	ldr	r3, [r7, #4]
 8004324:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8004326:	f003 031f 	and.w	r3, r3, #31
 800432a:	2201      	movs	r2, #1
 800432c:	409a      	lsls	r2, r3
 800432e:	68fb      	ldr	r3, [r7, #12]
 8004330:	605a      	str	r2, [r3, #4]
 8004332:	e008      	b.n	8004346 <HAL_DMA_Init+0x4d6>
  }
  else
  {
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8004334:	687b      	ldr	r3, [r7, #4]
 8004336:	2240      	movs	r2, #64	@ 0x40
 8004338:	655a      	str	r2, [r3, #84]	@ 0x54
    hdma->State     = HAL_DMA_STATE_ERROR;
 800433a:	687b      	ldr	r3, [r7, #4]
 800433c:	2203      	movs	r2, #3
 800433e:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

    return HAL_ERROR;
 8004342:	2301      	movs	r3, #1
 8004344:	e0b7      	b.n	80044b6 <HAL_DMA_Init+0x646>
  }

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8004346:	687b      	ldr	r3, [r7, #4]
 8004348:	681b      	ldr	r3, [r3, #0]
 800434a:	4a5f      	ldr	r2, [pc, #380]	@ (80044c8 <HAL_DMA_Init+0x658>)
 800434c:	4293      	cmp	r3, r2
 800434e:	d072      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 8004350:	687b      	ldr	r3, [r7, #4]
 8004352:	681b      	ldr	r3, [r3, #0]
 8004354:	4a5d      	ldr	r2, [pc, #372]	@ (80044cc <HAL_DMA_Init+0x65c>)
 8004356:	4293      	cmp	r3, r2
 8004358:	d06d      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 800435a:	687b      	ldr	r3, [r7, #4]
 800435c:	681b      	ldr	r3, [r3, #0]
 800435e:	4a5c      	ldr	r2, [pc, #368]	@ (80044d0 <HAL_DMA_Init+0x660>)
 8004360:	4293      	cmp	r3, r2
 8004362:	d068      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 8004364:	687b      	ldr	r3, [r7, #4]
 8004366:	681b      	ldr	r3, [r3, #0]
 8004368:	4a5a      	ldr	r2, [pc, #360]	@ (80044d4 <HAL_DMA_Init+0x664>)
 800436a:	4293      	cmp	r3, r2
 800436c:	d063      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 800436e:	687b      	ldr	r3, [r7, #4]
 8004370:	681b      	ldr	r3, [r3, #0]
 8004372:	4a59      	ldr	r2, [pc, #356]	@ (80044d8 <HAL_DMA_Init+0x668>)
 8004374:	4293      	cmp	r3, r2
 8004376:	d05e      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 8004378:	687b      	ldr	r3, [r7, #4]
 800437a:	681b      	ldr	r3, [r3, #0]
 800437c:	4a57      	ldr	r2, [pc, #348]	@ (80044dc <HAL_DMA_Init+0x66c>)
 800437e:	4293      	cmp	r3, r2
 8004380:	d059      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 8004382:	687b      	ldr	r3, [r7, #4]
 8004384:	681b      	ldr	r3, [r3, #0]
 8004386:	4a56      	ldr	r2, [pc, #344]	@ (80044e0 <HAL_DMA_Init+0x670>)
 8004388:	4293      	cmp	r3, r2
 800438a:	d054      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 800438c:	687b      	ldr	r3, [r7, #4]
 800438e:	681b      	ldr	r3, [r3, #0]
 8004390:	4a54      	ldr	r2, [pc, #336]	@ (80044e4 <HAL_DMA_Init+0x674>)
 8004392:	4293      	cmp	r3, r2
 8004394:	d04f      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 8004396:	687b      	ldr	r3, [r7, #4]
 8004398:	681b      	ldr	r3, [r3, #0]
 800439a:	4a53      	ldr	r2, [pc, #332]	@ (80044e8 <HAL_DMA_Init+0x678>)
 800439c:	4293      	cmp	r3, r2
 800439e:	d04a      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 80043a0:	687b      	ldr	r3, [r7, #4]
 80043a2:	681b      	ldr	r3, [r3, #0]
 80043a4:	4a51      	ldr	r2, [pc, #324]	@ (80044ec <HAL_DMA_Init+0x67c>)
 80043a6:	4293      	cmp	r3, r2
 80043a8:	d045      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 80043aa:	687b      	ldr	r3, [r7, #4]
 80043ac:	681b      	ldr	r3, [r3, #0]
 80043ae:	4a50      	ldr	r2, [pc, #320]	@ (80044f0 <HAL_DMA_Init+0x680>)
 80043b0:	4293      	cmp	r3, r2
 80043b2:	d040      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 80043b4:	687b      	ldr	r3, [r7, #4]
 80043b6:	681b      	ldr	r3, [r3, #0]
 80043b8:	4a4e      	ldr	r2, [pc, #312]	@ (80044f4 <HAL_DMA_Init+0x684>)
 80043ba:	4293      	cmp	r3, r2
 80043bc:	d03b      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 80043be:	687b      	ldr	r3, [r7, #4]
 80043c0:	681b      	ldr	r3, [r3, #0]
 80043c2:	4a4d      	ldr	r2, [pc, #308]	@ (80044f8 <HAL_DMA_Init+0x688>)
 80043c4:	4293      	cmp	r3, r2
 80043c6:	d036      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 80043c8:	687b      	ldr	r3, [r7, #4]
 80043ca:	681b      	ldr	r3, [r3, #0]
 80043cc:	4a4b      	ldr	r2, [pc, #300]	@ (80044fc <HAL_DMA_Init+0x68c>)
 80043ce:	4293      	cmp	r3, r2
 80043d0:	d031      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 80043d2:	687b      	ldr	r3, [r7, #4]
 80043d4:	681b      	ldr	r3, [r3, #0]
 80043d6:	4a4a      	ldr	r2, [pc, #296]	@ (8004500 <HAL_DMA_Init+0x690>)
 80043d8:	4293      	cmp	r3, r2
 80043da:	d02c      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 80043dc:	687b      	ldr	r3, [r7, #4]
 80043de:	681b      	ldr	r3, [r3, #0]
 80043e0:	4a48      	ldr	r2, [pc, #288]	@ (8004504 <HAL_DMA_Init+0x694>)
 80043e2:	4293      	cmp	r3, r2
 80043e4:	d027      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 80043e6:	687b      	ldr	r3, [r7, #4]
 80043e8:	681b      	ldr	r3, [r3, #0]
 80043ea:	4a47      	ldr	r2, [pc, #284]	@ (8004508 <HAL_DMA_Init+0x698>)
 80043ec:	4293      	cmp	r3, r2
 80043ee:	d022      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 80043f0:	687b      	ldr	r3, [r7, #4]
 80043f2:	681b      	ldr	r3, [r3, #0]
 80043f4:	4a45      	ldr	r2, [pc, #276]	@ (800450c <HAL_DMA_Init+0x69c>)
 80043f6:	4293      	cmp	r3, r2
 80043f8:	d01d      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 80043fa:	687b      	ldr	r3, [r7, #4]
 80043fc:	681b      	ldr	r3, [r3, #0]
 80043fe:	4a44      	ldr	r2, [pc, #272]	@ (8004510 <HAL_DMA_Init+0x6a0>)
 8004400:	4293      	cmp	r3, r2
 8004402:	d018      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 8004404:	687b      	ldr	r3, [r7, #4]
 8004406:	681b      	ldr	r3, [r3, #0]
 8004408:	4a42      	ldr	r2, [pc, #264]	@ (8004514 <HAL_DMA_Init+0x6a4>)
 800440a:	4293      	cmp	r3, r2
 800440c:	d013      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 800440e:	687b      	ldr	r3, [r7, #4]
 8004410:	681b      	ldr	r3, [r3, #0]
 8004412:	4a41      	ldr	r2, [pc, #260]	@ (8004518 <HAL_DMA_Init+0x6a8>)
 8004414:	4293      	cmp	r3, r2
 8004416:	d00e      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 8004418:	687b      	ldr	r3, [r7, #4]
 800441a:	681b      	ldr	r3, [r3, #0]
 800441c:	4a3f      	ldr	r2, [pc, #252]	@ (800451c <HAL_DMA_Init+0x6ac>)
 800441e:	4293      	cmp	r3, r2
 8004420:	d009      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 8004422:	687b      	ldr	r3, [r7, #4]
 8004424:	681b      	ldr	r3, [r3, #0]
 8004426:	4a3e      	ldr	r2, [pc, #248]	@ (8004520 <HAL_DMA_Init+0x6b0>)
 8004428:	4293      	cmp	r3, r2
 800442a:	d004      	beq.n	8004436 <HAL_DMA_Init+0x5c6>
 800442c:	687b      	ldr	r3, [r7, #4]
 800442e:	681b      	ldr	r3, [r3, #0]
 8004430:	4a3c      	ldr	r2, [pc, #240]	@ (8004524 <HAL_DMA_Init+0x6b4>)
 8004432:	4293      	cmp	r3, r2
 8004434:	d101      	bne.n	800443a <HAL_DMA_Init+0x5ca>
 8004436:	2301      	movs	r3, #1
 8004438:	e000      	b.n	800443c <HAL_DMA_Init+0x5cc>
 800443a:	2300      	movs	r3, #0
 800443c:	2b00      	cmp	r3, #0
 800443e:	d032      	beq.n	80044a6 <HAL_DMA_Init+0x636>
  {
    /* Initialize parameters for DMAMUX channel :
    DMAmuxChannel, DMAmuxChannelStatus and DMAmuxChannelStatusMask
    */
    DMA_CalcDMAMUXChannelBaseAndMask(hdma);
 8004440:	6878      	ldr	r0, [r7, #4]
 8004442:	f001 fcdf 	bl	8005e04 <DMA_CalcDMAMUXChannelBaseAndMask>

    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 8004446:	687b      	ldr	r3, [r7, #4]
 8004448:	689b      	ldr	r3, [r3, #8]
 800444a:	2b80      	cmp	r3, #128	@ 0x80
 800444c:	d102      	bne.n	8004454 <HAL_DMA_Init+0x5e4>
    {
      /* if memory to memory force the request to 0*/
      hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 800444e:	687b      	ldr	r3, [r7, #4]
 8004450:	2200      	movs	r2, #0
 8004452:	605a      	str	r2, [r3, #4]
    }

    /* Set peripheral request  to DMAMUX channel */
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 8004454:	687b      	ldr	r3, [r7, #4]
 8004456:	685a      	ldr	r2, [r3, #4]
 8004458:	687b      	ldr	r3, [r7, #4]
 800445a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 800445c:	b2d2      	uxtb	r2, r2
 800445e:	601a      	str	r2, [r3, #0]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8004460:	687b      	ldr	r3, [r7, #4]
 8004462:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8004464:	687a      	ldr	r2, [r7, #4]
 8004466:	6e92      	ldr	r2, [r2, #104]	@ 0x68
 8004468:	605a      	str	r2, [r3, #4]

    /* Initialize parameters for DMAMUX request generator :
    if the DMA request is DMA_REQUEST_GENERATOR0 to DMA_REQUEST_GENERATOR7
    */
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
 800446a:	687b      	ldr	r3, [r7, #4]
 800446c:	685b      	ldr	r3, [r3, #4]
 800446e:	2b00      	cmp	r3, #0
 8004470:	d010      	beq.n	8004494 <HAL_DMA_Init+0x624>
 8004472:	687b      	ldr	r3, [r7, #4]
 8004474:	685b      	ldr	r3, [r3, #4]
 8004476:	2b08      	cmp	r3, #8
 8004478:	d80c      	bhi.n	8004494 <HAL_DMA_Init+0x624>
    {
      /* Initialize parameters for DMAMUX request generator :
      DMAmuxRequestGen, DMAmuxRequestGenStatus and DMAmuxRequestGenStatusMask */
      DMA_CalcDMAMUXRequestGenBaseAndMask(hdma);
 800447a:	6878      	ldr	r0, [r7, #4]
 800447c:	f001 fd5c 	bl	8005f38 <DMA_CalcDMAMUXRequestGenBaseAndMask>

      /* Reset the DMAMUX request generator register */
      hdma->DMAmuxRequestGen->RGCR = 0U;
 8004480:	687b      	ldr	r3, [r7, #4]
 8004482:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8004484:	2200      	movs	r2, #0
 8004486:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8004488:	687b      	ldr	r3, [r7, #4]
 800448a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800448c:	687a      	ldr	r2, [r7, #4]
 800448e:	6f52      	ldr	r2, [r2, #116]	@ 0x74
 8004490:	605a      	str	r2, [r3, #4]
 8004492:	e008      	b.n	80044a6 <HAL_DMA_Init+0x636>
    }
    else
    {
      hdma->DMAmuxRequestGen = 0U;
 8004494:	687b      	ldr	r3, [r7, #4]
 8004496:	2200      	movs	r2, #0
 8004498:	66da      	str	r2, [r3, #108]	@ 0x6c
      hdma->DMAmuxRequestGenStatus = 0U;
 800449a:	687b      	ldr	r3, [r7, #4]
 800449c:	2200      	movs	r2, #0
 800449e:	671a      	str	r2, [r3, #112]	@ 0x70
      hdma->DMAmuxRequestGenStatusMask = 0U;
 80044a0:	687b      	ldr	r3, [r7, #4]
 80044a2:	2200      	movs	r2, #0
 80044a4:	675a      	str	r2, [r3, #116]	@ 0x74
    }
  }

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80044a6:	687b      	ldr	r3, [r7, #4]
 80044a8:	2200      	movs	r2, #0
 80044aa:	655a      	str	r2, [r3, #84]	@ 0x54

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 80044ac:	687b      	ldr	r3, [r7, #4]
 80044ae:	2201      	movs	r2, #1
 80044b0:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

  return HAL_OK;
 80044b4:	2300      	movs	r3, #0
}
 80044b6:	4618      	mov	r0, r3
 80044b8:	3718      	adds	r7, #24
 80044ba:	46bd      	mov	sp, r7
 80044bc:	bd80      	pop	{r7, pc}
 80044be:	bf00      	nop
 80044c0:	a7fdabf8 	.word	0xa7fdabf8
 80044c4:	cccccccd 	.word	0xcccccccd
 80044c8:	40020010 	.word	0x40020010
 80044cc:	40020028 	.word	0x40020028
 80044d0:	40020040 	.word	0x40020040
 80044d4:	40020058 	.word	0x40020058
 80044d8:	40020070 	.word	0x40020070
 80044dc:	40020088 	.word	0x40020088
 80044e0:	400200a0 	.word	0x400200a0
 80044e4:	400200b8 	.word	0x400200b8
 80044e8:	40020410 	.word	0x40020410
 80044ec:	40020428 	.word	0x40020428
 80044f0:	40020440 	.word	0x40020440
 80044f4:	40020458 	.word	0x40020458
 80044f8:	40020470 	.word	0x40020470
 80044fc:	40020488 	.word	0x40020488
 8004500:	400204a0 	.word	0x400204a0
 8004504:	400204b8 	.word	0x400204b8
 8004508:	58025408 	.word	0x58025408
 800450c:	5802541c 	.word	0x5802541c
 8004510:	58025430 	.word	0x58025430
 8004514:	58025444 	.word	0x58025444
 8004518:	58025458 	.word	0x58025458
 800451c:	5802546c 	.word	0x5802546c
 8004520:	58025480 	.word	0x58025480
 8004524:	58025494 	.word	0x58025494

08004528 <HAL_DMA_Start_IT>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8004528:	b580      	push	{r7, lr}
 800452a:	b086      	sub	sp, #24
 800452c:	af00      	add	r7, sp, #0
 800452e:	60f8      	str	r0, [r7, #12]
 8004530:	60b9      	str	r1, [r7, #8]
 8004532:	607a      	str	r2, [r7, #4]
 8004534:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8004536:	2300      	movs	r3, #0
 8004538:	75fb      	strb	r3, [r7, #23]

  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));

  /* Check the DMA peripheral handle */
  if(hdma == NULL)
 800453a:	68fb      	ldr	r3, [r7, #12]
 800453c:	2b00      	cmp	r3, #0
 800453e:	d101      	bne.n	8004544 <HAL_DMA_Start_IT+0x1c>
  {
    return HAL_ERROR;
 8004540:	2301      	movs	r3, #1
 8004542:	e226      	b.n	8004992 <HAL_DMA_Start_IT+0x46a>
  }

  /* Process locked */
  __HAL_LOCK(hdma);
 8004544:	68fb      	ldr	r3, [r7, #12]
 8004546:	f893 3034 	ldrb.w	r3, [r3, #52]	@ 0x34
 800454a:	2b01      	cmp	r3, #1
 800454c:	d101      	bne.n	8004552 <HAL_DMA_Start_IT+0x2a>
 800454e:	2302      	movs	r3, #2
 8004550:	e21f      	b.n	8004992 <HAL_DMA_Start_IT+0x46a>
 8004552:	68fb      	ldr	r3, [r7, #12]
 8004554:	2201      	movs	r2, #1
 8004556:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
 800455a:	68fb      	ldr	r3, [r7, #12]
 800455c:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 8004560:	b2db      	uxtb	r3, r3
 8004562:	2b01      	cmp	r3, #1
 8004564:	f040 820a 	bne.w	800497c <HAL_DMA_Start_IT+0x454>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 8004568:	68fb      	ldr	r3, [r7, #12]
 800456a:	2202      	movs	r2, #2
 800456c:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8004570:	68fb      	ldr	r3, [r7, #12]
 8004572:	2200      	movs	r2, #0
 8004574:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Disable the peripheral */
    __HAL_DMA_DISABLE(hdma);
 8004576:	68fb      	ldr	r3, [r7, #12]
 8004578:	681b      	ldr	r3, [r3, #0]
 800457a:	4a68      	ldr	r2, [pc, #416]	@ (800471c <HAL_DMA_Start_IT+0x1f4>)
 800457c:	4293      	cmp	r3, r2
 800457e:	d04a      	beq.n	8004616 <HAL_DMA_Start_IT+0xee>
 8004580:	68fb      	ldr	r3, [r7, #12]
 8004582:	681b      	ldr	r3, [r3, #0]
 8004584:	4a66      	ldr	r2, [pc, #408]	@ (8004720 <HAL_DMA_Start_IT+0x1f8>)
 8004586:	4293      	cmp	r3, r2
 8004588:	d045      	beq.n	8004616 <HAL_DMA_Start_IT+0xee>
 800458a:	68fb      	ldr	r3, [r7, #12]
 800458c:	681b      	ldr	r3, [r3, #0]
 800458e:	4a65      	ldr	r2, [pc, #404]	@ (8004724 <HAL_DMA_Start_IT+0x1fc>)
 8004590:	4293      	cmp	r3, r2
 8004592:	d040      	beq.n	8004616 <HAL_DMA_Start_IT+0xee>
 8004594:	68fb      	ldr	r3, [r7, #12]
 8004596:	681b      	ldr	r3, [r3, #0]
 8004598:	4a63      	ldr	r2, [pc, #396]	@ (8004728 <HAL_DMA_Start_IT+0x200>)
 800459a:	4293      	cmp	r3, r2
 800459c:	d03b      	beq.n	8004616 <HAL_DMA_Start_IT+0xee>
 800459e:	68fb      	ldr	r3, [r7, #12]
 80045a0:	681b      	ldr	r3, [r3, #0]
 80045a2:	4a62      	ldr	r2, [pc, #392]	@ (800472c <HAL_DMA_Start_IT+0x204>)
 80045a4:	4293      	cmp	r3, r2
 80045a6:	d036      	beq.n	8004616 <HAL_DMA_Start_IT+0xee>
 80045a8:	68fb      	ldr	r3, [r7, #12]
 80045aa:	681b      	ldr	r3, [r3, #0]
 80045ac:	4a60      	ldr	r2, [pc, #384]	@ (8004730 <HAL_DMA_Start_IT+0x208>)
 80045ae:	4293      	cmp	r3, r2
 80045b0:	d031      	beq.n	8004616 <HAL_DMA_Start_IT+0xee>
 80045b2:	68fb      	ldr	r3, [r7, #12]
 80045b4:	681b      	ldr	r3, [r3, #0]
 80045b6:	4a5f      	ldr	r2, [pc, #380]	@ (8004734 <HAL_DMA_Start_IT+0x20c>)
 80045b8:	4293      	cmp	r3, r2
 80045ba:	d02c      	beq.n	8004616 <HAL_DMA_Start_IT+0xee>
 80045bc:	68fb      	ldr	r3, [r7, #12]
 80045be:	681b      	ldr	r3, [r3, #0]
 80045c0:	4a5d      	ldr	r2, [pc, #372]	@ (8004738 <HAL_DMA_Start_IT+0x210>)
 80045c2:	4293      	cmp	r3, r2
 80045c4:	d027      	beq.n	8004616 <HAL_DMA_Start_IT+0xee>
 80045c6:	68fb      	ldr	r3, [r7, #12]
 80045c8:	681b      	ldr	r3, [r3, #0]
 80045ca:	4a5c      	ldr	r2, [pc, #368]	@ (800473c <HAL_DMA_Start_IT+0x214>)
 80045cc:	4293      	cmp	r3, r2
 80045ce:	d022      	beq.n	8004616 <HAL_DMA_Start_IT+0xee>
 80045d0:	68fb      	ldr	r3, [r7, #12]
 80045d2:	681b      	ldr	r3, [r3, #0]
 80045d4:	4a5a      	ldr	r2, [pc, #360]	@ (8004740 <HAL_DMA_Start_IT+0x218>)
 80045d6:	4293      	cmp	r3, r2
 80045d8:	d01d      	beq.n	8004616 <HAL_DMA_Start_IT+0xee>
 80045da:	68fb      	ldr	r3, [r7, #12]
 80045dc:	681b      	ldr	r3, [r3, #0]
 80045de:	4a59      	ldr	r2, [pc, #356]	@ (8004744 <HAL_DMA_Start_IT+0x21c>)
 80045e0:	4293      	cmp	r3, r2
 80045e2:	d018      	beq.n	8004616 <HAL_DMA_Start_IT+0xee>
 80045e4:	68fb      	ldr	r3, [r7, #12]
 80045e6:	681b      	ldr	r3, [r3, #0]
 80045e8:	4a57      	ldr	r2, [pc, #348]	@ (8004748 <HAL_DMA_Start_IT+0x220>)
 80045ea:	4293      	cmp	r3, r2
 80045ec:	d013      	beq.n	8004616 <HAL_DMA_Start_IT+0xee>
 80045ee:	68fb      	ldr	r3, [r7, #12]
 80045f0:	681b      	ldr	r3, [r3, #0]
 80045f2:	4a56      	ldr	r2, [pc, #344]	@ (800474c <HAL_DMA_Start_IT+0x224>)
 80045f4:	4293      	cmp	r3, r2
 80045f6:	d00e      	beq.n	8004616 <HAL_DMA_Start_IT+0xee>
 80045f8:	68fb      	ldr	r3, [r7, #12]
 80045fa:	681b      	ldr	r3, [r3, #0]
 80045fc:	4a54      	ldr	r2, [pc, #336]	@ (8004750 <HAL_DMA_Start_IT+0x228>)
 80045fe:	4293      	cmp	r3, r2
 8004600:	d009      	beq.n	8004616 <HAL_DMA_Start_IT+0xee>
 8004602:	68fb      	ldr	r3, [r7, #12]
 8004604:	681b      	ldr	r3, [r3, #0]
 8004606:	4a53      	ldr	r2, [pc, #332]	@ (8004754 <HAL_DMA_Start_IT+0x22c>)
 8004608:	4293      	cmp	r3, r2
 800460a:	d004      	beq.n	8004616 <HAL_DMA_Start_IT+0xee>
 800460c:	68fb      	ldr	r3, [r7, #12]
 800460e:	681b      	ldr	r3, [r3, #0]
 8004610:	4a51      	ldr	r2, [pc, #324]	@ (8004758 <HAL_DMA_Start_IT+0x230>)
 8004612:	4293      	cmp	r3, r2
 8004614:	d108      	bne.n	8004628 <HAL_DMA_Start_IT+0x100>
 8004616:	68fb      	ldr	r3, [r7, #12]
 8004618:	681b      	ldr	r3, [r3, #0]
 800461a:	681a      	ldr	r2, [r3, #0]
 800461c:	68fb      	ldr	r3, [r7, #12]
 800461e:	681b      	ldr	r3, [r3, #0]
 8004620:	f022 0201 	bic.w	r2, r2, #1
 8004624:	601a      	str	r2, [r3, #0]
 8004626:	e007      	b.n	8004638 <HAL_DMA_Start_IT+0x110>
 8004628:	68fb      	ldr	r3, [r7, #12]
 800462a:	681b      	ldr	r3, [r3, #0]
 800462c:	681a      	ldr	r2, [r3, #0]
 800462e:	68fb      	ldr	r3, [r7, #12]
 8004630:	681b      	ldr	r3, [r3, #0]
 8004632:	f022 0201 	bic.w	r2, r2, #1
 8004636:	601a      	str	r2, [r3, #0]

    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 8004638:	683b      	ldr	r3, [r7, #0]
 800463a:	687a      	ldr	r2, [r7, #4]
 800463c:	68b9      	ldr	r1, [r7, #8]
 800463e:	68f8      	ldr	r0, [r7, #12]
 8004640:	f001 f906 	bl	8005850 <DMA_SetConfig>

    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8004644:	68fb      	ldr	r3, [r7, #12]
 8004646:	681b      	ldr	r3, [r3, #0]
 8004648:	4a34      	ldr	r2, [pc, #208]	@ (800471c <HAL_DMA_Start_IT+0x1f4>)
 800464a:	4293      	cmp	r3, r2
 800464c:	d04a      	beq.n	80046e4 <HAL_DMA_Start_IT+0x1bc>
 800464e:	68fb      	ldr	r3, [r7, #12]
 8004650:	681b      	ldr	r3, [r3, #0]
 8004652:	4a33      	ldr	r2, [pc, #204]	@ (8004720 <HAL_DMA_Start_IT+0x1f8>)
 8004654:	4293      	cmp	r3, r2
 8004656:	d045      	beq.n	80046e4 <HAL_DMA_Start_IT+0x1bc>
 8004658:	68fb      	ldr	r3, [r7, #12]
 800465a:	681b      	ldr	r3, [r3, #0]
 800465c:	4a31      	ldr	r2, [pc, #196]	@ (8004724 <HAL_DMA_Start_IT+0x1fc>)
 800465e:	4293      	cmp	r3, r2
 8004660:	d040      	beq.n	80046e4 <HAL_DMA_Start_IT+0x1bc>
 8004662:	68fb      	ldr	r3, [r7, #12]
 8004664:	681b      	ldr	r3, [r3, #0]
 8004666:	4a30      	ldr	r2, [pc, #192]	@ (8004728 <HAL_DMA_Start_IT+0x200>)
 8004668:	4293      	cmp	r3, r2
 800466a:	d03b      	beq.n	80046e4 <HAL_DMA_Start_IT+0x1bc>
 800466c:	68fb      	ldr	r3, [r7, #12]
 800466e:	681b      	ldr	r3, [r3, #0]
 8004670:	4a2e      	ldr	r2, [pc, #184]	@ (800472c <HAL_DMA_Start_IT+0x204>)
 8004672:	4293      	cmp	r3, r2
 8004674:	d036      	beq.n	80046e4 <HAL_DMA_Start_IT+0x1bc>
 8004676:	68fb      	ldr	r3, [r7, #12]
 8004678:	681b      	ldr	r3, [r3, #0]
 800467a:	4a2d      	ldr	r2, [pc, #180]	@ (8004730 <HAL_DMA_Start_IT+0x208>)
 800467c:	4293      	cmp	r3, r2
 800467e:	d031      	beq.n	80046e4 <HAL_DMA_Start_IT+0x1bc>
 8004680:	68fb      	ldr	r3, [r7, #12]
 8004682:	681b      	ldr	r3, [r3, #0]
 8004684:	4a2b      	ldr	r2, [pc, #172]	@ (8004734 <HAL_DMA_Start_IT+0x20c>)
 8004686:	4293      	cmp	r3, r2
 8004688:	d02c      	beq.n	80046e4 <HAL_DMA_Start_IT+0x1bc>
 800468a:	68fb      	ldr	r3, [r7, #12]
 800468c:	681b      	ldr	r3, [r3, #0]
 800468e:	4a2a      	ldr	r2, [pc, #168]	@ (8004738 <HAL_DMA_Start_IT+0x210>)
 8004690:	4293      	cmp	r3, r2
 8004692:	d027      	beq.n	80046e4 <HAL_DMA_Start_IT+0x1bc>
 8004694:	68fb      	ldr	r3, [r7, #12]
 8004696:	681b      	ldr	r3, [r3, #0]
 8004698:	4a28      	ldr	r2, [pc, #160]	@ (800473c <HAL_DMA_Start_IT+0x214>)
 800469a:	4293      	cmp	r3, r2
 800469c:	d022      	beq.n	80046e4 <HAL_DMA_Start_IT+0x1bc>
 800469e:	68fb      	ldr	r3, [r7, #12]
 80046a0:	681b      	ldr	r3, [r3, #0]
 80046a2:	4a27      	ldr	r2, [pc, #156]	@ (8004740 <HAL_DMA_Start_IT+0x218>)
 80046a4:	4293      	cmp	r3, r2
 80046a6:	d01d      	beq.n	80046e4 <HAL_DMA_Start_IT+0x1bc>
 80046a8:	68fb      	ldr	r3, [r7, #12]
 80046aa:	681b      	ldr	r3, [r3, #0]
 80046ac:	4a25      	ldr	r2, [pc, #148]	@ (8004744 <HAL_DMA_Start_IT+0x21c>)
 80046ae:	4293      	cmp	r3, r2
 80046b0:	d018      	beq.n	80046e4 <HAL_DMA_Start_IT+0x1bc>
 80046b2:	68fb      	ldr	r3, [r7, #12]
 80046b4:	681b      	ldr	r3, [r3, #0]
 80046b6:	4a24      	ldr	r2, [pc, #144]	@ (8004748 <HAL_DMA_Start_IT+0x220>)
 80046b8:	4293      	cmp	r3, r2
 80046ba:	d013      	beq.n	80046e4 <HAL_DMA_Start_IT+0x1bc>
 80046bc:	68fb      	ldr	r3, [r7, #12]
 80046be:	681b      	ldr	r3, [r3, #0]
 80046c0:	4a22      	ldr	r2, [pc, #136]	@ (800474c <HAL_DMA_Start_IT+0x224>)
 80046c2:	4293      	cmp	r3, r2
 80046c4:	d00e      	beq.n	80046e4 <HAL_DMA_Start_IT+0x1bc>
 80046c6:	68fb      	ldr	r3, [r7, #12]
 80046c8:	681b      	ldr	r3, [r3, #0]
 80046ca:	4a21      	ldr	r2, [pc, #132]	@ (8004750 <HAL_DMA_Start_IT+0x228>)
 80046cc:	4293      	cmp	r3, r2
 80046ce:	d009      	beq.n	80046e4 <HAL_DMA_Start_IT+0x1bc>
 80046d0:	68fb      	ldr	r3, [r7, #12]
 80046d2:	681b      	ldr	r3, [r3, #0]
 80046d4:	4a1f      	ldr	r2, [pc, #124]	@ (8004754 <HAL_DMA_Start_IT+0x22c>)
 80046d6:	4293      	cmp	r3, r2
 80046d8:	d004      	beq.n	80046e4 <HAL_DMA_Start_IT+0x1bc>
 80046da:	68fb      	ldr	r3, [r7, #12]
 80046dc:	681b      	ldr	r3, [r3, #0]
 80046de:	4a1e      	ldr	r2, [pc, #120]	@ (8004758 <HAL_DMA_Start_IT+0x230>)
 80046e0:	4293      	cmp	r3, r2
 80046e2:	d101      	bne.n	80046e8 <HAL_DMA_Start_IT+0x1c0>
 80046e4:	2301      	movs	r3, #1
 80046e6:	e000      	b.n	80046ea <HAL_DMA_Start_IT+0x1c2>
 80046e8:	2300      	movs	r3, #0
 80046ea:	2b00      	cmp	r3, #0
 80046ec:	d036      	beq.n	800475c <HAL_DMA_Start_IT+0x234>
    {
      /* Enable Common interrupts*/
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
 80046ee:	68fb      	ldr	r3, [r7, #12]
 80046f0:	681b      	ldr	r3, [r3, #0]
 80046f2:	681b      	ldr	r3, [r3, #0]
 80046f4:	f023 021e 	bic.w	r2, r3, #30
 80046f8:	68fb      	ldr	r3, [r7, #12]
 80046fa:	681b      	ldr	r3, [r3, #0]
 80046fc:	f042 0216 	orr.w	r2, r2, #22
 8004700:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
 8004702:	68fb      	ldr	r3, [r7, #12]
 8004704:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004706:	2b00      	cmp	r3, #0
 8004708:	d03e      	beq.n	8004788 <HAL_DMA_Start_IT+0x260>
      {
        /* Enable Half Transfer IT if corresponding Callback is set */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
 800470a:	68fb      	ldr	r3, [r7, #12]
 800470c:	681b      	ldr	r3, [r3, #0]
 800470e:	681a      	ldr	r2, [r3, #0]
 8004710:	68fb      	ldr	r3, [r7, #12]
 8004712:	681b      	ldr	r3, [r3, #0]
 8004714:	f042 0208 	orr.w	r2, r2, #8
 8004718:	601a      	str	r2, [r3, #0]
 800471a:	e035      	b.n	8004788 <HAL_DMA_Start_IT+0x260>
 800471c:	40020010 	.word	0x40020010
 8004720:	40020028 	.word	0x40020028
 8004724:	40020040 	.word	0x40020040
 8004728:	40020058 	.word	0x40020058
 800472c:	40020070 	.word	0x40020070
 8004730:	40020088 	.word	0x40020088
 8004734:	400200a0 	.word	0x400200a0
 8004738:	400200b8 	.word	0x400200b8
 800473c:	40020410 	.word	0x40020410
 8004740:	40020428 	.word	0x40020428
 8004744:	40020440 	.word	0x40020440
 8004748:	40020458 	.word	0x40020458
 800474c:	40020470 	.word	0x40020470
 8004750:	40020488 	.word	0x40020488
 8004754:	400204a0 	.word	0x400204a0
 8004758:	400204b8 	.word	0x400204b8
      }
    }
    else /* BDMA channel */
    {
      /* Enable Common interrupts */
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
 800475c:	68fb      	ldr	r3, [r7, #12]
 800475e:	681b      	ldr	r3, [r3, #0]
 8004760:	681b      	ldr	r3, [r3, #0]
 8004762:	f023 020e 	bic.w	r2, r3, #14
 8004766:	68fb      	ldr	r3, [r7, #12]
 8004768:	681b      	ldr	r3, [r3, #0]
 800476a:	f042 020a 	orr.w	r2, r2, #10
 800476e:	601a      	str	r2, [r3, #0]

      if(hdma->XferHalfCpltCallback != NULL)
 8004770:	68fb      	ldr	r3, [r7, #12]
 8004772:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004774:	2b00      	cmp	r3, #0
 8004776:	d007      	beq.n	8004788 <HAL_DMA_Start_IT+0x260>
      {
        /*Enable Half Transfer IT if corresponding Callback is set */
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
 8004778:	68fb      	ldr	r3, [r7, #12]
 800477a:	681b      	ldr	r3, [r3, #0]
 800477c:	681a      	ldr	r2, [r3, #0]
 800477e:	68fb      	ldr	r3, [r7, #12]
 8004780:	681b      	ldr	r3, [r3, #0]
 8004782:	f042 0204 	orr.w	r2, r2, #4
 8004786:	601a      	str	r2, [r3, #0]
      }
    }

    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8004788:	68fb      	ldr	r3, [r7, #12]
 800478a:	681b      	ldr	r3, [r3, #0]
 800478c:	4a83      	ldr	r2, [pc, #524]	@ (800499c <HAL_DMA_Start_IT+0x474>)
 800478e:	4293      	cmp	r3, r2
 8004790:	d072      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 8004792:	68fb      	ldr	r3, [r7, #12]
 8004794:	681b      	ldr	r3, [r3, #0]
 8004796:	4a82      	ldr	r2, [pc, #520]	@ (80049a0 <HAL_DMA_Start_IT+0x478>)
 8004798:	4293      	cmp	r3, r2
 800479a:	d06d      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 800479c:	68fb      	ldr	r3, [r7, #12]
 800479e:	681b      	ldr	r3, [r3, #0]
 80047a0:	4a80      	ldr	r2, [pc, #512]	@ (80049a4 <HAL_DMA_Start_IT+0x47c>)
 80047a2:	4293      	cmp	r3, r2
 80047a4:	d068      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 80047a6:	68fb      	ldr	r3, [r7, #12]
 80047a8:	681b      	ldr	r3, [r3, #0]
 80047aa:	4a7f      	ldr	r2, [pc, #508]	@ (80049a8 <HAL_DMA_Start_IT+0x480>)
 80047ac:	4293      	cmp	r3, r2
 80047ae:	d063      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 80047b0:	68fb      	ldr	r3, [r7, #12]
 80047b2:	681b      	ldr	r3, [r3, #0]
 80047b4:	4a7d      	ldr	r2, [pc, #500]	@ (80049ac <HAL_DMA_Start_IT+0x484>)
 80047b6:	4293      	cmp	r3, r2
 80047b8:	d05e      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 80047ba:	68fb      	ldr	r3, [r7, #12]
 80047bc:	681b      	ldr	r3, [r3, #0]
 80047be:	4a7c      	ldr	r2, [pc, #496]	@ (80049b0 <HAL_DMA_Start_IT+0x488>)
 80047c0:	4293      	cmp	r3, r2
 80047c2:	d059      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 80047c4:	68fb      	ldr	r3, [r7, #12]
 80047c6:	681b      	ldr	r3, [r3, #0]
 80047c8:	4a7a      	ldr	r2, [pc, #488]	@ (80049b4 <HAL_DMA_Start_IT+0x48c>)
 80047ca:	4293      	cmp	r3, r2
 80047cc:	d054      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 80047ce:	68fb      	ldr	r3, [r7, #12]
 80047d0:	681b      	ldr	r3, [r3, #0]
 80047d2:	4a79      	ldr	r2, [pc, #484]	@ (80049b8 <HAL_DMA_Start_IT+0x490>)
 80047d4:	4293      	cmp	r3, r2
 80047d6:	d04f      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 80047d8:	68fb      	ldr	r3, [r7, #12]
 80047da:	681b      	ldr	r3, [r3, #0]
 80047dc:	4a77      	ldr	r2, [pc, #476]	@ (80049bc <HAL_DMA_Start_IT+0x494>)
 80047de:	4293      	cmp	r3, r2
 80047e0:	d04a      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 80047e2:	68fb      	ldr	r3, [r7, #12]
 80047e4:	681b      	ldr	r3, [r3, #0]
 80047e6:	4a76      	ldr	r2, [pc, #472]	@ (80049c0 <HAL_DMA_Start_IT+0x498>)
 80047e8:	4293      	cmp	r3, r2
 80047ea:	d045      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 80047ec:	68fb      	ldr	r3, [r7, #12]
 80047ee:	681b      	ldr	r3, [r3, #0]
 80047f0:	4a74      	ldr	r2, [pc, #464]	@ (80049c4 <HAL_DMA_Start_IT+0x49c>)
 80047f2:	4293      	cmp	r3, r2
 80047f4:	d040      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 80047f6:	68fb      	ldr	r3, [r7, #12]
 80047f8:	681b      	ldr	r3, [r3, #0]
 80047fa:	4a73      	ldr	r2, [pc, #460]	@ (80049c8 <HAL_DMA_Start_IT+0x4a0>)
 80047fc:	4293      	cmp	r3, r2
 80047fe:	d03b      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 8004800:	68fb      	ldr	r3, [r7, #12]
 8004802:	681b      	ldr	r3, [r3, #0]
 8004804:	4a71      	ldr	r2, [pc, #452]	@ (80049cc <HAL_DMA_Start_IT+0x4a4>)
 8004806:	4293      	cmp	r3, r2
 8004808:	d036      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 800480a:	68fb      	ldr	r3, [r7, #12]
 800480c:	681b      	ldr	r3, [r3, #0]
 800480e:	4a70      	ldr	r2, [pc, #448]	@ (80049d0 <HAL_DMA_Start_IT+0x4a8>)
 8004810:	4293      	cmp	r3, r2
 8004812:	d031      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 8004814:	68fb      	ldr	r3, [r7, #12]
 8004816:	681b      	ldr	r3, [r3, #0]
 8004818:	4a6e      	ldr	r2, [pc, #440]	@ (80049d4 <HAL_DMA_Start_IT+0x4ac>)
 800481a:	4293      	cmp	r3, r2
 800481c:	d02c      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 800481e:	68fb      	ldr	r3, [r7, #12]
 8004820:	681b      	ldr	r3, [r3, #0]
 8004822:	4a6d      	ldr	r2, [pc, #436]	@ (80049d8 <HAL_DMA_Start_IT+0x4b0>)
 8004824:	4293      	cmp	r3, r2
 8004826:	d027      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 8004828:	68fb      	ldr	r3, [r7, #12]
 800482a:	681b      	ldr	r3, [r3, #0]
 800482c:	4a6b      	ldr	r2, [pc, #428]	@ (80049dc <HAL_DMA_Start_IT+0x4b4>)
 800482e:	4293      	cmp	r3, r2
 8004830:	d022      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 8004832:	68fb      	ldr	r3, [r7, #12]
 8004834:	681b      	ldr	r3, [r3, #0]
 8004836:	4a6a      	ldr	r2, [pc, #424]	@ (80049e0 <HAL_DMA_Start_IT+0x4b8>)
 8004838:	4293      	cmp	r3, r2
 800483a:	d01d      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 800483c:	68fb      	ldr	r3, [r7, #12]
 800483e:	681b      	ldr	r3, [r3, #0]
 8004840:	4a68      	ldr	r2, [pc, #416]	@ (80049e4 <HAL_DMA_Start_IT+0x4bc>)
 8004842:	4293      	cmp	r3, r2
 8004844:	d018      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 8004846:	68fb      	ldr	r3, [r7, #12]
 8004848:	681b      	ldr	r3, [r3, #0]
 800484a:	4a67      	ldr	r2, [pc, #412]	@ (80049e8 <HAL_DMA_Start_IT+0x4c0>)
 800484c:	4293      	cmp	r3, r2
 800484e:	d013      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 8004850:	68fb      	ldr	r3, [r7, #12]
 8004852:	681b      	ldr	r3, [r3, #0]
 8004854:	4a65      	ldr	r2, [pc, #404]	@ (80049ec <HAL_DMA_Start_IT+0x4c4>)
 8004856:	4293      	cmp	r3, r2
 8004858:	d00e      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 800485a:	68fb      	ldr	r3, [r7, #12]
 800485c:	681b      	ldr	r3, [r3, #0]
 800485e:	4a64      	ldr	r2, [pc, #400]	@ (80049f0 <HAL_DMA_Start_IT+0x4c8>)
 8004860:	4293      	cmp	r3, r2
 8004862:	d009      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 8004864:	68fb      	ldr	r3, [r7, #12]
 8004866:	681b      	ldr	r3, [r3, #0]
 8004868:	4a62      	ldr	r2, [pc, #392]	@ (80049f4 <HAL_DMA_Start_IT+0x4cc>)
 800486a:	4293      	cmp	r3, r2
 800486c:	d004      	beq.n	8004878 <HAL_DMA_Start_IT+0x350>
 800486e:	68fb      	ldr	r3, [r7, #12]
 8004870:	681b      	ldr	r3, [r3, #0]
 8004872:	4a61      	ldr	r2, [pc, #388]	@ (80049f8 <HAL_DMA_Start_IT+0x4d0>)
 8004874:	4293      	cmp	r3, r2
 8004876:	d101      	bne.n	800487c <HAL_DMA_Start_IT+0x354>
 8004878:	2301      	movs	r3, #1
 800487a:	e000      	b.n	800487e <HAL_DMA_Start_IT+0x356>
 800487c:	2300      	movs	r3, #0
 800487e:	2b00      	cmp	r3, #0
 8004880:	d01a      	beq.n	80048b8 <HAL_DMA_Start_IT+0x390>
    {
      /* Check if DMAMUX Synchronization is enabled */
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
 8004882:	68fb      	ldr	r3, [r7, #12]
 8004884:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8004886:	681b      	ldr	r3, [r3, #0]
 8004888:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 800488c:	2b00      	cmp	r3, #0
 800488e:	d007      	beq.n	80048a0 <HAL_DMA_Start_IT+0x378>
      {
        /* Enable DMAMUX sync overrun IT*/
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
 8004890:	68fb      	ldr	r3, [r7, #12]
 8004892:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8004894:	681a      	ldr	r2, [r3, #0]
 8004896:	68fb      	ldr	r3, [r7, #12]
 8004898:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 800489a:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 800489e:	601a      	str	r2, [r3, #0]
      }

      if(hdma->DMAmuxRequestGen != 0U)
 80048a0:	68fb      	ldr	r3, [r7, #12]
 80048a2:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80048a4:	2b00      	cmp	r3, #0
 80048a6:	d007      	beq.n	80048b8 <HAL_DMA_Start_IT+0x390>
      {
        /* if using DMAMUX request generator, enable the DMAMUX request generator overrun IT*/
        /* enable the request gen overrun IT */
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
 80048a8:	68fb      	ldr	r3, [r7, #12]
 80048aa:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80048ac:	681a      	ldr	r2, [r3, #0]
 80048ae:	68fb      	ldr	r3, [r7, #12]
 80048b0:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 80048b2:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 80048b6:	601a      	str	r2, [r3, #0]
      }
    }

    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
 80048b8:	68fb      	ldr	r3, [r7, #12]
 80048ba:	681b      	ldr	r3, [r3, #0]
 80048bc:	4a37      	ldr	r2, [pc, #220]	@ (800499c <HAL_DMA_Start_IT+0x474>)
 80048be:	4293      	cmp	r3, r2
 80048c0:	d04a      	beq.n	8004958 <HAL_DMA_Start_IT+0x430>
 80048c2:	68fb      	ldr	r3, [r7, #12]
 80048c4:	681b      	ldr	r3, [r3, #0]
 80048c6:	4a36      	ldr	r2, [pc, #216]	@ (80049a0 <HAL_DMA_Start_IT+0x478>)
 80048c8:	4293      	cmp	r3, r2
 80048ca:	d045      	beq.n	8004958 <HAL_DMA_Start_IT+0x430>
 80048cc:	68fb      	ldr	r3, [r7, #12]
 80048ce:	681b      	ldr	r3, [r3, #0]
 80048d0:	4a34      	ldr	r2, [pc, #208]	@ (80049a4 <HAL_DMA_Start_IT+0x47c>)
 80048d2:	4293      	cmp	r3, r2
 80048d4:	d040      	beq.n	8004958 <HAL_DMA_Start_IT+0x430>
 80048d6:	68fb      	ldr	r3, [r7, #12]
 80048d8:	681b      	ldr	r3, [r3, #0]
 80048da:	4a33      	ldr	r2, [pc, #204]	@ (80049a8 <HAL_DMA_Start_IT+0x480>)
 80048dc:	4293      	cmp	r3, r2
 80048de:	d03b      	beq.n	8004958 <HAL_DMA_Start_IT+0x430>
 80048e0:	68fb      	ldr	r3, [r7, #12]
 80048e2:	681b      	ldr	r3, [r3, #0]
 80048e4:	4a31      	ldr	r2, [pc, #196]	@ (80049ac <HAL_DMA_Start_IT+0x484>)
 80048e6:	4293      	cmp	r3, r2
 80048e8:	d036      	beq.n	8004958 <HAL_DMA_Start_IT+0x430>
 80048ea:	68fb      	ldr	r3, [r7, #12]
 80048ec:	681b      	ldr	r3, [r3, #0]
 80048ee:	4a30      	ldr	r2, [pc, #192]	@ (80049b0 <HAL_DMA_Start_IT+0x488>)
 80048f0:	4293      	cmp	r3, r2
 80048f2:	d031      	beq.n	8004958 <HAL_DMA_Start_IT+0x430>
 80048f4:	68fb      	ldr	r3, [r7, #12]
 80048f6:	681b      	ldr	r3, [r3, #0]
 80048f8:	4a2e      	ldr	r2, [pc, #184]	@ (80049b4 <HAL_DMA_Start_IT+0x48c>)
 80048fa:	4293      	cmp	r3, r2
 80048fc:	d02c      	beq.n	8004958 <HAL_DMA_Start_IT+0x430>
 80048fe:	68fb      	ldr	r3, [r7, #12]
 8004900:	681b      	ldr	r3, [r3, #0]
 8004902:	4a2d      	ldr	r2, [pc, #180]	@ (80049b8 <HAL_DMA_Start_IT+0x490>)
 8004904:	4293      	cmp	r3, r2
 8004906:	d027      	beq.n	8004958 <HAL_DMA_Start_IT+0x430>
 8004908:	68fb      	ldr	r3, [r7, #12]
 800490a:	681b      	ldr	r3, [r3, #0]
 800490c:	4a2b      	ldr	r2, [pc, #172]	@ (80049bc <HAL_DMA_Start_IT+0x494>)
 800490e:	4293      	cmp	r3, r2
 8004910:	d022      	beq.n	8004958 <HAL_DMA_Start_IT+0x430>
 8004912:	68fb      	ldr	r3, [r7, #12]
 8004914:	681b      	ldr	r3, [r3, #0]
 8004916:	4a2a      	ldr	r2, [pc, #168]	@ (80049c0 <HAL_DMA_Start_IT+0x498>)
 8004918:	4293      	cmp	r3, r2
 800491a:	d01d      	beq.n	8004958 <HAL_DMA_Start_IT+0x430>
 800491c:	68fb      	ldr	r3, [r7, #12]
 800491e:	681b      	ldr	r3, [r3, #0]
 8004920:	4a28      	ldr	r2, [pc, #160]	@ (80049c4 <HAL_DMA_Start_IT+0x49c>)
 8004922:	4293      	cmp	r3, r2
 8004924:	d018      	beq.n	8004958 <HAL_DMA_Start_IT+0x430>
 8004926:	68fb      	ldr	r3, [r7, #12]
 8004928:	681b      	ldr	r3, [r3, #0]
 800492a:	4a27      	ldr	r2, [pc, #156]	@ (80049c8 <HAL_DMA_Start_IT+0x4a0>)
 800492c:	4293      	cmp	r3, r2
 800492e:	d013      	beq.n	8004958 <HAL_DMA_Start_IT+0x430>
 8004930:	68fb      	ldr	r3, [r7, #12]
 8004932:	681b      	ldr	r3, [r3, #0]
 8004934:	4a25      	ldr	r2, [pc, #148]	@ (80049cc <HAL_DMA_Start_IT+0x4a4>)
 8004936:	4293      	cmp	r3, r2
 8004938:	d00e      	beq.n	8004958 <HAL_DMA_Start_IT+0x430>
 800493a:	68fb      	ldr	r3, [r7, #12]
 800493c:	681b      	ldr	r3, [r3, #0]
 800493e:	4a24      	ldr	r2, [pc, #144]	@ (80049d0 <HAL_DMA_Start_IT+0x4a8>)
 8004940:	4293      	cmp	r3, r2
 8004942:	d009      	beq.n	8004958 <HAL_DMA_Start_IT+0x430>
 8004944:	68fb      	ldr	r3, [r7, #12]
 8004946:	681b      	ldr	r3, [r3, #0]
 8004948:	4a22      	ldr	r2, [pc, #136]	@ (80049d4 <HAL_DMA_Start_IT+0x4ac>)
 800494a:	4293      	cmp	r3, r2
 800494c:	d004      	beq.n	8004958 <HAL_DMA_Start_IT+0x430>
 800494e:	68fb      	ldr	r3, [r7, #12]
 8004950:	681b      	ldr	r3, [r3, #0]
 8004952:	4a21      	ldr	r2, [pc, #132]	@ (80049d8 <HAL_DMA_Start_IT+0x4b0>)
 8004954:	4293      	cmp	r3, r2
 8004956:	d108      	bne.n	800496a <HAL_DMA_Start_IT+0x442>
 8004958:	68fb      	ldr	r3, [r7, #12]
 800495a:	681b      	ldr	r3, [r3, #0]
 800495c:	681a      	ldr	r2, [r3, #0]
 800495e:	68fb      	ldr	r3, [r7, #12]
 8004960:	681b      	ldr	r3, [r3, #0]
 8004962:	f042 0201 	orr.w	r2, r2, #1
 8004966:	601a      	str	r2, [r3, #0]
 8004968:	e012      	b.n	8004990 <HAL_DMA_Start_IT+0x468>
 800496a:	68fb      	ldr	r3, [r7, #12]
 800496c:	681b      	ldr	r3, [r3, #0]
 800496e:	681a      	ldr	r2, [r3, #0]
 8004970:	68fb      	ldr	r3, [r7, #12]
 8004972:	681b      	ldr	r3, [r3, #0]
 8004974:	f042 0201 	orr.w	r2, r2, #1
 8004978:	601a      	str	r2, [r3, #0]
 800497a:	e009      	b.n	8004990 <HAL_DMA_Start_IT+0x468>
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 800497c:	68fb      	ldr	r3, [r7, #12]
 800497e:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8004982:	655a      	str	r2, [r3, #84]	@ 0x54

    /* Process unlocked */
    __HAL_UNLOCK(hdma);
 8004984:	68fb      	ldr	r3, [r7, #12]
 8004986:	2200      	movs	r2, #0
 8004988:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

    /* Return error status */
    status = HAL_ERROR;
 800498c:	2301      	movs	r3, #1
 800498e:	75fb      	strb	r3, [r7, #23]
  }

  return status;
 8004990:	7dfb      	ldrb	r3, [r7, #23]
}
 8004992:	4618      	mov	r0, r3
 8004994:	3718      	adds	r7, #24
 8004996:	46bd      	mov	sp, r7
 8004998:	bd80      	pop	{r7, pc}
 800499a:	bf00      	nop
 800499c:	40020010 	.word	0x40020010
 80049a0:	40020028 	.word	0x40020028
 80049a4:	40020040 	.word	0x40020040
 80049a8:	40020058 	.word	0x40020058
 80049ac:	40020070 	.word	0x40020070
 80049b0:	40020088 	.word	0x40020088
 80049b4:	400200a0 	.word	0x400200a0
 80049b8:	400200b8 	.word	0x400200b8
 80049bc:	40020410 	.word	0x40020410
 80049c0:	40020428 	.word	0x40020428
 80049c4:	40020440 	.word	0x40020440
 80049c8:	40020458 	.word	0x40020458
 80049cc:	40020470 	.word	0x40020470
 80049d0:	40020488 	.word	0x40020488
 80049d4:	400204a0 	.word	0x400204a0
 80049d8:	400204b8 	.word	0x400204b8
 80049dc:	58025408 	.word	0x58025408
 80049e0:	5802541c 	.word	0x5802541c
 80049e4:	58025430 	.word	0x58025430
 80049e8:	58025444 	.word	0x58025444
 80049ec:	58025458 	.word	0x58025458
 80049f0:	5802546c 	.word	0x5802546c
 80049f4:	58025480 	.word	0x58025480
 80049f8:	58025494 	.word	0x58025494

080049fc <HAL_DMA_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 80049fc:	b580      	push	{r7, lr}
 80049fe:	b08a      	sub	sp, #40	@ 0x28
 8004a00:	af00      	add	r7, sp, #0
 8004a02:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr_dma, tmpisr_bdma;
  uint32_t ccr_reg;
  __IO uint32_t count = 0U;
 8004a04:	2300      	movs	r3, #0
 8004a06:	60fb      	str	r3, [r7, #12]
  uint32_t timeout = SystemCoreClock / 9600U;
 8004a08:	4b67      	ldr	r3, [pc, #412]	@ (8004ba8 <HAL_DMA_IRQHandler+0x1ac>)
 8004a0a:	681b      	ldr	r3, [r3, #0]
 8004a0c:	4a67      	ldr	r2, [pc, #412]	@ (8004bac <HAL_DMA_IRQHandler+0x1b0>)
 8004a0e:	fba2 2303 	umull	r2, r3, r2, r3
 8004a12:	0a9b      	lsrs	r3, r3, #10
 8004a14:	627b      	str	r3, [r7, #36]	@ 0x24

  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8004a16:	687b      	ldr	r3, [r7, #4]
 8004a18:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8004a1a:	623b      	str	r3, [r7, #32]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
 8004a1c:	687b      	ldr	r3, [r7, #4]
 8004a1e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8004a20:	61fb      	str	r3, [r7, #28]

  tmpisr_dma  = regs_dma->ISR;
 8004a22:	6a3b      	ldr	r3, [r7, #32]
 8004a24:	681b      	ldr	r3, [r3, #0]
 8004a26:	61bb      	str	r3, [r7, #24]
  tmpisr_bdma = regs_bdma->ISR;
 8004a28:	69fb      	ldr	r3, [r7, #28]
 8004a2a:	681b      	ldr	r3, [r3, #0]
 8004a2c:	617b      	str	r3, [r7, #20]

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
 8004a2e:	687b      	ldr	r3, [r7, #4]
 8004a30:	681b      	ldr	r3, [r3, #0]
 8004a32:	4a5f      	ldr	r2, [pc, #380]	@ (8004bb0 <HAL_DMA_IRQHandler+0x1b4>)
 8004a34:	4293      	cmp	r3, r2
 8004a36:	d04a      	beq.n	8004ace <HAL_DMA_IRQHandler+0xd2>
 8004a38:	687b      	ldr	r3, [r7, #4]
 8004a3a:	681b      	ldr	r3, [r3, #0]
 8004a3c:	4a5d      	ldr	r2, [pc, #372]	@ (8004bb4 <HAL_DMA_IRQHandler+0x1b8>)
 8004a3e:	4293      	cmp	r3, r2
 8004a40:	d045      	beq.n	8004ace <HAL_DMA_IRQHandler+0xd2>
 8004a42:	687b      	ldr	r3, [r7, #4]
 8004a44:	681b      	ldr	r3, [r3, #0]
 8004a46:	4a5c      	ldr	r2, [pc, #368]	@ (8004bb8 <HAL_DMA_IRQHandler+0x1bc>)
 8004a48:	4293      	cmp	r3, r2
 8004a4a:	d040      	beq.n	8004ace <HAL_DMA_IRQHandler+0xd2>
 8004a4c:	687b      	ldr	r3, [r7, #4]
 8004a4e:	681b      	ldr	r3, [r3, #0]
 8004a50:	4a5a      	ldr	r2, [pc, #360]	@ (8004bbc <HAL_DMA_IRQHandler+0x1c0>)
 8004a52:	4293      	cmp	r3, r2
 8004a54:	d03b      	beq.n	8004ace <HAL_DMA_IRQHandler+0xd2>
 8004a56:	687b      	ldr	r3, [r7, #4]
 8004a58:	681b      	ldr	r3, [r3, #0]
 8004a5a:	4a59      	ldr	r2, [pc, #356]	@ (8004bc0 <HAL_DMA_IRQHandler+0x1c4>)
 8004a5c:	4293      	cmp	r3, r2
 8004a5e:	d036      	beq.n	8004ace <HAL_DMA_IRQHandler+0xd2>
 8004a60:	687b      	ldr	r3, [r7, #4]
 8004a62:	681b      	ldr	r3, [r3, #0]
 8004a64:	4a57      	ldr	r2, [pc, #348]	@ (8004bc4 <HAL_DMA_IRQHandler+0x1c8>)
 8004a66:	4293      	cmp	r3, r2
 8004a68:	d031      	beq.n	8004ace <HAL_DMA_IRQHandler+0xd2>
 8004a6a:	687b      	ldr	r3, [r7, #4]
 8004a6c:	681b      	ldr	r3, [r3, #0]
 8004a6e:	4a56      	ldr	r2, [pc, #344]	@ (8004bc8 <HAL_DMA_IRQHandler+0x1cc>)
 8004a70:	4293      	cmp	r3, r2
 8004a72:	d02c      	beq.n	8004ace <HAL_DMA_IRQHandler+0xd2>
 8004a74:	687b      	ldr	r3, [r7, #4]
 8004a76:	681b      	ldr	r3, [r3, #0]
 8004a78:	4a54      	ldr	r2, [pc, #336]	@ (8004bcc <HAL_DMA_IRQHandler+0x1d0>)
 8004a7a:	4293      	cmp	r3, r2
 8004a7c:	d027      	beq.n	8004ace <HAL_DMA_IRQHandler+0xd2>
 8004a7e:	687b      	ldr	r3, [r7, #4]
 8004a80:	681b      	ldr	r3, [r3, #0]
 8004a82:	4a53      	ldr	r2, [pc, #332]	@ (8004bd0 <HAL_DMA_IRQHandler+0x1d4>)
 8004a84:	4293      	cmp	r3, r2
 8004a86:	d022      	beq.n	8004ace <HAL_DMA_IRQHandler+0xd2>
 8004a88:	687b      	ldr	r3, [r7, #4]
 8004a8a:	681b      	ldr	r3, [r3, #0]
 8004a8c:	4a51      	ldr	r2, [pc, #324]	@ (8004bd4 <HAL_DMA_IRQHandler+0x1d8>)
 8004a8e:	4293      	cmp	r3, r2
 8004a90:	d01d      	beq.n	8004ace <HAL_DMA_IRQHandler+0xd2>
 8004a92:	687b      	ldr	r3, [r7, #4]
 8004a94:	681b      	ldr	r3, [r3, #0]
 8004a96:	4a50      	ldr	r2, [pc, #320]	@ (8004bd8 <HAL_DMA_IRQHandler+0x1dc>)
 8004a98:	4293      	cmp	r3, r2
 8004a9a:	d018      	beq.n	8004ace <HAL_DMA_IRQHandler+0xd2>
 8004a9c:	687b      	ldr	r3, [r7, #4]
 8004a9e:	681b      	ldr	r3, [r3, #0]
 8004aa0:	4a4e      	ldr	r2, [pc, #312]	@ (8004bdc <HAL_DMA_IRQHandler+0x1e0>)
 8004aa2:	4293      	cmp	r3, r2
 8004aa4:	d013      	beq.n	8004ace <HAL_DMA_IRQHandler+0xd2>
 8004aa6:	687b      	ldr	r3, [r7, #4]
 8004aa8:	681b      	ldr	r3, [r3, #0]
 8004aaa:	4a4d      	ldr	r2, [pc, #308]	@ (8004be0 <HAL_DMA_IRQHandler+0x1e4>)
 8004aac:	4293      	cmp	r3, r2
 8004aae:	d00e      	beq.n	8004ace <HAL_DMA_IRQHandler+0xd2>
 8004ab0:	687b      	ldr	r3, [r7, #4]
 8004ab2:	681b      	ldr	r3, [r3, #0]
 8004ab4:	4a4b      	ldr	r2, [pc, #300]	@ (8004be4 <HAL_DMA_IRQHandler+0x1e8>)
 8004ab6:	4293      	cmp	r3, r2
 8004ab8:	d009      	beq.n	8004ace <HAL_DMA_IRQHandler+0xd2>
 8004aba:	687b      	ldr	r3, [r7, #4]
 8004abc:	681b      	ldr	r3, [r3, #0]
 8004abe:	4a4a      	ldr	r2, [pc, #296]	@ (8004be8 <HAL_DMA_IRQHandler+0x1ec>)
 8004ac0:	4293      	cmp	r3, r2
 8004ac2:	d004      	beq.n	8004ace <HAL_DMA_IRQHandler+0xd2>
 8004ac4:	687b      	ldr	r3, [r7, #4]
 8004ac6:	681b      	ldr	r3, [r3, #0]
 8004ac8:	4a48      	ldr	r2, [pc, #288]	@ (8004bec <HAL_DMA_IRQHandler+0x1f0>)
 8004aca:	4293      	cmp	r3, r2
 8004acc:	d101      	bne.n	8004ad2 <HAL_DMA_IRQHandler+0xd6>
 8004ace:	2301      	movs	r3, #1
 8004ad0:	e000      	b.n	8004ad4 <HAL_DMA_IRQHandler+0xd8>
 8004ad2:	2300      	movs	r3, #0
 8004ad4:	2b00      	cmp	r3, #0
 8004ad6:	f000 842b 	beq.w	8005330 <HAL_DMA_IRQHandler+0x934>
  {
    /* Transfer Error Interrupt management ***************************************/
    if ((tmpisr_dma & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 8004ada:	687b      	ldr	r3, [r7, #4]
 8004adc:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8004ade:	f003 031f 	and.w	r3, r3, #31
 8004ae2:	2208      	movs	r2, #8
 8004ae4:	409a      	lsls	r2, r3
 8004ae6:	69bb      	ldr	r3, [r7, #24]
 8004ae8:	4013      	ands	r3, r2
 8004aea:	2b00      	cmp	r3, #0
 8004aec:	f000 80a2 	beq.w	8004c34 <HAL_DMA_IRQHandler+0x238>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != 0U)
 8004af0:	687b      	ldr	r3, [r7, #4]
 8004af2:	681b      	ldr	r3, [r3, #0]
 8004af4:	4a2e      	ldr	r2, [pc, #184]	@ (8004bb0 <HAL_DMA_IRQHandler+0x1b4>)
 8004af6:	4293      	cmp	r3, r2
 8004af8:	d04a      	beq.n	8004b90 <HAL_DMA_IRQHandler+0x194>
 8004afa:	687b      	ldr	r3, [r7, #4]
 8004afc:	681b      	ldr	r3, [r3, #0]
 8004afe:	4a2d      	ldr	r2, [pc, #180]	@ (8004bb4 <HAL_DMA_IRQHandler+0x1b8>)
 8004b00:	4293      	cmp	r3, r2
 8004b02:	d045      	beq.n	8004b90 <HAL_DMA_IRQHandler+0x194>
 8004b04:	687b      	ldr	r3, [r7, #4]
 8004b06:	681b      	ldr	r3, [r3, #0]
 8004b08:	4a2b      	ldr	r2, [pc, #172]	@ (8004bb8 <HAL_DMA_IRQHandler+0x1bc>)
 8004b0a:	4293      	cmp	r3, r2
 8004b0c:	d040      	beq.n	8004b90 <HAL_DMA_IRQHandler+0x194>
 8004b0e:	687b      	ldr	r3, [r7, #4]
 8004b10:	681b      	ldr	r3, [r3, #0]
 8004b12:	4a2a      	ldr	r2, [pc, #168]	@ (8004bbc <HAL_DMA_IRQHandler+0x1c0>)
 8004b14:	4293      	cmp	r3, r2
 8004b16:	d03b      	beq.n	8004b90 <HAL_DMA_IRQHandler+0x194>
 8004b18:	687b      	ldr	r3, [r7, #4]
 8004b1a:	681b      	ldr	r3, [r3, #0]
 8004b1c:	4a28      	ldr	r2, [pc, #160]	@ (8004bc0 <HAL_DMA_IRQHandler+0x1c4>)
 8004b1e:	4293      	cmp	r3, r2
 8004b20:	d036      	beq.n	8004b90 <HAL_DMA_IRQHandler+0x194>
 8004b22:	687b      	ldr	r3, [r7, #4]
 8004b24:	681b      	ldr	r3, [r3, #0]
 8004b26:	4a27      	ldr	r2, [pc, #156]	@ (8004bc4 <HAL_DMA_IRQHandler+0x1c8>)
 8004b28:	4293      	cmp	r3, r2
 8004b2a:	d031      	beq.n	8004b90 <HAL_DMA_IRQHandler+0x194>
 8004b2c:	687b      	ldr	r3, [r7, #4]
 8004b2e:	681b      	ldr	r3, [r3, #0]
 8004b30:	4a25      	ldr	r2, [pc, #148]	@ (8004bc8 <HAL_DMA_IRQHandler+0x1cc>)
 8004b32:	4293      	cmp	r3, r2
 8004b34:	d02c      	beq.n	8004b90 <HAL_DMA_IRQHandler+0x194>
 8004b36:	687b      	ldr	r3, [r7, #4]
 8004b38:	681b      	ldr	r3, [r3, #0]
 8004b3a:	4a24      	ldr	r2, [pc, #144]	@ (8004bcc <HAL_DMA_IRQHandler+0x1d0>)
 8004b3c:	4293      	cmp	r3, r2
 8004b3e:	d027      	beq.n	8004b90 <HAL_DMA_IRQHandler+0x194>
 8004b40:	687b      	ldr	r3, [r7, #4]
 8004b42:	681b      	ldr	r3, [r3, #0]
 8004b44:	4a22      	ldr	r2, [pc, #136]	@ (8004bd0 <HAL_DMA_IRQHandler+0x1d4>)
 8004b46:	4293      	cmp	r3, r2
 8004b48:	d022      	beq.n	8004b90 <HAL_DMA_IRQHandler+0x194>
 8004b4a:	687b      	ldr	r3, [r7, #4]
 8004b4c:	681b      	ldr	r3, [r3, #0]
 8004b4e:	4a21      	ldr	r2, [pc, #132]	@ (8004bd4 <HAL_DMA_IRQHandler+0x1d8>)
 8004b50:	4293      	cmp	r3, r2
 8004b52:	d01d      	beq.n	8004b90 <HAL_DMA_IRQHandler+0x194>
 8004b54:	687b      	ldr	r3, [r7, #4]
 8004b56:	681b      	ldr	r3, [r3, #0]
 8004b58:	4a1f      	ldr	r2, [pc, #124]	@ (8004bd8 <HAL_DMA_IRQHandler+0x1dc>)
 8004b5a:	4293      	cmp	r3, r2
 8004b5c:	d018      	beq.n	8004b90 <HAL_DMA_IRQHandler+0x194>
 8004b5e:	687b      	ldr	r3, [r7, #4]
 8004b60:	681b      	ldr	r3, [r3, #0]
 8004b62:	4a1e      	ldr	r2, [pc, #120]	@ (8004bdc <HAL_DMA_IRQHandler+0x1e0>)
 8004b64:	4293      	cmp	r3, r2
 8004b66:	d013      	beq.n	8004b90 <HAL_DMA_IRQHandler+0x194>
 8004b68:	687b      	ldr	r3, [r7, #4]
 8004b6a:	681b      	ldr	r3, [r3, #0]
 8004b6c:	4a1c      	ldr	r2, [pc, #112]	@ (8004be0 <HAL_DMA_IRQHandler+0x1e4>)
 8004b6e:	4293      	cmp	r3, r2
 8004b70:	d00e      	beq.n	8004b90 <HAL_DMA_IRQHandler+0x194>
 8004b72:	687b      	ldr	r3, [r7, #4]
 8004b74:	681b      	ldr	r3, [r3, #0]
 8004b76:	4a1b      	ldr	r2, [pc, #108]	@ (8004be4 <HAL_DMA_IRQHandler+0x1e8>)
 8004b78:	4293      	cmp	r3, r2
 8004b7a:	d009      	beq.n	8004b90 <HAL_DMA_IRQHandler+0x194>
 8004b7c:	687b      	ldr	r3, [r7, #4]
 8004b7e:	681b      	ldr	r3, [r3, #0]
 8004b80:	4a19      	ldr	r2, [pc, #100]	@ (8004be8 <HAL_DMA_IRQHandler+0x1ec>)
 8004b82:	4293      	cmp	r3, r2
 8004b84:	d004      	beq.n	8004b90 <HAL_DMA_IRQHandler+0x194>
 8004b86:	687b      	ldr	r3, [r7, #4]
 8004b88:	681b      	ldr	r3, [r3, #0]
 8004b8a:	4a18      	ldr	r2, [pc, #96]	@ (8004bec <HAL_DMA_IRQHandler+0x1f0>)
 8004b8c:	4293      	cmp	r3, r2
 8004b8e:	d12f      	bne.n	8004bf0 <HAL_DMA_IRQHandler+0x1f4>
 8004b90:	687b      	ldr	r3, [r7, #4]
 8004b92:	681b      	ldr	r3, [r3, #0]
 8004b94:	681b      	ldr	r3, [r3, #0]
 8004b96:	f003 0304 	and.w	r3, r3, #4
 8004b9a:	2b00      	cmp	r3, #0
 8004b9c:	bf14      	ite	ne
 8004b9e:	2301      	movne	r3, #1
 8004ba0:	2300      	moveq	r3, #0
 8004ba2:	b2db      	uxtb	r3, r3
 8004ba4:	e02e      	b.n	8004c04 <HAL_DMA_IRQHandler+0x208>
 8004ba6:	bf00      	nop
 8004ba8:	24000000 	.word	0x24000000
 8004bac:	1b4e81b5 	.word	0x1b4e81b5
 8004bb0:	40020010 	.word	0x40020010
 8004bb4:	40020028 	.word	0x40020028
 8004bb8:	40020040 	.word	0x40020040
 8004bbc:	40020058 	.word	0x40020058
 8004bc0:	40020070 	.word	0x40020070
 8004bc4:	40020088 	.word	0x40020088
 8004bc8:	400200a0 	.word	0x400200a0
 8004bcc:	400200b8 	.word	0x400200b8
 8004bd0:	40020410 	.word	0x40020410
 8004bd4:	40020428 	.word	0x40020428
 8004bd8:	40020440 	.word	0x40020440
 8004bdc:	40020458 	.word	0x40020458
 8004be0:	40020470 	.word	0x40020470
 8004be4:	40020488 	.word	0x40020488
 8004be8:	400204a0 	.word	0x400204a0
 8004bec:	400204b8 	.word	0x400204b8
 8004bf0:	687b      	ldr	r3, [r7, #4]
 8004bf2:	681b      	ldr	r3, [r3, #0]
 8004bf4:	681b      	ldr	r3, [r3, #0]
 8004bf6:	f003 0308 	and.w	r3, r3, #8
 8004bfa:	2b00      	cmp	r3, #0
 8004bfc:	bf14      	ite	ne
 8004bfe:	2301      	movne	r3, #1
 8004c00:	2300      	moveq	r3, #0
 8004c02:	b2db      	uxtb	r3, r3
 8004c04:	2b00      	cmp	r3, #0
 8004c06:	d015      	beq.n	8004c34 <HAL_DMA_IRQHandler+0x238>
      {
        /* Disable the transfer error interrupt */
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TE);
 8004c08:	687b      	ldr	r3, [r7, #4]
 8004c0a:	681b      	ldr	r3, [r3, #0]
 8004c0c:	681a      	ldr	r2, [r3, #0]
 8004c0e:	687b      	ldr	r3, [r7, #4]
 8004c10:	681b      	ldr	r3, [r3, #0]
 8004c12:	f022 0204 	bic.w	r2, r2, #4
 8004c16:	601a      	str	r2, [r3, #0]

        /* Clear the transfer error flag */
        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
 8004c18:	687b      	ldr	r3, [r7, #4]
 8004c1a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8004c1c:	f003 031f 	and.w	r3, r3, #31
 8004c20:	2208      	movs	r2, #8
 8004c22:	409a      	lsls	r2, r3
 8004c24:	6a3b      	ldr	r3, [r7, #32]
 8004c26:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8004c28:	687b      	ldr	r3, [r7, #4]
 8004c2a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8004c2c:	f043 0201 	orr.w	r2, r3, #1
 8004c30:	687b      	ldr	r3, [r7, #4]
 8004c32:	655a      	str	r2, [r3, #84]	@ 0x54
      }
    }
    /* FIFO Error Interrupt management ******************************************/
    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 8004c34:	687b      	ldr	r3, [r7, #4]
 8004c36:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8004c38:	f003 031f 	and.w	r3, r3, #31
 8004c3c:	69ba      	ldr	r2, [r7, #24]
 8004c3e:	fa22 f303 	lsr.w	r3, r2, r3
 8004c42:	f003 0301 	and.w	r3, r3, #1
 8004c46:	2b00      	cmp	r3, #0
 8004c48:	d06e      	beq.n	8004d28 <HAL_DMA_IRQHandler+0x32c>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)
 8004c4a:	687b      	ldr	r3, [r7, #4]
 8004c4c:	681b      	ldr	r3, [r3, #0]
 8004c4e:	4a69      	ldr	r2, [pc, #420]	@ (8004df4 <HAL_DMA_IRQHandler+0x3f8>)
 8004c50:	4293      	cmp	r3, r2
 8004c52:	d04a      	beq.n	8004cea <HAL_DMA_IRQHandler+0x2ee>
 8004c54:	687b      	ldr	r3, [r7, #4]
 8004c56:	681b      	ldr	r3, [r3, #0]
 8004c58:	4a67      	ldr	r2, [pc, #412]	@ (8004df8 <HAL_DMA_IRQHandler+0x3fc>)
 8004c5a:	4293      	cmp	r3, r2
 8004c5c:	d045      	beq.n	8004cea <HAL_DMA_IRQHandler+0x2ee>
 8004c5e:	687b      	ldr	r3, [r7, #4]
 8004c60:	681b      	ldr	r3, [r3, #0]
 8004c62:	4a66      	ldr	r2, [pc, #408]	@ (8004dfc <HAL_DMA_IRQHandler+0x400>)
 8004c64:	4293      	cmp	r3, r2
 8004c66:	d040      	beq.n	8004cea <HAL_DMA_IRQHandler+0x2ee>
 8004c68:	687b      	ldr	r3, [r7, #4]
 8004c6a:	681b      	ldr	r3, [r3, #0]
 8004c6c:	4a64      	ldr	r2, [pc, #400]	@ (8004e00 <HAL_DMA_IRQHandler+0x404>)
 8004c6e:	4293      	cmp	r3, r2
 8004c70:	d03b      	beq.n	8004cea <HAL_DMA_IRQHandler+0x2ee>
 8004c72:	687b      	ldr	r3, [r7, #4]
 8004c74:	681b      	ldr	r3, [r3, #0]
 8004c76:	4a63      	ldr	r2, [pc, #396]	@ (8004e04 <HAL_DMA_IRQHandler+0x408>)
 8004c78:	4293      	cmp	r3, r2
 8004c7a:	d036      	beq.n	8004cea <HAL_DMA_IRQHandler+0x2ee>
 8004c7c:	687b      	ldr	r3, [r7, #4]
 8004c7e:	681b      	ldr	r3, [r3, #0]
 8004c80:	4a61      	ldr	r2, [pc, #388]	@ (8004e08 <HAL_DMA_IRQHandler+0x40c>)
 8004c82:	4293      	cmp	r3, r2
 8004c84:	d031      	beq.n	8004cea <HAL_DMA_IRQHandler+0x2ee>
 8004c86:	687b      	ldr	r3, [r7, #4]
 8004c88:	681b      	ldr	r3, [r3, #0]
 8004c8a:	4a60      	ldr	r2, [pc, #384]	@ (8004e0c <HAL_DMA_IRQHandler+0x410>)
 8004c8c:	4293      	cmp	r3, r2
 8004c8e:	d02c      	beq.n	8004cea <HAL_DMA_IRQHandler+0x2ee>
 8004c90:	687b      	ldr	r3, [r7, #4]
 8004c92:	681b      	ldr	r3, [r3, #0]
 8004c94:	4a5e      	ldr	r2, [pc, #376]	@ (8004e10 <HAL_DMA_IRQHandler+0x414>)
 8004c96:	4293      	cmp	r3, r2
 8004c98:	d027      	beq.n	8004cea <HAL_DMA_IRQHandler+0x2ee>
 8004c9a:	687b      	ldr	r3, [r7, #4]
 8004c9c:	681b      	ldr	r3, [r3, #0]
 8004c9e:	4a5d      	ldr	r2, [pc, #372]	@ (8004e14 <HAL_DMA_IRQHandler+0x418>)
 8004ca0:	4293      	cmp	r3, r2
 8004ca2:	d022      	beq.n	8004cea <HAL_DMA_IRQHandler+0x2ee>
 8004ca4:	687b      	ldr	r3, [r7, #4]
 8004ca6:	681b      	ldr	r3, [r3, #0]
 8004ca8:	4a5b      	ldr	r2, [pc, #364]	@ (8004e18 <HAL_DMA_IRQHandler+0x41c>)
 8004caa:	4293      	cmp	r3, r2
 8004cac:	d01d      	beq.n	8004cea <HAL_DMA_IRQHandler+0x2ee>
 8004cae:	687b      	ldr	r3, [r7, #4]
 8004cb0:	681b      	ldr	r3, [r3, #0]
 8004cb2:	4a5a      	ldr	r2, [pc, #360]	@ (8004e1c <HAL_DMA_IRQHandler+0x420>)
 8004cb4:	4293      	cmp	r3, r2
 8004cb6:	d018      	beq.n	8004cea <HAL_DMA_IRQHandler+0x2ee>
 8004cb8:	687b      	ldr	r3, [r7, #4]
 8004cba:	681b      	ldr	r3, [r3, #0]
 8004cbc:	4a58      	ldr	r2, [pc, #352]	@ (8004e20 <HAL_DMA_IRQHandler+0x424>)
 8004cbe:	4293      	cmp	r3, r2
 8004cc0:	d013      	beq.n	8004cea <HAL_DMA_IRQHandler+0x2ee>
 8004cc2:	687b      	ldr	r3, [r7, #4]
 8004cc4:	681b      	ldr	r3, [r3, #0]
 8004cc6:	4a57      	ldr	r2, [pc, #348]	@ (8004e24 <HAL_DMA_IRQHandler+0x428>)
 8004cc8:	4293      	cmp	r3, r2
 8004cca:	d00e      	beq.n	8004cea <HAL_DMA_IRQHandler+0x2ee>
 8004ccc:	687b      	ldr	r3, [r7, #4]
 8004cce:	681b      	ldr	r3, [r3, #0]
 8004cd0:	4a55      	ldr	r2, [pc, #340]	@ (8004e28 <HAL_DMA_IRQHandler+0x42c>)
 8004cd2:	4293      	cmp	r3, r2
 8004cd4:	d009      	beq.n	8004cea <HAL_DMA_IRQHandler+0x2ee>
 8004cd6:	687b      	ldr	r3, [r7, #4]
 8004cd8:	681b      	ldr	r3, [r3, #0]
 8004cda:	4a54      	ldr	r2, [pc, #336]	@ (8004e2c <HAL_DMA_IRQHandler+0x430>)
 8004cdc:	4293      	cmp	r3, r2
 8004cde:	d004      	beq.n	8004cea <HAL_DMA_IRQHandler+0x2ee>
 8004ce0:	687b      	ldr	r3, [r7, #4]
 8004ce2:	681b      	ldr	r3, [r3, #0]
 8004ce4:	4a52      	ldr	r2, [pc, #328]	@ (8004e30 <HAL_DMA_IRQHandler+0x434>)
 8004ce6:	4293      	cmp	r3, r2
 8004ce8:	d10a      	bne.n	8004d00 <HAL_DMA_IRQHandler+0x304>
 8004cea:	687b      	ldr	r3, [r7, #4]
 8004cec:	681b      	ldr	r3, [r3, #0]
 8004cee:	695b      	ldr	r3, [r3, #20]
 8004cf0:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8004cf4:	2b00      	cmp	r3, #0
 8004cf6:	bf14      	ite	ne
 8004cf8:	2301      	movne	r3, #1
 8004cfa:	2300      	moveq	r3, #0
 8004cfc:	b2db      	uxtb	r3, r3
 8004cfe:	e003      	b.n	8004d08 <HAL_DMA_IRQHandler+0x30c>
 8004d00:	687b      	ldr	r3, [r7, #4]
 8004d02:	681b      	ldr	r3, [r3, #0]
 8004d04:	681b      	ldr	r3, [r3, #0]
 8004d06:	2300      	movs	r3, #0
 8004d08:	2b00      	cmp	r3, #0
 8004d0a:	d00d      	beq.n	8004d28 <HAL_DMA_IRQHandler+0x32c>
      {
        /* Clear the FIFO error flag */
        regs_dma->IFCR = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
 8004d0c:	687b      	ldr	r3, [r7, #4]
 8004d0e:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8004d10:	f003 031f 	and.w	r3, r3, #31
 8004d14:	2201      	movs	r2, #1
 8004d16:	409a      	lsls	r2, r3
 8004d18:	6a3b      	ldr	r3, [r7, #32]
 8004d1a:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8004d1c:	687b      	ldr	r3, [r7, #4]
 8004d1e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8004d20:	f043 0202 	orr.w	r2, r3, #2
 8004d24:	687b      	ldr	r3, [r7, #4]
 8004d26:	655a      	str	r2, [r3, #84]	@ 0x54
      }
    }
    /* Direct Mode Error Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 8004d28:	687b      	ldr	r3, [r7, #4]
 8004d2a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8004d2c:	f003 031f 	and.w	r3, r3, #31
 8004d30:	2204      	movs	r2, #4
 8004d32:	409a      	lsls	r2, r3
 8004d34:	69bb      	ldr	r3, [r7, #24]
 8004d36:	4013      	ands	r3, r2
 8004d38:	2b00      	cmp	r3, #0
 8004d3a:	f000 808f 	beq.w	8004e5c <HAL_DMA_IRQHandler+0x460>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)
 8004d3e:	687b      	ldr	r3, [r7, #4]
 8004d40:	681b      	ldr	r3, [r3, #0]
 8004d42:	4a2c      	ldr	r2, [pc, #176]	@ (8004df4 <HAL_DMA_IRQHandler+0x3f8>)
 8004d44:	4293      	cmp	r3, r2
 8004d46:	d04a      	beq.n	8004dde <HAL_DMA_IRQHandler+0x3e2>
 8004d48:	687b      	ldr	r3, [r7, #4]
 8004d4a:	681b      	ldr	r3, [r3, #0]
 8004d4c:	4a2a      	ldr	r2, [pc, #168]	@ (8004df8 <HAL_DMA_IRQHandler+0x3fc>)
 8004d4e:	4293      	cmp	r3, r2
 8004d50:	d045      	beq.n	8004dde <HAL_DMA_IRQHandler+0x3e2>
 8004d52:	687b      	ldr	r3, [r7, #4]
 8004d54:	681b      	ldr	r3, [r3, #0]
 8004d56:	4a29      	ldr	r2, [pc, #164]	@ (8004dfc <HAL_DMA_IRQHandler+0x400>)
 8004d58:	4293      	cmp	r3, r2
 8004d5a:	d040      	beq.n	8004dde <HAL_DMA_IRQHandler+0x3e2>
 8004d5c:	687b      	ldr	r3, [r7, #4]
 8004d5e:	681b      	ldr	r3, [r3, #0]
 8004d60:	4a27      	ldr	r2, [pc, #156]	@ (8004e00 <HAL_DMA_IRQHandler+0x404>)
 8004d62:	4293      	cmp	r3, r2
 8004d64:	d03b      	beq.n	8004dde <HAL_DMA_IRQHandler+0x3e2>
 8004d66:	687b      	ldr	r3, [r7, #4]
 8004d68:	681b      	ldr	r3, [r3, #0]
 8004d6a:	4a26      	ldr	r2, [pc, #152]	@ (8004e04 <HAL_DMA_IRQHandler+0x408>)
 8004d6c:	4293      	cmp	r3, r2
 8004d6e:	d036      	beq.n	8004dde <HAL_DMA_IRQHandler+0x3e2>
 8004d70:	687b      	ldr	r3, [r7, #4]
 8004d72:	681b      	ldr	r3, [r3, #0]
 8004d74:	4a24      	ldr	r2, [pc, #144]	@ (8004e08 <HAL_DMA_IRQHandler+0x40c>)
 8004d76:	4293      	cmp	r3, r2
 8004d78:	d031      	beq.n	8004dde <HAL_DMA_IRQHandler+0x3e2>
 8004d7a:	687b      	ldr	r3, [r7, #4]
 8004d7c:	681b      	ldr	r3, [r3, #0]
 8004d7e:	4a23      	ldr	r2, [pc, #140]	@ (8004e0c <HAL_DMA_IRQHandler+0x410>)
 8004d80:	4293      	cmp	r3, r2
 8004d82:	d02c      	beq.n	8004dde <HAL_DMA_IRQHandler+0x3e2>
 8004d84:	687b      	ldr	r3, [r7, #4]
 8004d86:	681b      	ldr	r3, [r3, #0]
 8004d88:	4a21      	ldr	r2, [pc, #132]	@ (8004e10 <HAL_DMA_IRQHandler+0x414>)
 8004d8a:	4293      	cmp	r3, r2
 8004d8c:	d027      	beq.n	8004dde <HAL_DMA_IRQHandler+0x3e2>
 8004d8e:	687b      	ldr	r3, [r7, #4]
 8004d90:	681b      	ldr	r3, [r3, #0]
 8004d92:	4a20      	ldr	r2, [pc, #128]	@ (8004e14 <HAL_DMA_IRQHandler+0x418>)
 8004d94:	4293      	cmp	r3, r2
 8004d96:	d022      	beq.n	8004dde <HAL_DMA_IRQHandler+0x3e2>
 8004d98:	687b      	ldr	r3, [r7, #4]
 8004d9a:	681b      	ldr	r3, [r3, #0]
 8004d9c:	4a1e      	ldr	r2, [pc, #120]	@ (8004e18 <HAL_DMA_IRQHandler+0x41c>)
 8004d9e:	4293      	cmp	r3, r2
 8004da0:	d01d      	beq.n	8004dde <HAL_DMA_IRQHandler+0x3e2>
 8004da2:	687b      	ldr	r3, [r7, #4]
 8004da4:	681b      	ldr	r3, [r3, #0]
 8004da6:	4a1d      	ldr	r2, [pc, #116]	@ (8004e1c <HAL_DMA_IRQHandler+0x420>)
 8004da8:	4293      	cmp	r3, r2
 8004daa:	d018      	beq.n	8004dde <HAL_DMA_IRQHandler+0x3e2>
 8004dac:	687b      	ldr	r3, [r7, #4]
 8004dae:	681b      	ldr	r3, [r3, #0]
 8004db0:	4a1b      	ldr	r2, [pc, #108]	@ (8004e20 <HAL_DMA_IRQHandler+0x424>)
 8004db2:	4293      	cmp	r3, r2
 8004db4:	d013      	beq.n	8004dde <HAL_DMA_IRQHandler+0x3e2>
 8004db6:	687b      	ldr	r3, [r7, #4]
 8004db8:	681b      	ldr	r3, [r3, #0]
 8004dba:	4a1a      	ldr	r2, [pc, #104]	@ (8004e24 <HAL_DMA_IRQHandler+0x428>)
 8004dbc:	4293      	cmp	r3, r2
 8004dbe:	d00e      	beq.n	8004dde <HAL_DMA_IRQHandler+0x3e2>
 8004dc0:	687b      	ldr	r3, [r7, #4]
 8004dc2:	681b      	ldr	r3, [r3, #0]
 8004dc4:	4a18      	ldr	r2, [pc, #96]	@ (8004e28 <HAL_DMA_IRQHandler+0x42c>)
 8004dc6:	4293      	cmp	r3, r2
 8004dc8:	d009      	beq.n	8004dde <HAL_DMA_IRQHandler+0x3e2>
 8004dca:	687b      	ldr	r3, [r7, #4]
 8004dcc:	681b      	ldr	r3, [r3, #0]
 8004dce:	4a17      	ldr	r2, [pc, #92]	@ (8004e2c <HAL_DMA_IRQHandler+0x430>)
 8004dd0:	4293      	cmp	r3, r2
 8004dd2:	d004      	beq.n	8004dde <HAL_DMA_IRQHandler+0x3e2>
 8004dd4:	687b      	ldr	r3, [r7, #4]
 8004dd6:	681b      	ldr	r3, [r3, #0]
 8004dd8:	4a15      	ldr	r2, [pc, #84]	@ (8004e30 <HAL_DMA_IRQHandler+0x434>)
 8004dda:	4293      	cmp	r3, r2
 8004ddc:	d12a      	bne.n	8004e34 <HAL_DMA_IRQHandler+0x438>
 8004dde:	687b      	ldr	r3, [r7, #4]
 8004de0:	681b      	ldr	r3, [r3, #0]
 8004de2:	681b      	ldr	r3, [r3, #0]
 8004de4:	f003 0302 	and.w	r3, r3, #2
 8004de8:	2b00      	cmp	r3, #0
 8004dea:	bf14      	ite	ne
 8004dec:	2301      	movne	r3, #1
 8004dee:	2300      	moveq	r3, #0
 8004df0:	b2db      	uxtb	r3, r3
 8004df2:	e023      	b.n	8004e3c <HAL_DMA_IRQHandler+0x440>
 8004df4:	40020010 	.word	0x40020010
 8004df8:	40020028 	.word	0x40020028
 8004dfc:	40020040 	.word	0x40020040
 8004e00:	40020058 	.word	0x40020058
 8004e04:	40020070 	.word	0x40020070
 8004e08:	40020088 	.word	0x40020088
 8004e0c:	400200a0 	.word	0x400200a0
 8004e10:	400200b8 	.word	0x400200b8
 8004e14:	40020410 	.word	0x40020410
 8004e18:	40020428 	.word	0x40020428
 8004e1c:	40020440 	.word	0x40020440
 8004e20:	40020458 	.word	0x40020458
 8004e24:	40020470 	.word	0x40020470
 8004e28:	40020488 	.word	0x40020488
 8004e2c:	400204a0 	.word	0x400204a0
 8004e30:	400204b8 	.word	0x400204b8
 8004e34:	687b      	ldr	r3, [r7, #4]
 8004e36:	681b      	ldr	r3, [r3, #0]
 8004e38:	681b      	ldr	r3, [r3, #0]
 8004e3a:	2300      	movs	r3, #0
 8004e3c:	2b00      	cmp	r3, #0
 8004e3e:	d00d      	beq.n	8004e5c <HAL_DMA_IRQHandler+0x460>
      {
        /* Clear the direct mode error flag */
        regs_dma->IFCR = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
 8004e40:	687b      	ldr	r3, [r7, #4]
 8004e42:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8004e44:	f003 031f 	and.w	r3, r3, #31
 8004e48:	2204      	movs	r2, #4
 8004e4a:	409a      	lsls	r2, r3
 8004e4c:	6a3b      	ldr	r3, [r7, #32]
 8004e4e:	609a      	str	r2, [r3, #8]

        /* Update error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8004e50:	687b      	ldr	r3, [r7, #4]
 8004e52:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8004e54:	f043 0204 	orr.w	r2, r3, #4
 8004e58:	687b      	ldr	r3, [r7, #4]
 8004e5a:	655a      	str	r2, [r3, #84]	@ 0x54
      }
    }
    /* Half Transfer Complete Interrupt management ******************************/
    if ((tmpisr_dma & (DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 8004e5c:	687b      	ldr	r3, [r7, #4]
 8004e5e:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8004e60:	f003 031f 	and.w	r3, r3, #31
 8004e64:	2210      	movs	r2, #16
 8004e66:	409a      	lsls	r2, r3
 8004e68:	69bb      	ldr	r3, [r7, #24]
 8004e6a:	4013      	ands	r3, r2
 8004e6c:	2b00      	cmp	r3, #0
 8004e6e:	f000 80a6 	beq.w	8004fbe <HAL_DMA_IRQHandler+0x5c2>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
 8004e72:	687b      	ldr	r3, [r7, #4]
 8004e74:	681b      	ldr	r3, [r3, #0]
 8004e76:	4a85      	ldr	r2, [pc, #532]	@ (800508c <HAL_DMA_IRQHandler+0x690>)
 8004e78:	4293      	cmp	r3, r2
 8004e7a:	d04a      	beq.n	8004f12 <HAL_DMA_IRQHandler+0x516>
 8004e7c:	687b      	ldr	r3, [r7, #4]
 8004e7e:	681b      	ldr	r3, [r3, #0]
 8004e80:	4a83      	ldr	r2, [pc, #524]	@ (8005090 <HAL_DMA_IRQHandler+0x694>)
 8004e82:	4293      	cmp	r3, r2
 8004e84:	d045      	beq.n	8004f12 <HAL_DMA_IRQHandler+0x516>
 8004e86:	687b      	ldr	r3, [r7, #4]
 8004e88:	681b      	ldr	r3, [r3, #0]
 8004e8a:	4a82      	ldr	r2, [pc, #520]	@ (8005094 <HAL_DMA_IRQHandler+0x698>)
 8004e8c:	4293      	cmp	r3, r2
 8004e8e:	d040      	beq.n	8004f12 <HAL_DMA_IRQHandler+0x516>
 8004e90:	687b      	ldr	r3, [r7, #4]
 8004e92:	681b      	ldr	r3, [r3, #0]
 8004e94:	4a80      	ldr	r2, [pc, #512]	@ (8005098 <HAL_DMA_IRQHandler+0x69c>)
 8004e96:	4293      	cmp	r3, r2
 8004e98:	d03b      	beq.n	8004f12 <HAL_DMA_IRQHandler+0x516>
 8004e9a:	687b      	ldr	r3, [r7, #4]
 8004e9c:	681b      	ldr	r3, [r3, #0]
 8004e9e:	4a7f      	ldr	r2, [pc, #508]	@ (800509c <HAL_DMA_IRQHandler+0x6a0>)
 8004ea0:	4293      	cmp	r3, r2
 8004ea2:	d036      	beq.n	8004f12 <HAL_DMA_IRQHandler+0x516>
 8004ea4:	687b      	ldr	r3, [r7, #4]
 8004ea6:	681b      	ldr	r3, [r3, #0]
 8004ea8:	4a7d      	ldr	r2, [pc, #500]	@ (80050a0 <HAL_DMA_IRQHandler+0x6a4>)
 8004eaa:	4293      	cmp	r3, r2
 8004eac:	d031      	beq.n	8004f12 <HAL_DMA_IRQHandler+0x516>
 8004eae:	687b      	ldr	r3, [r7, #4]
 8004eb0:	681b      	ldr	r3, [r3, #0]
 8004eb2:	4a7c      	ldr	r2, [pc, #496]	@ (80050a4 <HAL_DMA_IRQHandler+0x6a8>)
 8004eb4:	4293      	cmp	r3, r2
 8004eb6:	d02c      	beq.n	8004f12 <HAL_DMA_IRQHandler+0x516>
 8004eb8:	687b      	ldr	r3, [r7, #4]
 8004eba:	681b      	ldr	r3, [r3, #0]
 8004ebc:	4a7a      	ldr	r2, [pc, #488]	@ (80050a8 <HAL_DMA_IRQHandler+0x6ac>)
 8004ebe:	4293      	cmp	r3, r2
 8004ec0:	d027      	beq.n	8004f12 <HAL_DMA_IRQHandler+0x516>
 8004ec2:	687b      	ldr	r3, [r7, #4]
 8004ec4:	681b      	ldr	r3, [r3, #0]
 8004ec6:	4a79      	ldr	r2, [pc, #484]	@ (80050ac <HAL_DMA_IRQHandler+0x6b0>)
 8004ec8:	4293      	cmp	r3, r2
 8004eca:	d022      	beq.n	8004f12 <HAL_DMA_IRQHandler+0x516>
 8004ecc:	687b      	ldr	r3, [r7, #4]
 8004ece:	681b      	ldr	r3, [r3, #0]
 8004ed0:	4a77      	ldr	r2, [pc, #476]	@ (80050b0 <HAL_DMA_IRQHandler+0x6b4>)
 8004ed2:	4293      	cmp	r3, r2
 8004ed4:	d01d      	beq.n	8004f12 <HAL_DMA_IRQHandler+0x516>
 8004ed6:	687b      	ldr	r3, [r7, #4]
 8004ed8:	681b      	ldr	r3, [r3, #0]
 8004eda:	4a76      	ldr	r2, [pc, #472]	@ (80050b4 <HAL_DMA_IRQHandler+0x6b8>)
 8004edc:	4293      	cmp	r3, r2
 8004ede:	d018      	beq.n	8004f12 <HAL_DMA_IRQHandler+0x516>
 8004ee0:	687b      	ldr	r3, [r7, #4]
 8004ee2:	681b      	ldr	r3, [r3, #0]
 8004ee4:	4a74      	ldr	r2, [pc, #464]	@ (80050b8 <HAL_DMA_IRQHandler+0x6bc>)
 8004ee6:	4293      	cmp	r3, r2
 8004ee8:	d013      	beq.n	8004f12 <HAL_DMA_IRQHandler+0x516>
 8004eea:	687b      	ldr	r3, [r7, #4]
 8004eec:	681b      	ldr	r3, [r3, #0]
 8004eee:	4a73      	ldr	r2, [pc, #460]	@ (80050bc <HAL_DMA_IRQHandler+0x6c0>)
 8004ef0:	4293      	cmp	r3, r2
 8004ef2:	d00e      	beq.n	8004f12 <HAL_DMA_IRQHandler+0x516>
 8004ef4:	687b      	ldr	r3, [r7, #4]
 8004ef6:	681b      	ldr	r3, [r3, #0]
 8004ef8:	4a71      	ldr	r2, [pc, #452]	@ (80050c0 <HAL_DMA_IRQHandler+0x6c4>)
 8004efa:	4293      	cmp	r3, r2
 8004efc:	d009      	beq.n	8004f12 <HAL_DMA_IRQHandler+0x516>
 8004efe:	687b      	ldr	r3, [r7, #4]
 8004f00:	681b      	ldr	r3, [r3, #0]
 8004f02:	4a70      	ldr	r2, [pc, #448]	@ (80050c4 <HAL_DMA_IRQHandler+0x6c8>)
 8004f04:	4293      	cmp	r3, r2
 8004f06:	d004      	beq.n	8004f12 <HAL_DMA_IRQHandler+0x516>
 8004f08:	687b      	ldr	r3, [r7, #4]
 8004f0a:	681b      	ldr	r3, [r3, #0]
 8004f0c:	4a6e      	ldr	r2, [pc, #440]	@ (80050c8 <HAL_DMA_IRQHandler+0x6cc>)
 8004f0e:	4293      	cmp	r3, r2
 8004f10:	d10a      	bne.n	8004f28 <HAL_DMA_IRQHandler+0x52c>
 8004f12:	687b      	ldr	r3, [r7, #4]
 8004f14:	681b      	ldr	r3, [r3, #0]
 8004f16:	681b      	ldr	r3, [r3, #0]
 8004f18:	f003 0308 	and.w	r3, r3, #8
 8004f1c:	2b00      	cmp	r3, #0
 8004f1e:	bf14      	ite	ne
 8004f20:	2301      	movne	r3, #1
 8004f22:	2300      	moveq	r3, #0
 8004f24:	b2db      	uxtb	r3, r3
 8004f26:	e009      	b.n	8004f3c <HAL_DMA_IRQHandler+0x540>
 8004f28:	687b      	ldr	r3, [r7, #4]
 8004f2a:	681b      	ldr	r3, [r3, #0]
 8004f2c:	681b      	ldr	r3, [r3, #0]
 8004f2e:	f003 0304 	and.w	r3, r3, #4
 8004f32:	2b00      	cmp	r3, #0
 8004f34:	bf14      	ite	ne
 8004f36:	2301      	movne	r3, #1
 8004f38:	2300      	moveq	r3, #0
 8004f3a:	b2db      	uxtb	r3, r3
 8004f3c:	2b00      	cmp	r3, #0
 8004f3e:	d03e      	beq.n	8004fbe <HAL_DMA_IRQHandler+0x5c2>
      {
        /* Clear the half transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
 8004f40:	687b      	ldr	r3, [r7, #4]
 8004f42:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8004f44:	f003 031f 	and.w	r3, r3, #31
 8004f48:	2210      	movs	r2, #16
 8004f4a:	409a      	lsls	r2, r3
 8004f4c:	6a3b      	ldr	r3, [r7, #32]
 8004f4e:	609a      	str	r2, [r3, #8]

        /* Multi_Buffering mode enabled */
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
 8004f50:	687b      	ldr	r3, [r7, #4]
 8004f52:	681b      	ldr	r3, [r3, #0]
 8004f54:	681b      	ldr	r3, [r3, #0]
 8004f56:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8004f5a:	2b00      	cmp	r3, #0
 8004f5c:	d018      	beq.n	8004f90 <HAL_DMA_IRQHandler+0x594>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
 8004f5e:	687b      	ldr	r3, [r7, #4]
 8004f60:	681b      	ldr	r3, [r3, #0]
 8004f62:	681b      	ldr	r3, [r3, #0]
 8004f64:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 8004f68:	2b00      	cmp	r3, #0
 8004f6a:	d108      	bne.n	8004f7e <HAL_DMA_IRQHandler+0x582>
          {
            if(hdma->XferHalfCpltCallback != NULL)
 8004f6c:	687b      	ldr	r3, [r7, #4]
 8004f6e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004f70:	2b00      	cmp	r3, #0
 8004f72:	d024      	beq.n	8004fbe <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferHalfCpltCallback(hdma);
 8004f74:	687b      	ldr	r3, [r7, #4]
 8004f76:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004f78:	6878      	ldr	r0, [r7, #4]
 8004f7a:	4798      	blx	r3
 8004f7c:	e01f      	b.n	8004fbe <HAL_DMA_IRQHandler+0x5c2>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferM1HalfCpltCallback != NULL)
 8004f7e:	687b      	ldr	r3, [r7, #4]
 8004f80:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8004f82:	2b00      	cmp	r3, #0
 8004f84:	d01b      	beq.n	8004fbe <HAL_DMA_IRQHandler+0x5c2>
            {
              /* Half transfer callback */
              hdma->XferM1HalfCpltCallback(hdma);
 8004f86:	687b      	ldr	r3, [r7, #4]
 8004f88:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8004f8a:	6878      	ldr	r0, [r7, #4]
 8004f8c:	4798      	blx	r3
 8004f8e:	e016      	b.n	8004fbe <HAL_DMA_IRQHandler+0x5c2>
          }
        }
        else
        {
          /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
 8004f90:	687b      	ldr	r3, [r7, #4]
 8004f92:	681b      	ldr	r3, [r3, #0]
 8004f94:	681b      	ldr	r3, [r3, #0]
 8004f96:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8004f9a:	2b00      	cmp	r3, #0
 8004f9c:	d107      	bne.n	8004fae <HAL_DMA_IRQHandler+0x5b2>
          {
            /* Disable the half transfer interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
 8004f9e:	687b      	ldr	r3, [r7, #4]
 8004fa0:	681b      	ldr	r3, [r3, #0]
 8004fa2:	681a      	ldr	r2, [r3, #0]
 8004fa4:	687b      	ldr	r3, [r7, #4]
 8004fa6:	681b      	ldr	r3, [r3, #0]
 8004fa8:	f022 0208 	bic.w	r2, r2, #8
 8004fac:	601a      	str	r2, [r3, #0]
          }

          if(hdma->XferHalfCpltCallback != NULL)
 8004fae:	687b      	ldr	r3, [r7, #4]
 8004fb0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004fb2:	2b00      	cmp	r3, #0
 8004fb4:	d003      	beq.n	8004fbe <HAL_DMA_IRQHandler+0x5c2>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
 8004fb6:	687b      	ldr	r3, [r7, #4]
 8004fb8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8004fba:	6878      	ldr	r0, [r7, #4]
 8004fbc:	4798      	blx	r3
          }
        }
      }
    }
    /* Transfer Complete Interrupt management ***********************************/
    if ((tmpisr_dma & (DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 8004fbe:	687b      	ldr	r3, [r7, #4]
 8004fc0:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8004fc2:	f003 031f 	and.w	r3, r3, #31
 8004fc6:	2220      	movs	r2, #32
 8004fc8:	409a      	lsls	r2, r3
 8004fca:	69bb      	ldr	r3, [r7, #24]
 8004fcc:	4013      	ands	r3, r2
 8004fce:	2b00      	cmp	r3, #0
 8004fd0:	f000 8110 	beq.w	80051f4 <HAL_DMA_IRQHandler+0x7f8>
    {
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
 8004fd4:	687b      	ldr	r3, [r7, #4]
 8004fd6:	681b      	ldr	r3, [r3, #0]
 8004fd8:	4a2c      	ldr	r2, [pc, #176]	@ (800508c <HAL_DMA_IRQHandler+0x690>)
 8004fda:	4293      	cmp	r3, r2
 8004fdc:	d04a      	beq.n	8005074 <HAL_DMA_IRQHandler+0x678>
 8004fde:	687b      	ldr	r3, [r7, #4]
 8004fe0:	681b      	ldr	r3, [r3, #0]
 8004fe2:	4a2b      	ldr	r2, [pc, #172]	@ (8005090 <HAL_DMA_IRQHandler+0x694>)
 8004fe4:	4293      	cmp	r3, r2
 8004fe6:	d045      	beq.n	8005074 <HAL_DMA_IRQHandler+0x678>
 8004fe8:	687b      	ldr	r3, [r7, #4]
 8004fea:	681b      	ldr	r3, [r3, #0]
 8004fec:	4a29      	ldr	r2, [pc, #164]	@ (8005094 <HAL_DMA_IRQHandler+0x698>)
 8004fee:	4293      	cmp	r3, r2
 8004ff0:	d040      	beq.n	8005074 <HAL_DMA_IRQHandler+0x678>
 8004ff2:	687b      	ldr	r3, [r7, #4]
 8004ff4:	681b      	ldr	r3, [r3, #0]
 8004ff6:	4a28      	ldr	r2, [pc, #160]	@ (8005098 <HAL_DMA_IRQHandler+0x69c>)
 8004ff8:	4293      	cmp	r3, r2
 8004ffa:	d03b      	beq.n	8005074 <HAL_DMA_IRQHandler+0x678>
 8004ffc:	687b      	ldr	r3, [r7, #4]
 8004ffe:	681b      	ldr	r3, [r3, #0]
 8005000:	4a26      	ldr	r2, [pc, #152]	@ (800509c <HAL_DMA_IRQHandler+0x6a0>)
 8005002:	4293      	cmp	r3, r2
 8005004:	d036      	beq.n	8005074 <HAL_DMA_IRQHandler+0x678>
 8005006:	687b      	ldr	r3, [r7, #4]
 8005008:	681b      	ldr	r3, [r3, #0]
 800500a:	4a25      	ldr	r2, [pc, #148]	@ (80050a0 <HAL_DMA_IRQHandler+0x6a4>)
 800500c:	4293      	cmp	r3, r2
 800500e:	d031      	beq.n	8005074 <HAL_DMA_IRQHandler+0x678>
 8005010:	687b      	ldr	r3, [r7, #4]
 8005012:	681b      	ldr	r3, [r3, #0]
 8005014:	4a23      	ldr	r2, [pc, #140]	@ (80050a4 <HAL_DMA_IRQHandler+0x6a8>)
 8005016:	4293      	cmp	r3, r2
 8005018:	d02c      	beq.n	8005074 <HAL_DMA_IRQHandler+0x678>
 800501a:	687b      	ldr	r3, [r7, #4]
 800501c:	681b      	ldr	r3, [r3, #0]
 800501e:	4a22      	ldr	r2, [pc, #136]	@ (80050a8 <HAL_DMA_IRQHandler+0x6ac>)
 8005020:	4293      	cmp	r3, r2
 8005022:	d027      	beq.n	8005074 <HAL_DMA_IRQHandler+0x678>
 8005024:	687b      	ldr	r3, [r7, #4]
 8005026:	681b      	ldr	r3, [r3, #0]
 8005028:	4a20      	ldr	r2, [pc, #128]	@ (80050ac <HAL_DMA_IRQHandler+0x6b0>)
 800502a:	4293      	cmp	r3, r2
 800502c:	d022      	beq.n	8005074 <HAL_DMA_IRQHandler+0x678>
 800502e:	687b      	ldr	r3, [r7, #4]
 8005030:	681b      	ldr	r3, [r3, #0]
 8005032:	4a1f      	ldr	r2, [pc, #124]	@ (80050b0 <HAL_DMA_IRQHandler+0x6b4>)
 8005034:	4293      	cmp	r3, r2
 8005036:	d01d      	beq.n	8005074 <HAL_DMA_IRQHandler+0x678>
 8005038:	687b      	ldr	r3, [r7, #4]
 800503a:	681b      	ldr	r3, [r3, #0]
 800503c:	4a1d      	ldr	r2, [pc, #116]	@ (80050b4 <HAL_DMA_IRQHandler+0x6b8>)
 800503e:	4293      	cmp	r3, r2
 8005040:	d018      	beq.n	8005074 <HAL_DMA_IRQHandler+0x678>
 8005042:	687b      	ldr	r3, [r7, #4]
 8005044:	681b      	ldr	r3, [r3, #0]
 8005046:	4a1c      	ldr	r2, [pc, #112]	@ (80050b8 <HAL_DMA_IRQHandler+0x6bc>)
 8005048:	4293      	cmp	r3, r2
 800504a:	d013      	beq.n	8005074 <HAL_DMA_IRQHandler+0x678>
 800504c:	687b      	ldr	r3, [r7, #4]
 800504e:	681b      	ldr	r3, [r3, #0]
 8005050:	4a1a      	ldr	r2, [pc, #104]	@ (80050bc <HAL_DMA_IRQHandler+0x6c0>)
 8005052:	4293      	cmp	r3, r2
 8005054:	d00e      	beq.n	8005074 <HAL_DMA_IRQHandler+0x678>
 8005056:	687b      	ldr	r3, [r7, #4]
 8005058:	681b      	ldr	r3, [r3, #0]
 800505a:	4a19      	ldr	r2, [pc, #100]	@ (80050c0 <HAL_DMA_IRQHandler+0x6c4>)
 800505c:	4293      	cmp	r3, r2
 800505e:	d009      	beq.n	8005074 <HAL_DMA_IRQHandler+0x678>
 8005060:	687b      	ldr	r3, [r7, #4]
 8005062:	681b      	ldr	r3, [r3, #0]
 8005064:	4a17      	ldr	r2, [pc, #92]	@ (80050c4 <HAL_DMA_IRQHandler+0x6c8>)
 8005066:	4293      	cmp	r3, r2
 8005068:	d004      	beq.n	8005074 <HAL_DMA_IRQHandler+0x678>
 800506a:	687b      	ldr	r3, [r7, #4]
 800506c:	681b      	ldr	r3, [r3, #0]
 800506e:	4a16      	ldr	r2, [pc, #88]	@ (80050c8 <HAL_DMA_IRQHandler+0x6cc>)
 8005070:	4293      	cmp	r3, r2
 8005072:	d12b      	bne.n	80050cc <HAL_DMA_IRQHandler+0x6d0>
 8005074:	687b      	ldr	r3, [r7, #4]
 8005076:	681b      	ldr	r3, [r3, #0]
 8005078:	681b      	ldr	r3, [r3, #0]
 800507a:	f003 0310 	and.w	r3, r3, #16
 800507e:	2b00      	cmp	r3, #0
 8005080:	bf14      	ite	ne
 8005082:	2301      	movne	r3, #1
 8005084:	2300      	moveq	r3, #0
 8005086:	b2db      	uxtb	r3, r3
 8005088:	e02a      	b.n	80050e0 <HAL_DMA_IRQHandler+0x6e4>
 800508a:	bf00      	nop
 800508c:	40020010 	.word	0x40020010
 8005090:	40020028 	.word	0x40020028
 8005094:	40020040 	.word	0x40020040
 8005098:	40020058 	.word	0x40020058
 800509c:	40020070 	.word	0x40020070
 80050a0:	40020088 	.word	0x40020088
 80050a4:	400200a0 	.word	0x400200a0
 80050a8:	400200b8 	.word	0x400200b8
 80050ac:	40020410 	.word	0x40020410
 80050b0:	40020428 	.word	0x40020428
 80050b4:	40020440 	.word	0x40020440
 80050b8:	40020458 	.word	0x40020458
 80050bc:	40020470 	.word	0x40020470
 80050c0:	40020488 	.word	0x40020488
 80050c4:	400204a0 	.word	0x400204a0
 80050c8:	400204b8 	.word	0x400204b8
 80050cc:	687b      	ldr	r3, [r7, #4]
 80050ce:	681b      	ldr	r3, [r3, #0]
 80050d0:	681b      	ldr	r3, [r3, #0]
 80050d2:	f003 0302 	and.w	r3, r3, #2
 80050d6:	2b00      	cmp	r3, #0
 80050d8:	bf14      	ite	ne
 80050da:	2301      	movne	r3, #1
 80050dc:	2300      	moveq	r3, #0
 80050de:	b2db      	uxtb	r3, r3
 80050e0:	2b00      	cmp	r3, #0
 80050e2:	f000 8087 	beq.w	80051f4 <HAL_DMA_IRQHandler+0x7f8>
      {
        /* Clear the transfer complete flag */
        regs_dma->IFCR = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
 80050e6:	687b      	ldr	r3, [r7, #4]
 80050e8:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80050ea:	f003 031f 	and.w	r3, r3, #31
 80050ee:	2220      	movs	r2, #32
 80050f0:	409a      	lsls	r2, r3
 80050f2:	6a3b      	ldr	r3, [r7, #32]
 80050f4:	609a      	str	r2, [r3, #8]

        if(HAL_DMA_STATE_ABORT == hdma->State)
 80050f6:	687b      	ldr	r3, [r7, #4]
 80050f8:	f893 3035 	ldrb.w	r3, [r3, #53]	@ 0x35
 80050fc:	b2db      	uxtb	r3, r3
 80050fe:	2b04      	cmp	r3, #4
 8005100:	d139      	bne.n	8005176 <HAL_DMA_IRQHandler+0x77a>
        {
          /* Disable all the transfer interrupts */
          ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8005102:	687b      	ldr	r3, [r7, #4]
 8005104:	681b      	ldr	r3, [r3, #0]
 8005106:	681a      	ldr	r2, [r3, #0]
 8005108:	687b      	ldr	r3, [r7, #4]
 800510a:	681b      	ldr	r3, [r3, #0]
 800510c:	f022 0216 	bic.w	r2, r2, #22
 8005110:	601a      	str	r2, [r3, #0]
          ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
 8005112:	687b      	ldr	r3, [r7, #4]
 8005114:	681b      	ldr	r3, [r3, #0]
 8005116:	695a      	ldr	r2, [r3, #20]
 8005118:	687b      	ldr	r3, [r7, #4]
 800511a:	681b      	ldr	r3, [r3, #0]
 800511c:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8005120:	615a      	str	r2, [r3, #20]

          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8005122:	687b      	ldr	r3, [r7, #4]
 8005124:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8005126:	2b00      	cmp	r3, #0
 8005128:	d103      	bne.n	8005132 <HAL_DMA_IRQHandler+0x736>
 800512a:	687b      	ldr	r3, [r7, #4]
 800512c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 800512e:	2b00      	cmp	r3, #0
 8005130:	d007      	beq.n	8005142 <HAL_DMA_IRQHandler+0x746>
          {
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
 8005132:	687b      	ldr	r3, [r7, #4]
 8005134:	681b      	ldr	r3, [r3, #0]
 8005136:	681a      	ldr	r2, [r3, #0]
 8005138:	687b      	ldr	r3, [r7, #4]
 800513a:	681b      	ldr	r3, [r3, #0]
 800513c:	f022 0208 	bic.w	r2, r2, #8
 8005140:	601a      	str	r2, [r3, #0]
          }

          /* Clear all interrupt flags at correct offset within the register */
          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 8005142:	687b      	ldr	r3, [r7, #4]
 8005144:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005146:	f003 031f 	and.w	r3, r3, #31
 800514a:	223f      	movs	r2, #63	@ 0x3f
 800514c:	409a      	lsls	r2, r3
 800514e:	6a3b      	ldr	r3, [r7, #32]
 8005150:	609a      	str	r2, [r3, #8]

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 8005152:	687b      	ldr	r3, [r7, #4]
 8005154:	2201      	movs	r2, #1
 8005156:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
 800515a:	687b      	ldr	r3, [r7, #4]
 800515c:	2200      	movs	r2, #0
 800515e:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

          if(hdma->XferAbortCallback != NULL)
 8005162:	687b      	ldr	r3, [r7, #4]
 8005164:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8005166:	2b00      	cmp	r3, #0
 8005168:	f000 834a 	beq.w	8005800 <HAL_DMA_IRQHandler+0xe04>
          {
            hdma->XferAbortCallback(hdma);
 800516c:	687b      	ldr	r3, [r7, #4]
 800516e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8005170:	6878      	ldr	r0, [r7, #4]
 8005172:	4798      	blx	r3
          }
          return;
 8005174:	e344      	b.n	8005800 <HAL_DMA_IRQHandler+0xe04>
        }

        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
 8005176:	687b      	ldr	r3, [r7, #4]
 8005178:	681b      	ldr	r3, [r3, #0]
 800517a:	681b      	ldr	r3, [r3, #0]
 800517c:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
 8005180:	2b00      	cmp	r3, #0
 8005182:	d018      	beq.n	80051b6 <HAL_DMA_IRQHandler+0x7ba>
        {
          /* Current memory buffer used is Memory 0 */
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
 8005184:	687b      	ldr	r3, [r7, #4]
 8005186:	681b      	ldr	r3, [r3, #0]
 8005188:	681b      	ldr	r3, [r3, #0]
 800518a:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
 800518e:	2b00      	cmp	r3, #0
 8005190:	d108      	bne.n	80051a4 <HAL_DMA_IRQHandler+0x7a8>
          {
            if(hdma->XferM1CpltCallback != NULL)
 8005192:	687b      	ldr	r3, [r7, #4]
 8005194:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8005196:	2b00      	cmp	r3, #0
 8005198:	d02c      	beq.n	80051f4 <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory1 */
              hdma->XferM1CpltCallback(hdma);
 800519a:	687b      	ldr	r3, [r7, #4]
 800519c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800519e:	6878      	ldr	r0, [r7, #4]
 80051a0:	4798      	blx	r3
 80051a2:	e027      	b.n	80051f4 <HAL_DMA_IRQHandler+0x7f8>
            }
          }
          /* Current memory buffer used is Memory 1 */
          else
          {
            if(hdma->XferCpltCallback != NULL)
 80051a4:	687b      	ldr	r3, [r7, #4]
 80051a6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80051a8:	2b00      	cmp	r3, #0
 80051aa:	d023      	beq.n	80051f4 <HAL_DMA_IRQHandler+0x7f8>
            {
              /* Transfer complete Callback for memory0 */
              hdma->XferCpltCallback(hdma);
 80051ac:	687b      	ldr	r3, [r7, #4]
 80051ae:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80051b0:	6878      	ldr	r0, [r7, #4]
 80051b2:	4798      	blx	r3
 80051b4:	e01e      	b.n	80051f4 <HAL_DMA_IRQHandler+0x7f8>
          }
        }
        /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
        else
        {
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
 80051b6:	687b      	ldr	r3, [r7, #4]
 80051b8:	681b      	ldr	r3, [r3, #0]
 80051ba:	681b      	ldr	r3, [r3, #0]
 80051bc:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80051c0:	2b00      	cmp	r3, #0
 80051c2:	d10f      	bne.n	80051e4 <HAL_DMA_IRQHandler+0x7e8>
          {
            /* Disable the transfer complete interrupt */
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC);
 80051c4:	687b      	ldr	r3, [r7, #4]
 80051c6:	681b      	ldr	r3, [r3, #0]
 80051c8:	681a      	ldr	r2, [r3, #0]
 80051ca:	687b      	ldr	r3, [r7, #4]
 80051cc:	681b      	ldr	r3, [r3, #0]
 80051ce:	f022 0210 	bic.w	r2, r2, #16
 80051d2:	601a      	str	r2, [r3, #0]

            /* Change the DMA state */
            hdma->State = HAL_DMA_STATE_READY;
 80051d4:	687b      	ldr	r3, [r7, #4]
 80051d6:	2201      	movs	r2, #1
 80051d8:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

            /* Process Unlocked */
            __HAL_UNLOCK(hdma);
 80051dc:	687b      	ldr	r3, [r7, #4]
 80051de:	2200      	movs	r2, #0
 80051e0:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
          }

          if(hdma->XferCpltCallback != NULL)
 80051e4:	687b      	ldr	r3, [r7, #4]
 80051e6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80051e8:	2b00      	cmp	r3, #0
 80051ea:	d003      	beq.n	80051f4 <HAL_DMA_IRQHandler+0x7f8>
          {
            /* Transfer complete callback */
            hdma->XferCpltCallback(hdma);
 80051ec:	687b      	ldr	r3, [r7, #4]
 80051ee:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80051f0:	6878      	ldr	r0, [r7, #4]
 80051f2:	4798      	blx	r3
        }
      }
    }

    /* manage error case */
    if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 80051f4:	687b      	ldr	r3, [r7, #4]
 80051f6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80051f8:	2b00      	cmp	r3, #0
 80051fa:	f000 8306 	beq.w	800580a <HAL_DMA_IRQHandler+0xe0e>
    {
      if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != 0U)
 80051fe:	687b      	ldr	r3, [r7, #4]
 8005200:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8005202:	f003 0301 	and.w	r3, r3, #1
 8005206:	2b00      	cmp	r3, #0
 8005208:	f000 8088 	beq.w	800531c <HAL_DMA_IRQHandler+0x920>
      {
        hdma->State = HAL_DMA_STATE_ABORT;
 800520c:	687b      	ldr	r3, [r7, #4]
 800520e:	2204      	movs	r2, #4
 8005210:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

        /* Disable the stream */
        __HAL_DMA_DISABLE(hdma);
 8005214:	687b      	ldr	r3, [r7, #4]
 8005216:	681b      	ldr	r3, [r3, #0]
 8005218:	4a7a      	ldr	r2, [pc, #488]	@ (8005404 <HAL_DMA_IRQHandler+0xa08>)
 800521a:	4293      	cmp	r3, r2
 800521c:	d04a      	beq.n	80052b4 <HAL_DMA_IRQHandler+0x8b8>
 800521e:	687b      	ldr	r3, [r7, #4]
 8005220:	681b      	ldr	r3, [r3, #0]
 8005222:	4a79      	ldr	r2, [pc, #484]	@ (8005408 <HAL_DMA_IRQHandler+0xa0c>)
 8005224:	4293      	cmp	r3, r2
 8005226:	d045      	beq.n	80052b4 <HAL_DMA_IRQHandler+0x8b8>
 8005228:	687b      	ldr	r3, [r7, #4]
 800522a:	681b      	ldr	r3, [r3, #0]
 800522c:	4a77      	ldr	r2, [pc, #476]	@ (800540c <HAL_DMA_IRQHandler+0xa10>)
 800522e:	4293      	cmp	r3, r2
 8005230:	d040      	beq.n	80052b4 <HAL_DMA_IRQHandler+0x8b8>
 8005232:	687b      	ldr	r3, [r7, #4]
 8005234:	681b      	ldr	r3, [r3, #0]
 8005236:	4a76      	ldr	r2, [pc, #472]	@ (8005410 <HAL_DMA_IRQHandler+0xa14>)
 8005238:	4293      	cmp	r3, r2
 800523a:	d03b      	beq.n	80052b4 <HAL_DMA_IRQHandler+0x8b8>
 800523c:	687b      	ldr	r3, [r7, #4]
 800523e:	681b      	ldr	r3, [r3, #0]
 8005240:	4a74      	ldr	r2, [pc, #464]	@ (8005414 <HAL_DMA_IRQHandler+0xa18>)
 8005242:	4293      	cmp	r3, r2
 8005244:	d036      	beq.n	80052b4 <HAL_DMA_IRQHandler+0x8b8>
 8005246:	687b      	ldr	r3, [r7, #4]
 8005248:	681b      	ldr	r3, [r3, #0]
 800524a:	4a73      	ldr	r2, [pc, #460]	@ (8005418 <HAL_DMA_IRQHandler+0xa1c>)
 800524c:	4293      	cmp	r3, r2
 800524e:	d031      	beq.n	80052b4 <HAL_DMA_IRQHandler+0x8b8>
 8005250:	687b      	ldr	r3, [r7, #4]
 8005252:	681b      	ldr	r3, [r3, #0]
 8005254:	4a71      	ldr	r2, [pc, #452]	@ (800541c <HAL_DMA_IRQHandler+0xa20>)
 8005256:	4293      	cmp	r3, r2
 8005258:	d02c      	beq.n	80052b4 <HAL_DMA_IRQHandler+0x8b8>
 800525a:	687b      	ldr	r3, [r7, #4]
 800525c:	681b      	ldr	r3, [r3, #0]
 800525e:	4a70      	ldr	r2, [pc, #448]	@ (8005420 <HAL_DMA_IRQHandler+0xa24>)
 8005260:	4293      	cmp	r3, r2
 8005262:	d027      	beq.n	80052b4 <HAL_DMA_IRQHandler+0x8b8>
 8005264:	687b      	ldr	r3, [r7, #4]
 8005266:	681b      	ldr	r3, [r3, #0]
 8005268:	4a6e      	ldr	r2, [pc, #440]	@ (8005424 <HAL_DMA_IRQHandler+0xa28>)
 800526a:	4293      	cmp	r3, r2
 800526c:	d022      	beq.n	80052b4 <HAL_DMA_IRQHandler+0x8b8>
 800526e:	687b      	ldr	r3, [r7, #4]
 8005270:	681b      	ldr	r3, [r3, #0]
 8005272:	4a6d      	ldr	r2, [pc, #436]	@ (8005428 <HAL_DMA_IRQHandler+0xa2c>)
 8005274:	4293      	cmp	r3, r2
 8005276:	d01d      	beq.n	80052b4 <HAL_DMA_IRQHandler+0x8b8>
 8005278:	687b      	ldr	r3, [r7, #4]
 800527a:	681b      	ldr	r3, [r3, #0]
 800527c:	4a6b      	ldr	r2, [pc, #428]	@ (800542c <HAL_DMA_IRQHandler+0xa30>)
 800527e:	4293      	cmp	r3, r2
 8005280:	d018      	beq.n	80052b4 <HAL_DMA_IRQHandler+0x8b8>
 8005282:	687b      	ldr	r3, [r7, #4]
 8005284:	681b      	ldr	r3, [r3, #0]
 8005286:	4a6a      	ldr	r2, [pc, #424]	@ (8005430 <HAL_DMA_IRQHandler+0xa34>)
 8005288:	4293      	cmp	r3, r2
 800528a:	d013      	beq.n	80052b4 <HAL_DMA_IRQHandler+0x8b8>
 800528c:	687b      	ldr	r3, [r7, #4]
 800528e:	681b      	ldr	r3, [r3, #0]
 8005290:	4a68      	ldr	r2, [pc, #416]	@ (8005434 <HAL_DMA_IRQHandler+0xa38>)
 8005292:	4293      	cmp	r3, r2
 8005294:	d00e      	beq.n	80052b4 <HAL_DMA_IRQHandler+0x8b8>
 8005296:	687b      	ldr	r3, [r7, #4]
 8005298:	681b      	ldr	r3, [r3, #0]
 800529a:	4a67      	ldr	r2, [pc, #412]	@ (8005438 <HAL_DMA_IRQHandler+0xa3c>)
 800529c:	4293      	cmp	r3, r2
 800529e:	d009      	beq.n	80052b4 <HAL_DMA_IRQHandler+0x8b8>
 80052a0:	687b      	ldr	r3, [r7, #4]
 80052a2:	681b      	ldr	r3, [r3, #0]
 80052a4:	4a65      	ldr	r2, [pc, #404]	@ (800543c <HAL_DMA_IRQHandler+0xa40>)
 80052a6:	4293      	cmp	r3, r2
 80052a8:	d004      	beq.n	80052b4 <HAL_DMA_IRQHandler+0x8b8>
 80052aa:	687b      	ldr	r3, [r7, #4]
 80052ac:	681b      	ldr	r3, [r3, #0]
 80052ae:	4a64      	ldr	r2, [pc, #400]	@ (8005440 <HAL_DMA_IRQHandler+0xa44>)
 80052b0:	4293      	cmp	r3, r2
 80052b2:	d108      	bne.n	80052c6 <HAL_DMA_IRQHandler+0x8ca>
 80052b4:	687b      	ldr	r3, [r7, #4]
 80052b6:	681b      	ldr	r3, [r3, #0]
 80052b8:	681a      	ldr	r2, [r3, #0]
 80052ba:	687b      	ldr	r3, [r7, #4]
 80052bc:	681b      	ldr	r3, [r3, #0]
 80052be:	f022 0201 	bic.w	r2, r2, #1
 80052c2:	601a      	str	r2, [r3, #0]
 80052c4:	e007      	b.n	80052d6 <HAL_DMA_IRQHandler+0x8da>
 80052c6:	687b      	ldr	r3, [r7, #4]
 80052c8:	681b      	ldr	r3, [r3, #0]
 80052ca:	681a      	ldr	r2, [r3, #0]
 80052cc:	687b      	ldr	r3, [r7, #4]
 80052ce:	681b      	ldr	r3, [r3, #0]
 80052d0:	f022 0201 	bic.w	r2, r2, #1
 80052d4:	601a      	str	r2, [r3, #0]

        do
        {
          if (++count > timeout)
 80052d6:	68fb      	ldr	r3, [r7, #12]
 80052d8:	3301      	adds	r3, #1
 80052da:	60fb      	str	r3, [r7, #12]
 80052dc:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 80052de:	429a      	cmp	r2, r3
 80052e0:	d307      	bcc.n	80052f2 <HAL_DMA_IRQHandler+0x8f6>
          {
            break;
          }
        }
        while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U);
 80052e2:	687b      	ldr	r3, [r7, #4]
 80052e4:	681b      	ldr	r3, [r3, #0]
 80052e6:	681b      	ldr	r3, [r3, #0]
 80052e8:	f003 0301 	and.w	r3, r3, #1
 80052ec:	2b00      	cmp	r3, #0
 80052ee:	d1f2      	bne.n	80052d6 <HAL_DMA_IRQHandler+0x8da>
 80052f0:	e000      	b.n	80052f4 <HAL_DMA_IRQHandler+0x8f8>
            break;
 80052f2:	bf00      	nop

        if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
 80052f4:	687b      	ldr	r3, [r7, #4]
 80052f6:	681b      	ldr	r3, [r3, #0]
 80052f8:	681b      	ldr	r3, [r3, #0]
 80052fa:	f003 0301 	and.w	r3, r3, #1
 80052fe:	2b00      	cmp	r3, #0
 8005300:	d004      	beq.n	800530c <HAL_DMA_IRQHandler+0x910>
        {
          /* Change the DMA state to error if DMA disable fails */
          hdma->State = HAL_DMA_STATE_ERROR;
 8005302:	687b      	ldr	r3, [r7, #4]
 8005304:	2203      	movs	r2, #3
 8005306:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
 800530a:	e003      	b.n	8005314 <HAL_DMA_IRQHandler+0x918>
        }
        else
        {
          /* Change the DMA state to Ready if DMA disable success */
          hdma->State = HAL_DMA_STATE_READY;
 800530c:	687b      	ldr	r3, [r7, #4]
 800530e:	2201      	movs	r2, #1
 8005310:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35
        }

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 8005314:	687b      	ldr	r3, [r7, #4]
 8005316:	2200      	movs	r2, #0
 8005318:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
      }

      if(hdma->XferErrorCallback != NULL)
 800531c:	687b      	ldr	r3, [r7, #4]
 800531e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8005320:	2b00      	cmp	r3, #0
 8005322:	f000 8272 	beq.w	800580a <HAL_DMA_IRQHandler+0xe0e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 8005326:	687b      	ldr	r3, [r7, #4]
 8005328:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800532a:	6878      	ldr	r0, [r7, #4]
 800532c:	4798      	blx	r3
 800532e:	e26c      	b.n	800580a <HAL_DMA_IRQHandler+0xe0e>
      }
    }
  }
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U)  /* BDMA instance(s) */
 8005330:	687b      	ldr	r3, [r7, #4]
 8005332:	681b      	ldr	r3, [r3, #0]
 8005334:	4a43      	ldr	r2, [pc, #268]	@ (8005444 <HAL_DMA_IRQHandler+0xa48>)
 8005336:	4293      	cmp	r3, r2
 8005338:	d022      	beq.n	8005380 <HAL_DMA_IRQHandler+0x984>
 800533a:	687b      	ldr	r3, [r7, #4]
 800533c:	681b      	ldr	r3, [r3, #0]
 800533e:	4a42      	ldr	r2, [pc, #264]	@ (8005448 <HAL_DMA_IRQHandler+0xa4c>)
 8005340:	4293      	cmp	r3, r2
 8005342:	d01d      	beq.n	8005380 <HAL_DMA_IRQHandler+0x984>
 8005344:	687b      	ldr	r3, [r7, #4]
 8005346:	681b      	ldr	r3, [r3, #0]
 8005348:	4a40      	ldr	r2, [pc, #256]	@ (800544c <HAL_DMA_IRQHandler+0xa50>)
 800534a:	4293      	cmp	r3, r2
 800534c:	d018      	beq.n	8005380 <HAL_DMA_IRQHandler+0x984>
 800534e:	687b      	ldr	r3, [r7, #4]
 8005350:	681b      	ldr	r3, [r3, #0]
 8005352:	4a3f      	ldr	r2, [pc, #252]	@ (8005450 <HAL_DMA_IRQHandler+0xa54>)
 8005354:	4293      	cmp	r3, r2
 8005356:	d013      	beq.n	8005380 <HAL_DMA_IRQHandler+0x984>
 8005358:	687b      	ldr	r3, [r7, #4]
 800535a:	681b      	ldr	r3, [r3, #0]
 800535c:	4a3d      	ldr	r2, [pc, #244]	@ (8005454 <HAL_DMA_IRQHandler+0xa58>)
 800535e:	4293      	cmp	r3, r2
 8005360:	d00e      	beq.n	8005380 <HAL_DMA_IRQHandler+0x984>
 8005362:	687b      	ldr	r3, [r7, #4]
 8005364:	681b      	ldr	r3, [r3, #0]
 8005366:	4a3c      	ldr	r2, [pc, #240]	@ (8005458 <HAL_DMA_IRQHandler+0xa5c>)
 8005368:	4293      	cmp	r3, r2
 800536a:	d009      	beq.n	8005380 <HAL_DMA_IRQHandler+0x984>
 800536c:	687b      	ldr	r3, [r7, #4]
 800536e:	681b      	ldr	r3, [r3, #0]
 8005370:	4a3a      	ldr	r2, [pc, #232]	@ (800545c <HAL_DMA_IRQHandler+0xa60>)
 8005372:	4293      	cmp	r3, r2
 8005374:	d004      	beq.n	8005380 <HAL_DMA_IRQHandler+0x984>
 8005376:	687b      	ldr	r3, [r7, #4]
 8005378:	681b      	ldr	r3, [r3, #0]
 800537a:	4a39      	ldr	r2, [pc, #228]	@ (8005460 <HAL_DMA_IRQHandler+0xa64>)
 800537c:	4293      	cmp	r3, r2
 800537e:	d101      	bne.n	8005384 <HAL_DMA_IRQHandler+0x988>
 8005380:	2301      	movs	r3, #1
 8005382:	e000      	b.n	8005386 <HAL_DMA_IRQHandler+0x98a>
 8005384:	2300      	movs	r3, #0
 8005386:	2b00      	cmp	r3, #0
 8005388:	f000 823f 	beq.w	800580a <HAL_DMA_IRQHandler+0xe0e>
  {
    ccr_reg = (((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR);
 800538c:	687b      	ldr	r3, [r7, #4]
 800538e:	681b      	ldr	r3, [r3, #0]
 8005390:	681b      	ldr	r3, [r3, #0]
 8005392:	613b      	str	r3, [r7, #16]

    /* Half Transfer Complete Interrupt management ******************************/
    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))
 8005394:	687b      	ldr	r3, [r7, #4]
 8005396:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005398:	f003 031f 	and.w	r3, r3, #31
 800539c:	2204      	movs	r2, #4
 800539e:	409a      	lsls	r2, r3
 80053a0:	697b      	ldr	r3, [r7, #20]
 80053a2:	4013      	ands	r3, r2
 80053a4:	2b00      	cmp	r3, #0
 80053a6:	f000 80cd 	beq.w	8005544 <HAL_DMA_IRQHandler+0xb48>
 80053aa:	693b      	ldr	r3, [r7, #16]
 80053ac:	f003 0304 	and.w	r3, r3, #4
 80053b0:	2b00      	cmp	r3, #0
 80053b2:	f000 80c7 	beq.w	8005544 <HAL_DMA_IRQHandler+0xb48>
    {
      /* Clear the half transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_HTIF0 << (hdma->StreamIndex & 0x1FU));
 80053b6:	687b      	ldr	r3, [r7, #4]
 80053b8:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80053ba:	f003 031f 	and.w	r3, r3, #31
 80053be:	2204      	movs	r2, #4
 80053c0:	409a      	lsls	r2, r3
 80053c2:	69fb      	ldr	r3, [r7, #28]
 80053c4:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 80053c6:	693b      	ldr	r3, [r7, #16]
 80053c8:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 80053cc:	2b00      	cmp	r3, #0
 80053ce:	d049      	beq.n	8005464 <HAL_DMA_IRQHandler+0xa68>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
 80053d0:	693b      	ldr	r3, [r7, #16]
 80053d2:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 80053d6:	2b00      	cmp	r3, #0
 80053d8:	d109      	bne.n	80053ee <HAL_DMA_IRQHandler+0x9f2>
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
 80053da:	687b      	ldr	r3, [r7, #4]
 80053dc:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 80053de:	2b00      	cmp	r3, #0
 80053e0:	f000 8210 	beq.w	8005804 <HAL_DMA_IRQHandler+0xe08>
          {
            /* Half transfer Callback for Memory 1 */
            hdma->XferM1HalfCpltCallback(hdma);
 80053e4:	687b      	ldr	r3, [r7, #4]
 80053e6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 80053e8:	6878      	ldr	r0, [r7, #4]
 80053ea:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 80053ec:	e20a      	b.n	8005804 <HAL_DMA_IRQHandler+0xe08>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferHalfCpltCallback != NULL)
 80053ee:	687b      	ldr	r3, [r7, #4]
 80053f0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80053f2:	2b00      	cmp	r3, #0
 80053f4:	f000 8206 	beq.w	8005804 <HAL_DMA_IRQHandler+0xe08>
          {
            /* Half transfer Callback for Memory 0 */
            hdma->XferHalfCpltCallback(hdma);
 80053f8:	687b      	ldr	r3, [r7, #4]
 80053fa:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80053fc:	6878      	ldr	r0, [r7, #4]
 80053fe:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8005400:	e200      	b.n	8005804 <HAL_DMA_IRQHandler+0xe08>
 8005402:	bf00      	nop
 8005404:	40020010 	.word	0x40020010
 8005408:	40020028 	.word	0x40020028
 800540c:	40020040 	.word	0x40020040
 8005410:	40020058 	.word	0x40020058
 8005414:	40020070 	.word	0x40020070
 8005418:	40020088 	.word	0x40020088
 800541c:	400200a0 	.word	0x400200a0
 8005420:	400200b8 	.word	0x400200b8
 8005424:	40020410 	.word	0x40020410
 8005428:	40020428 	.word	0x40020428
 800542c:	40020440 	.word	0x40020440
 8005430:	40020458 	.word	0x40020458
 8005434:	40020470 	.word	0x40020470
 8005438:	40020488 	.word	0x40020488
 800543c:	400204a0 	.word	0x400204a0
 8005440:	400204b8 	.word	0x400204b8
 8005444:	58025408 	.word	0x58025408
 8005448:	5802541c 	.word	0x5802541c
 800544c:	58025430 	.word	0x58025430
 8005450:	58025444 	.word	0x58025444
 8005454:	58025458 	.word	0x58025458
 8005458:	5802546c 	.word	0x5802546c
 800545c:	58025480 	.word	0x58025480
 8005460:	58025494 	.word	0x58025494
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
 8005464:	693b      	ldr	r3, [r7, #16]
 8005466:	f003 0320 	and.w	r3, r3, #32
 800546a:	2b00      	cmp	r3, #0
 800546c:	d160      	bne.n	8005530 <HAL_DMA_IRQHandler+0xb34>
        {
          /* Disable the half transfer interrupt */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 800546e:	687b      	ldr	r3, [r7, #4]
 8005470:	681b      	ldr	r3, [r3, #0]
 8005472:	4a7f      	ldr	r2, [pc, #508]	@ (8005670 <HAL_DMA_IRQHandler+0xc74>)
 8005474:	4293      	cmp	r3, r2
 8005476:	d04a      	beq.n	800550e <HAL_DMA_IRQHandler+0xb12>
 8005478:	687b      	ldr	r3, [r7, #4]
 800547a:	681b      	ldr	r3, [r3, #0]
 800547c:	4a7d      	ldr	r2, [pc, #500]	@ (8005674 <HAL_DMA_IRQHandler+0xc78>)
 800547e:	4293      	cmp	r3, r2
 8005480:	d045      	beq.n	800550e <HAL_DMA_IRQHandler+0xb12>
 8005482:	687b      	ldr	r3, [r7, #4]
 8005484:	681b      	ldr	r3, [r3, #0]
 8005486:	4a7c      	ldr	r2, [pc, #496]	@ (8005678 <HAL_DMA_IRQHandler+0xc7c>)
 8005488:	4293      	cmp	r3, r2
 800548a:	d040      	beq.n	800550e <HAL_DMA_IRQHandler+0xb12>
 800548c:	687b      	ldr	r3, [r7, #4]
 800548e:	681b      	ldr	r3, [r3, #0]
 8005490:	4a7a      	ldr	r2, [pc, #488]	@ (800567c <HAL_DMA_IRQHandler+0xc80>)
 8005492:	4293      	cmp	r3, r2
 8005494:	d03b      	beq.n	800550e <HAL_DMA_IRQHandler+0xb12>
 8005496:	687b      	ldr	r3, [r7, #4]
 8005498:	681b      	ldr	r3, [r3, #0]
 800549a:	4a79      	ldr	r2, [pc, #484]	@ (8005680 <HAL_DMA_IRQHandler+0xc84>)
 800549c:	4293      	cmp	r3, r2
 800549e:	d036      	beq.n	800550e <HAL_DMA_IRQHandler+0xb12>
 80054a0:	687b      	ldr	r3, [r7, #4]
 80054a2:	681b      	ldr	r3, [r3, #0]
 80054a4:	4a77      	ldr	r2, [pc, #476]	@ (8005684 <HAL_DMA_IRQHandler+0xc88>)
 80054a6:	4293      	cmp	r3, r2
 80054a8:	d031      	beq.n	800550e <HAL_DMA_IRQHandler+0xb12>
 80054aa:	687b      	ldr	r3, [r7, #4]
 80054ac:	681b      	ldr	r3, [r3, #0]
 80054ae:	4a76      	ldr	r2, [pc, #472]	@ (8005688 <HAL_DMA_IRQHandler+0xc8c>)
 80054b0:	4293      	cmp	r3, r2
 80054b2:	d02c      	beq.n	800550e <HAL_DMA_IRQHandler+0xb12>
 80054b4:	687b      	ldr	r3, [r7, #4]
 80054b6:	681b      	ldr	r3, [r3, #0]
 80054b8:	4a74      	ldr	r2, [pc, #464]	@ (800568c <HAL_DMA_IRQHandler+0xc90>)
 80054ba:	4293      	cmp	r3, r2
 80054bc:	d027      	beq.n	800550e <HAL_DMA_IRQHandler+0xb12>
 80054be:	687b      	ldr	r3, [r7, #4]
 80054c0:	681b      	ldr	r3, [r3, #0]
 80054c2:	4a73      	ldr	r2, [pc, #460]	@ (8005690 <HAL_DMA_IRQHandler+0xc94>)
 80054c4:	4293      	cmp	r3, r2
 80054c6:	d022      	beq.n	800550e <HAL_DMA_IRQHandler+0xb12>
 80054c8:	687b      	ldr	r3, [r7, #4]
 80054ca:	681b      	ldr	r3, [r3, #0]
 80054cc:	4a71      	ldr	r2, [pc, #452]	@ (8005694 <HAL_DMA_IRQHandler+0xc98>)
 80054ce:	4293      	cmp	r3, r2
 80054d0:	d01d      	beq.n	800550e <HAL_DMA_IRQHandler+0xb12>
 80054d2:	687b      	ldr	r3, [r7, #4]
 80054d4:	681b      	ldr	r3, [r3, #0]
 80054d6:	4a70      	ldr	r2, [pc, #448]	@ (8005698 <HAL_DMA_IRQHandler+0xc9c>)
 80054d8:	4293      	cmp	r3, r2
 80054da:	d018      	beq.n	800550e <HAL_DMA_IRQHandler+0xb12>
 80054dc:	687b      	ldr	r3, [r7, #4]
 80054de:	681b      	ldr	r3, [r3, #0]
 80054e0:	4a6e      	ldr	r2, [pc, #440]	@ (800569c <HAL_DMA_IRQHandler+0xca0>)
 80054e2:	4293      	cmp	r3, r2
 80054e4:	d013      	beq.n	800550e <HAL_DMA_IRQHandler+0xb12>
 80054e6:	687b      	ldr	r3, [r7, #4]
 80054e8:	681b      	ldr	r3, [r3, #0]
 80054ea:	4a6d      	ldr	r2, [pc, #436]	@ (80056a0 <HAL_DMA_IRQHandler+0xca4>)
 80054ec:	4293      	cmp	r3, r2
 80054ee:	d00e      	beq.n	800550e <HAL_DMA_IRQHandler+0xb12>
 80054f0:	687b      	ldr	r3, [r7, #4]
 80054f2:	681b      	ldr	r3, [r3, #0]
 80054f4:	4a6b      	ldr	r2, [pc, #428]	@ (80056a4 <HAL_DMA_IRQHandler+0xca8>)
 80054f6:	4293      	cmp	r3, r2
 80054f8:	d009      	beq.n	800550e <HAL_DMA_IRQHandler+0xb12>
 80054fa:	687b      	ldr	r3, [r7, #4]
 80054fc:	681b      	ldr	r3, [r3, #0]
 80054fe:	4a6a      	ldr	r2, [pc, #424]	@ (80056a8 <HAL_DMA_IRQHandler+0xcac>)
 8005500:	4293      	cmp	r3, r2
 8005502:	d004      	beq.n	800550e <HAL_DMA_IRQHandler+0xb12>
 8005504:	687b      	ldr	r3, [r7, #4]
 8005506:	681b      	ldr	r3, [r3, #0]
 8005508:	4a68      	ldr	r2, [pc, #416]	@ (80056ac <HAL_DMA_IRQHandler+0xcb0>)
 800550a:	4293      	cmp	r3, r2
 800550c:	d108      	bne.n	8005520 <HAL_DMA_IRQHandler+0xb24>
 800550e:	687b      	ldr	r3, [r7, #4]
 8005510:	681b      	ldr	r3, [r3, #0]
 8005512:	681a      	ldr	r2, [r3, #0]
 8005514:	687b      	ldr	r3, [r7, #4]
 8005516:	681b      	ldr	r3, [r3, #0]
 8005518:	f022 0208 	bic.w	r2, r2, #8
 800551c:	601a      	str	r2, [r3, #0]
 800551e:	e007      	b.n	8005530 <HAL_DMA_IRQHandler+0xb34>
 8005520:	687b      	ldr	r3, [r7, #4]
 8005522:	681b      	ldr	r3, [r3, #0]
 8005524:	681a      	ldr	r2, [r3, #0]
 8005526:	687b      	ldr	r3, [r7, #4]
 8005528:	681b      	ldr	r3, [r3, #0]
 800552a:	f022 0204 	bic.w	r2, r2, #4
 800552e:	601a      	str	r2, [r3, #0]
        }

        /* DMA peripheral state is not updated in Half Transfer */
        /* but in Transfer Complete case */

       if(hdma->XferHalfCpltCallback != NULL)
 8005530:	687b      	ldr	r3, [r7, #4]
 8005532:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 8005534:	2b00      	cmp	r3, #0
 8005536:	f000 8165 	beq.w	8005804 <HAL_DMA_IRQHandler+0xe08>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
 800553a:	687b      	ldr	r3, [r7, #4]
 800553c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800553e:	6878      	ldr	r0, [r7, #4]
 8005540:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8005542:	e15f      	b.n	8005804 <HAL_DMA_IRQHandler+0xe08>
        }
      }
    }

    /* Transfer Complete Interrupt management ***********************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TCIE) != 0U))
 8005544:	687b      	ldr	r3, [r7, #4]
 8005546:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005548:	f003 031f 	and.w	r3, r3, #31
 800554c:	2202      	movs	r2, #2
 800554e:	409a      	lsls	r2, r3
 8005550:	697b      	ldr	r3, [r7, #20]
 8005552:	4013      	ands	r3, r2
 8005554:	2b00      	cmp	r3, #0
 8005556:	f000 80c5 	beq.w	80056e4 <HAL_DMA_IRQHandler+0xce8>
 800555a:	693b      	ldr	r3, [r7, #16]
 800555c:	f003 0302 	and.w	r3, r3, #2
 8005560:	2b00      	cmp	r3, #0
 8005562:	f000 80bf 	beq.w	80056e4 <HAL_DMA_IRQHandler+0xce8>
    {
      /* Clear the transfer complete flag */
      regs_bdma->IFCR = (BDMA_ISR_TCIF0) << (hdma->StreamIndex & 0x1FU);
 8005566:	687b      	ldr	r3, [r7, #4]
 8005568:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 800556a:	f003 031f 	and.w	r3, r3, #31
 800556e:	2202      	movs	r2, #2
 8005570:	409a      	lsls	r2, r3
 8005572:	69fb      	ldr	r3, [r7, #28]
 8005574:	605a      	str	r2, [r3, #4]

      /* Disable the transfer complete interrupt if the DMA mode is Double Buffering */
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8005576:	693b      	ldr	r3, [r7, #16]
 8005578:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 800557c:	2b00      	cmp	r3, #0
 800557e:	d018      	beq.n	80055b2 <HAL_DMA_IRQHandler+0xbb6>
      {
        /* Current memory buffer used is Memory 0 */
        if((ccr_reg & BDMA_CCR_CT) == 0U)
 8005580:	693b      	ldr	r3, [r7, #16]
 8005582:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8005586:	2b00      	cmp	r3, #0
 8005588:	d109      	bne.n	800559e <HAL_DMA_IRQHandler+0xba2>
        {
          if(hdma->XferM1CpltCallback != NULL)
 800558a:	687b      	ldr	r3, [r7, #4]
 800558c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800558e:	2b00      	cmp	r3, #0
 8005590:	f000 813a 	beq.w	8005808 <HAL_DMA_IRQHandler+0xe0c>
          {
            /* Transfer complete Callback for Memory 1 */
            hdma->XferM1CpltCallback(hdma);
 8005594:	687b      	ldr	r3, [r7, #4]
 8005596:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8005598:	6878      	ldr	r0, [r7, #4]
 800559a:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 800559c:	e134      	b.n	8005808 <HAL_DMA_IRQHandler+0xe0c>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
 800559e:	687b      	ldr	r3, [r7, #4]
 80055a0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80055a2:	2b00      	cmp	r3, #0
 80055a4:	f000 8130 	beq.w	8005808 <HAL_DMA_IRQHandler+0xe0c>
          {
            /* Transfer complete Callback for Memory 0 */
            hdma->XferCpltCallback(hdma);
 80055a8:	687b      	ldr	r3, [r7, #4]
 80055aa:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80055ac:	6878      	ldr	r0, [r7, #4]
 80055ae:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 80055b0:	e12a      	b.n	8005808 <HAL_DMA_IRQHandler+0xe0c>
          }
        }
      }
      else
      {
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
 80055b2:	693b      	ldr	r3, [r7, #16]
 80055b4:	f003 0320 	and.w	r3, r3, #32
 80055b8:	2b00      	cmp	r3, #0
 80055ba:	f040 8089 	bne.w	80056d0 <HAL_DMA_IRQHandler+0xcd4>
        {
          /* Disable the transfer complete and error interrupt, if the DMA mode is not CIRCULAR */
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 80055be:	687b      	ldr	r3, [r7, #4]
 80055c0:	681b      	ldr	r3, [r3, #0]
 80055c2:	4a2b      	ldr	r2, [pc, #172]	@ (8005670 <HAL_DMA_IRQHandler+0xc74>)
 80055c4:	4293      	cmp	r3, r2
 80055c6:	d04a      	beq.n	800565e <HAL_DMA_IRQHandler+0xc62>
 80055c8:	687b      	ldr	r3, [r7, #4]
 80055ca:	681b      	ldr	r3, [r3, #0]
 80055cc:	4a29      	ldr	r2, [pc, #164]	@ (8005674 <HAL_DMA_IRQHandler+0xc78>)
 80055ce:	4293      	cmp	r3, r2
 80055d0:	d045      	beq.n	800565e <HAL_DMA_IRQHandler+0xc62>
 80055d2:	687b      	ldr	r3, [r7, #4]
 80055d4:	681b      	ldr	r3, [r3, #0]
 80055d6:	4a28      	ldr	r2, [pc, #160]	@ (8005678 <HAL_DMA_IRQHandler+0xc7c>)
 80055d8:	4293      	cmp	r3, r2
 80055da:	d040      	beq.n	800565e <HAL_DMA_IRQHandler+0xc62>
 80055dc:	687b      	ldr	r3, [r7, #4]
 80055de:	681b      	ldr	r3, [r3, #0]
 80055e0:	4a26      	ldr	r2, [pc, #152]	@ (800567c <HAL_DMA_IRQHandler+0xc80>)
 80055e2:	4293      	cmp	r3, r2
 80055e4:	d03b      	beq.n	800565e <HAL_DMA_IRQHandler+0xc62>
 80055e6:	687b      	ldr	r3, [r7, #4]
 80055e8:	681b      	ldr	r3, [r3, #0]
 80055ea:	4a25      	ldr	r2, [pc, #148]	@ (8005680 <HAL_DMA_IRQHandler+0xc84>)
 80055ec:	4293      	cmp	r3, r2
 80055ee:	d036      	beq.n	800565e <HAL_DMA_IRQHandler+0xc62>
 80055f0:	687b      	ldr	r3, [r7, #4]
 80055f2:	681b      	ldr	r3, [r3, #0]
 80055f4:	4a23      	ldr	r2, [pc, #140]	@ (8005684 <HAL_DMA_IRQHandler+0xc88>)
 80055f6:	4293      	cmp	r3, r2
 80055f8:	d031      	beq.n	800565e <HAL_DMA_IRQHandler+0xc62>
 80055fa:	687b      	ldr	r3, [r7, #4]
 80055fc:	681b      	ldr	r3, [r3, #0]
 80055fe:	4a22      	ldr	r2, [pc, #136]	@ (8005688 <HAL_DMA_IRQHandler+0xc8c>)
 8005600:	4293      	cmp	r3, r2
 8005602:	d02c      	beq.n	800565e <HAL_DMA_IRQHandler+0xc62>
 8005604:	687b      	ldr	r3, [r7, #4]
 8005606:	681b      	ldr	r3, [r3, #0]
 8005608:	4a20      	ldr	r2, [pc, #128]	@ (800568c <HAL_DMA_IRQHandler+0xc90>)
 800560a:	4293      	cmp	r3, r2
 800560c:	d027      	beq.n	800565e <HAL_DMA_IRQHandler+0xc62>
 800560e:	687b      	ldr	r3, [r7, #4]
 8005610:	681b      	ldr	r3, [r3, #0]
 8005612:	4a1f      	ldr	r2, [pc, #124]	@ (8005690 <HAL_DMA_IRQHandler+0xc94>)
 8005614:	4293      	cmp	r3, r2
 8005616:	d022      	beq.n	800565e <HAL_DMA_IRQHandler+0xc62>
 8005618:	687b      	ldr	r3, [r7, #4]
 800561a:	681b      	ldr	r3, [r3, #0]
 800561c:	4a1d      	ldr	r2, [pc, #116]	@ (8005694 <HAL_DMA_IRQHandler+0xc98>)
 800561e:	4293      	cmp	r3, r2
 8005620:	d01d      	beq.n	800565e <HAL_DMA_IRQHandler+0xc62>
 8005622:	687b      	ldr	r3, [r7, #4]
 8005624:	681b      	ldr	r3, [r3, #0]
 8005626:	4a1c      	ldr	r2, [pc, #112]	@ (8005698 <HAL_DMA_IRQHandler+0xc9c>)
 8005628:	4293      	cmp	r3, r2
 800562a:	d018      	beq.n	800565e <HAL_DMA_IRQHandler+0xc62>
 800562c:	687b      	ldr	r3, [r7, #4]
 800562e:	681b      	ldr	r3, [r3, #0]
 8005630:	4a1a      	ldr	r2, [pc, #104]	@ (800569c <HAL_DMA_IRQHandler+0xca0>)
 8005632:	4293      	cmp	r3, r2
 8005634:	d013      	beq.n	800565e <HAL_DMA_IRQHandler+0xc62>
 8005636:	687b      	ldr	r3, [r7, #4]
 8005638:	681b      	ldr	r3, [r3, #0]
 800563a:	4a19      	ldr	r2, [pc, #100]	@ (80056a0 <HAL_DMA_IRQHandler+0xca4>)
 800563c:	4293      	cmp	r3, r2
 800563e:	d00e      	beq.n	800565e <HAL_DMA_IRQHandler+0xc62>
 8005640:	687b      	ldr	r3, [r7, #4]
 8005642:	681b      	ldr	r3, [r3, #0]
 8005644:	4a17      	ldr	r2, [pc, #92]	@ (80056a4 <HAL_DMA_IRQHandler+0xca8>)
 8005646:	4293      	cmp	r3, r2
 8005648:	d009      	beq.n	800565e <HAL_DMA_IRQHandler+0xc62>
 800564a:	687b      	ldr	r3, [r7, #4]
 800564c:	681b      	ldr	r3, [r3, #0]
 800564e:	4a16      	ldr	r2, [pc, #88]	@ (80056a8 <HAL_DMA_IRQHandler+0xcac>)
 8005650:	4293      	cmp	r3, r2
 8005652:	d004      	beq.n	800565e <HAL_DMA_IRQHandler+0xc62>
 8005654:	687b      	ldr	r3, [r7, #4]
 8005656:	681b      	ldr	r3, [r3, #0]
 8005658:	4a14      	ldr	r2, [pc, #80]	@ (80056ac <HAL_DMA_IRQHandler+0xcb0>)
 800565a:	4293      	cmp	r3, r2
 800565c:	d128      	bne.n	80056b0 <HAL_DMA_IRQHandler+0xcb4>
 800565e:	687b      	ldr	r3, [r7, #4]
 8005660:	681b      	ldr	r3, [r3, #0]
 8005662:	681a      	ldr	r2, [r3, #0]
 8005664:	687b      	ldr	r3, [r7, #4]
 8005666:	681b      	ldr	r3, [r3, #0]
 8005668:	f022 0214 	bic.w	r2, r2, #20
 800566c:	601a      	str	r2, [r3, #0]
 800566e:	e027      	b.n	80056c0 <HAL_DMA_IRQHandler+0xcc4>
 8005670:	40020010 	.word	0x40020010
 8005674:	40020028 	.word	0x40020028
 8005678:	40020040 	.word	0x40020040
 800567c:	40020058 	.word	0x40020058
 8005680:	40020070 	.word	0x40020070
 8005684:	40020088 	.word	0x40020088
 8005688:	400200a0 	.word	0x400200a0
 800568c:	400200b8 	.word	0x400200b8
 8005690:	40020410 	.word	0x40020410
 8005694:	40020428 	.word	0x40020428
 8005698:	40020440 	.word	0x40020440
 800569c:	40020458 	.word	0x40020458
 80056a0:	40020470 	.word	0x40020470
 80056a4:	40020488 	.word	0x40020488
 80056a8:	400204a0 	.word	0x400204a0
 80056ac:	400204b8 	.word	0x400204b8
 80056b0:	687b      	ldr	r3, [r7, #4]
 80056b2:	681b      	ldr	r3, [r3, #0]
 80056b4:	681a      	ldr	r2, [r3, #0]
 80056b6:	687b      	ldr	r3, [r7, #4]
 80056b8:	681b      	ldr	r3, [r3, #0]
 80056ba:	f022 020a 	bic.w	r2, r2, #10
 80056be:	601a      	str	r2, [r3, #0]

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 80056c0:	687b      	ldr	r3, [r7, #4]
 80056c2:	2201      	movs	r2, #1
 80056c4:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
 80056c8:	687b      	ldr	r3, [r7, #4]
 80056ca:	2200      	movs	r2, #0
 80056cc:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
        }

        if(hdma->XferCpltCallback != NULL)
 80056d0:	687b      	ldr	r3, [r7, #4]
 80056d2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80056d4:	2b00      	cmp	r3, #0
 80056d6:	f000 8097 	beq.w	8005808 <HAL_DMA_IRQHandler+0xe0c>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 80056da:	687b      	ldr	r3, [r7, #4]
 80056dc:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80056de:	6878      	ldr	r0, [r7, #4]
 80056e0:	4798      	blx	r3
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 80056e2:	e091      	b.n	8005808 <HAL_DMA_IRQHandler+0xe0c>
        }
      }
    }
    /* Transfer Error Interrupt management **************************************/
    else if (((tmpisr_bdma & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TEIE) != 0U))
 80056e4:	687b      	ldr	r3, [r7, #4]
 80056e6:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80056e8:	f003 031f 	and.w	r3, r3, #31
 80056ec:	2208      	movs	r2, #8
 80056ee:	409a      	lsls	r2, r3
 80056f0:	697b      	ldr	r3, [r7, #20]
 80056f2:	4013      	ands	r3, r2
 80056f4:	2b00      	cmp	r3, #0
 80056f6:	f000 8088 	beq.w	800580a <HAL_DMA_IRQHandler+0xe0e>
 80056fa:	693b      	ldr	r3, [r7, #16]
 80056fc:	f003 0308 	and.w	r3, r3, #8
 8005700:	2b00      	cmp	r3, #0
 8005702:	f000 8082 	beq.w	800580a <HAL_DMA_IRQHandler+0xe0e>
    {
      /* When a DMA transfer error occurs */
      /* A hardware clear of its EN bits is performed */
      /* Disable ALL DMA IT */
      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 8005706:	687b      	ldr	r3, [r7, #4]
 8005708:	681b      	ldr	r3, [r3, #0]
 800570a:	4a41      	ldr	r2, [pc, #260]	@ (8005810 <HAL_DMA_IRQHandler+0xe14>)
 800570c:	4293      	cmp	r3, r2
 800570e:	d04a      	beq.n	80057a6 <HAL_DMA_IRQHandler+0xdaa>
 8005710:	687b      	ldr	r3, [r7, #4]
 8005712:	681b      	ldr	r3, [r3, #0]
 8005714:	4a3f      	ldr	r2, [pc, #252]	@ (8005814 <HAL_DMA_IRQHandler+0xe18>)
 8005716:	4293      	cmp	r3, r2
 8005718:	d045      	beq.n	80057a6 <HAL_DMA_IRQHandler+0xdaa>
 800571a:	687b      	ldr	r3, [r7, #4]
 800571c:	681b      	ldr	r3, [r3, #0]
 800571e:	4a3e      	ldr	r2, [pc, #248]	@ (8005818 <HAL_DMA_IRQHandler+0xe1c>)
 8005720:	4293      	cmp	r3, r2
 8005722:	d040      	beq.n	80057a6 <HAL_DMA_IRQHandler+0xdaa>
 8005724:	687b      	ldr	r3, [r7, #4]
 8005726:	681b      	ldr	r3, [r3, #0]
 8005728:	4a3c      	ldr	r2, [pc, #240]	@ (800581c <HAL_DMA_IRQHandler+0xe20>)
 800572a:	4293      	cmp	r3, r2
 800572c:	d03b      	beq.n	80057a6 <HAL_DMA_IRQHandler+0xdaa>
 800572e:	687b      	ldr	r3, [r7, #4]
 8005730:	681b      	ldr	r3, [r3, #0]
 8005732:	4a3b      	ldr	r2, [pc, #236]	@ (8005820 <HAL_DMA_IRQHandler+0xe24>)
 8005734:	4293      	cmp	r3, r2
 8005736:	d036      	beq.n	80057a6 <HAL_DMA_IRQHandler+0xdaa>
 8005738:	687b      	ldr	r3, [r7, #4]
 800573a:	681b      	ldr	r3, [r3, #0]
 800573c:	4a39      	ldr	r2, [pc, #228]	@ (8005824 <HAL_DMA_IRQHandler+0xe28>)
 800573e:	4293      	cmp	r3, r2
 8005740:	d031      	beq.n	80057a6 <HAL_DMA_IRQHandler+0xdaa>
 8005742:	687b      	ldr	r3, [r7, #4]
 8005744:	681b      	ldr	r3, [r3, #0]
 8005746:	4a38      	ldr	r2, [pc, #224]	@ (8005828 <HAL_DMA_IRQHandler+0xe2c>)
 8005748:	4293      	cmp	r3, r2
 800574a:	d02c      	beq.n	80057a6 <HAL_DMA_IRQHandler+0xdaa>
 800574c:	687b      	ldr	r3, [r7, #4]
 800574e:	681b      	ldr	r3, [r3, #0]
 8005750:	4a36      	ldr	r2, [pc, #216]	@ (800582c <HAL_DMA_IRQHandler+0xe30>)
 8005752:	4293      	cmp	r3, r2
 8005754:	d027      	beq.n	80057a6 <HAL_DMA_IRQHandler+0xdaa>
 8005756:	687b      	ldr	r3, [r7, #4]
 8005758:	681b      	ldr	r3, [r3, #0]
 800575a:	4a35      	ldr	r2, [pc, #212]	@ (8005830 <HAL_DMA_IRQHandler+0xe34>)
 800575c:	4293      	cmp	r3, r2
 800575e:	d022      	beq.n	80057a6 <HAL_DMA_IRQHandler+0xdaa>
 8005760:	687b      	ldr	r3, [r7, #4]
 8005762:	681b      	ldr	r3, [r3, #0]
 8005764:	4a33      	ldr	r2, [pc, #204]	@ (8005834 <HAL_DMA_IRQHandler+0xe38>)
 8005766:	4293      	cmp	r3, r2
 8005768:	d01d      	beq.n	80057a6 <HAL_DMA_IRQHandler+0xdaa>
 800576a:	687b      	ldr	r3, [r7, #4]
 800576c:	681b      	ldr	r3, [r3, #0]
 800576e:	4a32      	ldr	r2, [pc, #200]	@ (8005838 <HAL_DMA_IRQHandler+0xe3c>)
 8005770:	4293      	cmp	r3, r2
 8005772:	d018      	beq.n	80057a6 <HAL_DMA_IRQHandler+0xdaa>
 8005774:	687b      	ldr	r3, [r7, #4]
 8005776:	681b      	ldr	r3, [r3, #0]
 8005778:	4a30      	ldr	r2, [pc, #192]	@ (800583c <HAL_DMA_IRQHandler+0xe40>)
 800577a:	4293      	cmp	r3, r2
 800577c:	d013      	beq.n	80057a6 <HAL_DMA_IRQHandler+0xdaa>
 800577e:	687b      	ldr	r3, [r7, #4]
 8005780:	681b      	ldr	r3, [r3, #0]
 8005782:	4a2f      	ldr	r2, [pc, #188]	@ (8005840 <HAL_DMA_IRQHandler+0xe44>)
 8005784:	4293      	cmp	r3, r2
 8005786:	d00e      	beq.n	80057a6 <HAL_DMA_IRQHandler+0xdaa>
 8005788:	687b      	ldr	r3, [r7, #4]
 800578a:	681b      	ldr	r3, [r3, #0]
 800578c:	4a2d      	ldr	r2, [pc, #180]	@ (8005844 <HAL_DMA_IRQHandler+0xe48>)
 800578e:	4293      	cmp	r3, r2
 8005790:	d009      	beq.n	80057a6 <HAL_DMA_IRQHandler+0xdaa>
 8005792:	687b      	ldr	r3, [r7, #4]
 8005794:	681b      	ldr	r3, [r3, #0]
 8005796:	4a2c      	ldr	r2, [pc, #176]	@ (8005848 <HAL_DMA_IRQHandler+0xe4c>)
 8005798:	4293      	cmp	r3, r2
 800579a:	d004      	beq.n	80057a6 <HAL_DMA_IRQHandler+0xdaa>
 800579c:	687b      	ldr	r3, [r7, #4]
 800579e:	681b      	ldr	r3, [r3, #0]
 80057a0:	4a2a      	ldr	r2, [pc, #168]	@ (800584c <HAL_DMA_IRQHandler+0xe50>)
 80057a2:	4293      	cmp	r3, r2
 80057a4:	d108      	bne.n	80057b8 <HAL_DMA_IRQHandler+0xdbc>
 80057a6:	687b      	ldr	r3, [r7, #4]
 80057a8:	681b      	ldr	r3, [r3, #0]
 80057aa:	681a      	ldr	r2, [r3, #0]
 80057ac:	687b      	ldr	r3, [r7, #4]
 80057ae:	681b      	ldr	r3, [r3, #0]
 80057b0:	f022 021c 	bic.w	r2, r2, #28
 80057b4:	601a      	str	r2, [r3, #0]
 80057b6:	e007      	b.n	80057c8 <HAL_DMA_IRQHandler+0xdcc>
 80057b8:	687b      	ldr	r3, [r7, #4]
 80057ba:	681b      	ldr	r3, [r3, #0]
 80057bc:	681a      	ldr	r2, [r3, #0]
 80057be:	687b      	ldr	r3, [r7, #4]
 80057c0:	681b      	ldr	r3, [r3, #0]
 80057c2:	f022 020e 	bic.w	r2, r2, #14
 80057c6:	601a      	str	r2, [r3, #0]

      /* Clear all flags */
      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
 80057c8:	687b      	ldr	r3, [r7, #4]
 80057ca:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80057cc:	f003 031f 	and.w	r3, r3, #31
 80057d0:	2201      	movs	r2, #1
 80057d2:	409a      	lsls	r2, r3
 80057d4:	69fb      	ldr	r3, [r7, #28]
 80057d6:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TE;
 80057d8:	687b      	ldr	r3, [r7, #4]
 80057da:	2201      	movs	r2, #1
 80057dc:	655a      	str	r2, [r3, #84]	@ 0x54

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 80057de:	687b      	ldr	r3, [r7, #4]
 80057e0:	2201      	movs	r2, #1
 80057e2:	f883 2035 	strb.w	r2, [r3, #53]	@ 0x35

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 80057e6:	687b      	ldr	r3, [r7, #4]
 80057e8:	2200      	movs	r2, #0
 80057ea:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34

      if (hdma->XferErrorCallback != NULL)
 80057ee:	687b      	ldr	r3, [r7, #4]
 80057f0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80057f2:	2b00      	cmp	r3, #0
 80057f4:	d009      	beq.n	800580a <HAL_DMA_IRQHandler+0xe0e>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 80057f6:	687b      	ldr	r3, [r7, #4]
 80057f8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80057fa:	6878      	ldr	r0, [r7, #4]
 80057fc:	4798      	blx	r3
 80057fe:	e004      	b.n	800580a <HAL_DMA_IRQHandler+0xe0e>
          return;
 8005800:	bf00      	nop
 8005802:	e002      	b.n	800580a <HAL_DMA_IRQHandler+0xe0e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8005804:	bf00      	nop
 8005806:	e000      	b.n	800580a <HAL_DMA_IRQHandler+0xe0e>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 8005808:	bf00      	nop
  }
  else
  {
    /* Nothing To Do */
  }
}
 800580a:	3728      	adds	r7, #40	@ 0x28
 800580c:	46bd      	mov	sp, r7
 800580e:	bd80      	pop	{r7, pc}
 8005810:	40020010 	.word	0x40020010
 8005814:	40020028 	.word	0x40020028
 8005818:	40020040 	.word	0x40020040
 800581c:	40020058 	.word	0x40020058
 8005820:	40020070 	.word	0x40020070
 8005824:	40020088 	.word	0x40020088
 8005828:	400200a0 	.word	0x400200a0
 800582c:	400200b8 	.word	0x400200b8
 8005830:	40020410 	.word	0x40020410
 8005834:	40020428 	.word	0x40020428
 8005838:	40020440 	.word	0x40020440
 800583c:	40020458 	.word	0x40020458
 8005840:	40020470 	.word	0x40020470
 8005844:	40020488 	.word	0x40020488
 8005848:	400204a0 	.word	0x400204a0
 800584c:	400204b8 	.word	0x400204b8

08005850 <DMA_SetConfig>:
  * @param  DstAddress: The destination memory Buffer address
  * @param  DataLength: The length of data to be transferred from source to destination
  * @retval None
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8005850:	b480      	push	{r7}
 8005852:	b087      	sub	sp, #28
 8005854:	af00      	add	r7, sp, #0
 8005856:	60f8      	str	r0, [r7, #12]
 8005858:	60b9      	str	r1, [r7, #8]
 800585a:	607a      	str	r2, [r7, #4]
 800585c:	603b      	str	r3, [r7, #0]
  /* calculate DMA base and stream number */
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 800585e:	68fb      	ldr	r3, [r7, #12]
 8005860:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8005862:	617b      	str	r3, [r7, #20]
  BDMA_Base_Registers *regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
 8005864:	68fb      	ldr	r3, [r7, #12]
 8005866:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8005868:	613b      	str	r3, [r7, #16]

  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800586a:	68fb      	ldr	r3, [r7, #12]
 800586c:	681b      	ldr	r3, [r3, #0]
 800586e:	4a7f      	ldr	r2, [pc, #508]	@ (8005a6c <DMA_SetConfig+0x21c>)
 8005870:	4293      	cmp	r3, r2
 8005872:	d072      	beq.n	800595a <DMA_SetConfig+0x10a>
 8005874:	68fb      	ldr	r3, [r7, #12]
 8005876:	681b      	ldr	r3, [r3, #0]
 8005878:	4a7d      	ldr	r2, [pc, #500]	@ (8005a70 <DMA_SetConfig+0x220>)
 800587a:	4293      	cmp	r3, r2
 800587c:	d06d      	beq.n	800595a <DMA_SetConfig+0x10a>
 800587e:	68fb      	ldr	r3, [r7, #12]
 8005880:	681b      	ldr	r3, [r3, #0]
 8005882:	4a7c      	ldr	r2, [pc, #496]	@ (8005a74 <DMA_SetConfig+0x224>)
 8005884:	4293      	cmp	r3, r2
 8005886:	d068      	beq.n	800595a <DMA_SetConfig+0x10a>
 8005888:	68fb      	ldr	r3, [r7, #12]
 800588a:	681b      	ldr	r3, [r3, #0]
 800588c:	4a7a      	ldr	r2, [pc, #488]	@ (8005a78 <DMA_SetConfig+0x228>)
 800588e:	4293      	cmp	r3, r2
 8005890:	d063      	beq.n	800595a <DMA_SetConfig+0x10a>
 8005892:	68fb      	ldr	r3, [r7, #12]
 8005894:	681b      	ldr	r3, [r3, #0]
 8005896:	4a79      	ldr	r2, [pc, #484]	@ (8005a7c <DMA_SetConfig+0x22c>)
 8005898:	4293      	cmp	r3, r2
 800589a:	d05e      	beq.n	800595a <DMA_SetConfig+0x10a>
 800589c:	68fb      	ldr	r3, [r7, #12]
 800589e:	681b      	ldr	r3, [r3, #0]
 80058a0:	4a77      	ldr	r2, [pc, #476]	@ (8005a80 <DMA_SetConfig+0x230>)
 80058a2:	4293      	cmp	r3, r2
 80058a4:	d059      	beq.n	800595a <DMA_SetConfig+0x10a>
 80058a6:	68fb      	ldr	r3, [r7, #12]
 80058a8:	681b      	ldr	r3, [r3, #0]
 80058aa:	4a76      	ldr	r2, [pc, #472]	@ (8005a84 <DMA_SetConfig+0x234>)
 80058ac:	4293      	cmp	r3, r2
 80058ae:	d054      	beq.n	800595a <DMA_SetConfig+0x10a>
 80058b0:	68fb      	ldr	r3, [r7, #12]
 80058b2:	681b      	ldr	r3, [r3, #0]
 80058b4:	4a74      	ldr	r2, [pc, #464]	@ (8005a88 <DMA_SetConfig+0x238>)
 80058b6:	4293      	cmp	r3, r2
 80058b8:	d04f      	beq.n	800595a <DMA_SetConfig+0x10a>
 80058ba:	68fb      	ldr	r3, [r7, #12]
 80058bc:	681b      	ldr	r3, [r3, #0]
 80058be:	4a73      	ldr	r2, [pc, #460]	@ (8005a8c <DMA_SetConfig+0x23c>)
 80058c0:	4293      	cmp	r3, r2
 80058c2:	d04a      	beq.n	800595a <DMA_SetConfig+0x10a>
 80058c4:	68fb      	ldr	r3, [r7, #12]
 80058c6:	681b      	ldr	r3, [r3, #0]
 80058c8:	4a71      	ldr	r2, [pc, #452]	@ (8005a90 <DMA_SetConfig+0x240>)
 80058ca:	4293      	cmp	r3, r2
 80058cc:	d045      	beq.n	800595a <DMA_SetConfig+0x10a>
 80058ce:	68fb      	ldr	r3, [r7, #12]
 80058d0:	681b      	ldr	r3, [r3, #0]
 80058d2:	4a70      	ldr	r2, [pc, #448]	@ (8005a94 <DMA_SetConfig+0x244>)
 80058d4:	4293      	cmp	r3, r2
 80058d6:	d040      	beq.n	800595a <DMA_SetConfig+0x10a>
 80058d8:	68fb      	ldr	r3, [r7, #12]
 80058da:	681b      	ldr	r3, [r3, #0]
 80058dc:	4a6e      	ldr	r2, [pc, #440]	@ (8005a98 <DMA_SetConfig+0x248>)
 80058de:	4293      	cmp	r3, r2
 80058e0:	d03b      	beq.n	800595a <DMA_SetConfig+0x10a>
 80058e2:	68fb      	ldr	r3, [r7, #12]
 80058e4:	681b      	ldr	r3, [r3, #0]
 80058e6:	4a6d      	ldr	r2, [pc, #436]	@ (8005a9c <DMA_SetConfig+0x24c>)
 80058e8:	4293      	cmp	r3, r2
 80058ea:	d036      	beq.n	800595a <DMA_SetConfig+0x10a>
 80058ec:	68fb      	ldr	r3, [r7, #12]
 80058ee:	681b      	ldr	r3, [r3, #0]
 80058f0:	4a6b      	ldr	r2, [pc, #428]	@ (8005aa0 <DMA_SetConfig+0x250>)
 80058f2:	4293      	cmp	r3, r2
 80058f4:	d031      	beq.n	800595a <DMA_SetConfig+0x10a>
 80058f6:	68fb      	ldr	r3, [r7, #12]
 80058f8:	681b      	ldr	r3, [r3, #0]
 80058fa:	4a6a      	ldr	r2, [pc, #424]	@ (8005aa4 <DMA_SetConfig+0x254>)
 80058fc:	4293      	cmp	r3, r2
 80058fe:	d02c      	beq.n	800595a <DMA_SetConfig+0x10a>
 8005900:	68fb      	ldr	r3, [r7, #12]
 8005902:	681b      	ldr	r3, [r3, #0]
 8005904:	4a68      	ldr	r2, [pc, #416]	@ (8005aa8 <DMA_SetConfig+0x258>)
 8005906:	4293      	cmp	r3, r2
 8005908:	d027      	beq.n	800595a <DMA_SetConfig+0x10a>
 800590a:	68fb      	ldr	r3, [r7, #12]
 800590c:	681b      	ldr	r3, [r3, #0]
 800590e:	4a67      	ldr	r2, [pc, #412]	@ (8005aac <DMA_SetConfig+0x25c>)
 8005910:	4293      	cmp	r3, r2
 8005912:	d022      	beq.n	800595a <DMA_SetConfig+0x10a>
 8005914:	68fb      	ldr	r3, [r7, #12]
 8005916:	681b      	ldr	r3, [r3, #0]
 8005918:	4a65      	ldr	r2, [pc, #404]	@ (8005ab0 <DMA_SetConfig+0x260>)
 800591a:	4293      	cmp	r3, r2
 800591c:	d01d      	beq.n	800595a <DMA_SetConfig+0x10a>
 800591e:	68fb      	ldr	r3, [r7, #12]
 8005920:	681b      	ldr	r3, [r3, #0]
 8005922:	4a64      	ldr	r2, [pc, #400]	@ (8005ab4 <DMA_SetConfig+0x264>)
 8005924:	4293      	cmp	r3, r2
 8005926:	d018      	beq.n	800595a <DMA_SetConfig+0x10a>
 8005928:	68fb      	ldr	r3, [r7, #12]
 800592a:	681b      	ldr	r3, [r3, #0]
 800592c:	4a62      	ldr	r2, [pc, #392]	@ (8005ab8 <DMA_SetConfig+0x268>)
 800592e:	4293      	cmp	r3, r2
 8005930:	d013      	beq.n	800595a <DMA_SetConfig+0x10a>
 8005932:	68fb      	ldr	r3, [r7, #12]
 8005934:	681b      	ldr	r3, [r3, #0]
 8005936:	4a61      	ldr	r2, [pc, #388]	@ (8005abc <DMA_SetConfig+0x26c>)
 8005938:	4293      	cmp	r3, r2
 800593a:	d00e      	beq.n	800595a <DMA_SetConfig+0x10a>
 800593c:	68fb      	ldr	r3, [r7, #12]
 800593e:	681b      	ldr	r3, [r3, #0]
 8005940:	4a5f      	ldr	r2, [pc, #380]	@ (8005ac0 <DMA_SetConfig+0x270>)
 8005942:	4293      	cmp	r3, r2
 8005944:	d009      	beq.n	800595a <DMA_SetConfig+0x10a>
 8005946:	68fb      	ldr	r3, [r7, #12]
 8005948:	681b      	ldr	r3, [r3, #0]
 800594a:	4a5e      	ldr	r2, [pc, #376]	@ (8005ac4 <DMA_SetConfig+0x274>)
 800594c:	4293      	cmp	r3, r2
 800594e:	d004      	beq.n	800595a <DMA_SetConfig+0x10a>
 8005950:	68fb      	ldr	r3, [r7, #12]
 8005952:	681b      	ldr	r3, [r3, #0]
 8005954:	4a5c      	ldr	r2, [pc, #368]	@ (8005ac8 <DMA_SetConfig+0x278>)
 8005956:	4293      	cmp	r3, r2
 8005958:	d101      	bne.n	800595e <DMA_SetConfig+0x10e>
 800595a:	2301      	movs	r3, #1
 800595c:	e000      	b.n	8005960 <DMA_SetConfig+0x110>
 800595e:	2300      	movs	r3, #0
 8005960:	2b00      	cmp	r3, #0
 8005962:	d00d      	beq.n	8005980 <DMA_SetConfig+0x130>
  {
    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005964:	68fb      	ldr	r3, [r7, #12]
 8005966:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8005968:	68fa      	ldr	r2, [r7, #12]
 800596a:	6e92      	ldr	r2, [r2, #104]	@ 0x68
 800596c:	605a      	str	r2, [r3, #4]

    if(hdma->DMAmuxRequestGen != 0U)
 800596e:	68fb      	ldr	r3, [r7, #12]
 8005970:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8005972:	2b00      	cmp	r3, #0
 8005974:	d004      	beq.n	8005980 <DMA_SetConfig+0x130>
    {
      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8005976:	68fb      	ldr	r3, [r7, #12]
 8005978:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800597a:	68fa      	ldr	r2, [r7, #12]
 800597c:	6f52      	ldr	r2, [r2, #116]	@ 0x74
 800597e:	605a      	str	r2, [r3, #4]
    }
  }

  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8005980:	68fb      	ldr	r3, [r7, #12]
 8005982:	681b      	ldr	r3, [r3, #0]
 8005984:	4a39      	ldr	r2, [pc, #228]	@ (8005a6c <DMA_SetConfig+0x21c>)
 8005986:	4293      	cmp	r3, r2
 8005988:	d04a      	beq.n	8005a20 <DMA_SetConfig+0x1d0>
 800598a:	68fb      	ldr	r3, [r7, #12]
 800598c:	681b      	ldr	r3, [r3, #0]
 800598e:	4a38      	ldr	r2, [pc, #224]	@ (8005a70 <DMA_SetConfig+0x220>)
 8005990:	4293      	cmp	r3, r2
 8005992:	d045      	beq.n	8005a20 <DMA_SetConfig+0x1d0>
 8005994:	68fb      	ldr	r3, [r7, #12]
 8005996:	681b      	ldr	r3, [r3, #0]
 8005998:	4a36      	ldr	r2, [pc, #216]	@ (8005a74 <DMA_SetConfig+0x224>)
 800599a:	4293      	cmp	r3, r2
 800599c:	d040      	beq.n	8005a20 <DMA_SetConfig+0x1d0>
 800599e:	68fb      	ldr	r3, [r7, #12]
 80059a0:	681b      	ldr	r3, [r3, #0]
 80059a2:	4a35      	ldr	r2, [pc, #212]	@ (8005a78 <DMA_SetConfig+0x228>)
 80059a4:	4293      	cmp	r3, r2
 80059a6:	d03b      	beq.n	8005a20 <DMA_SetConfig+0x1d0>
 80059a8:	68fb      	ldr	r3, [r7, #12]
 80059aa:	681b      	ldr	r3, [r3, #0]
 80059ac:	4a33      	ldr	r2, [pc, #204]	@ (8005a7c <DMA_SetConfig+0x22c>)
 80059ae:	4293      	cmp	r3, r2
 80059b0:	d036      	beq.n	8005a20 <DMA_SetConfig+0x1d0>
 80059b2:	68fb      	ldr	r3, [r7, #12]
 80059b4:	681b      	ldr	r3, [r3, #0]
 80059b6:	4a32      	ldr	r2, [pc, #200]	@ (8005a80 <DMA_SetConfig+0x230>)
 80059b8:	4293      	cmp	r3, r2
 80059ba:	d031      	beq.n	8005a20 <DMA_SetConfig+0x1d0>
 80059bc:	68fb      	ldr	r3, [r7, #12]
 80059be:	681b      	ldr	r3, [r3, #0]
 80059c0:	4a30      	ldr	r2, [pc, #192]	@ (8005a84 <DMA_SetConfig+0x234>)
 80059c2:	4293      	cmp	r3, r2
 80059c4:	d02c      	beq.n	8005a20 <DMA_SetConfig+0x1d0>
 80059c6:	68fb      	ldr	r3, [r7, #12]
 80059c8:	681b      	ldr	r3, [r3, #0]
 80059ca:	4a2f      	ldr	r2, [pc, #188]	@ (8005a88 <DMA_SetConfig+0x238>)
 80059cc:	4293      	cmp	r3, r2
 80059ce:	d027      	beq.n	8005a20 <DMA_SetConfig+0x1d0>
 80059d0:	68fb      	ldr	r3, [r7, #12]
 80059d2:	681b      	ldr	r3, [r3, #0]
 80059d4:	4a2d      	ldr	r2, [pc, #180]	@ (8005a8c <DMA_SetConfig+0x23c>)
 80059d6:	4293      	cmp	r3, r2
 80059d8:	d022      	beq.n	8005a20 <DMA_SetConfig+0x1d0>
 80059da:	68fb      	ldr	r3, [r7, #12]
 80059dc:	681b      	ldr	r3, [r3, #0]
 80059de:	4a2c      	ldr	r2, [pc, #176]	@ (8005a90 <DMA_SetConfig+0x240>)
 80059e0:	4293      	cmp	r3, r2
 80059e2:	d01d      	beq.n	8005a20 <DMA_SetConfig+0x1d0>
 80059e4:	68fb      	ldr	r3, [r7, #12]
 80059e6:	681b      	ldr	r3, [r3, #0]
 80059e8:	4a2a      	ldr	r2, [pc, #168]	@ (8005a94 <DMA_SetConfig+0x244>)
 80059ea:	4293      	cmp	r3, r2
 80059ec:	d018      	beq.n	8005a20 <DMA_SetConfig+0x1d0>
 80059ee:	68fb      	ldr	r3, [r7, #12]
 80059f0:	681b      	ldr	r3, [r3, #0]
 80059f2:	4a29      	ldr	r2, [pc, #164]	@ (8005a98 <DMA_SetConfig+0x248>)
 80059f4:	4293      	cmp	r3, r2
 80059f6:	d013      	beq.n	8005a20 <DMA_SetConfig+0x1d0>
 80059f8:	68fb      	ldr	r3, [r7, #12]
 80059fa:	681b      	ldr	r3, [r3, #0]
 80059fc:	4a27      	ldr	r2, [pc, #156]	@ (8005a9c <DMA_SetConfig+0x24c>)
 80059fe:	4293      	cmp	r3, r2
 8005a00:	d00e      	beq.n	8005a20 <DMA_SetConfig+0x1d0>
 8005a02:	68fb      	ldr	r3, [r7, #12]
 8005a04:	681b      	ldr	r3, [r3, #0]
 8005a06:	4a26      	ldr	r2, [pc, #152]	@ (8005aa0 <DMA_SetConfig+0x250>)
 8005a08:	4293      	cmp	r3, r2
 8005a0a:	d009      	beq.n	8005a20 <DMA_SetConfig+0x1d0>
 8005a0c:	68fb      	ldr	r3, [r7, #12]
 8005a0e:	681b      	ldr	r3, [r3, #0]
 8005a10:	4a24      	ldr	r2, [pc, #144]	@ (8005aa4 <DMA_SetConfig+0x254>)
 8005a12:	4293      	cmp	r3, r2
 8005a14:	d004      	beq.n	8005a20 <DMA_SetConfig+0x1d0>
 8005a16:	68fb      	ldr	r3, [r7, #12]
 8005a18:	681b      	ldr	r3, [r3, #0]
 8005a1a:	4a23      	ldr	r2, [pc, #140]	@ (8005aa8 <DMA_SetConfig+0x258>)
 8005a1c:	4293      	cmp	r3, r2
 8005a1e:	d101      	bne.n	8005a24 <DMA_SetConfig+0x1d4>
 8005a20:	2301      	movs	r3, #1
 8005a22:	e000      	b.n	8005a26 <DMA_SetConfig+0x1d6>
 8005a24:	2300      	movs	r3, #0
 8005a26:	2b00      	cmp	r3, #0
 8005a28:	d059      	beq.n	8005ade <DMA_SetConfig+0x28e>
  {
    /* Clear all interrupt flags at correct offset within the register */
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 8005a2a:	68fb      	ldr	r3, [r7, #12]
 8005a2c:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005a2e:	f003 031f 	and.w	r3, r3, #31
 8005a32:	223f      	movs	r2, #63	@ 0x3f
 8005a34:	409a      	lsls	r2, r3
 8005a36:	697b      	ldr	r3, [r7, #20]
 8005a38:	609a      	str	r2, [r3, #8]

    /* Clear DBM bit */
    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8005a3a:	68fb      	ldr	r3, [r7, #12]
 8005a3c:	681b      	ldr	r3, [r3, #0]
 8005a3e:	681a      	ldr	r2, [r3, #0]
 8005a40:	68fb      	ldr	r3, [r7, #12]
 8005a42:	681b      	ldr	r3, [r3, #0]
 8005a44:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 8005a48:	601a      	str	r2, [r3, #0]

    /* Configure DMA Stream data length */
    ((DMA_Stream_TypeDef *)hdma->Instance)->NDTR = DataLength;
 8005a4a:	68fb      	ldr	r3, [r7, #12]
 8005a4c:	681b      	ldr	r3, [r3, #0]
 8005a4e:	683a      	ldr	r2, [r7, #0]
 8005a50:	605a      	str	r2, [r3, #4]

    /* Peripheral to Memory */
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8005a52:	68fb      	ldr	r3, [r7, #12]
 8005a54:	689b      	ldr	r3, [r3, #8]
 8005a56:	2b40      	cmp	r3, #64	@ 0x40
 8005a58:	d138      	bne.n	8005acc <DMA_SetConfig+0x27c>
    {
      /* Configure DMA Stream destination address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = DstAddress;
 8005a5a:	68fb      	ldr	r3, [r7, #12]
 8005a5c:	681b      	ldr	r3, [r3, #0]
 8005a5e:	687a      	ldr	r2, [r7, #4]
 8005a60:	609a      	str	r2, [r3, #8]

      /* Configure DMA Stream source address */
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = SrcAddress;
 8005a62:	68fb      	ldr	r3, [r7, #12]
 8005a64:	681b      	ldr	r3, [r3, #0]
 8005a66:	68ba      	ldr	r2, [r7, #8]
 8005a68:	60da      	str	r2, [r3, #12]
  }
  else
  {
    /* Nothing To Do */
  }
}
 8005a6a:	e086      	b.n	8005b7a <DMA_SetConfig+0x32a>
 8005a6c:	40020010 	.word	0x40020010
 8005a70:	40020028 	.word	0x40020028
 8005a74:	40020040 	.word	0x40020040
 8005a78:	40020058 	.word	0x40020058
 8005a7c:	40020070 	.word	0x40020070
 8005a80:	40020088 	.word	0x40020088
 8005a84:	400200a0 	.word	0x400200a0
 8005a88:	400200b8 	.word	0x400200b8
 8005a8c:	40020410 	.word	0x40020410
 8005a90:	40020428 	.word	0x40020428
 8005a94:	40020440 	.word	0x40020440
 8005a98:	40020458 	.word	0x40020458
 8005a9c:	40020470 	.word	0x40020470
 8005aa0:	40020488 	.word	0x40020488
 8005aa4:	400204a0 	.word	0x400204a0
 8005aa8:	400204b8 	.word	0x400204b8
 8005aac:	58025408 	.word	0x58025408
 8005ab0:	5802541c 	.word	0x5802541c
 8005ab4:	58025430 	.word	0x58025430
 8005ab8:	58025444 	.word	0x58025444
 8005abc:	58025458 	.word	0x58025458
 8005ac0:	5802546c 	.word	0x5802546c
 8005ac4:	58025480 	.word	0x58025480
 8005ac8:	58025494 	.word	0x58025494
      ((DMA_Stream_TypeDef *)hdma->Instance)->PAR = SrcAddress;
 8005acc:	68fb      	ldr	r3, [r7, #12]
 8005ace:	681b      	ldr	r3, [r3, #0]
 8005ad0:	68ba      	ldr	r2, [r7, #8]
 8005ad2:	609a      	str	r2, [r3, #8]
      ((DMA_Stream_TypeDef *)hdma->Instance)->M0AR = DstAddress;
 8005ad4:	68fb      	ldr	r3, [r7, #12]
 8005ad6:	681b      	ldr	r3, [r3, #0]
 8005ad8:	687a      	ldr	r2, [r7, #4]
 8005ada:	60da      	str	r2, [r3, #12]
}
 8005adc:	e04d      	b.n	8005b7a <DMA_SetConfig+0x32a>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 8005ade:	68fb      	ldr	r3, [r7, #12]
 8005ae0:	681b      	ldr	r3, [r3, #0]
 8005ae2:	4a29      	ldr	r2, [pc, #164]	@ (8005b88 <DMA_SetConfig+0x338>)
 8005ae4:	4293      	cmp	r3, r2
 8005ae6:	d022      	beq.n	8005b2e <DMA_SetConfig+0x2de>
 8005ae8:	68fb      	ldr	r3, [r7, #12]
 8005aea:	681b      	ldr	r3, [r3, #0]
 8005aec:	4a27      	ldr	r2, [pc, #156]	@ (8005b8c <DMA_SetConfig+0x33c>)
 8005aee:	4293      	cmp	r3, r2
 8005af0:	d01d      	beq.n	8005b2e <DMA_SetConfig+0x2de>
 8005af2:	68fb      	ldr	r3, [r7, #12]
 8005af4:	681b      	ldr	r3, [r3, #0]
 8005af6:	4a26      	ldr	r2, [pc, #152]	@ (8005b90 <DMA_SetConfig+0x340>)
 8005af8:	4293      	cmp	r3, r2
 8005afa:	d018      	beq.n	8005b2e <DMA_SetConfig+0x2de>
 8005afc:	68fb      	ldr	r3, [r7, #12]
 8005afe:	681b      	ldr	r3, [r3, #0]
 8005b00:	4a24      	ldr	r2, [pc, #144]	@ (8005b94 <DMA_SetConfig+0x344>)
 8005b02:	4293      	cmp	r3, r2
 8005b04:	d013      	beq.n	8005b2e <DMA_SetConfig+0x2de>
 8005b06:	68fb      	ldr	r3, [r7, #12]
 8005b08:	681b      	ldr	r3, [r3, #0]
 8005b0a:	4a23      	ldr	r2, [pc, #140]	@ (8005b98 <DMA_SetConfig+0x348>)
 8005b0c:	4293      	cmp	r3, r2
 8005b0e:	d00e      	beq.n	8005b2e <DMA_SetConfig+0x2de>
 8005b10:	68fb      	ldr	r3, [r7, #12]
 8005b12:	681b      	ldr	r3, [r3, #0]
 8005b14:	4a21      	ldr	r2, [pc, #132]	@ (8005b9c <DMA_SetConfig+0x34c>)
 8005b16:	4293      	cmp	r3, r2
 8005b18:	d009      	beq.n	8005b2e <DMA_SetConfig+0x2de>
 8005b1a:	68fb      	ldr	r3, [r7, #12]
 8005b1c:	681b      	ldr	r3, [r3, #0]
 8005b1e:	4a20      	ldr	r2, [pc, #128]	@ (8005ba0 <DMA_SetConfig+0x350>)
 8005b20:	4293      	cmp	r3, r2
 8005b22:	d004      	beq.n	8005b2e <DMA_SetConfig+0x2de>
 8005b24:	68fb      	ldr	r3, [r7, #12]
 8005b26:	681b      	ldr	r3, [r3, #0]
 8005b28:	4a1e      	ldr	r2, [pc, #120]	@ (8005ba4 <DMA_SetConfig+0x354>)
 8005b2a:	4293      	cmp	r3, r2
 8005b2c:	d101      	bne.n	8005b32 <DMA_SetConfig+0x2e2>
 8005b2e:	2301      	movs	r3, #1
 8005b30:	e000      	b.n	8005b34 <DMA_SetConfig+0x2e4>
 8005b32:	2300      	movs	r3, #0
 8005b34:	2b00      	cmp	r3, #0
 8005b36:	d020      	beq.n	8005b7a <DMA_SetConfig+0x32a>
    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
 8005b38:	68fb      	ldr	r3, [r7, #12]
 8005b3a:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8005b3c:	f003 031f 	and.w	r3, r3, #31
 8005b40:	2201      	movs	r2, #1
 8005b42:	409a      	lsls	r2, r3
 8005b44:	693b      	ldr	r3, [r7, #16]
 8005b46:	605a      	str	r2, [r3, #4]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;
 8005b48:	68fb      	ldr	r3, [r7, #12]
 8005b4a:	681b      	ldr	r3, [r3, #0]
 8005b4c:	683a      	ldr	r2, [r7, #0]
 8005b4e:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8005b50:	68fb      	ldr	r3, [r7, #12]
 8005b52:	689b      	ldr	r3, [r3, #8]
 8005b54:	2b40      	cmp	r3, #64	@ 0x40
 8005b56:	d108      	bne.n	8005b6a <DMA_SetConfig+0x31a>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
 8005b58:	68fb      	ldr	r3, [r7, #12]
 8005b5a:	681b      	ldr	r3, [r3, #0]
 8005b5c:	687a      	ldr	r2, [r7, #4]
 8005b5e:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;
 8005b60:	68fb      	ldr	r3, [r7, #12]
 8005b62:	681b      	ldr	r3, [r3, #0]
 8005b64:	68ba      	ldr	r2, [r7, #8]
 8005b66:	60da      	str	r2, [r3, #12]
}
 8005b68:	e007      	b.n	8005b7a <DMA_SetConfig+0x32a>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;
 8005b6a:	68fb      	ldr	r3, [r7, #12]
 8005b6c:	681b      	ldr	r3, [r3, #0]
 8005b6e:	68ba      	ldr	r2, [r7, #8]
 8005b70:	609a      	str	r2, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;
 8005b72:	68fb      	ldr	r3, [r7, #12]
 8005b74:	681b      	ldr	r3, [r3, #0]
 8005b76:	687a      	ldr	r2, [r7, #4]
 8005b78:	60da      	str	r2, [r3, #12]
}
 8005b7a:	bf00      	nop
 8005b7c:	371c      	adds	r7, #28
 8005b7e:	46bd      	mov	sp, r7
 8005b80:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005b84:	4770      	bx	lr
 8005b86:	bf00      	nop
 8005b88:	58025408 	.word	0x58025408
 8005b8c:	5802541c 	.word	0x5802541c
 8005b90:	58025430 	.word	0x58025430
 8005b94:	58025444 	.word	0x58025444
 8005b98:	58025458 	.word	0x58025458
 8005b9c:	5802546c 	.word	0x5802546c
 8005ba0:	58025480 	.word	0x58025480
 8005ba4:	58025494 	.word	0x58025494

08005ba8 <DMA_CalcBaseAndBitshift>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
 8005ba8:	b480      	push	{r7}
 8005baa:	b085      	sub	sp, #20
 8005bac:	af00      	add	r7, sp, #0
 8005bae:	6078      	str	r0, [r7, #4]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8005bb0:	687b      	ldr	r3, [r7, #4]
 8005bb2:	681b      	ldr	r3, [r3, #0]
 8005bb4:	4a42      	ldr	r2, [pc, #264]	@ (8005cc0 <DMA_CalcBaseAndBitshift+0x118>)
 8005bb6:	4293      	cmp	r3, r2
 8005bb8:	d04a      	beq.n	8005c50 <DMA_CalcBaseAndBitshift+0xa8>
 8005bba:	687b      	ldr	r3, [r7, #4]
 8005bbc:	681b      	ldr	r3, [r3, #0]
 8005bbe:	4a41      	ldr	r2, [pc, #260]	@ (8005cc4 <DMA_CalcBaseAndBitshift+0x11c>)
 8005bc0:	4293      	cmp	r3, r2
 8005bc2:	d045      	beq.n	8005c50 <DMA_CalcBaseAndBitshift+0xa8>
 8005bc4:	687b      	ldr	r3, [r7, #4]
 8005bc6:	681b      	ldr	r3, [r3, #0]
 8005bc8:	4a3f      	ldr	r2, [pc, #252]	@ (8005cc8 <DMA_CalcBaseAndBitshift+0x120>)
 8005bca:	4293      	cmp	r3, r2
 8005bcc:	d040      	beq.n	8005c50 <DMA_CalcBaseAndBitshift+0xa8>
 8005bce:	687b      	ldr	r3, [r7, #4]
 8005bd0:	681b      	ldr	r3, [r3, #0]
 8005bd2:	4a3e      	ldr	r2, [pc, #248]	@ (8005ccc <DMA_CalcBaseAndBitshift+0x124>)
 8005bd4:	4293      	cmp	r3, r2
 8005bd6:	d03b      	beq.n	8005c50 <DMA_CalcBaseAndBitshift+0xa8>
 8005bd8:	687b      	ldr	r3, [r7, #4]
 8005bda:	681b      	ldr	r3, [r3, #0]
 8005bdc:	4a3c      	ldr	r2, [pc, #240]	@ (8005cd0 <DMA_CalcBaseAndBitshift+0x128>)
 8005bde:	4293      	cmp	r3, r2
 8005be0:	d036      	beq.n	8005c50 <DMA_CalcBaseAndBitshift+0xa8>
 8005be2:	687b      	ldr	r3, [r7, #4]
 8005be4:	681b      	ldr	r3, [r3, #0]
 8005be6:	4a3b      	ldr	r2, [pc, #236]	@ (8005cd4 <DMA_CalcBaseAndBitshift+0x12c>)
 8005be8:	4293      	cmp	r3, r2
 8005bea:	d031      	beq.n	8005c50 <DMA_CalcBaseAndBitshift+0xa8>
 8005bec:	687b      	ldr	r3, [r7, #4]
 8005bee:	681b      	ldr	r3, [r3, #0]
 8005bf0:	4a39      	ldr	r2, [pc, #228]	@ (8005cd8 <DMA_CalcBaseAndBitshift+0x130>)
 8005bf2:	4293      	cmp	r3, r2
 8005bf4:	d02c      	beq.n	8005c50 <DMA_CalcBaseAndBitshift+0xa8>
 8005bf6:	687b      	ldr	r3, [r7, #4]
 8005bf8:	681b      	ldr	r3, [r3, #0]
 8005bfa:	4a38      	ldr	r2, [pc, #224]	@ (8005cdc <DMA_CalcBaseAndBitshift+0x134>)
 8005bfc:	4293      	cmp	r3, r2
 8005bfe:	d027      	beq.n	8005c50 <DMA_CalcBaseAndBitshift+0xa8>
 8005c00:	687b      	ldr	r3, [r7, #4]
 8005c02:	681b      	ldr	r3, [r3, #0]
 8005c04:	4a36      	ldr	r2, [pc, #216]	@ (8005ce0 <DMA_CalcBaseAndBitshift+0x138>)
 8005c06:	4293      	cmp	r3, r2
 8005c08:	d022      	beq.n	8005c50 <DMA_CalcBaseAndBitshift+0xa8>
 8005c0a:	687b      	ldr	r3, [r7, #4]
 8005c0c:	681b      	ldr	r3, [r3, #0]
 8005c0e:	4a35      	ldr	r2, [pc, #212]	@ (8005ce4 <DMA_CalcBaseAndBitshift+0x13c>)
 8005c10:	4293      	cmp	r3, r2
 8005c12:	d01d      	beq.n	8005c50 <DMA_CalcBaseAndBitshift+0xa8>
 8005c14:	687b      	ldr	r3, [r7, #4]
 8005c16:	681b      	ldr	r3, [r3, #0]
 8005c18:	4a33      	ldr	r2, [pc, #204]	@ (8005ce8 <DMA_CalcBaseAndBitshift+0x140>)
 8005c1a:	4293      	cmp	r3, r2
 8005c1c:	d018      	beq.n	8005c50 <DMA_CalcBaseAndBitshift+0xa8>
 8005c1e:	687b      	ldr	r3, [r7, #4]
 8005c20:	681b      	ldr	r3, [r3, #0]
 8005c22:	4a32      	ldr	r2, [pc, #200]	@ (8005cec <DMA_CalcBaseAndBitshift+0x144>)
 8005c24:	4293      	cmp	r3, r2
 8005c26:	d013      	beq.n	8005c50 <DMA_CalcBaseAndBitshift+0xa8>
 8005c28:	687b      	ldr	r3, [r7, #4]
 8005c2a:	681b      	ldr	r3, [r3, #0]
 8005c2c:	4a30      	ldr	r2, [pc, #192]	@ (8005cf0 <DMA_CalcBaseAndBitshift+0x148>)
 8005c2e:	4293      	cmp	r3, r2
 8005c30:	d00e      	beq.n	8005c50 <DMA_CalcBaseAndBitshift+0xa8>
 8005c32:	687b      	ldr	r3, [r7, #4]
 8005c34:	681b      	ldr	r3, [r3, #0]
 8005c36:	4a2f      	ldr	r2, [pc, #188]	@ (8005cf4 <DMA_CalcBaseAndBitshift+0x14c>)
 8005c38:	4293      	cmp	r3, r2
 8005c3a:	d009      	beq.n	8005c50 <DMA_CalcBaseAndBitshift+0xa8>
 8005c3c:	687b      	ldr	r3, [r7, #4]
 8005c3e:	681b      	ldr	r3, [r3, #0]
 8005c40:	4a2d      	ldr	r2, [pc, #180]	@ (8005cf8 <DMA_CalcBaseAndBitshift+0x150>)
 8005c42:	4293      	cmp	r3, r2
 8005c44:	d004      	beq.n	8005c50 <DMA_CalcBaseAndBitshift+0xa8>
 8005c46:	687b      	ldr	r3, [r7, #4]
 8005c48:	681b      	ldr	r3, [r3, #0]
 8005c4a:	4a2c      	ldr	r2, [pc, #176]	@ (8005cfc <DMA_CalcBaseAndBitshift+0x154>)
 8005c4c:	4293      	cmp	r3, r2
 8005c4e:	d101      	bne.n	8005c54 <DMA_CalcBaseAndBitshift+0xac>
 8005c50:	2301      	movs	r3, #1
 8005c52:	e000      	b.n	8005c56 <DMA_CalcBaseAndBitshift+0xae>
 8005c54:	2300      	movs	r3, #0
 8005c56:	2b00      	cmp	r3, #0
 8005c58:	d024      	beq.n	8005ca4 <DMA_CalcBaseAndBitshift+0xfc>
  {
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 8005c5a:	687b      	ldr	r3, [r7, #4]
 8005c5c:	681b      	ldr	r3, [r3, #0]
 8005c5e:	b2db      	uxtb	r3, r3
 8005c60:	3b10      	subs	r3, #16
 8005c62:	4a27      	ldr	r2, [pc, #156]	@ (8005d00 <DMA_CalcBaseAndBitshift+0x158>)
 8005c64:	fba2 2303 	umull	r2, r3, r2, r3
 8005c68:	091b      	lsrs	r3, r3, #4
 8005c6a:	60fb      	str	r3, [r7, #12]

    /* lookup table for necessary bitshift of flags within status registers */
    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 8005c6c:	68fb      	ldr	r3, [r7, #12]
 8005c6e:	f003 0307 	and.w	r3, r3, #7
 8005c72:	4a24      	ldr	r2, [pc, #144]	@ (8005d04 <DMA_CalcBaseAndBitshift+0x15c>)
 8005c74:	5cd3      	ldrb	r3, [r2, r3]
 8005c76:	461a      	mov	r2, r3
 8005c78:	687b      	ldr	r3, [r7, #4]
 8005c7a:	65da      	str	r2, [r3, #92]	@ 0x5c

    if (stream_number > 3U)
 8005c7c:	68fb      	ldr	r3, [r7, #12]
 8005c7e:	2b03      	cmp	r3, #3
 8005c80:	d908      	bls.n	8005c94 <DMA_CalcBaseAndBitshift+0xec>
    {
      /* return pointer to HISR and HIFCR */
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
 8005c82:	687b      	ldr	r3, [r7, #4]
 8005c84:	681b      	ldr	r3, [r3, #0]
 8005c86:	461a      	mov	r2, r3
 8005c88:	4b1f      	ldr	r3, [pc, #124]	@ (8005d08 <DMA_CalcBaseAndBitshift+0x160>)
 8005c8a:	4013      	ands	r3, r2
 8005c8c:	1d1a      	adds	r2, r3, #4
 8005c8e:	687b      	ldr	r3, [r7, #4]
 8005c90:	659a      	str	r2, [r3, #88]	@ 0x58
 8005c92:	e00d      	b.n	8005cb0 <DMA_CalcBaseAndBitshift+0x108>
    }
    else
    {
      /* return pointer to LISR and LIFCR */
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
 8005c94:	687b      	ldr	r3, [r7, #4]
 8005c96:	681b      	ldr	r3, [r3, #0]
 8005c98:	461a      	mov	r2, r3
 8005c9a:	4b1b      	ldr	r3, [pc, #108]	@ (8005d08 <DMA_CalcBaseAndBitshift+0x160>)
 8005c9c:	4013      	ands	r3, r2
 8005c9e:	687a      	ldr	r2, [r7, #4]
 8005ca0:	6593      	str	r3, [r2, #88]	@ 0x58
 8005ca2:	e005      	b.n	8005cb0 <DMA_CalcBaseAndBitshift+0x108>
    }
  }
  else /* BDMA instance(s) */
  {
    /* return pointer to ISR and IFCR */
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
 8005ca4:	687b      	ldr	r3, [r7, #4]
 8005ca6:	681b      	ldr	r3, [r3, #0]
 8005ca8:	f023 02ff 	bic.w	r2, r3, #255	@ 0xff
 8005cac:	687b      	ldr	r3, [r7, #4]
 8005cae:	659a      	str	r2, [r3, #88]	@ 0x58
  }

  return hdma->StreamBaseAddress;
 8005cb0:	687b      	ldr	r3, [r7, #4]
 8005cb2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
}
 8005cb4:	4618      	mov	r0, r3
 8005cb6:	3714      	adds	r7, #20
 8005cb8:	46bd      	mov	sp, r7
 8005cba:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005cbe:	4770      	bx	lr
 8005cc0:	40020010 	.word	0x40020010
 8005cc4:	40020028 	.word	0x40020028
 8005cc8:	40020040 	.word	0x40020040
 8005ccc:	40020058 	.word	0x40020058
 8005cd0:	40020070 	.word	0x40020070
 8005cd4:	40020088 	.word	0x40020088
 8005cd8:	400200a0 	.word	0x400200a0
 8005cdc:	400200b8 	.word	0x400200b8
 8005ce0:	40020410 	.word	0x40020410
 8005ce4:	40020428 	.word	0x40020428
 8005ce8:	40020440 	.word	0x40020440
 8005cec:	40020458 	.word	0x40020458
 8005cf0:	40020470 	.word	0x40020470
 8005cf4:	40020488 	.word	0x40020488
 8005cf8:	400204a0 	.word	0x400204a0
 8005cfc:	400204b8 	.word	0x400204b8
 8005d00:	aaaaaaab 	.word	0xaaaaaaab
 8005d04:	08018694 	.word	0x08018694
 8005d08:	fffffc00 	.word	0xfffffc00

08005d0c <DMA_CheckFifoParam>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(const DMA_HandleTypeDef *hdma)
{
 8005d0c:	b480      	push	{r7}
 8005d0e:	b085      	sub	sp, #20
 8005d10:	af00      	add	r7, sp, #0
 8005d12:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8005d14:	2300      	movs	r3, #0
 8005d16:	73fb      	strb	r3, [r7, #15]

  /* Memory Data size equal to Byte */
  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 8005d18:	687b      	ldr	r3, [r7, #4]
 8005d1a:	699b      	ldr	r3, [r3, #24]
 8005d1c:	2b00      	cmp	r3, #0
 8005d1e:	d120      	bne.n	8005d62 <DMA_CheckFifoParam+0x56>
  {
    switch (hdma->Init.FIFOThreshold)
 8005d20:	687b      	ldr	r3, [r7, #4]
 8005d22:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8005d24:	2b03      	cmp	r3, #3
 8005d26:	d858      	bhi.n	8005dda <DMA_CheckFifoParam+0xce>
 8005d28:	a201      	add	r2, pc, #4	@ (adr r2, 8005d30 <DMA_CheckFifoParam+0x24>)
 8005d2a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005d2e:	bf00      	nop
 8005d30:	08005d41 	.word	0x08005d41
 8005d34:	08005d53 	.word	0x08005d53
 8005d38:	08005d41 	.word	0x08005d41
 8005d3c:	08005ddb 	.word	0x08005ddb
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:

        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8005d40:	687b      	ldr	r3, [r7, #4]
 8005d42:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8005d44:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 8005d48:	2b00      	cmp	r3, #0
 8005d4a:	d048      	beq.n	8005dde <DMA_CheckFifoParam+0xd2>
        {
          status = HAL_ERROR;
 8005d4c:	2301      	movs	r3, #1
 8005d4e:	73fb      	strb	r3, [r7, #15]
        }
        break;
 8005d50:	e045      	b.n	8005dde <DMA_CheckFifoParam+0xd2>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8005d52:	687b      	ldr	r3, [r7, #4]
 8005d54:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8005d56:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
 8005d5a:	d142      	bne.n	8005de2 <DMA_CheckFifoParam+0xd6>
        {
          status = HAL_ERROR;
 8005d5c:	2301      	movs	r3, #1
 8005d5e:	73fb      	strb	r3, [r7, #15]
        }
        break;
 8005d60:	e03f      	b.n	8005de2 <DMA_CheckFifoParam+0xd6>
        break;
    }
  }

  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8005d62:	687b      	ldr	r3, [r7, #4]
 8005d64:	699b      	ldr	r3, [r3, #24]
 8005d66:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8005d6a:	d123      	bne.n	8005db4 <DMA_CheckFifoParam+0xa8>
  {
    switch (hdma->Init.FIFOThreshold)
 8005d6c:	687b      	ldr	r3, [r7, #4]
 8005d6e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8005d70:	2b03      	cmp	r3, #3
 8005d72:	d838      	bhi.n	8005de6 <DMA_CheckFifoParam+0xda>
 8005d74:	a201      	add	r2, pc, #4	@ (adr r2, 8005d7c <DMA_CheckFifoParam+0x70>)
 8005d76:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005d7a:	bf00      	nop
 8005d7c:	08005d8d 	.word	0x08005d8d
 8005d80:	08005d93 	.word	0x08005d93
 8005d84:	08005d8d 	.word	0x08005d8d
 8005d88:	08005da5 	.word	0x08005da5
    {
      case DMA_FIFO_THRESHOLD_1QUARTERFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
        status = HAL_ERROR;
 8005d8c:	2301      	movs	r3, #1
 8005d8e:	73fb      	strb	r3, [r7, #15]
        break;
 8005d90:	e030      	b.n	8005df4 <DMA_CheckFifoParam+0xe8>

      case DMA_FIFO_THRESHOLD_HALFFULL:
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8005d92:	687b      	ldr	r3, [r7, #4]
 8005d94:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8005d96:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 8005d9a:	2b00      	cmp	r3, #0
 8005d9c:	d025      	beq.n	8005dea <DMA_CheckFifoParam+0xde>
        {
          status = HAL_ERROR;
 8005d9e:	2301      	movs	r3, #1
 8005da0:	73fb      	strb	r3, [r7, #15]
        }
        break;
 8005da2:	e022      	b.n	8005dea <DMA_CheckFifoParam+0xde>

      case DMA_FIFO_THRESHOLD_FULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8005da4:	687b      	ldr	r3, [r7, #4]
 8005da6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8005da8:	f1b3 7fc0 	cmp.w	r3, #25165824	@ 0x1800000
 8005dac:	d11f      	bne.n	8005dee <DMA_CheckFifoParam+0xe2>
        {
          status = HAL_ERROR;
 8005dae:	2301      	movs	r3, #1
 8005db0:	73fb      	strb	r3, [r7, #15]
        }
        break;
 8005db2:	e01c      	b.n	8005dee <DMA_CheckFifoParam+0xe2>
  }

  /* Memory Data size equal to Word */
  else
  {
    switch (hdma->Init.FIFOThreshold)
 8005db4:	687b      	ldr	r3, [r7, #4]
 8005db6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8005db8:	2b02      	cmp	r3, #2
 8005dba:	d902      	bls.n	8005dc2 <DMA_CheckFifoParam+0xb6>
 8005dbc:	2b03      	cmp	r3, #3
 8005dbe:	d003      	beq.n	8005dc8 <DMA_CheckFifoParam+0xbc>
          status = HAL_ERROR;
        }
    break;

      default:
        break;
 8005dc0:	e018      	b.n	8005df4 <DMA_CheckFifoParam+0xe8>
        status = HAL_ERROR;
 8005dc2:	2301      	movs	r3, #1
 8005dc4:	73fb      	strb	r3, [r7, #15]
        break;
 8005dc6:	e015      	b.n	8005df4 <DMA_CheckFifoParam+0xe8>
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8005dc8:	687b      	ldr	r3, [r7, #4]
 8005dca:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8005dcc:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
 8005dd0:	2b00      	cmp	r3, #0
 8005dd2:	d00e      	beq.n	8005df2 <DMA_CheckFifoParam+0xe6>
          status = HAL_ERROR;
 8005dd4:	2301      	movs	r3, #1
 8005dd6:	73fb      	strb	r3, [r7, #15]
    break;
 8005dd8:	e00b      	b.n	8005df2 <DMA_CheckFifoParam+0xe6>
        break;
 8005dda:	bf00      	nop
 8005ddc:	e00a      	b.n	8005df4 <DMA_CheckFifoParam+0xe8>
        break;
 8005dde:	bf00      	nop
 8005de0:	e008      	b.n	8005df4 <DMA_CheckFifoParam+0xe8>
        break;
 8005de2:	bf00      	nop
 8005de4:	e006      	b.n	8005df4 <DMA_CheckFifoParam+0xe8>
        break;
 8005de6:	bf00      	nop
 8005de8:	e004      	b.n	8005df4 <DMA_CheckFifoParam+0xe8>
        break;
 8005dea:	bf00      	nop
 8005dec:	e002      	b.n	8005df4 <DMA_CheckFifoParam+0xe8>
        break;
 8005dee:	bf00      	nop
 8005df0:	e000      	b.n	8005df4 <DMA_CheckFifoParam+0xe8>
    break;
 8005df2:	bf00      	nop
    }
  }

  return status;
 8005df4:	7bfb      	ldrb	r3, [r7, #15]
}
 8005df6:	4618      	mov	r0, r3
 8005df8:	3714      	adds	r7, #20
 8005dfa:	46bd      	mov	sp, r7
 8005dfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005e00:	4770      	bx	lr
 8005e02:	bf00      	nop

08005e04 <DMA_CalcDMAMUXChannelBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
 8005e04:	b480      	push	{r7}
 8005e06:	b085      	sub	sp, #20
 8005e08:	af00      	add	r7, sp, #0
 8005e0a:	6078      	str	r0, [r7, #4]
  uint32_t stream_number;
  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);
 8005e0c:	687b      	ldr	r3, [r7, #4]
 8005e0e:	681b      	ldr	r3, [r3, #0]
 8005e10:	60bb      	str	r3, [r7, #8]

  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 8005e12:	687b      	ldr	r3, [r7, #4]
 8005e14:	681b      	ldr	r3, [r3, #0]
 8005e16:	4a38      	ldr	r2, [pc, #224]	@ (8005ef8 <DMA_CalcDMAMUXChannelBaseAndMask+0xf4>)
 8005e18:	4293      	cmp	r3, r2
 8005e1a:	d022      	beq.n	8005e62 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 8005e1c:	687b      	ldr	r3, [r7, #4]
 8005e1e:	681b      	ldr	r3, [r3, #0]
 8005e20:	4a36      	ldr	r2, [pc, #216]	@ (8005efc <DMA_CalcDMAMUXChannelBaseAndMask+0xf8>)
 8005e22:	4293      	cmp	r3, r2
 8005e24:	d01d      	beq.n	8005e62 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 8005e26:	687b      	ldr	r3, [r7, #4]
 8005e28:	681b      	ldr	r3, [r3, #0]
 8005e2a:	4a35      	ldr	r2, [pc, #212]	@ (8005f00 <DMA_CalcDMAMUXChannelBaseAndMask+0xfc>)
 8005e2c:	4293      	cmp	r3, r2
 8005e2e:	d018      	beq.n	8005e62 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 8005e30:	687b      	ldr	r3, [r7, #4]
 8005e32:	681b      	ldr	r3, [r3, #0]
 8005e34:	4a33      	ldr	r2, [pc, #204]	@ (8005f04 <DMA_CalcDMAMUXChannelBaseAndMask+0x100>)
 8005e36:	4293      	cmp	r3, r2
 8005e38:	d013      	beq.n	8005e62 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 8005e3a:	687b      	ldr	r3, [r7, #4]
 8005e3c:	681b      	ldr	r3, [r3, #0]
 8005e3e:	4a32      	ldr	r2, [pc, #200]	@ (8005f08 <DMA_CalcDMAMUXChannelBaseAndMask+0x104>)
 8005e40:	4293      	cmp	r3, r2
 8005e42:	d00e      	beq.n	8005e62 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 8005e44:	687b      	ldr	r3, [r7, #4]
 8005e46:	681b      	ldr	r3, [r3, #0]
 8005e48:	4a30      	ldr	r2, [pc, #192]	@ (8005f0c <DMA_CalcDMAMUXChannelBaseAndMask+0x108>)
 8005e4a:	4293      	cmp	r3, r2
 8005e4c:	d009      	beq.n	8005e62 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 8005e4e:	687b      	ldr	r3, [r7, #4]
 8005e50:	681b      	ldr	r3, [r3, #0]
 8005e52:	4a2f      	ldr	r2, [pc, #188]	@ (8005f10 <DMA_CalcDMAMUXChannelBaseAndMask+0x10c>)
 8005e54:	4293      	cmp	r3, r2
 8005e56:	d004      	beq.n	8005e62 <DMA_CalcDMAMUXChannelBaseAndMask+0x5e>
 8005e58:	687b      	ldr	r3, [r7, #4]
 8005e5a:	681b      	ldr	r3, [r3, #0]
 8005e5c:	4a2d      	ldr	r2, [pc, #180]	@ (8005f14 <DMA_CalcDMAMUXChannelBaseAndMask+0x110>)
 8005e5e:	4293      	cmp	r3, r2
 8005e60:	d101      	bne.n	8005e66 <DMA_CalcDMAMUXChannelBaseAndMask+0x62>
 8005e62:	2301      	movs	r3, #1
 8005e64:	e000      	b.n	8005e68 <DMA_CalcDMAMUXChannelBaseAndMask+0x64>
 8005e66:	2300      	movs	r3, #0
 8005e68:	2b00      	cmp	r3, #0
 8005e6a:	d01a      	beq.n	8005ea2 <DMA_CalcDMAMUXChannelBaseAndMask+0x9e>
  {
    /* BDMA Channels are connected to DMAMUX2 channels */
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 8005e6c:	687b      	ldr	r3, [r7, #4]
 8005e6e:	681b      	ldr	r3, [r3, #0]
 8005e70:	b2db      	uxtb	r3, r3
 8005e72:	3b08      	subs	r3, #8
 8005e74:	4a28      	ldr	r2, [pc, #160]	@ (8005f18 <DMA_CalcDMAMUXChannelBaseAndMask+0x114>)
 8005e76:	fba2 2303 	umull	r2, r3, r2, r3
 8005e7a:	091b      	lsrs	r3, r3, #4
 8005e7c:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 8005e7e:	68fa      	ldr	r2, [r7, #12]
 8005e80:	4b26      	ldr	r3, [pc, #152]	@ (8005f1c <DMA_CalcDMAMUXChannelBaseAndMask+0x118>)
 8005e82:	4413      	add	r3, r2
 8005e84:	009b      	lsls	r3, r3, #2
 8005e86:	461a      	mov	r2, r3
 8005e88:	687b      	ldr	r3, [r7, #4]
 8005e8a:	661a      	str	r2, [r3, #96]	@ 0x60
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
 8005e8c:	687b      	ldr	r3, [r7, #4]
 8005e8e:	4a24      	ldr	r2, [pc, #144]	@ (8005f20 <DMA_CalcDMAMUXChannelBaseAndMask+0x11c>)
 8005e90:	665a      	str	r2, [r3, #100]	@ 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8005e92:	68fb      	ldr	r3, [r7, #12]
 8005e94:	f003 031f 	and.w	r3, r3, #31
 8005e98:	2201      	movs	r2, #1
 8005e9a:	409a      	lsls	r2, r3
 8005e9c:	687b      	ldr	r3, [r7, #4]
 8005e9e:	669a      	str	r2, [r3, #104]	@ 0x68
    }
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
  }
}
 8005ea0:	e024      	b.n	8005eec <DMA_CalcDMAMUXChannelBaseAndMask+0xe8>
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 8005ea2:	687b      	ldr	r3, [r7, #4]
 8005ea4:	681b      	ldr	r3, [r3, #0]
 8005ea6:	b2db      	uxtb	r3, r3
 8005ea8:	3b10      	subs	r3, #16
 8005eaa:	4a1e      	ldr	r2, [pc, #120]	@ (8005f24 <DMA_CalcDMAMUXChannelBaseAndMask+0x120>)
 8005eac:	fba2 2303 	umull	r2, r3, r2, r3
 8005eb0:	091b      	lsrs	r3, r3, #4
 8005eb2:	60fb      	str	r3, [r7, #12]
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 8005eb4:	68bb      	ldr	r3, [r7, #8]
 8005eb6:	4a1c      	ldr	r2, [pc, #112]	@ (8005f28 <DMA_CalcDMAMUXChannelBaseAndMask+0x124>)
 8005eb8:	4293      	cmp	r3, r2
 8005eba:	d806      	bhi.n	8005eca <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
 8005ebc:	68bb      	ldr	r3, [r7, #8]
 8005ebe:	4a1b      	ldr	r2, [pc, #108]	@ (8005f2c <DMA_CalcDMAMUXChannelBaseAndMask+0x128>)
 8005ec0:	4293      	cmp	r3, r2
 8005ec2:	d902      	bls.n	8005eca <DMA_CalcDMAMUXChannelBaseAndMask+0xc6>
      stream_number += 8U;
 8005ec4:	68fb      	ldr	r3, [r7, #12]
 8005ec6:	3308      	adds	r3, #8
 8005ec8:	60fb      	str	r3, [r7, #12]
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 8005eca:	68fa      	ldr	r2, [r7, #12]
 8005ecc:	4b18      	ldr	r3, [pc, #96]	@ (8005f30 <DMA_CalcDMAMUXChannelBaseAndMask+0x12c>)
 8005ece:	4413      	add	r3, r2
 8005ed0:	009b      	lsls	r3, r3, #2
 8005ed2:	461a      	mov	r2, r3
 8005ed4:	687b      	ldr	r3, [r7, #4]
 8005ed6:	661a      	str	r2, [r3, #96]	@ 0x60
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 8005ed8:	687b      	ldr	r3, [r7, #4]
 8005eda:	4a16      	ldr	r2, [pc, #88]	@ (8005f34 <DMA_CalcDMAMUXChannelBaseAndMask+0x130>)
 8005edc:	665a      	str	r2, [r3, #100]	@ 0x64
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8005ede:	68fb      	ldr	r3, [r7, #12]
 8005ee0:	f003 031f 	and.w	r3, r3, #31
 8005ee4:	2201      	movs	r2, #1
 8005ee6:	409a      	lsls	r2, r3
 8005ee8:	687b      	ldr	r3, [r7, #4]
 8005eea:	669a      	str	r2, [r3, #104]	@ 0x68
}
 8005eec:	bf00      	nop
 8005eee:	3714      	adds	r7, #20
 8005ef0:	46bd      	mov	sp, r7
 8005ef2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005ef6:	4770      	bx	lr
 8005ef8:	58025408 	.word	0x58025408
 8005efc:	5802541c 	.word	0x5802541c
 8005f00:	58025430 	.word	0x58025430
 8005f04:	58025444 	.word	0x58025444
 8005f08:	58025458 	.word	0x58025458
 8005f0c:	5802546c 	.word	0x5802546c
 8005f10:	58025480 	.word	0x58025480
 8005f14:	58025494 	.word	0x58025494
 8005f18:	cccccccd 	.word	0xcccccccd
 8005f1c:	16009600 	.word	0x16009600
 8005f20:	58025880 	.word	0x58025880
 8005f24:	aaaaaaab 	.word	0xaaaaaaab
 8005f28:	400204b8 	.word	0x400204b8
 8005f2c:	4002040f 	.word	0x4002040f
 8005f30:	10008200 	.word	0x10008200
 8005f34:	40020880 	.word	0x40020880

08005f38 <DMA_CalcDMAMUXRequestGenBaseAndMask>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
static void DMA_CalcDMAMUXRequestGenBaseAndMask(DMA_HandleTypeDef *hdma)
{
 8005f38:	b480      	push	{r7}
 8005f3a:	b085      	sub	sp, #20
 8005f3c:	af00      	add	r7, sp, #0
 8005f3e:	6078      	str	r0, [r7, #4]
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;
 8005f40:	687b      	ldr	r3, [r7, #4]
 8005f42:	685b      	ldr	r3, [r3, #4]
 8005f44:	b2db      	uxtb	r3, r3
 8005f46:	60fb      	str	r3, [r7, #12]

  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))
 8005f48:	68fb      	ldr	r3, [r7, #12]
 8005f4a:	2b00      	cmp	r3, #0
 8005f4c:	d04a      	beq.n	8005fe4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
 8005f4e:	68fb      	ldr	r3, [r7, #12]
 8005f50:	2b08      	cmp	r3, #8
 8005f52:	d847      	bhi.n	8005fe4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xac>
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 8005f54:	687b      	ldr	r3, [r7, #4]
 8005f56:	681b      	ldr	r3, [r3, #0]
 8005f58:	4a25      	ldr	r2, [pc, #148]	@ (8005ff0 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xb8>)
 8005f5a:	4293      	cmp	r3, r2
 8005f5c:	d022      	beq.n	8005fa4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 8005f5e:	687b      	ldr	r3, [r7, #4]
 8005f60:	681b      	ldr	r3, [r3, #0]
 8005f62:	4a24      	ldr	r2, [pc, #144]	@ (8005ff4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xbc>)
 8005f64:	4293      	cmp	r3, r2
 8005f66:	d01d      	beq.n	8005fa4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 8005f68:	687b      	ldr	r3, [r7, #4]
 8005f6a:	681b      	ldr	r3, [r3, #0]
 8005f6c:	4a22      	ldr	r2, [pc, #136]	@ (8005ff8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc0>)
 8005f6e:	4293      	cmp	r3, r2
 8005f70:	d018      	beq.n	8005fa4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 8005f72:	687b      	ldr	r3, [r7, #4]
 8005f74:	681b      	ldr	r3, [r3, #0]
 8005f76:	4a21      	ldr	r2, [pc, #132]	@ (8005ffc <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc4>)
 8005f78:	4293      	cmp	r3, r2
 8005f7a:	d013      	beq.n	8005fa4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 8005f7c:	687b      	ldr	r3, [r7, #4]
 8005f7e:	681b      	ldr	r3, [r3, #0]
 8005f80:	4a1f      	ldr	r2, [pc, #124]	@ (8006000 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xc8>)
 8005f82:	4293      	cmp	r3, r2
 8005f84:	d00e      	beq.n	8005fa4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 8005f86:	687b      	ldr	r3, [r7, #4]
 8005f88:	681b      	ldr	r3, [r3, #0]
 8005f8a:	4a1e      	ldr	r2, [pc, #120]	@ (8006004 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xcc>)
 8005f8c:	4293      	cmp	r3, r2
 8005f8e:	d009      	beq.n	8005fa4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 8005f90:	687b      	ldr	r3, [r7, #4]
 8005f92:	681b      	ldr	r3, [r3, #0]
 8005f94:	4a1c      	ldr	r2, [pc, #112]	@ (8006008 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd0>)
 8005f96:	4293      	cmp	r3, r2
 8005f98:	d004      	beq.n	8005fa4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x6c>
 8005f9a:	687b      	ldr	r3, [r7, #4]
 8005f9c:	681b      	ldr	r3, [r3, #0]
 8005f9e:	4a1b      	ldr	r2, [pc, #108]	@ (800600c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd4>)
 8005fa0:	4293      	cmp	r3, r2
 8005fa2:	d101      	bne.n	8005fa8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x70>
 8005fa4:	2301      	movs	r3, #1
 8005fa6:	e000      	b.n	8005faa <DMA_CalcDMAMUXRequestGenBaseAndMask+0x72>
 8005fa8:	2300      	movs	r3, #0
 8005faa:	2b00      	cmp	r3, #0
 8005fac:	d00a      	beq.n	8005fc4 <DMA_CalcDMAMUXRequestGenBaseAndMask+0x8c>
    {
      /* BDMA Channels are connected to DMAMUX2 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
 8005fae:	68fa      	ldr	r2, [r7, #12]
 8005fb0:	4b17      	ldr	r3, [pc, #92]	@ (8006010 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xd8>)
 8005fb2:	4413      	add	r3, r2
 8005fb4:	009b      	lsls	r3, r3, #2
 8005fb6:	461a      	mov	r2, r3
 8005fb8:	687b      	ldr	r3, [r7, #4]
 8005fba:	66da      	str	r2, [r3, #108]	@ 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
 8005fbc:	687b      	ldr	r3, [r7, #4]
 8005fbe:	4a15      	ldr	r2, [pc, #84]	@ (8006014 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xdc>)
 8005fc0:	671a      	str	r2, [r3, #112]	@ 0x70
 8005fc2:	e009      	b.n	8005fd8 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xa0>
    }
    else
    {
      /* DMA1 and DMA2 Streams use DMAMUX1 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8005fc4:	68fa      	ldr	r2, [r7, #12]
 8005fc6:	4b14      	ldr	r3, [pc, #80]	@ (8006018 <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe0>)
 8005fc8:	4413      	add	r3, r2
 8005fca:	009b      	lsls	r3, r3, #2
 8005fcc:	461a      	mov	r2, r3
 8005fce:	687b      	ldr	r3, [r7, #4]
 8005fd0:	66da      	str	r2, [r3, #108]	@ 0x6c

      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 8005fd2:	687b      	ldr	r3, [r7, #4]
 8005fd4:	4a11      	ldr	r2, [pc, #68]	@ (800601c <DMA_CalcDMAMUXRequestGenBaseAndMask+0xe4>)
 8005fd6:	671a      	str	r2, [r3, #112]	@ 0x70
    }

    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
 8005fd8:	68fb      	ldr	r3, [r7, #12]
 8005fda:	3b01      	subs	r3, #1
 8005fdc:	2201      	movs	r2, #1
 8005fde:	409a      	lsls	r2, r3
 8005fe0:	687b      	ldr	r3, [r7, #4]
 8005fe2:	675a      	str	r2, [r3, #116]	@ 0x74
  }
}
 8005fe4:	bf00      	nop
 8005fe6:	3714      	adds	r7, #20
 8005fe8:	46bd      	mov	sp, r7
 8005fea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005fee:	4770      	bx	lr
 8005ff0:	58025408 	.word	0x58025408
 8005ff4:	5802541c 	.word	0x5802541c
 8005ff8:	58025430 	.word	0x58025430
 8005ffc:	58025444 	.word	0x58025444
 8006000:	58025458 	.word	0x58025458
 8006004:	5802546c 	.word	0x5802546c
 8006008:	58025480 	.word	0x58025480
 800600c:	58025494 	.word	0x58025494
 8006010:	1600963f 	.word	0x1600963f
 8006014:	58025940 	.word	0x58025940
 8006018:	1000823f 	.word	0x1000823f
 800601c:	40020940 	.word	0x40020940

08006020 <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
 8006020:	b480      	push	{r7}
 8006022:	b087      	sub	sp, #28
 8006024:	af00      	add	r7, sp, #0
 8006026:	60f8      	str	r0, [r7, #12]
 8006028:	460b      	mov	r3, r1
 800602a:	607a      	str	r2, [r7, #4]
 800602c:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
 800602e:	2300      	movs	r3, #0
 8006030:	75fb      	strb	r3, [r7, #23]

  /* Check null pointer */
  if (hexti == NULL)
 8006032:	68fb      	ldr	r3, [r7, #12]
 8006034:	2b00      	cmp	r3, #0
 8006036:	d101      	bne.n	800603c <HAL_EXTI_RegisterCallback+0x1c>
  {
    return HAL_ERROR;
 8006038:	2301      	movs	r3, #1
 800603a:	e00a      	b.n	8006052 <HAL_EXTI_RegisterCallback+0x32>
  }

  switch (CallbackID)
 800603c:	7afb      	ldrb	r3, [r7, #11]
 800603e:	2b00      	cmp	r3, #0
 8006040:	d103      	bne.n	800604a <HAL_EXTI_RegisterCallback+0x2a>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
 8006042:	68fb      	ldr	r3, [r7, #12]
 8006044:	687a      	ldr	r2, [r7, #4]
 8006046:	605a      	str	r2, [r3, #4]
      break;
 8006048:	e002      	b.n	8006050 <HAL_EXTI_RegisterCallback+0x30>

    default:
      status = HAL_ERROR;
 800604a:	2301      	movs	r3, #1
 800604c:	75fb      	strb	r3, [r7, #23]
      break;
 800604e:	bf00      	nop
  }

  return status;
 8006050:	7dfb      	ldrb	r3, [r7, #23]
}
 8006052:	4618      	mov	r0, r3
 8006054:	371c      	adds	r7, #28
 8006056:	46bd      	mov	sp, r7
 8006058:	f85d 7b04 	ldr.w	r7, [sp], #4
 800605c:	4770      	bx	lr

0800605e <HAL_EXTI_GetHandle>:
  * @param  ExtiLine Exti line number.
  *         This parameter can be from 0 to @ref EXTI_LINE_NB.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)
{
 800605e:	b480      	push	{r7}
 8006060:	b083      	sub	sp, #12
 8006062:	af00      	add	r7, sp, #0
 8006064:	6078      	str	r0, [r7, #4]
 8006066:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
 8006068:	687b      	ldr	r3, [r7, #4]
 800606a:	2b00      	cmp	r3, #0
 800606c:	d101      	bne.n	8006072 <HAL_EXTI_GetHandle+0x14>
  {
    return HAL_ERROR;
 800606e:	2301      	movs	r3, #1
 8006070:	e003      	b.n	800607a <HAL_EXTI_GetHandle+0x1c>
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
 8006072:	687b      	ldr	r3, [r7, #4]
 8006074:	683a      	ldr	r2, [r7, #0]
 8006076:	601a      	str	r2, [r3, #0]

    return HAL_OK;
 8006078:	2300      	movs	r3, #0
  }
}
 800607a:	4618      	mov	r0, r3
 800607c:	370c      	adds	r7, #12
 800607e:	46bd      	mov	sp, r7
 8006080:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006084:	4770      	bx	lr
	...

08006088 <HAL_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  hexti Exti handle.
  * @retval none.
  */
void HAL_EXTI_IRQHandler(const EXTI_HandleTypeDef *hexti)
{
 8006088:	b580      	push	{r7, lr}
 800608a:	b086      	sub	sp, #24
 800608c:	af00      	add	r7, sp, #0
 800608e:	6078      	str	r0, [r7, #4]
  uint32_t regval;
  uint32_t maskline;
  uint32_t offset;

  /* Compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
 8006090:	687b      	ldr	r3, [r7, #4]
 8006092:	681b      	ldr	r3, [r3, #0]
 8006094:	0c1b      	lsrs	r3, r3, #16
 8006096:	f003 0303 	and.w	r3, r3, #3
 800609a:	613b      	str	r3, [r7, #16]
  maskline = (1UL << (hexti->Line & EXTI_PIN_MASK));
 800609c:	687b      	ldr	r3, [r7, #4]
 800609e:	681b      	ldr	r3, [r3, #0]
 80060a0:	f003 031f 	and.w	r3, r3, #31
 80060a4:	2201      	movs	r2, #1
 80060a6:	fa02 f303 	lsl.w	r3, r2, r3
 80060aa:	60fb      	str	r3, [r7, #12]

#if defined(DUAL_CORE)
  if (HAL_GetCurrentCPUID() == CM7_CPUID)
 80060ac:	f7fd fecc 	bl	8003e48 <HAL_GetCurrentCPUID>
 80060b0:	4603      	mov	r3, r0
 80060b2:	2b03      	cmp	r3, #3
 80060b4:	d105      	bne.n	80060c2 <HAL_EXTI_IRQHandler+0x3a>
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
 80060b6:	693b      	ldr	r3, [r7, #16]
 80060b8:	011a      	lsls	r2, r3, #4
 80060ba:	4b0f      	ldr	r3, [pc, #60]	@ (80060f8 <HAL_EXTI_IRQHandler+0x70>)
 80060bc:	4413      	add	r3, r2
 80060be:	617b      	str	r3, [r7, #20]
 80060c0:	e004      	b.n	80060cc <HAL_EXTI_IRQHandler+0x44>
  }
  else /* Cortex-M4*/
  {
    /* Get pending register address */
    regaddr = (__IO uint32_t *)(&EXTI->C2PR1 + (EXTI_MODE_OFFSET * offset));
 80060c2:	693b      	ldr	r3, [r7, #16]
 80060c4:	011a      	lsls	r2, r3, #4
 80060c6:	4b0d      	ldr	r3, [pc, #52]	@ (80060fc <HAL_EXTI_IRQHandler+0x74>)
 80060c8:	4413      	add	r3, r2
 80060ca:	617b      	str	r3, [r7, #20]
#else
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
#endif /* DUAL_CORE */

  /* Get pending bit  */
  regval = (*regaddr & maskline);
 80060cc:	697b      	ldr	r3, [r7, #20]
 80060ce:	681b      	ldr	r3, [r3, #0]
 80060d0:	68fa      	ldr	r2, [r7, #12]
 80060d2:	4013      	ands	r3, r2
 80060d4:	60bb      	str	r3, [r7, #8]

  if (regval != 0x00U)
 80060d6:	68bb      	ldr	r3, [r7, #8]
 80060d8:	2b00      	cmp	r3, #0
 80060da:	d009      	beq.n	80060f0 <HAL_EXTI_IRQHandler+0x68>
  {
    /* Clear pending bit */
    *regaddr = maskline;
 80060dc:	697b      	ldr	r3, [r7, #20]
 80060de:	68fa      	ldr	r2, [r7, #12]
 80060e0:	601a      	str	r2, [r3, #0]

    /* Call callback */
    if (hexti->PendingCallback != NULL)
 80060e2:	687b      	ldr	r3, [r7, #4]
 80060e4:	685b      	ldr	r3, [r3, #4]
 80060e6:	2b00      	cmp	r3, #0
 80060e8:	d002      	beq.n	80060f0 <HAL_EXTI_IRQHandler+0x68>
    {
      hexti->PendingCallback();
 80060ea:	687b      	ldr	r3, [r7, #4]
 80060ec:	685b      	ldr	r3, [r3, #4]
 80060ee:	4798      	blx	r3
    }
  }
}
 80060f0:	bf00      	nop
 80060f2:	3718      	adds	r7, #24
 80060f4:	46bd      	mov	sp, r7
 80060f6:	bd80      	pop	{r7, pc}
 80060f8:	58000088 	.word	0x58000088
 80060fc:	580000c8 	.word	0x580000c8

08006100 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
 8006100:	b480      	push	{r7}
 8006102:	b089      	sub	sp, #36	@ 0x24
 8006104:	af00      	add	r7, sp, #0
 8006106:	6078      	str	r0, [r7, #4]
 8006108:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 800610a:	2300      	movs	r3, #0
 800610c:	61fb      	str	r3, [r7, #28]
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
 800610e:	4b89      	ldr	r3, [pc, #548]	@ (8006334 <HAL_GPIO_Init+0x234>)
 8006110:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 8006112:	e194      	b.n	800643e <HAL_GPIO_Init+0x33e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 8006114:	683b      	ldr	r3, [r7, #0]
 8006116:	681a      	ldr	r2, [r3, #0]
 8006118:	2101      	movs	r1, #1
 800611a:	69fb      	ldr	r3, [r7, #28]
 800611c:	fa01 f303 	lsl.w	r3, r1, r3
 8006120:	4013      	ands	r3, r2
 8006122:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00U)
 8006124:	693b      	ldr	r3, [r7, #16]
 8006126:	2b00      	cmp	r3, #0
 8006128:	f000 8186 	beq.w	8006438 <HAL_GPIO_Init+0x338>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 800612c:	683b      	ldr	r3, [r7, #0]
 800612e:	685b      	ldr	r3, [r3, #4]
 8006130:	f003 0303 	and.w	r3, r3, #3
 8006134:	2b01      	cmp	r3, #1
 8006136:	d005      	beq.n	8006144 <HAL_GPIO_Init+0x44>
 8006138:	683b      	ldr	r3, [r7, #0]
 800613a:	685b      	ldr	r3, [r3, #4]
 800613c:	f003 0303 	and.w	r3, r3, #3
 8006140:	2b02      	cmp	r3, #2
 8006142:	d130      	bne.n	80061a6 <HAL_GPIO_Init+0xa6>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8006144:	687b      	ldr	r3, [r7, #4]
 8006146:	689b      	ldr	r3, [r3, #8]
 8006148:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 800614a:	69fb      	ldr	r3, [r7, #28]
 800614c:	005b      	lsls	r3, r3, #1
 800614e:	2203      	movs	r2, #3
 8006150:	fa02 f303 	lsl.w	r3, r2, r3
 8006154:	43db      	mvns	r3, r3
 8006156:	69ba      	ldr	r2, [r7, #24]
 8006158:	4013      	ands	r3, r2
 800615a:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 800615c:	683b      	ldr	r3, [r7, #0]
 800615e:	68da      	ldr	r2, [r3, #12]
 8006160:	69fb      	ldr	r3, [r7, #28]
 8006162:	005b      	lsls	r3, r3, #1
 8006164:	fa02 f303 	lsl.w	r3, r2, r3
 8006168:	69ba      	ldr	r2, [r7, #24]
 800616a:	4313      	orrs	r3, r2
 800616c:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 800616e:	687b      	ldr	r3, [r7, #4]
 8006170:	69ba      	ldr	r2, [r7, #24]
 8006172:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8006174:	687b      	ldr	r3, [r7, #4]
 8006176:	685b      	ldr	r3, [r3, #4]
 8006178:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 800617a:	2201      	movs	r2, #1
 800617c:	69fb      	ldr	r3, [r7, #28]
 800617e:	fa02 f303 	lsl.w	r3, r2, r3
 8006182:	43db      	mvns	r3, r3
 8006184:	69ba      	ldr	r2, [r7, #24]
 8006186:	4013      	ands	r3, r2
 8006188:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 800618a:	683b      	ldr	r3, [r7, #0]
 800618c:	685b      	ldr	r3, [r3, #4]
 800618e:	091b      	lsrs	r3, r3, #4
 8006190:	f003 0201 	and.w	r2, r3, #1
 8006194:	69fb      	ldr	r3, [r7, #28]
 8006196:	fa02 f303 	lsl.w	r3, r2, r3
 800619a:	69ba      	ldr	r2, [r7, #24]
 800619c:	4313      	orrs	r3, r2
 800619e:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 80061a0:	687b      	ldr	r3, [r7, #4]
 80061a2:	69ba      	ldr	r2, [r7, #24]
 80061a4:	605a      	str	r2, [r3, #4]
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 80061a6:	683b      	ldr	r3, [r7, #0]
 80061a8:	685b      	ldr	r3, [r3, #4]
 80061aa:	f003 0303 	and.w	r3, r3, #3
 80061ae:	2b03      	cmp	r3, #3
 80061b0:	d017      	beq.n	80061e2 <HAL_GPIO_Init+0xe2>
      {
       /* Check the Pull parameter */
       assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 80061b2:	687b      	ldr	r3, [r7, #4]
 80061b4:	68db      	ldr	r3, [r3, #12]
 80061b6:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 80061b8:	69fb      	ldr	r3, [r7, #28]
 80061ba:	005b      	lsls	r3, r3, #1
 80061bc:	2203      	movs	r2, #3
 80061be:	fa02 f303 	lsl.w	r3, r2, r3
 80061c2:	43db      	mvns	r3, r3
 80061c4:	69ba      	ldr	r2, [r7, #24]
 80061c6:	4013      	ands	r3, r2
 80061c8:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 80061ca:	683b      	ldr	r3, [r7, #0]
 80061cc:	689a      	ldr	r2, [r3, #8]
 80061ce:	69fb      	ldr	r3, [r7, #28]
 80061d0:	005b      	lsls	r3, r3, #1
 80061d2:	fa02 f303 	lsl.w	r3, r2, r3
 80061d6:	69ba      	ldr	r2, [r7, #24]
 80061d8:	4313      	orrs	r3, r2
 80061da:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 80061dc:	687b      	ldr	r3, [r7, #4]
 80061de:	69ba      	ldr	r2, [r7, #24]
 80061e0:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 80061e2:	683b      	ldr	r3, [r7, #0]
 80061e4:	685b      	ldr	r3, [r3, #4]
 80061e6:	f003 0303 	and.w	r3, r3, #3
 80061ea:	2b02      	cmp	r3, #2
 80061ec:	d123      	bne.n	8006236 <HAL_GPIO_Init+0x136>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 80061ee:	69fb      	ldr	r3, [r7, #28]
 80061f0:	08da      	lsrs	r2, r3, #3
 80061f2:	687b      	ldr	r3, [r7, #4]
 80061f4:	3208      	adds	r2, #8
 80061f6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80061fa:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 80061fc:	69fb      	ldr	r3, [r7, #28]
 80061fe:	f003 0307 	and.w	r3, r3, #7
 8006202:	009b      	lsls	r3, r3, #2
 8006204:	220f      	movs	r2, #15
 8006206:	fa02 f303 	lsl.w	r3, r2, r3
 800620a:	43db      	mvns	r3, r3
 800620c:	69ba      	ldr	r2, [r7, #24]
 800620e:	4013      	ands	r3, r2
 8006210:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8006212:	683b      	ldr	r3, [r7, #0]
 8006214:	691a      	ldr	r2, [r3, #16]
 8006216:	69fb      	ldr	r3, [r7, #28]
 8006218:	f003 0307 	and.w	r3, r3, #7
 800621c:	009b      	lsls	r3, r3, #2
 800621e:	fa02 f303 	lsl.w	r3, r2, r3
 8006222:	69ba      	ldr	r2, [r7, #24]
 8006224:	4313      	orrs	r3, r2
 8006226:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 8006228:	69fb      	ldr	r3, [r7, #28]
 800622a:	08da      	lsrs	r2, r3, #3
 800622c:	687b      	ldr	r3, [r7, #4]
 800622e:	3208      	adds	r2, #8
 8006230:	69b9      	ldr	r1, [r7, #24]
 8006232:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8006236:	687b      	ldr	r3, [r7, #4]
 8006238:	681b      	ldr	r3, [r3, #0]
 800623a:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 800623c:	69fb      	ldr	r3, [r7, #28]
 800623e:	005b      	lsls	r3, r3, #1
 8006240:	2203      	movs	r2, #3
 8006242:	fa02 f303 	lsl.w	r3, r2, r3
 8006246:	43db      	mvns	r3, r3
 8006248:	69ba      	ldr	r2, [r7, #24]
 800624a:	4013      	ands	r3, r2
 800624c:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800624e:	683b      	ldr	r3, [r7, #0]
 8006250:	685b      	ldr	r3, [r3, #4]
 8006252:	f003 0203 	and.w	r2, r3, #3
 8006256:	69fb      	ldr	r3, [r7, #28]
 8006258:	005b      	lsls	r3, r3, #1
 800625a:	fa02 f303 	lsl.w	r3, r2, r3
 800625e:	69ba      	ldr	r2, [r7, #24]
 8006260:	4313      	orrs	r3, r2
 8006262:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8006264:	687b      	ldr	r3, [r7, #4]
 8006266:	69ba      	ldr	r2, [r7, #24]
 8006268:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 800626a:	683b      	ldr	r3, [r7, #0]
 800626c:	685b      	ldr	r3, [r3, #4]
 800626e:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 8006272:	2b00      	cmp	r3, #0
 8006274:	f000 80e0 	beq.w	8006438 <HAL_GPIO_Init+0x338>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8006278:	4b2f      	ldr	r3, [pc, #188]	@ (8006338 <HAL_GPIO_Init+0x238>)
 800627a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 800627e:	4a2e      	ldr	r2, [pc, #184]	@ (8006338 <HAL_GPIO_Init+0x238>)
 8006280:	f043 0302 	orr.w	r3, r3, #2
 8006284:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
 8006288:	4b2b      	ldr	r3, [pc, #172]	@ (8006338 <HAL_GPIO_Init+0x238>)
 800628a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 800628e:	f003 0302 	and.w	r3, r3, #2
 8006292:	60fb      	str	r3, [r7, #12]
 8006294:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8006296:	4a29      	ldr	r2, [pc, #164]	@ (800633c <HAL_GPIO_Init+0x23c>)
 8006298:	69fb      	ldr	r3, [r7, #28]
 800629a:	089b      	lsrs	r3, r3, #2
 800629c:	3302      	adds	r3, #2
 800629e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80062a2:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 80062a4:	69fb      	ldr	r3, [r7, #28]
 80062a6:	f003 0303 	and.w	r3, r3, #3
 80062aa:	009b      	lsls	r3, r3, #2
 80062ac:	220f      	movs	r2, #15
 80062ae:	fa02 f303 	lsl.w	r3, r2, r3
 80062b2:	43db      	mvns	r3, r3
 80062b4:	69ba      	ldr	r2, [r7, #24]
 80062b6:	4013      	ands	r3, r2
 80062b8:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80062ba:	687b      	ldr	r3, [r7, #4]
 80062bc:	4a20      	ldr	r2, [pc, #128]	@ (8006340 <HAL_GPIO_Init+0x240>)
 80062be:	4293      	cmp	r3, r2
 80062c0:	d052      	beq.n	8006368 <HAL_GPIO_Init+0x268>
 80062c2:	687b      	ldr	r3, [r7, #4]
 80062c4:	4a1f      	ldr	r2, [pc, #124]	@ (8006344 <HAL_GPIO_Init+0x244>)
 80062c6:	4293      	cmp	r3, r2
 80062c8:	d031      	beq.n	800632e <HAL_GPIO_Init+0x22e>
 80062ca:	687b      	ldr	r3, [r7, #4]
 80062cc:	4a1e      	ldr	r2, [pc, #120]	@ (8006348 <HAL_GPIO_Init+0x248>)
 80062ce:	4293      	cmp	r3, r2
 80062d0:	d02b      	beq.n	800632a <HAL_GPIO_Init+0x22a>
 80062d2:	687b      	ldr	r3, [r7, #4]
 80062d4:	4a1d      	ldr	r2, [pc, #116]	@ (800634c <HAL_GPIO_Init+0x24c>)
 80062d6:	4293      	cmp	r3, r2
 80062d8:	d025      	beq.n	8006326 <HAL_GPIO_Init+0x226>
 80062da:	687b      	ldr	r3, [r7, #4]
 80062dc:	4a1c      	ldr	r2, [pc, #112]	@ (8006350 <HAL_GPIO_Init+0x250>)
 80062de:	4293      	cmp	r3, r2
 80062e0:	d01f      	beq.n	8006322 <HAL_GPIO_Init+0x222>
 80062e2:	687b      	ldr	r3, [r7, #4]
 80062e4:	4a1b      	ldr	r2, [pc, #108]	@ (8006354 <HAL_GPIO_Init+0x254>)
 80062e6:	4293      	cmp	r3, r2
 80062e8:	d019      	beq.n	800631e <HAL_GPIO_Init+0x21e>
 80062ea:	687b      	ldr	r3, [r7, #4]
 80062ec:	4a1a      	ldr	r2, [pc, #104]	@ (8006358 <HAL_GPIO_Init+0x258>)
 80062ee:	4293      	cmp	r3, r2
 80062f0:	d013      	beq.n	800631a <HAL_GPIO_Init+0x21a>
 80062f2:	687b      	ldr	r3, [r7, #4]
 80062f4:	4a19      	ldr	r2, [pc, #100]	@ (800635c <HAL_GPIO_Init+0x25c>)
 80062f6:	4293      	cmp	r3, r2
 80062f8:	d00d      	beq.n	8006316 <HAL_GPIO_Init+0x216>
 80062fa:	687b      	ldr	r3, [r7, #4]
 80062fc:	4a18      	ldr	r2, [pc, #96]	@ (8006360 <HAL_GPIO_Init+0x260>)
 80062fe:	4293      	cmp	r3, r2
 8006300:	d007      	beq.n	8006312 <HAL_GPIO_Init+0x212>
 8006302:	687b      	ldr	r3, [r7, #4]
 8006304:	4a17      	ldr	r2, [pc, #92]	@ (8006364 <HAL_GPIO_Init+0x264>)
 8006306:	4293      	cmp	r3, r2
 8006308:	d101      	bne.n	800630e <HAL_GPIO_Init+0x20e>
 800630a:	2309      	movs	r3, #9
 800630c:	e02d      	b.n	800636a <HAL_GPIO_Init+0x26a>
 800630e:	230a      	movs	r3, #10
 8006310:	e02b      	b.n	800636a <HAL_GPIO_Init+0x26a>
 8006312:	2308      	movs	r3, #8
 8006314:	e029      	b.n	800636a <HAL_GPIO_Init+0x26a>
 8006316:	2307      	movs	r3, #7
 8006318:	e027      	b.n	800636a <HAL_GPIO_Init+0x26a>
 800631a:	2306      	movs	r3, #6
 800631c:	e025      	b.n	800636a <HAL_GPIO_Init+0x26a>
 800631e:	2305      	movs	r3, #5
 8006320:	e023      	b.n	800636a <HAL_GPIO_Init+0x26a>
 8006322:	2304      	movs	r3, #4
 8006324:	e021      	b.n	800636a <HAL_GPIO_Init+0x26a>
 8006326:	2303      	movs	r3, #3
 8006328:	e01f      	b.n	800636a <HAL_GPIO_Init+0x26a>
 800632a:	2302      	movs	r3, #2
 800632c:	e01d      	b.n	800636a <HAL_GPIO_Init+0x26a>
 800632e:	2301      	movs	r3, #1
 8006330:	e01b      	b.n	800636a <HAL_GPIO_Init+0x26a>
 8006332:	bf00      	nop
 8006334:	58000080 	.word	0x58000080
 8006338:	58024400 	.word	0x58024400
 800633c:	58000400 	.word	0x58000400
 8006340:	58020000 	.word	0x58020000
 8006344:	58020400 	.word	0x58020400
 8006348:	58020800 	.word	0x58020800
 800634c:	58020c00 	.word	0x58020c00
 8006350:	58021000 	.word	0x58021000
 8006354:	58021400 	.word	0x58021400
 8006358:	58021800 	.word	0x58021800
 800635c:	58021c00 	.word	0x58021c00
 8006360:	58022000 	.word	0x58022000
 8006364:	58022400 	.word	0x58022400
 8006368:	2300      	movs	r3, #0
 800636a:	69fa      	ldr	r2, [r7, #28]
 800636c:	f002 0203 	and.w	r2, r2, #3
 8006370:	0092      	lsls	r2, r2, #2
 8006372:	4093      	lsls	r3, r2
 8006374:	69ba      	ldr	r2, [r7, #24]
 8006376:	4313      	orrs	r3, r2
 8006378:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 800637a:	4938      	ldr	r1, [pc, #224]	@ (800645c <HAL_GPIO_Init+0x35c>)
 800637c:	69fb      	ldr	r3, [r7, #28]
 800637e:	089b      	lsrs	r3, r3, #2
 8006380:	3302      	adds	r3, #2
 8006382:	69ba      	ldr	r2, [r7, #24]
 8006384:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8006388:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 800638c:	681b      	ldr	r3, [r3, #0]
 800638e:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8006390:	693b      	ldr	r3, [r7, #16]
 8006392:	43db      	mvns	r3, r3
 8006394:	69ba      	ldr	r2, [r7, #24]
 8006396:	4013      	ands	r3, r2
 8006398:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 800639a:	683b      	ldr	r3, [r7, #0]
 800639c:	685b      	ldr	r3, [r3, #4]
 800639e:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 80063a2:	2b00      	cmp	r3, #0
 80063a4:	d003      	beq.n	80063ae <HAL_GPIO_Init+0x2ae>
        {
          temp |= iocurrent;
 80063a6:	69ba      	ldr	r2, [r7, #24]
 80063a8:	693b      	ldr	r3, [r7, #16]
 80063aa:	4313      	orrs	r3, r2
 80063ac:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR1 = temp;
 80063ae:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80063b2:	69bb      	ldr	r3, [r7, #24]
 80063b4:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
 80063b6:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 80063ba:	685b      	ldr	r3, [r3, #4]
 80063bc:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 80063be:	693b      	ldr	r3, [r7, #16]
 80063c0:	43db      	mvns	r3, r3
 80063c2:	69ba      	ldr	r2, [r7, #24]
 80063c4:	4013      	ands	r3, r2
 80063c6:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 80063c8:	683b      	ldr	r3, [r7, #0]
 80063ca:	685b      	ldr	r3, [r3, #4]
 80063cc:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 80063d0:	2b00      	cmp	r3, #0
 80063d2:	d003      	beq.n	80063dc <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
 80063d4:	69ba      	ldr	r2, [r7, #24]
 80063d6:	693b      	ldr	r3, [r7, #16]
 80063d8:	4313      	orrs	r3, r2
 80063da:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR1 = temp;
 80063dc:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 80063e0:	69bb      	ldr	r3, [r7, #24]
 80063e2:	6053      	str	r3, [r2, #4]

        temp = EXTI_CurrentCPU->EMR1;
 80063e4:	697b      	ldr	r3, [r7, #20]
 80063e6:	685b      	ldr	r3, [r3, #4]
 80063e8:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 80063ea:	693b      	ldr	r3, [r7, #16]
 80063ec:	43db      	mvns	r3, r3
 80063ee:	69ba      	ldr	r2, [r7, #24]
 80063f0:	4013      	ands	r3, r2
 80063f2:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 80063f4:	683b      	ldr	r3, [r7, #0]
 80063f6:	685b      	ldr	r3, [r3, #4]
 80063f8:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80063fc:	2b00      	cmp	r3, #0
 80063fe:	d003      	beq.n	8006408 <HAL_GPIO_Init+0x308>
        {
          temp |= iocurrent;
 8006400:	69ba      	ldr	r2, [r7, #24]
 8006402:	693b      	ldr	r3, [r7, #16]
 8006404:	4313      	orrs	r3, r2
 8006406:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->EMR1 = temp;
 8006408:	697b      	ldr	r3, [r7, #20]
 800640a:	69ba      	ldr	r2, [r7, #24]
 800640c:	605a      	str	r2, [r3, #4]

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
 800640e:	697b      	ldr	r3, [r7, #20]
 8006410:	681b      	ldr	r3, [r3, #0]
 8006412:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8006414:	693b      	ldr	r3, [r7, #16]
 8006416:	43db      	mvns	r3, r3
 8006418:	69ba      	ldr	r2, [r7, #24]
 800641a:	4013      	ands	r3, r2
 800641c:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 800641e:	683b      	ldr	r3, [r7, #0]
 8006420:	685b      	ldr	r3, [r3, #4]
 8006422:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8006426:	2b00      	cmp	r3, #0
 8006428:	d003      	beq.n	8006432 <HAL_GPIO_Init+0x332>
        {
          temp |= iocurrent;
 800642a:	69ba      	ldr	r2, [r7, #24]
 800642c:	693b      	ldr	r3, [r7, #16]
 800642e:	4313      	orrs	r3, r2
 8006430:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->IMR1 = temp;
 8006432:	697b      	ldr	r3, [r7, #20]
 8006434:	69ba      	ldr	r2, [r7, #24]
 8006436:	601a      	str	r2, [r3, #0]
      }
    }

    position++;
 8006438:	69fb      	ldr	r3, [r7, #28]
 800643a:	3301      	adds	r3, #1
 800643c:	61fb      	str	r3, [r7, #28]
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 800643e:	683b      	ldr	r3, [r7, #0]
 8006440:	681a      	ldr	r2, [r3, #0]
 8006442:	69fb      	ldr	r3, [r7, #28]
 8006444:	fa22 f303 	lsr.w	r3, r2, r3
 8006448:	2b00      	cmp	r3, #0
 800644a:	f47f ae63 	bne.w	8006114 <HAL_GPIO_Init+0x14>
  }
}
 800644e:	bf00      	nop
 8006450:	bf00      	nop
 8006452:	3724      	adds	r7, #36	@ 0x24
 8006454:	46bd      	mov	sp, r7
 8006456:	f85d 7b04 	ldr.w	r7, [sp], #4
 800645a:	4770      	bx	lr
 800645c:	58000400 	.word	0x58000400

08006460 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8006460:	b480      	push	{r7}
 8006462:	b083      	sub	sp, #12
 8006464:	af00      	add	r7, sp, #0
 8006466:	6078      	str	r0, [r7, #4]
 8006468:	460b      	mov	r3, r1
 800646a:	807b      	strh	r3, [r7, #2]
 800646c:	4613      	mov	r3, r2
 800646e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8006470:	787b      	ldrb	r3, [r7, #1]
 8006472:	2b00      	cmp	r3, #0
 8006474:	d003      	beq.n	800647e <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 8006476:	887a      	ldrh	r2, [r7, #2]
 8006478:	687b      	ldr	r3, [r7, #4]
 800647a:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
  }
}
 800647c:	e003      	b.n	8006486 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 800647e:	887b      	ldrh	r3, [r7, #2]
 8006480:	041a      	lsls	r2, r3, #16
 8006482:	687b      	ldr	r3, [r7, #4]
 8006484:	619a      	str	r2, [r3, #24]
}
 8006486:	bf00      	nop
 8006488:	370c      	adds	r7, #12
 800648a:	46bd      	mov	sp, r7
 800648c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006490:	4770      	bx	lr
	...

08006494 <HAL_HSEM_FastTake>:
  * @brief  Fast Take a semaphore with 1 Step mode.
  * @param  SemID: semaphore ID from 0 to 31
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HSEM_FastTake(uint32_t SemID)
{
 8006494:	b480      	push	{r7}
 8006496:	b083      	sub	sp, #12
 8006498:	af00      	add	r7, sp, #0
 800649a:	6078      	str	r0, [r7, #4]
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
  }
#else
  /* Read the RLR register to take the semaphore */
  if (HSEM->RLR[SemID] == (HSEM_CR_COREID_CURRENT | HSEM_RLR_LOCK))
 800649c:	4a08      	ldr	r2, [pc, #32]	@ (80064c0 <HAL_HSEM_FastTake+0x2c>)
 800649e:	687b      	ldr	r3, [r7, #4]
 80064a0:	3320      	adds	r3, #32
 80064a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80064a6:	4a07      	ldr	r2, [pc, #28]	@ (80064c4 <HAL_HSEM_FastTake+0x30>)
 80064a8:	4293      	cmp	r3, r2
 80064aa:	d101      	bne.n	80064b0 <HAL_HSEM_FastTake+0x1c>
  {
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
 80064ac:	2300      	movs	r3, #0
 80064ae:	e000      	b.n	80064b2 <HAL_HSEM_FastTake+0x1e>
  }
#endif

  /* Semaphore take fails */
  return HAL_ERROR;
 80064b0:	2301      	movs	r3, #1
}
 80064b2:	4618      	mov	r0, r3
 80064b4:	370c      	adds	r7, #12
 80064b6:	46bd      	mov	sp, r7
 80064b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80064bc:	4770      	bx	lr
 80064be:	bf00      	nop
 80064c0:	58026400 	.word	0x58026400
 80064c4:	80000300 	.word	0x80000300

080064c8 <HAL_HSEM_Release>:
  * @param  SemID: semaphore ID from 0 to 31
  * @param  ProcessID: Process ID from 0 to 255
  * @retval None
  */
void  HAL_HSEM_Release(uint32_t SemID, uint32_t ProcessID)
{
 80064c8:	b480      	push	{r7}
 80064ca:	b083      	sub	sp, #12
 80064cc:	af00      	add	r7, sp, #0
 80064ce:	6078      	str	r0, [r7, #4]
 80064d0:	6039      	str	r1, [r7, #0]

  /* Clear the semaphore by writing to the R register : the MasterID , the processID and take bit = 0  */
#if  USE_MULTI_CORE_SHARED_CODE != 0U
  HSEM->R[SemID] = (ProcessID | ((HAL_GetCurrentCPUID() << POSITION_VAL(HSEM_R_MASTERID)) & HSEM_R_MASTERID));
#else
  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT);
 80064d2:	4906      	ldr	r1, [pc, #24]	@ (80064ec <HAL_HSEM_Release+0x24>)
 80064d4:	683b      	ldr	r3, [r7, #0]
 80064d6:	f443 7240 	orr.w	r2, r3, #768	@ 0x300
 80064da:	687b      	ldr	r3, [r7, #4]
 80064dc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif

}
 80064e0:	bf00      	nop
 80064e2:	370c      	adds	r7, #12
 80064e4:	46bd      	mov	sp, r7
 80064e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80064ea:	4770      	bx	lr
 80064ec:	58026400 	.word	0x58026400

080064f0 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 80064f0:	b580      	push	{r7, lr}
 80064f2:	b082      	sub	sp, #8
 80064f4:	af00      	add	r7, sp, #0
 80064f6:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 80064f8:	687b      	ldr	r3, [r7, #4]
 80064fa:	2b00      	cmp	r3, #0
 80064fc:	d101      	bne.n	8006502 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
 80064fe:	2301      	movs	r3, #1
 8006500:	e08b      	b.n	800661a <HAL_I2C_Init+0x12a>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 8006502:	687b      	ldr	r3, [r7, #4]
 8006504:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8006508:	b2db      	uxtb	r3, r3
 800650a:	2b00      	cmp	r3, #0
 800650c:	d106      	bne.n	800651c <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 800650e:	687b      	ldr	r3, [r7, #4]
 8006510:	2200      	movs	r2, #0
 8006512:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
 8006516:	6878      	ldr	r0, [r7, #4]
 8006518:	f7fb f852 	bl	80015c0 <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 800651c:	687b      	ldr	r3, [r7, #4]
 800651e:	2224      	movs	r2, #36	@ 0x24
 8006520:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 8006524:	687b      	ldr	r3, [r7, #4]
 8006526:	681b      	ldr	r3, [r3, #0]
 8006528:	681a      	ldr	r2, [r3, #0]
 800652a:	687b      	ldr	r3, [r7, #4]
 800652c:	681b      	ldr	r3, [r3, #0]
 800652e:	f022 0201 	bic.w	r2, r2, #1
 8006532:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8006534:	687b      	ldr	r3, [r7, #4]
 8006536:	685a      	ldr	r2, [r3, #4]
 8006538:	687b      	ldr	r3, [r7, #4]
 800653a:	681b      	ldr	r3, [r3, #0]
 800653c:	f022 6270 	bic.w	r2, r2, #251658240	@ 0xf000000
 8006540:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8006542:	687b      	ldr	r3, [r7, #4]
 8006544:	681b      	ldr	r3, [r3, #0]
 8006546:	689a      	ldr	r2, [r3, #8]
 8006548:	687b      	ldr	r3, [r7, #4]
 800654a:	681b      	ldr	r3, [r3, #0]
 800654c:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 8006550:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8006552:	687b      	ldr	r3, [r7, #4]
 8006554:	68db      	ldr	r3, [r3, #12]
 8006556:	2b01      	cmp	r3, #1
 8006558:	d107      	bne.n	800656a <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 800655a:	687b      	ldr	r3, [r7, #4]
 800655c:	689a      	ldr	r2, [r3, #8]
 800655e:	687b      	ldr	r3, [r7, #4]
 8006560:	681b      	ldr	r3, [r3, #0]
 8006562:	f442 4200 	orr.w	r2, r2, #32768	@ 0x8000
 8006566:	609a      	str	r2, [r3, #8]
 8006568:	e006      	b.n	8006578 <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 800656a:	687b      	ldr	r3, [r7, #4]
 800656c:	689a      	ldr	r2, [r3, #8]
 800656e:	687b      	ldr	r3, [r7, #4]
 8006570:	681b      	ldr	r3, [r3, #0]
 8006572:	f442 4204 	orr.w	r2, r2, #33792	@ 0x8400
 8006576:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8006578:	687b      	ldr	r3, [r7, #4]
 800657a:	68db      	ldr	r3, [r3, #12]
 800657c:	2b02      	cmp	r3, #2
 800657e:	d108      	bne.n	8006592 <HAL_I2C_Init+0xa2>
  {
    SET_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
 8006580:	687b      	ldr	r3, [r7, #4]
 8006582:	681b      	ldr	r3, [r3, #0]
 8006584:	685a      	ldr	r2, [r3, #4]
 8006586:	687b      	ldr	r3, [r7, #4]
 8006588:	681b      	ldr	r3, [r3, #0]
 800658a:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 800658e:	605a      	str	r2, [r3, #4]
 8006590:	e007      	b.n	80065a2 <HAL_I2C_Init+0xb2>
  }
  else
  {
    /* Clear the I2C ADD10 bit */
    CLEAR_BIT(hi2c->Instance->CR2, I2C_CR2_ADD10);
 8006592:	687b      	ldr	r3, [r7, #4]
 8006594:	681b      	ldr	r3, [r3, #0]
 8006596:	685a      	ldr	r2, [r3, #4]
 8006598:	687b      	ldr	r3, [r7, #4]
 800659a:	681b      	ldr	r3, [r3, #0]
 800659c:	f422 6200 	bic.w	r2, r2, #2048	@ 0x800
 80065a0:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 80065a2:	687b      	ldr	r3, [r7, #4]
 80065a4:	681b      	ldr	r3, [r3, #0]
 80065a6:	6859      	ldr	r1, [r3, #4]
 80065a8:	687b      	ldr	r3, [r7, #4]
 80065aa:	681a      	ldr	r2, [r3, #0]
 80065ac:	4b1d      	ldr	r3, [pc, #116]	@ (8006624 <HAL_I2C_Init+0x134>)
 80065ae:	430b      	orrs	r3, r1
 80065b0:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 80065b2:	687b      	ldr	r3, [r7, #4]
 80065b4:	681b      	ldr	r3, [r3, #0]
 80065b6:	68da      	ldr	r2, [r3, #12]
 80065b8:	687b      	ldr	r3, [r7, #4]
 80065ba:	681b      	ldr	r3, [r3, #0]
 80065bc:	f422 4200 	bic.w	r2, r2, #32768	@ 0x8000
 80065c0:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 80065c2:	687b      	ldr	r3, [r7, #4]
 80065c4:	691a      	ldr	r2, [r3, #16]
 80065c6:	687b      	ldr	r3, [r7, #4]
 80065c8:	695b      	ldr	r3, [r3, #20]
 80065ca:	ea42 0103 	orr.w	r1, r2, r3
                          (hi2c->Init.OwnAddress2Masks << 8));
 80065ce:	687b      	ldr	r3, [r7, #4]
 80065d0:	699b      	ldr	r3, [r3, #24]
 80065d2:	021a      	lsls	r2, r3, #8
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | \
 80065d4:	687b      	ldr	r3, [r7, #4]
 80065d6:	681b      	ldr	r3, [r3, #0]
 80065d8:	430a      	orrs	r2, r1
 80065da:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 80065dc:	687b      	ldr	r3, [r7, #4]
 80065de:	69d9      	ldr	r1, [r3, #28]
 80065e0:	687b      	ldr	r3, [r7, #4]
 80065e2:	6a1a      	ldr	r2, [r3, #32]
 80065e4:	687b      	ldr	r3, [r7, #4]
 80065e6:	681b      	ldr	r3, [r3, #0]
 80065e8:	430a      	orrs	r2, r1
 80065ea:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 80065ec:	687b      	ldr	r3, [r7, #4]
 80065ee:	681b      	ldr	r3, [r3, #0]
 80065f0:	681a      	ldr	r2, [r3, #0]
 80065f2:	687b      	ldr	r3, [r7, #4]
 80065f4:	681b      	ldr	r3, [r3, #0]
 80065f6:	f042 0201 	orr.w	r2, r2, #1
 80065fa:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80065fc:	687b      	ldr	r3, [r7, #4]
 80065fe:	2200      	movs	r2, #0
 8006600:	645a      	str	r2, [r3, #68]	@ 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8006602:	687b      	ldr	r3, [r7, #4]
 8006604:	2220      	movs	r2, #32
 8006606:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 800660a:	687b      	ldr	r3, [r7, #4]
 800660c:	2200      	movs	r2, #0
 800660e:	631a      	str	r2, [r3, #48]	@ 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8006610:	687b      	ldr	r3, [r7, #4]
 8006612:	2200      	movs	r2, #0
 8006614:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

  return HAL_OK;
 8006618:	2300      	movs	r3, #0
}
 800661a:	4618      	mov	r0, r3
 800661c:	3708      	adds	r7, #8
 800661e:	46bd      	mov	sp, r7
 8006620:	bd80      	pop	{r7, pc}
 8006622:	bf00      	nop
 8006624:	02008000 	.word	0x02008000

08006628 <HAL_I2C_Mem_Write>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                    uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8006628:	b580      	push	{r7, lr}
 800662a:	b088      	sub	sp, #32
 800662c:	af02      	add	r7, sp, #8
 800662e:	60f8      	str	r0, [r7, #12]
 8006630:	4608      	mov	r0, r1
 8006632:	4611      	mov	r1, r2
 8006634:	461a      	mov	r2, r3
 8006636:	4603      	mov	r3, r0
 8006638:	817b      	strh	r3, [r7, #10]
 800663a:	460b      	mov	r3, r1
 800663c:	813b      	strh	r3, [r7, #8]
 800663e:	4613      	mov	r3, r2
 8006640:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8006642:	68fb      	ldr	r3, [r7, #12]
 8006644:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8006648:	b2db      	uxtb	r3, r3
 800664a:	2b20      	cmp	r3, #32
 800664c:	f040 80f9 	bne.w	8006842 <HAL_I2C_Mem_Write+0x21a>
  {
    if ((pData == NULL) || (Size == 0U))
 8006650:	6a3b      	ldr	r3, [r7, #32]
 8006652:	2b00      	cmp	r3, #0
 8006654:	d002      	beq.n	800665c <HAL_I2C_Mem_Write+0x34>
 8006656:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8006658:	2b00      	cmp	r3, #0
 800665a:	d105      	bne.n	8006668 <HAL_I2C_Mem_Write+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 800665c:	68fb      	ldr	r3, [r7, #12]
 800665e:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8006662:	645a      	str	r2, [r3, #68]	@ 0x44
      return  HAL_ERROR;
 8006664:	2301      	movs	r3, #1
 8006666:	e0ed      	b.n	8006844 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8006668:	68fb      	ldr	r3, [r7, #12]
 800666a:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 800666e:	2b01      	cmp	r3, #1
 8006670:	d101      	bne.n	8006676 <HAL_I2C_Mem_Write+0x4e>
 8006672:	2302      	movs	r3, #2
 8006674:	e0e6      	b.n	8006844 <HAL_I2C_Mem_Write+0x21c>
 8006676:	68fb      	ldr	r3, [r7, #12]
 8006678:	2201      	movs	r2, #1
 800667a:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 800667e:	f7fb fc79 	bl	8001f74 <HAL_GetTick>
 8006682:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8006684:	697b      	ldr	r3, [r7, #20]
 8006686:	9300      	str	r3, [sp, #0]
 8006688:	2319      	movs	r3, #25
 800668a:	2201      	movs	r2, #1
 800668c:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 8006690:	68f8      	ldr	r0, [r7, #12]
 8006692:	f000 fac3 	bl	8006c1c <I2C_WaitOnFlagUntilTimeout>
 8006696:	4603      	mov	r3, r0
 8006698:	2b00      	cmp	r3, #0
 800669a:	d001      	beq.n	80066a0 <HAL_I2C_Mem_Write+0x78>
    {
      return HAL_ERROR;
 800669c:	2301      	movs	r3, #1
 800669e:	e0d1      	b.n	8006844 <HAL_I2C_Mem_Write+0x21c>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 80066a0:	68fb      	ldr	r3, [r7, #12]
 80066a2:	2221      	movs	r2, #33	@ 0x21
 80066a4:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 80066a8:	68fb      	ldr	r3, [r7, #12]
 80066aa:	2240      	movs	r2, #64	@ 0x40
 80066ac:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80066b0:	68fb      	ldr	r3, [r7, #12]
 80066b2:	2200      	movs	r2, #0
 80066b4:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 80066b6:	68fb      	ldr	r3, [r7, #12]
 80066b8:	6a3a      	ldr	r2, [r7, #32]
 80066ba:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount = Size;
 80066bc:	68fb      	ldr	r3, [r7, #12]
 80066be:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
 80066c0:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferISR   = NULL;
 80066c2:	68fb      	ldr	r3, [r7, #12]
 80066c4:	2200      	movs	r2, #0
 80066c6:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80066c8:	88f8      	ldrh	r0, [r7, #6]
 80066ca:	893a      	ldrh	r2, [r7, #8]
 80066cc:	8979      	ldrh	r1, [r7, #10]
 80066ce:	697b      	ldr	r3, [r7, #20]
 80066d0:	9301      	str	r3, [sp, #4]
 80066d2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80066d4:	9300      	str	r3, [sp, #0]
 80066d6:	4603      	mov	r3, r0
 80066d8:	68f8      	ldr	r0, [r7, #12]
 80066da:	f000 f9d3 	bl	8006a84 <I2C_RequestMemoryWrite>
 80066de:	4603      	mov	r3, r0
 80066e0:	2b00      	cmp	r3, #0
 80066e2:	d005      	beq.n	80066f0 <HAL_I2C_Mem_Write+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 80066e4:	68fb      	ldr	r3, [r7, #12]
 80066e6:	2200      	movs	r2, #0
 80066e8:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      return HAL_ERROR;
 80066ec:	2301      	movs	r3, #1
 80066ee:	e0a9      	b.n	8006844 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80066f0:	68fb      	ldr	r3, [r7, #12]
 80066f2:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80066f4:	b29b      	uxth	r3, r3
 80066f6:	2bff      	cmp	r3, #255	@ 0xff
 80066f8:	d90e      	bls.n	8006718 <HAL_I2C_Mem_Write+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80066fa:	68fb      	ldr	r3, [r7, #12]
 80066fc:	22ff      	movs	r2, #255	@ 0xff
 80066fe:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8006700:	68fb      	ldr	r3, [r7, #12]
 8006702:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8006704:	b2da      	uxtb	r2, r3
 8006706:	8979      	ldrh	r1, [r7, #10]
 8006708:	2300      	movs	r3, #0
 800670a:	9300      	str	r3, [sp, #0]
 800670c:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8006710:	68f8      	ldr	r0, [r7, #12]
 8006712:	f000 fc47 	bl	8006fa4 <I2C_TransferConfig>
 8006716:	e00f      	b.n	8006738 <HAL_I2C_Mem_Write+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 8006718:	68fb      	ldr	r3, [r7, #12]
 800671a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800671c:	b29a      	uxth	r2, r3
 800671e:	68fb      	ldr	r3, [r7, #12]
 8006720:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8006722:	68fb      	ldr	r3, [r7, #12]
 8006724:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8006726:	b2da      	uxtb	r2, r3
 8006728:	8979      	ldrh	r1, [r7, #10]
 800672a:	2300      	movs	r3, #0
 800672c:	9300      	str	r3, [sp, #0]
 800672e:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 8006732:	68f8      	ldr	r0, [r7, #12]
 8006734:	f000 fc36 	bl	8006fa4 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8006738:	697a      	ldr	r2, [r7, #20]
 800673a:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800673c:	68f8      	ldr	r0, [r7, #12]
 800673e:	f000 fac6 	bl	8006cce <I2C_WaitOnTXISFlagUntilTimeout>
 8006742:	4603      	mov	r3, r0
 8006744:	2b00      	cmp	r3, #0
 8006746:	d001      	beq.n	800674c <HAL_I2C_Mem_Write+0x124>
      {
        return HAL_ERROR;
 8006748:	2301      	movs	r3, #1
 800674a:	e07b      	b.n	8006844 <HAL_I2C_Mem_Write+0x21c>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 800674c:	68fb      	ldr	r3, [r7, #12]
 800674e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8006750:	781a      	ldrb	r2, [r3, #0]
 8006752:	68fb      	ldr	r3, [r7, #12]
 8006754:	681b      	ldr	r3, [r3, #0]
 8006756:	629a      	str	r2, [r3, #40]	@ 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8006758:	68fb      	ldr	r3, [r7, #12]
 800675a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800675c:	1c5a      	adds	r2, r3, #1
 800675e:	68fb      	ldr	r3, [r7, #12]
 8006760:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferCount--;
 8006762:	68fb      	ldr	r3, [r7, #12]
 8006764:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006766:	b29b      	uxth	r3, r3
 8006768:	3b01      	subs	r3, #1
 800676a:	b29a      	uxth	r2, r3
 800676c:	68fb      	ldr	r3, [r7, #12]
 800676e:	855a      	strh	r2, [r3, #42]	@ 0x2a
      hi2c->XferSize--;
 8006770:	68fb      	ldr	r3, [r7, #12]
 8006772:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8006774:	3b01      	subs	r3, #1
 8006776:	b29a      	uxth	r2, r3
 8006778:	68fb      	ldr	r3, [r7, #12]
 800677a:	851a      	strh	r2, [r3, #40]	@ 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800677c:	68fb      	ldr	r3, [r7, #12]
 800677e:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006780:	b29b      	uxth	r3, r3
 8006782:	2b00      	cmp	r3, #0
 8006784:	d034      	beq.n	80067f0 <HAL_I2C_Mem_Write+0x1c8>
 8006786:	68fb      	ldr	r3, [r7, #12]
 8006788:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800678a:	2b00      	cmp	r3, #0
 800678c:	d130      	bne.n	80067f0 <HAL_I2C_Mem_Write+0x1c8>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800678e:	697b      	ldr	r3, [r7, #20]
 8006790:	9300      	str	r3, [sp, #0]
 8006792:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006794:	2200      	movs	r2, #0
 8006796:	2180      	movs	r1, #128	@ 0x80
 8006798:	68f8      	ldr	r0, [r7, #12]
 800679a:	f000 fa3f 	bl	8006c1c <I2C_WaitOnFlagUntilTimeout>
 800679e:	4603      	mov	r3, r0
 80067a0:	2b00      	cmp	r3, #0
 80067a2:	d001      	beq.n	80067a8 <HAL_I2C_Mem_Write+0x180>
        {
          return HAL_ERROR;
 80067a4:	2301      	movs	r3, #1
 80067a6:	e04d      	b.n	8006844 <HAL_I2C_Mem_Write+0x21c>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80067a8:	68fb      	ldr	r3, [r7, #12]
 80067aa:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80067ac:	b29b      	uxth	r3, r3
 80067ae:	2bff      	cmp	r3, #255	@ 0xff
 80067b0:	d90e      	bls.n	80067d0 <HAL_I2C_Mem_Write+0x1a8>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 80067b2:	68fb      	ldr	r3, [r7, #12]
 80067b4:	22ff      	movs	r2, #255	@ 0xff
 80067b6:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 80067b8:	68fb      	ldr	r3, [r7, #12]
 80067ba:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80067bc:	b2da      	uxtb	r2, r3
 80067be:	8979      	ldrh	r1, [r7, #10]
 80067c0:	2300      	movs	r3, #0
 80067c2:	9300      	str	r3, [sp, #0]
 80067c4:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 80067c8:	68f8      	ldr	r0, [r7, #12]
 80067ca:	f000 fbeb 	bl	8006fa4 <I2C_TransferConfig>
 80067ce:	e00f      	b.n	80067f0 <HAL_I2C_Mem_Write+0x1c8>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 80067d0:	68fb      	ldr	r3, [r7, #12]
 80067d2:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80067d4:	b29a      	uxth	r2, r3
 80067d6:	68fb      	ldr	r3, [r7, #12]
 80067d8:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 80067da:	68fb      	ldr	r3, [r7, #12]
 80067dc:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80067de:	b2da      	uxtb	r2, r3
 80067e0:	8979      	ldrh	r1, [r7, #10]
 80067e2:	2300      	movs	r3, #0
 80067e4:	9300      	str	r3, [sp, #0]
 80067e6:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 80067ea:	68f8      	ldr	r0, [r7, #12]
 80067ec:	f000 fbda 	bl	8006fa4 <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }

    } while (hi2c->XferCount > 0U);
 80067f0:	68fb      	ldr	r3, [r7, #12]
 80067f2:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80067f4:	b29b      	uxth	r3, r3
 80067f6:	2b00      	cmp	r3, #0
 80067f8:	d19e      	bne.n	8006738 <HAL_I2C_Mem_Write+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 80067fa:	697a      	ldr	r2, [r7, #20]
 80067fc:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 80067fe:	68f8      	ldr	r0, [r7, #12]
 8006800:	f000 faac 	bl	8006d5c <I2C_WaitOnSTOPFlagUntilTimeout>
 8006804:	4603      	mov	r3, r0
 8006806:	2b00      	cmp	r3, #0
 8006808:	d001      	beq.n	800680e <HAL_I2C_Mem_Write+0x1e6>
    {
      return HAL_ERROR;
 800680a:	2301      	movs	r3, #1
 800680c:	e01a      	b.n	8006844 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800680e:	68fb      	ldr	r3, [r7, #12]
 8006810:	681b      	ldr	r3, [r3, #0]
 8006812:	2220      	movs	r2, #32
 8006814:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8006816:	68fb      	ldr	r3, [r7, #12]
 8006818:	681b      	ldr	r3, [r3, #0]
 800681a:	6859      	ldr	r1, [r3, #4]
 800681c:	68fb      	ldr	r3, [r7, #12]
 800681e:	681a      	ldr	r2, [r3, #0]
 8006820:	4b0a      	ldr	r3, [pc, #40]	@ (800684c <HAL_I2C_Mem_Write+0x224>)
 8006822:	400b      	ands	r3, r1
 8006824:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 8006826:	68fb      	ldr	r3, [r7, #12]
 8006828:	2220      	movs	r2, #32
 800682a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800682e:	68fb      	ldr	r3, [r7, #12]
 8006830:	2200      	movs	r2, #0
 8006832:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8006836:	68fb      	ldr	r3, [r7, #12]
 8006838:	2200      	movs	r2, #0
 800683a:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
 800683e:	2300      	movs	r3, #0
 8006840:	e000      	b.n	8006844 <HAL_I2C_Mem_Write+0x21c>
  }
  else
  {
    return HAL_BUSY;
 8006842:	2302      	movs	r3, #2
  }
}
 8006844:	4618      	mov	r0, r3
 8006846:	3718      	adds	r7, #24
 8006848:	46bd      	mov	sp, r7
 800684a:	bd80      	pop	{r7, pc}
 800684c:	fe00e800 	.word	0xfe00e800

08006850 <HAL_I2C_Mem_Read>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress,
                                   uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8006850:	b580      	push	{r7, lr}
 8006852:	b088      	sub	sp, #32
 8006854:	af02      	add	r7, sp, #8
 8006856:	60f8      	str	r0, [r7, #12]
 8006858:	4608      	mov	r0, r1
 800685a:	4611      	mov	r1, r2
 800685c:	461a      	mov	r2, r3
 800685e:	4603      	mov	r3, r0
 8006860:	817b      	strh	r3, [r7, #10]
 8006862:	460b      	mov	r3, r1
 8006864:	813b      	strh	r3, [r7, #8]
 8006866:	4613      	mov	r3, r2
 8006868:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
 800686a:	68fb      	ldr	r3, [r7, #12]
 800686c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8006870:	b2db      	uxtb	r3, r3
 8006872:	2b20      	cmp	r3, #32
 8006874:	f040 80fd 	bne.w	8006a72 <HAL_I2C_Mem_Read+0x222>
  {
    if ((pData == NULL) || (Size == 0U))
 8006878:	6a3b      	ldr	r3, [r7, #32]
 800687a:	2b00      	cmp	r3, #0
 800687c:	d002      	beq.n	8006884 <HAL_I2C_Mem_Read+0x34>
 800687e:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8006880:	2b00      	cmp	r3, #0
 8006882:	d105      	bne.n	8006890 <HAL_I2C_Mem_Read+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 8006884:	68fb      	ldr	r3, [r7, #12]
 8006886:	f44f 7200 	mov.w	r2, #512	@ 0x200
 800688a:	645a      	str	r2, [r3, #68]	@ 0x44
      return  HAL_ERROR;
 800688c:	2301      	movs	r3, #1
 800688e:	e0f1      	b.n	8006a74 <HAL_I2C_Mem_Read+0x224>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8006890:	68fb      	ldr	r3, [r7, #12]
 8006892:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 8006896:	2b01      	cmp	r3, #1
 8006898:	d101      	bne.n	800689e <HAL_I2C_Mem_Read+0x4e>
 800689a:	2302      	movs	r3, #2
 800689c:	e0ea      	b.n	8006a74 <HAL_I2C_Mem_Read+0x224>
 800689e:	68fb      	ldr	r3, [r7, #12]
 80068a0:	2201      	movs	r2, #1
 80068a2:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 80068a6:	f7fb fb65 	bl	8001f74 <HAL_GetTick>
 80068aa:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 80068ac:	697b      	ldr	r3, [r7, #20]
 80068ae:	9300      	str	r3, [sp, #0]
 80068b0:	2319      	movs	r3, #25
 80068b2:	2201      	movs	r2, #1
 80068b4:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 80068b8:	68f8      	ldr	r0, [r7, #12]
 80068ba:	f000 f9af 	bl	8006c1c <I2C_WaitOnFlagUntilTimeout>
 80068be:	4603      	mov	r3, r0
 80068c0:	2b00      	cmp	r3, #0
 80068c2:	d001      	beq.n	80068c8 <HAL_I2C_Mem_Read+0x78>
    {
      return HAL_ERROR;
 80068c4:	2301      	movs	r3, #1
 80068c6:	e0d5      	b.n	8006a74 <HAL_I2C_Mem_Read+0x224>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 80068c8:	68fb      	ldr	r3, [r7, #12]
 80068ca:	2222      	movs	r2, #34	@ 0x22
 80068cc:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 80068d0:	68fb      	ldr	r3, [r7, #12]
 80068d2:	2240      	movs	r2, #64	@ 0x40
 80068d4:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80068d8:	68fb      	ldr	r3, [r7, #12]
 80068da:	2200      	movs	r2, #0
 80068dc:	645a      	str	r2, [r3, #68]	@ 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 80068de:	68fb      	ldr	r3, [r7, #12]
 80068e0:	6a3a      	ldr	r2, [r7, #32]
 80068e2:	625a      	str	r2, [r3, #36]	@ 0x24
    hi2c->XferCount = Size;
 80068e4:	68fb      	ldr	r3, [r7, #12]
 80068e6:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
 80068e8:	855a      	strh	r2, [r3, #42]	@ 0x2a
    hi2c->XferISR   = NULL;
 80068ea:	68fb      	ldr	r3, [r7, #12]
 80068ec:	2200      	movs	r2, #0
 80068ee:	635a      	str	r2, [r3, #52]	@ 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80068f0:	88f8      	ldrh	r0, [r7, #6]
 80068f2:	893a      	ldrh	r2, [r7, #8]
 80068f4:	8979      	ldrh	r1, [r7, #10]
 80068f6:	697b      	ldr	r3, [r7, #20]
 80068f8:	9301      	str	r3, [sp, #4]
 80068fa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80068fc:	9300      	str	r3, [sp, #0]
 80068fe:	4603      	mov	r3, r0
 8006900:	68f8      	ldr	r0, [r7, #12]
 8006902:	f000 f913 	bl	8006b2c <I2C_RequestMemoryRead>
 8006906:	4603      	mov	r3, r0
 8006908:	2b00      	cmp	r3, #0
 800690a:	d005      	beq.n	8006918 <HAL_I2C_Mem_Read+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800690c:	68fb      	ldr	r3, [r7, #12]
 800690e:	2200      	movs	r2, #0
 8006910:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
      return HAL_ERROR;
 8006914:	2301      	movs	r3, #1
 8006916:	e0ad      	b.n	8006a74 <HAL_I2C_Mem_Read+0x224>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8006918:	68fb      	ldr	r3, [r7, #12]
 800691a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 800691c:	b29b      	uxth	r3, r3
 800691e:	2bff      	cmp	r3, #255	@ 0xff
 8006920:	d90e      	bls.n	8006940 <HAL_I2C_Mem_Read+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8006922:	68fb      	ldr	r3, [r7, #12]
 8006924:	22ff      	movs	r2, #255	@ 0xff
 8006926:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE,
 8006928:	68fb      	ldr	r3, [r7, #12]
 800692a:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800692c:	b2da      	uxtb	r2, r3
 800692e:	8979      	ldrh	r1, [r7, #10]
 8006930:	4b52      	ldr	r3, [pc, #328]	@ (8006a7c <HAL_I2C_Mem_Read+0x22c>)
 8006932:	9300      	str	r3, [sp, #0]
 8006934:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8006938:	68f8      	ldr	r0, [r7, #12]
 800693a:	f000 fb33 	bl	8006fa4 <I2C_TransferConfig>
 800693e:	e00f      	b.n	8006960 <HAL_I2C_Mem_Read+0x110>
                         I2C_GENERATE_START_READ);
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 8006940:	68fb      	ldr	r3, [r7, #12]
 8006942:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006944:	b29a      	uxth	r2, r3
 8006946:	68fb      	ldr	r3, [r7, #12]
 8006948:	851a      	strh	r2, [r3, #40]	@ 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 800694a:	68fb      	ldr	r3, [r7, #12]
 800694c:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 800694e:	b2da      	uxtb	r2, r3
 8006950:	8979      	ldrh	r1, [r7, #10]
 8006952:	4b4a      	ldr	r3, [pc, #296]	@ (8006a7c <HAL_I2C_Mem_Read+0x22c>)
 8006954:	9300      	str	r3, [sp, #0]
 8006956:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 800695a:	68f8      	ldr	r0, [r7, #12]
 800695c:	f000 fb22 	bl	8006fa4 <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 8006960:	697b      	ldr	r3, [r7, #20]
 8006962:	9300      	str	r3, [sp, #0]
 8006964:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8006966:	2200      	movs	r2, #0
 8006968:	2104      	movs	r1, #4
 800696a:	68f8      	ldr	r0, [r7, #12]
 800696c:	f000 f956 	bl	8006c1c <I2C_WaitOnFlagUntilTimeout>
 8006970:	4603      	mov	r3, r0
 8006972:	2b00      	cmp	r3, #0
 8006974:	d001      	beq.n	800697a <HAL_I2C_Mem_Read+0x12a>
      {
        return HAL_ERROR;
 8006976:	2301      	movs	r3, #1
 8006978:	e07c      	b.n	8006a74 <HAL_I2C_Mem_Read+0x224>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 800697a:	68fb      	ldr	r3, [r7, #12]
 800697c:	681b      	ldr	r3, [r3, #0]
 800697e:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 8006980:	68fb      	ldr	r3, [r7, #12]
 8006982:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8006984:	b2d2      	uxtb	r2, r2
 8006986:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8006988:	68fb      	ldr	r3, [r7, #12]
 800698a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800698c:	1c5a      	adds	r2, r3, #1
 800698e:	68fb      	ldr	r3, [r7, #12]
 8006990:	625a      	str	r2, [r3, #36]	@ 0x24

      hi2c->XferSize--;
 8006992:	68fb      	ldr	r3, [r7, #12]
 8006994:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8006996:	3b01      	subs	r3, #1
 8006998:	b29a      	uxth	r2, r3
 800699a:	68fb      	ldr	r3, [r7, #12]
 800699c:	851a      	strh	r2, [r3, #40]	@ 0x28
      hi2c->XferCount--;
 800699e:	68fb      	ldr	r3, [r7, #12]
 80069a0:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80069a2:	b29b      	uxth	r3, r3
 80069a4:	3b01      	subs	r3, #1
 80069a6:	b29a      	uxth	r2, r3
 80069a8:	68fb      	ldr	r3, [r7, #12]
 80069aa:	855a      	strh	r2, [r3, #42]	@ 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80069ac:	68fb      	ldr	r3, [r7, #12]
 80069ae:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80069b0:	b29b      	uxth	r3, r3
 80069b2:	2b00      	cmp	r3, #0
 80069b4:	d034      	beq.n	8006a20 <HAL_I2C_Mem_Read+0x1d0>
 80069b6:	68fb      	ldr	r3, [r7, #12]
 80069b8:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80069ba:	2b00      	cmp	r3, #0
 80069bc:	d130      	bne.n	8006a20 <HAL_I2C_Mem_Read+0x1d0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 80069be:	697b      	ldr	r3, [r7, #20]
 80069c0:	9300      	str	r3, [sp, #0]
 80069c2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80069c4:	2200      	movs	r2, #0
 80069c6:	2180      	movs	r1, #128	@ 0x80
 80069c8:	68f8      	ldr	r0, [r7, #12]
 80069ca:	f000 f927 	bl	8006c1c <I2C_WaitOnFlagUntilTimeout>
 80069ce:	4603      	mov	r3, r0
 80069d0:	2b00      	cmp	r3, #0
 80069d2:	d001      	beq.n	80069d8 <HAL_I2C_Mem_Read+0x188>
        {
          return HAL_ERROR;
 80069d4:	2301      	movs	r3, #1
 80069d6:	e04d      	b.n	8006a74 <HAL_I2C_Mem_Read+0x224>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80069d8:	68fb      	ldr	r3, [r7, #12]
 80069da:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 80069dc:	b29b      	uxth	r3, r3
 80069de:	2bff      	cmp	r3, #255	@ 0xff
 80069e0:	d90e      	bls.n	8006a00 <HAL_I2C_Mem_Read+0x1b0>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 80069e2:	68fb      	ldr	r3, [r7, #12]
 80069e4:	22ff      	movs	r2, #255	@ 0xff
 80069e6:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE,
 80069e8:	68fb      	ldr	r3, [r7, #12]
 80069ea:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 80069ec:	b2da      	uxtb	r2, r3
 80069ee:	8979      	ldrh	r1, [r7, #10]
 80069f0:	2300      	movs	r3, #0
 80069f2:	9300      	str	r3, [sp, #0]
 80069f4:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 80069f8:	68f8      	ldr	r0, [r7, #12]
 80069fa:	f000 fad3 	bl	8006fa4 <I2C_TransferConfig>
 80069fe:	e00f      	b.n	8006a20 <HAL_I2C_Mem_Read+0x1d0>
                             I2C_NO_STARTSTOP);
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 8006a00:	68fb      	ldr	r3, [r7, #12]
 8006a02:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006a04:	b29a      	uxth	r2, r3
 8006a06:	68fb      	ldr	r3, [r7, #12]
 8006a08:	851a      	strh	r2, [r3, #40]	@ 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE,
 8006a0a:	68fb      	ldr	r3, [r7, #12]
 8006a0c:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
 8006a0e:	b2da      	uxtb	r2, r3
 8006a10:	8979      	ldrh	r1, [r7, #10]
 8006a12:	2300      	movs	r3, #0
 8006a14:	9300      	str	r3, [sp, #0]
 8006a16:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 8006a1a:	68f8      	ldr	r0, [r7, #12]
 8006a1c:	f000 fac2 	bl	8006fa4 <I2C_TransferConfig>
                             I2C_NO_STARTSTOP);
        }
      }
    } while (hi2c->XferCount > 0U);
 8006a20:	68fb      	ldr	r3, [r7, #12]
 8006a22:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 8006a24:	b29b      	uxth	r3, r3
 8006a26:	2b00      	cmp	r3, #0
 8006a28:	d19a      	bne.n	8006960 <HAL_I2C_Mem_Read+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8006a2a:	697a      	ldr	r2, [r7, #20]
 8006a2c:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8006a2e:	68f8      	ldr	r0, [r7, #12]
 8006a30:	f000 f994 	bl	8006d5c <I2C_WaitOnSTOPFlagUntilTimeout>
 8006a34:	4603      	mov	r3, r0
 8006a36:	2b00      	cmp	r3, #0
 8006a38:	d001      	beq.n	8006a3e <HAL_I2C_Mem_Read+0x1ee>
    {
      return HAL_ERROR;
 8006a3a:	2301      	movs	r3, #1
 8006a3c:	e01a      	b.n	8006a74 <HAL_I2C_Mem_Read+0x224>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8006a3e:	68fb      	ldr	r3, [r7, #12]
 8006a40:	681b      	ldr	r3, [r3, #0]
 8006a42:	2220      	movs	r2, #32
 8006a44:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8006a46:	68fb      	ldr	r3, [r7, #12]
 8006a48:	681b      	ldr	r3, [r3, #0]
 8006a4a:	6859      	ldr	r1, [r3, #4]
 8006a4c:	68fb      	ldr	r3, [r7, #12]
 8006a4e:	681a      	ldr	r2, [r3, #0]
 8006a50:	4b0b      	ldr	r3, [pc, #44]	@ (8006a80 <HAL_I2C_Mem_Read+0x230>)
 8006a52:	400b      	ands	r3, r1
 8006a54:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 8006a56:	68fb      	ldr	r3, [r7, #12]
 8006a58:	2220      	movs	r2, #32
 8006a5a:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8006a5e:	68fb      	ldr	r3, [r7, #12]
 8006a60:	2200      	movs	r2, #0
 8006a62:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8006a66:	68fb      	ldr	r3, [r7, #12]
 8006a68:	2200      	movs	r2, #0
 8006a6a:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
 8006a6e:	2300      	movs	r3, #0
 8006a70:	e000      	b.n	8006a74 <HAL_I2C_Mem_Read+0x224>
  }
  else
  {
    return HAL_BUSY;
 8006a72:	2302      	movs	r3, #2
  }
}
 8006a74:	4618      	mov	r0, r3
 8006a76:	3718      	adds	r7, #24
 8006a78:	46bd      	mov	sp, r7
 8006a7a:	bd80      	pop	{r7, pc}
 8006a7c:	80002400 	.word	0x80002400
 8006a80:	fe00e800 	.word	0xfe00e800

08006a84 <I2C_RequestMemoryWrite>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                                uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                                uint32_t Tickstart)
{
 8006a84:	b580      	push	{r7, lr}
 8006a86:	b086      	sub	sp, #24
 8006a88:	af02      	add	r7, sp, #8
 8006a8a:	60f8      	str	r0, [r7, #12]
 8006a8c:	4608      	mov	r0, r1
 8006a8e:	4611      	mov	r1, r2
 8006a90:	461a      	mov	r2, r3
 8006a92:	4603      	mov	r3, r0
 8006a94:	817b      	strh	r3, [r7, #10]
 8006a96:	460b      	mov	r3, r1
 8006a98:	813b      	strh	r3, [r7, #8]
 8006a9a:	4613      	mov	r3, r2
 8006a9c:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 8006a9e:	88fb      	ldrh	r3, [r7, #6]
 8006aa0:	b2da      	uxtb	r2, r3
 8006aa2:	8979      	ldrh	r1, [r7, #10]
 8006aa4:	4b20      	ldr	r3, [pc, #128]	@ (8006b28 <I2C_RequestMemoryWrite+0xa4>)
 8006aa6:	9300      	str	r3, [sp, #0]
 8006aa8:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
 8006aac:	68f8      	ldr	r0, [r7, #12]
 8006aae:	f000 fa79 	bl	8006fa4 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8006ab2:	69fa      	ldr	r2, [r7, #28]
 8006ab4:	69b9      	ldr	r1, [r7, #24]
 8006ab6:	68f8      	ldr	r0, [r7, #12]
 8006ab8:	f000 f909 	bl	8006cce <I2C_WaitOnTXISFlagUntilTimeout>
 8006abc:	4603      	mov	r3, r0
 8006abe:	2b00      	cmp	r3, #0
 8006ac0:	d001      	beq.n	8006ac6 <I2C_RequestMemoryWrite+0x42>
  {
    return HAL_ERROR;
 8006ac2:	2301      	movs	r3, #1
 8006ac4:	e02c      	b.n	8006b20 <I2C_RequestMemoryWrite+0x9c>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8006ac6:	88fb      	ldrh	r3, [r7, #6]
 8006ac8:	2b01      	cmp	r3, #1
 8006aca:	d105      	bne.n	8006ad8 <I2C_RequestMemoryWrite+0x54>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8006acc:	893b      	ldrh	r3, [r7, #8]
 8006ace:	b2da      	uxtb	r2, r3
 8006ad0:	68fb      	ldr	r3, [r7, #12]
 8006ad2:	681b      	ldr	r3, [r3, #0]
 8006ad4:	629a      	str	r2, [r3, #40]	@ 0x28
 8006ad6:	e015      	b.n	8006b04 <I2C_RequestMemoryWrite+0x80>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8006ad8:	893b      	ldrh	r3, [r7, #8]
 8006ada:	0a1b      	lsrs	r3, r3, #8
 8006adc:	b29b      	uxth	r3, r3
 8006ade:	b2da      	uxtb	r2, r3
 8006ae0:	68fb      	ldr	r3, [r7, #12]
 8006ae2:	681b      	ldr	r3, [r3, #0]
 8006ae4:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8006ae6:	69fa      	ldr	r2, [r7, #28]
 8006ae8:	69b9      	ldr	r1, [r7, #24]
 8006aea:	68f8      	ldr	r0, [r7, #12]
 8006aec:	f000 f8ef 	bl	8006cce <I2C_WaitOnTXISFlagUntilTimeout>
 8006af0:	4603      	mov	r3, r0
 8006af2:	2b00      	cmp	r3, #0
 8006af4:	d001      	beq.n	8006afa <I2C_RequestMemoryWrite+0x76>
    {
      return HAL_ERROR;
 8006af6:	2301      	movs	r3, #1
 8006af8:	e012      	b.n	8006b20 <I2C_RequestMemoryWrite+0x9c>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8006afa:	893b      	ldrh	r3, [r7, #8]
 8006afc:	b2da      	uxtb	r2, r3
 8006afe:	68fb      	ldr	r3, [r7, #12]
 8006b00:	681b      	ldr	r3, [r3, #0]
 8006b02:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
 8006b04:	69fb      	ldr	r3, [r7, #28]
 8006b06:	9300      	str	r3, [sp, #0]
 8006b08:	69bb      	ldr	r3, [r7, #24]
 8006b0a:	2200      	movs	r2, #0
 8006b0c:	2180      	movs	r1, #128	@ 0x80
 8006b0e:	68f8      	ldr	r0, [r7, #12]
 8006b10:	f000 f884 	bl	8006c1c <I2C_WaitOnFlagUntilTimeout>
 8006b14:	4603      	mov	r3, r0
 8006b16:	2b00      	cmp	r3, #0
 8006b18:	d001      	beq.n	8006b1e <I2C_RequestMemoryWrite+0x9a>
  {
    return HAL_ERROR;
 8006b1a:	2301      	movs	r3, #1
 8006b1c:	e000      	b.n	8006b20 <I2C_RequestMemoryWrite+0x9c>
  }

  return HAL_OK;
 8006b1e:	2300      	movs	r3, #0
}
 8006b20:	4618      	mov	r0, r3
 8006b22:	3710      	adds	r7, #16
 8006b24:	46bd      	mov	sp, r7
 8006b26:	bd80      	pop	{r7, pc}
 8006b28:	80002000 	.word	0x80002000

08006b2c <I2C_RequestMemoryRead>:
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress,
                                               uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout,
                                               uint32_t Tickstart)
{
 8006b2c:	b580      	push	{r7, lr}
 8006b2e:	b086      	sub	sp, #24
 8006b30:	af02      	add	r7, sp, #8
 8006b32:	60f8      	str	r0, [r7, #12]
 8006b34:	4608      	mov	r0, r1
 8006b36:	4611      	mov	r1, r2
 8006b38:	461a      	mov	r2, r3
 8006b3a:	4603      	mov	r3, r0
 8006b3c:	817b      	strh	r3, [r7, #10]
 8006b3e:	460b      	mov	r3, r1
 8006b40:	813b      	strh	r3, [r7, #8]
 8006b42:	4613      	mov	r3, r2
 8006b44:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 8006b46:	88fb      	ldrh	r3, [r7, #6]
 8006b48:	b2da      	uxtb	r2, r3
 8006b4a:	8979      	ldrh	r1, [r7, #10]
 8006b4c:	4b20      	ldr	r3, [pc, #128]	@ (8006bd0 <I2C_RequestMemoryRead+0xa4>)
 8006b4e:	9300      	str	r3, [sp, #0]
 8006b50:	2300      	movs	r3, #0
 8006b52:	68f8      	ldr	r0, [r7, #12]
 8006b54:	f000 fa26 	bl	8006fa4 <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8006b58:	69fa      	ldr	r2, [r7, #28]
 8006b5a:	69b9      	ldr	r1, [r7, #24]
 8006b5c:	68f8      	ldr	r0, [r7, #12]
 8006b5e:	f000 f8b6 	bl	8006cce <I2C_WaitOnTXISFlagUntilTimeout>
 8006b62:	4603      	mov	r3, r0
 8006b64:	2b00      	cmp	r3, #0
 8006b66:	d001      	beq.n	8006b6c <I2C_RequestMemoryRead+0x40>
  {
    return HAL_ERROR;
 8006b68:	2301      	movs	r3, #1
 8006b6a:	e02c      	b.n	8006bc6 <I2C_RequestMemoryRead+0x9a>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8006b6c:	88fb      	ldrh	r3, [r7, #6]
 8006b6e:	2b01      	cmp	r3, #1
 8006b70:	d105      	bne.n	8006b7e <I2C_RequestMemoryRead+0x52>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8006b72:	893b      	ldrh	r3, [r7, #8]
 8006b74:	b2da      	uxtb	r2, r3
 8006b76:	68fb      	ldr	r3, [r7, #12]
 8006b78:	681b      	ldr	r3, [r3, #0]
 8006b7a:	629a      	str	r2, [r3, #40]	@ 0x28
 8006b7c:	e015      	b.n	8006baa <I2C_RequestMemoryRead+0x7e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8006b7e:	893b      	ldrh	r3, [r7, #8]
 8006b80:	0a1b      	lsrs	r3, r3, #8
 8006b82:	b29b      	uxth	r3, r3
 8006b84:	b2da      	uxtb	r2, r3
 8006b86:	68fb      	ldr	r3, [r7, #12]
 8006b88:	681b      	ldr	r3, [r3, #0]
 8006b8a:	629a      	str	r2, [r3, #40]	@ 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8006b8c:	69fa      	ldr	r2, [r7, #28]
 8006b8e:	69b9      	ldr	r1, [r7, #24]
 8006b90:	68f8      	ldr	r0, [r7, #12]
 8006b92:	f000 f89c 	bl	8006cce <I2C_WaitOnTXISFlagUntilTimeout>
 8006b96:	4603      	mov	r3, r0
 8006b98:	2b00      	cmp	r3, #0
 8006b9a:	d001      	beq.n	8006ba0 <I2C_RequestMemoryRead+0x74>
    {
      return HAL_ERROR;
 8006b9c:	2301      	movs	r3, #1
 8006b9e:	e012      	b.n	8006bc6 <I2C_RequestMemoryRead+0x9a>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8006ba0:	893b      	ldrh	r3, [r7, #8]
 8006ba2:	b2da      	uxtb	r2, r3
 8006ba4:	68fb      	ldr	r3, [r7, #12]
 8006ba6:	681b      	ldr	r3, [r3, #0]
 8006ba8:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 8006baa:	69fb      	ldr	r3, [r7, #28]
 8006bac:	9300      	str	r3, [sp, #0]
 8006bae:	69bb      	ldr	r3, [r7, #24]
 8006bb0:	2200      	movs	r2, #0
 8006bb2:	2140      	movs	r1, #64	@ 0x40
 8006bb4:	68f8      	ldr	r0, [r7, #12]
 8006bb6:	f000 f831 	bl	8006c1c <I2C_WaitOnFlagUntilTimeout>
 8006bba:	4603      	mov	r3, r0
 8006bbc:	2b00      	cmp	r3, #0
 8006bbe:	d001      	beq.n	8006bc4 <I2C_RequestMemoryRead+0x98>
  {
    return HAL_ERROR;
 8006bc0:	2301      	movs	r3, #1
 8006bc2:	e000      	b.n	8006bc6 <I2C_RequestMemoryRead+0x9a>
  }

  return HAL_OK;
 8006bc4:	2300      	movs	r3, #0
}
 8006bc6:	4618      	mov	r0, r3
 8006bc8:	3710      	adds	r7, #16
 8006bca:	46bd      	mov	sp, r7
 8006bcc:	bd80      	pop	{r7, pc}
 8006bce:	bf00      	nop
 8006bd0:	80002000 	.word	0x80002000

08006bd4 <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
 8006bd4:	b480      	push	{r7}
 8006bd6:	b083      	sub	sp, #12
 8006bd8:	af00      	add	r7, sp, #0
 8006bda:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8006bdc:	687b      	ldr	r3, [r7, #4]
 8006bde:	681b      	ldr	r3, [r3, #0]
 8006be0:	699b      	ldr	r3, [r3, #24]
 8006be2:	f003 0302 	and.w	r3, r3, #2
 8006be6:	2b02      	cmp	r3, #2
 8006be8:	d103      	bne.n	8006bf2 <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
 8006bea:	687b      	ldr	r3, [r7, #4]
 8006bec:	681b      	ldr	r3, [r3, #0]
 8006bee:	2200      	movs	r2, #0
 8006bf0:	629a      	str	r2, [r3, #40]	@ 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8006bf2:	687b      	ldr	r3, [r7, #4]
 8006bf4:	681b      	ldr	r3, [r3, #0]
 8006bf6:	699b      	ldr	r3, [r3, #24]
 8006bf8:	f003 0301 	and.w	r3, r3, #1
 8006bfc:	2b01      	cmp	r3, #1
 8006bfe:	d007      	beq.n	8006c10 <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8006c00:	687b      	ldr	r3, [r7, #4]
 8006c02:	681b      	ldr	r3, [r3, #0]
 8006c04:	699a      	ldr	r2, [r3, #24]
 8006c06:	687b      	ldr	r3, [r7, #4]
 8006c08:	681b      	ldr	r3, [r3, #0]
 8006c0a:	f042 0201 	orr.w	r2, r2, #1
 8006c0e:	619a      	str	r2, [r3, #24]
  }
}
 8006c10:	bf00      	nop
 8006c12:	370c      	adds	r7, #12
 8006c14:	46bd      	mov	sp, r7
 8006c16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006c1a:	4770      	bx	lr

08006c1c <I2C_WaitOnFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
 8006c1c:	b580      	push	{r7, lr}
 8006c1e:	b084      	sub	sp, #16
 8006c20:	af00      	add	r7, sp, #0
 8006c22:	60f8      	str	r0, [r7, #12]
 8006c24:	60b9      	str	r1, [r7, #8]
 8006c26:	603b      	str	r3, [r7, #0]
 8006c28:	4613      	mov	r3, r2
 8006c2a:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8006c2c:	e03b      	b.n	8006ca6 <I2C_WaitOnFlagUntilTimeout+0x8a>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
 8006c2e:	69ba      	ldr	r2, [r7, #24]
 8006c30:	6839      	ldr	r1, [r7, #0]
 8006c32:	68f8      	ldr	r0, [r7, #12]
 8006c34:	f000 f8d6 	bl	8006de4 <I2C_IsErrorOccurred>
 8006c38:	4603      	mov	r3, r0
 8006c3a:	2b00      	cmp	r3, #0
 8006c3c:	d001      	beq.n	8006c42 <I2C_WaitOnFlagUntilTimeout+0x26>
    {
      return HAL_ERROR;
 8006c3e:	2301      	movs	r3, #1
 8006c40:	e041      	b.n	8006cc6 <I2C_WaitOnFlagUntilTimeout+0xaa>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8006c42:	683b      	ldr	r3, [r7, #0]
 8006c44:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006c48:	d02d      	beq.n	8006ca6 <I2C_WaitOnFlagUntilTimeout+0x8a>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006c4a:	f7fb f993 	bl	8001f74 <HAL_GetTick>
 8006c4e:	4602      	mov	r2, r0
 8006c50:	69bb      	ldr	r3, [r7, #24]
 8006c52:	1ad3      	subs	r3, r2, r3
 8006c54:	683a      	ldr	r2, [r7, #0]
 8006c56:	429a      	cmp	r2, r3
 8006c58:	d302      	bcc.n	8006c60 <I2C_WaitOnFlagUntilTimeout+0x44>
 8006c5a:	683b      	ldr	r3, [r7, #0]
 8006c5c:	2b00      	cmp	r3, #0
 8006c5e:	d122      	bne.n	8006ca6 <I2C_WaitOnFlagUntilTimeout+0x8a>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, Flag) == Status))
 8006c60:	68fb      	ldr	r3, [r7, #12]
 8006c62:	681b      	ldr	r3, [r3, #0]
 8006c64:	699a      	ldr	r2, [r3, #24]
 8006c66:	68bb      	ldr	r3, [r7, #8]
 8006c68:	4013      	ands	r3, r2
 8006c6a:	68ba      	ldr	r2, [r7, #8]
 8006c6c:	429a      	cmp	r2, r3
 8006c6e:	bf0c      	ite	eq
 8006c70:	2301      	moveq	r3, #1
 8006c72:	2300      	movne	r3, #0
 8006c74:	b2db      	uxtb	r3, r3
 8006c76:	461a      	mov	r2, r3
 8006c78:	79fb      	ldrb	r3, [r7, #7]
 8006c7a:	429a      	cmp	r2, r3
 8006c7c:	d113      	bne.n	8006ca6 <I2C_WaitOnFlagUntilTimeout+0x8a>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8006c7e:	68fb      	ldr	r3, [r7, #12]
 8006c80:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8006c82:	f043 0220 	orr.w	r2, r3, #32
 8006c86:	68fb      	ldr	r3, [r7, #12]
 8006c88:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 8006c8a:	68fb      	ldr	r3, [r7, #12]
 8006c8c:	2220      	movs	r2, #32
 8006c8e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8006c92:	68fb      	ldr	r3, [r7, #12]
 8006c94:	2200      	movs	r2, #0
 8006c96:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 8006c9a:	68fb      	ldr	r3, [r7, #12]
 8006c9c:	2200      	movs	r2, #0
 8006c9e:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
          return HAL_ERROR;
 8006ca2:	2301      	movs	r3, #1
 8006ca4:	e00f      	b.n	8006cc6 <I2C_WaitOnFlagUntilTimeout+0xaa>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8006ca6:	68fb      	ldr	r3, [r7, #12]
 8006ca8:	681b      	ldr	r3, [r3, #0]
 8006caa:	699a      	ldr	r2, [r3, #24]
 8006cac:	68bb      	ldr	r3, [r7, #8]
 8006cae:	4013      	ands	r3, r2
 8006cb0:	68ba      	ldr	r2, [r7, #8]
 8006cb2:	429a      	cmp	r2, r3
 8006cb4:	bf0c      	ite	eq
 8006cb6:	2301      	moveq	r3, #1
 8006cb8:	2300      	movne	r3, #0
 8006cba:	b2db      	uxtb	r3, r3
 8006cbc:	461a      	mov	r2, r3
 8006cbe:	79fb      	ldrb	r3, [r7, #7]
 8006cc0:	429a      	cmp	r2, r3
 8006cc2:	d0b4      	beq.n	8006c2e <I2C_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 8006cc4:	2300      	movs	r3, #0
}
 8006cc6:	4618      	mov	r0, r3
 8006cc8:	3710      	adds	r7, #16
 8006cca:	46bd      	mov	sp, r7
 8006ccc:	bd80      	pop	{r7, pc}

08006cce <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
 8006cce:	b580      	push	{r7, lr}
 8006cd0:	b084      	sub	sp, #16
 8006cd2:	af00      	add	r7, sp, #0
 8006cd4:	60f8      	str	r0, [r7, #12]
 8006cd6:	60b9      	str	r1, [r7, #8]
 8006cd8:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8006cda:	e033      	b.n	8006d44 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
 8006cdc:	687a      	ldr	r2, [r7, #4]
 8006cde:	68b9      	ldr	r1, [r7, #8]
 8006ce0:	68f8      	ldr	r0, [r7, #12]
 8006ce2:	f000 f87f 	bl	8006de4 <I2C_IsErrorOccurred>
 8006ce6:	4603      	mov	r3, r0
 8006ce8:	2b00      	cmp	r3, #0
 8006cea:	d001      	beq.n	8006cf0 <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 8006cec:	2301      	movs	r3, #1
 8006cee:	e031      	b.n	8006d54 <I2C_WaitOnTXISFlagUntilTimeout+0x86>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8006cf0:	68bb      	ldr	r3, [r7, #8]
 8006cf2:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006cf6:	d025      	beq.n	8006d44 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006cf8:	f7fb f93c 	bl	8001f74 <HAL_GetTick>
 8006cfc:	4602      	mov	r2, r0
 8006cfe:	687b      	ldr	r3, [r7, #4]
 8006d00:	1ad3      	subs	r3, r2, r3
 8006d02:	68ba      	ldr	r2, [r7, #8]
 8006d04:	429a      	cmp	r2, r3
 8006d06:	d302      	bcc.n	8006d0e <I2C_WaitOnTXISFlagUntilTimeout+0x40>
 8006d08:	68bb      	ldr	r3, [r7, #8]
 8006d0a:	2b00      	cmp	r3, #0
 8006d0c:	d11a      	bne.n	8006d44 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
      {
        if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET))
 8006d0e:	68fb      	ldr	r3, [r7, #12]
 8006d10:	681b      	ldr	r3, [r3, #0]
 8006d12:	699b      	ldr	r3, [r3, #24]
 8006d14:	f003 0302 	and.w	r3, r3, #2
 8006d18:	2b02      	cmp	r3, #2
 8006d1a:	d013      	beq.n	8006d44 <I2C_WaitOnTXISFlagUntilTimeout+0x76>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8006d1c:	68fb      	ldr	r3, [r7, #12]
 8006d1e:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8006d20:	f043 0220 	orr.w	r2, r3, #32
 8006d24:	68fb      	ldr	r3, [r7, #12]
 8006d26:	645a      	str	r2, [r3, #68]	@ 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 8006d28:	68fb      	ldr	r3, [r7, #12]
 8006d2a:	2220      	movs	r2, #32
 8006d2c:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8006d30:	68fb      	ldr	r3, [r7, #12]
 8006d32:	2200      	movs	r2, #0
 8006d34:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 8006d38:	68fb      	ldr	r3, [r7, #12]
 8006d3a:	2200      	movs	r2, #0
 8006d3c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

          return HAL_ERROR;
 8006d40:	2301      	movs	r3, #1
 8006d42:	e007      	b.n	8006d54 <I2C_WaitOnTXISFlagUntilTimeout+0x86>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8006d44:	68fb      	ldr	r3, [r7, #12]
 8006d46:	681b      	ldr	r3, [r3, #0]
 8006d48:	699b      	ldr	r3, [r3, #24]
 8006d4a:	f003 0302 	and.w	r3, r3, #2
 8006d4e:	2b02      	cmp	r3, #2
 8006d50:	d1c4      	bne.n	8006cdc <I2C_WaitOnTXISFlagUntilTimeout+0xe>
        }
      }
    }
  }
  return HAL_OK;
 8006d52:	2300      	movs	r3, #0
}
 8006d54:	4618      	mov	r0, r3
 8006d56:	3710      	adds	r7, #16
 8006d58:	46bd      	mov	sp, r7
 8006d5a:	bd80      	pop	{r7, pc}

08006d5c <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout,
                                                        uint32_t Tickstart)
{
 8006d5c:	b580      	push	{r7, lr}
 8006d5e:	b084      	sub	sp, #16
 8006d60:	af00      	add	r7, sp, #0
 8006d62:	60f8      	str	r0, [r7, #12]
 8006d64:	60b9      	str	r1, [r7, #8]
 8006d66:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8006d68:	e02f      	b.n	8006dca <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
  {
    /* Check if an error is detected */
    if (I2C_IsErrorOccurred(hi2c, Timeout, Tickstart) != HAL_OK)
 8006d6a:	687a      	ldr	r2, [r7, #4]
 8006d6c:	68b9      	ldr	r1, [r7, #8]
 8006d6e:	68f8      	ldr	r0, [r7, #12]
 8006d70:	f000 f838 	bl	8006de4 <I2C_IsErrorOccurred>
 8006d74:	4603      	mov	r3, r0
 8006d76:	2b00      	cmp	r3, #0
 8006d78:	d001      	beq.n	8006d7e <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 8006d7a:	2301      	movs	r3, #1
 8006d7c:	e02d      	b.n	8006dda <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8006d7e:	f7fb f8f9 	bl	8001f74 <HAL_GetTick>
 8006d82:	4602      	mov	r2, r0
 8006d84:	687b      	ldr	r3, [r7, #4]
 8006d86:	1ad3      	subs	r3, r2, r3
 8006d88:	68ba      	ldr	r2, [r7, #8]
 8006d8a:	429a      	cmp	r2, r3
 8006d8c:	d302      	bcc.n	8006d94 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
 8006d8e:	68bb      	ldr	r3, [r7, #8]
 8006d90:	2b00      	cmp	r3, #0
 8006d92:	d11a      	bne.n	8006dca <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
    {
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET))
 8006d94:	68fb      	ldr	r3, [r7, #12]
 8006d96:	681b      	ldr	r3, [r3, #0]
 8006d98:	699b      	ldr	r3, [r3, #24]
 8006d9a:	f003 0320 	and.w	r3, r3, #32
 8006d9e:	2b20      	cmp	r3, #32
 8006da0:	d013      	beq.n	8006dca <I2C_WaitOnSTOPFlagUntilTimeout+0x6e>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8006da2:	68fb      	ldr	r3, [r7, #12]
 8006da4:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8006da6:	f043 0220 	orr.w	r2, r3, #32
 8006daa:	68fb      	ldr	r3, [r7, #12]
 8006dac:	645a      	str	r2, [r3, #68]	@ 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8006dae:	68fb      	ldr	r3, [r7, #12]
 8006db0:	2220      	movs	r2, #32
 8006db2:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8006db6:	68fb      	ldr	r3, [r7, #12]
 8006db8:	2200      	movs	r2, #0
 8006dba:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 8006dbe:	68fb      	ldr	r3, [r7, #12]
 8006dc0:	2200      	movs	r2, #0
 8006dc2:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

        return HAL_ERROR;
 8006dc6:	2301      	movs	r3, #1
 8006dc8:	e007      	b.n	8006dda <I2C_WaitOnSTOPFlagUntilTimeout+0x7e>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8006dca:	68fb      	ldr	r3, [r7, #12]
 8006dcc:	681b      	ldr	r3, [r3, #0]
 8006dce:	699b      	ldr	r3, [r3, #24]
 8006dd0:	f003 0320 	and.w	r3, r3, #32
 8006dd4:	2b20      	cmp	r3, #32
 8006dd6:	d1c8      	bne.n	8006d6a <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
 8006dd8:	2300      	movs	r3, #0
}
 8006dda:	4618      	mov	r0, r3
 8006ddc:	3710      	adds	r7, #16
 8006dde:	46bd      	mov	sp, r7
 8006de0:	bd80      	pop	{r7, pc}
	...

08006de4 <I2C_IsErrorOccurred>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsErrorOccurred(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 8006de4:	b580      	push	{r7, lr}
 8006de6:	b08a      	sub	sp, #40	@ 0x28
 8006de8:	af00      	add	r7, sp, #0
 8006dea:	60f8      	str	r0, [r7, #12]
 8006dec:	60b9      	str	r1, [r7, #8]
 8006dee:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8006df0:	2300      	movs	r3, #0
 8006df2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  uint32_t itflag   = hi2c->Instance->ISR;
 8006df6:	68fb      	ldr	r3, [r7, #12]
 8006df8:	681b      	ldr	r3, [r3, #0]
 8006dfa:	699b      	ldr	r3, [r3, #24]
 8006dfc:	61bb      	str	r3, [r7, #24]
  uint32_t error_code = 0;
 8006dfe:	2300      	movs	r3, #0
 8006e00:	623b      	str	r3, [r7, #32]
  uint32_t tickstart = Tickstart;
 8006e02:	687b      	ldr	r3, [r7, #4]
 8006e04:	61fb      	str	r3, [r7, #28]
  uint32_t tmp1;
  HAL_I2C_ModeTypeDef tmp2;

  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_AF))
 8006e06:	69bb      	ldr	r3, [r7, #24]
 8006e08:	f003 0310 	and.w	r3, r3, #16
 8006e0c:	2b00      	cmp	r3, #0
 8006e0e:	d068      	beq.n	8006ee2 <I2C_IsErrorOccurred+0xfe>
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8006e10:	68fb      	ldr	r3, [r7, #12]
 8006e12:	681b      	ldr	r3, [r3, #0]
 8006e14:	2210      	movs	r2, #16
 8006e16:	61da      	str	r2, [r3, #28]

    /* Wait until STOP Flag is set or timeout occurred */
    /* AutoEnd should be initiate after AF */
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 8006e18:	e049      	b.n	8006eae <I2C_IsErrorOccurred+0xca>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 8006e1a:	68bb      	ldr	r3, [r7, #8]
 8006e1c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8006e20:	d045      	beq.n	8006eae <I2C_IsErrorOccurred+0xca>
      {
        if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8006e22:	f7fb f8a7 	bl	8001f74 <HAL_GetTick>
 8006e26:	4602      	mov	r2, r0
 8006e28:	69fb      	ldr	r3, [r7, #28]
 8006e2a:	1ad3      	subs	r3, r2, r3
 8006e2c:	68ba      	ldr	r2, [r7, #8]
 8006e2e:	429a      	cmp	r2, r3
 8006e30:	d302      	bcc.n	8006e38 <I2C_IsErrorOccurred+0x54>
 8006e32:	68bb      	ldr	r3, [r7, #8]
 8006e34:	2b00      	cmp	r3, #0
 8006e36:	d13a      	bne.n	8006eae <I2C_IsErrorOccurred+0xca>
        {
          tmp1 = (uint32_t)(hi2c->Instance->CR2 & I2C_CR2_STOP);
 8006e38:	68fb      	ldr	r3, [r7, #12]
 8006e3a:	681b      	ldr	r3, [r3, #0]
 8006e3c:	685b      	ldr	r3, [r3, #4]
 8006e3e:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 8006e42:	617b      	str	r3, [r7, #20]
          tmp2 = hi2c->Mode;
 8006e44:	68fb      	ldr	r3, [r7, #12]
 8006e46:	f893 3042 	ldrb.w	r3, [r3, #66]	@ 0x42
 8006e4a:	74fb      	strb	r3, [r7, #19]

          /* In case of I2C still busy, try to regenerate a STOP manually */
          if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) != RESET) && \
 8006e4c:	68fb      	ldr	r3, [r7, #12]
 8006e4e:	681b      	ldr	r3, [r3, #0]
 8006e50:	699b      	ldr	r3, [r3, #24]
 8006e52:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8006e56:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8006e5a:	d121      	bne.n	8006ea0 <I2C_IsErrorOccurred+0xbc>
 8006e5c:	697b      	ldr	r3, [r7, #20]
 8006e5e:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8006e62:	d01d      	beq.n	8006ea0 <I2C_IsErrorOccurred+0xbc>
              (tmp1 != I2C_CR2_STOP) && \
 8006e64:	7cfb      	ldrb	r3, [r7, #19]
 8006e66:	2b20      	cmp	r3, #32
 8006e68:	d01a      	beq.n	8006ea0 <I2C_IsErrorOccurred+0xbc>
              (tmp2 != HAL_I2C_MODE_SLAVE))
          {
            /* Generate Stop */
            hi2c->Instance->CR2 |= I2C_CR2_STOP;
 8006e6a:	68fb      	ldr	r3, [r7, #12]
 8006e6c:	681b      	ldr	r3, [r3, #0]
 8006e6e:	685a      	ldr	r2, [r3, #4]
 8006e70:	68fb      	ldr	r3, [r7, #12]
 8006e72:	681b      	ldr	r3, [r3, #0]
 8006e74:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 8006e78:	605a      	str	r2, [r3, #4]

            /* Update Tick with new reference */
            tickstart = HAL_GetTick();
 8006e7a:	f7fb f87b 	bl	8001f74 <HAL_GetTick>
 8006e7e:	61f8      	str	r0, [r7, #28]
          }

          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8006e80:	e00e      	b.n	8006ea0 <I2C_IsErrorOccurred+0xbc>
          {
            /* Check for the Timeout */
            if ((HAL_GetTick() - tickstart) > I2C_TIMEOUT_STOPF)
 8006e82:	f7fb f877 	bl	8001f74 <HAL_GetTick>
 8006e86:	4602      	mov	r2, r0
 8006e88:	69fb      	ldr	r3, [r7, #28]
 8006e8a:	1ad3      	subs	r3, r2, r3
 8006e8c:	2b19      	cmp	r3, #25
 8006e8e:	d907      	bls.n	8006ea0 <I2C_IsErrorOccurred+0xbc>
            {
              error_code |= HAL_I2C_ERROR_TIMEOUT;
 8006e90:	6a3b      	ldr	r3, [r7, #32]
 8006e92:	f043 0320 	orr.w	r3, r3, #32
 8006e96:	623b      	str	r3, [r7, #32]

              status = HAL_ERROR;
 8006e98:	2301      	movs	r3, #1
 8006e9a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

              break;
 8006e9e:	e006      	b.n	8006eae <I2C_IsErrorOccurred+0xca>
          while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8006ea0:	68fb      	ldr	r3, [r7, #12]
 8006ea2:	681b      	ldr	r3, [r3, #0]
 8006ea4:	699b      	ldr	r3, [r3, #24]
 8006ea6:	f003 0320 	and.w	r3, r3, #32
 8006eaa:	2b20      	cmp	r3, #32
 8006eac:	d1e9      	bne.n	8006e82 <I2C_IsErrorOccurred+0x9e>
    while ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET) && (status == HAL_OK))
 8006eae:	68fb      	ldr	r3, [r7, #12]
 8006eb0:	681b      	ldr	r3, [r3, #0]
 8006eb2:	699b      	ldr	r3, [r3, #24]
 8006eb4:	f003 0320 	and.w	r3, r3, #32
 8006eb8:	2b20      	cmp	r3, #32
 8006eba:	d003      	beq.n	8006ec4 <I2C_IsErrorOccurred+0xe0>
 8006ebc:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8006ec0:	2b00      	cmp	r3, #0
 8006ec2:	d0aa      	beq.n	8006e1a <I2C_IsErrorOccurred+0x36>
        }
      }
    }

    /* In case STOP Flag is detected, clear it */
    if (status == HAL_OK)
 8006ec4:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8006ec8:	2b00      	cmp	r3, #0
 8006eca:	d103      	bne.n	8006ed4 <I2C_IsErrorOccurred+0xf0>
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8006ecc:	68fb      	ldr	r3, [r7, #12]
 8006ece:	681b      	ldr	r3, [r3, #0]
 8006ed0:	2220      	movs	r2, #32
 8006ed2:	61da      	str	r2, [r3, #28]
    }

    error_code |= HAL_I2C_ERROR_AF;
 8006ed4:	6a3b      	ldr	r3, [r7, #32]
 8006ed6:	f043 0304 	orr.w	r3, r3, #4
 8006eda:	623b      	str	r3, [r7, #32]

    status = HAL_ERROR;
 8006edc:	2301      	movs	r3, #1
 8006ede:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Refresh Content of Status register */
  itflag = hi2c->Instance->ISR;
 8006ee2:	68fb      	ldr	r3, [r7, #12]
 8006ee4:	681b      	ldr	r3, [r3, #0]
 8006ee6:	699b      	ldr	r3, [r3, #24]
 8006ee8:	61bb      	str	r3, [r7, #24]

  /* Then verify if an additional errors occurs */
  /* Check if a Bus error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_BERR))
 8006eea:	69bb      	ldr	r3, [r7, #24]
 8006eec:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8006ef0:	2b00      	cmp	r3, #0
 8006ef2:	d00b      	beq.n	8006f0c <I2C_IsErrorOccurred+0x128>
  {
    error_code |= HAL_I2C_ERROR_BERR;
 8006ef4:	6a3b      	ldr	r3, [r7, #32]
 8006ef6:	f043 0301 	orr.w	r3, r3, #1
 8006efa:	623b      	str	r3, [r7, #32]

    /* Clear BERR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8006efc:	68fb      	ldr	r3, [r7, #12]
 8006efe:	681b      	ldr	r3, [r3, #0]
 8006f00:	f44f 7280 	mov.w	r2, #256	@ 0x100
 8006f04:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
 8006f06:	2301      	movs	r3, #1
 8006f08:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Check if an Over-Run/Under-Run error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_OVR))
 8006f0c:	69bb      	ldr	r3, [r7, #24]
 8006f0e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8006f12:	2b00      	cmp	r3, #0
 8006f14:	d00b      	beq.n	8006f2e <I2C_IsErrorOccurred+0x14a>
  {
    error_code |= HAL_I2C_ERROR_OVR;
 8006f16:	6a3b      	ldr	r3, [r7, #32]
 8006f18:	f043 0308 	orr.w	r3, r3, #8
 8006f1c:	623b      	str	r3, [r7, #32]

    /* Clear OVR flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8006f1e:	68fb      	ldr	r3, [r7, #12]
 8006f20:	681b      	ldr	r3, [r3, #0]
 8006f22:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8006f26:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
 8006f28:	2301      	movs	r3, #1
 8006f2a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  /* Check if an Arbitration Loss error occurred */
  if (HAL_IS_BIT_SET(itflag, I2C_FLAG_ARLO))
 8006f2e:	69bb      	ldr	r3, [r7, #24]
 8006f30:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8006f34:	2b00      	cmp	r3, #0
 8006f36:	d00b      	beq.n	8006f50 <I2C_IsErrorOccurred+0x16c>
  {
    error_code |= HAL_I2C_ERROR_ARLO;
 8006f38:	6a3b      	ldr	r3, [r7, #32]
 8006f3a:	f043 0302 	orr.w	r3, r3, #2
 8006f3e:	623b      	str	r3, [r7, #32]

    /* Clear ARLO flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8006f40:	68fb      	ldr	r3, [r7, #12]
 8006f42:	681b      	ldr	r3, [r3, #0]
 8006f44:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8006f48:	61da      	str	r2, [r3, #28]

    status = HAL_ERROR;
 8006f4a:	2301      	movs	r3, #1
 8006f4c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  }

  if (status != HAL_OK)
 8006f50:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8006f54:	2b00      	cmp	r3, #0
 8006f56:	d01c      	beq.n	8006f92 <I2C_IsErrorOccurred+0x1ae>
  {
    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
 8006f58:	68f8      	ldr	r0, [r7, #12]
 8006f5a:	f7ff fe3b 	bl	8006bd4 <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8006f5e:	68fb      	ldr	r3, [r7, #12]
 8006f60:	681b      	ldr	r3, [r3, #0]
 8006f62:	6859      	ldr	r1, [r3, #4]
 8006f64:	68fb      	ldr	r3, [r7, #12]
 8006f66:	681a      	ldr	r2, [r3, #0]
 8006f68:	4b0d      	ldr	r3, [pc, #52]	@ (8006fa0 <I2C_IsErrorOccurred+0x1bc>)
 8006f6a:	400b      	ands	r3, r1
 8006f6c:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= error_code;
 8006f6e:	68fb      	ldr	r3, [r7, #12]
 8006f70:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 8006f72:	6a3b      	ldr	r3, [r7, #32]
 8006f74:	431a      	orrs	r2, r3
 8006f76:	68fb      	ldr	r3, [r7, #12]
 8006f78:	645a      	str	r2, [r3, #68]	@ 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 8006f7a:	68fb      	ldr	r3, [r7, #12]
 8006f7c:	2220      	movs	r2, #32
 8006f7e:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8006f82:	68fb      	ldr	r3, [r7, #12]
 8006f84:	2200      	movs	r2, #0
 8006f86:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8006f8a:	68fb      	ldr	r3, [r7, #12]
 8006f8c:	2200      	movs	r2, #0
 8006f8e:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
  }

  return status;
 8006f92:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
 8006f96:	4618      	mov	r0, r3
 8006f98:	3728      	adds	r7, #40	@ 0x28
 8006f9a:	46bd      	mov	sp, r7
 8006f9c:	bd80      	pop	{r7, pc}
 8006f9e:	bf00      	nop
 8006fa0:	fe00e800 	.word	0xfe00e800

08006fa4 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode,
                               uint32_t Request)
{
 8006fa4:	b480      	push	{r7}
 8006fa6:	b087      	sub	sp, #28
 8006fa8:	af00      	add	r7, sp, #0
 8006faa:	60f8      	str	r0, [r7, #12]
 8006fac:	607b      	str	r3, [r7, #4]
 8006fae:	460b      	mov	r3, r1
 8006fb0:	817b      	strh	r3, [r7, #10]
 8006fb2:	4613      	mov	r3, r2
 8006fb4:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* Declaration of tmp to prevent undefined behavior of volatile usage */
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 8006fb6:	897b      	ldrh	r3, [r7, #10]
 8006fb8:	f3c3 0209 	ubfx	r2, r3, #0, #10
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 8006fbc:	7a7b      	ldrb	r3, [r7, #9]
 8006fbe:	041b      	lsls	r3, r3, #16
 8006fc0:	f403 037f 	and.w	r3, r3, #16711680	@ 0xff0000
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 8006fc4:	431a      	orrs	r2, r3
                    (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | \
 8006fc6:	687b      	ldr	r3, [r7, #4]
 8006fc8:	431a      	orrs	r2, r3
  tmp = ((uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | \
 8006fca:	6a3b      	ldr	r3, [r7, #32]
 8006fcc:	4313      	orrs	r3, r2
 8006fce:	f023 4300 	bic.w	r3, r3, #2147483648	@ 0x80000000
 8006fd2:	617b      	str	r3, [r7, #20]
                    (uint32_t)Mode | (uint32_t)Request) & (~0x80000000U));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, \
 8006fd4:	68fb      	ldr	r3, [r7, #12]
 8006fd6:	681b      	ldr	r3, [r3, #0]
 8006fd8:	685a      	ldr	r2, [r3, #4]
 8006fda:	6a3b      	ldr	r3, [r7, #32]
 8006fdc:	0d5b      	lsrs	r3, r3, #21
 8006fde:	f403 6180 	and.w	r1, r3, #1024	@ 0x400
 8006fe2:	4b08      	ldr	r3, [pc, #32]	@ (8007004 <I2C_TransferConfig+0x60>)
 8006fe4:	430b      	orrs	r3, r1
 8006fe6:	43db      	mvns	r3, r3
 8006fe8:	ea02 0103 	and.w	r1, r2, r3
 8006fec:	68fb      	ldr	r3, [r7, #12]
 8006fee:	681b      	ldr	r3, [r3, #0]
 8006ff0:	697a      	ldr	r2, [r7, #20]
 8006ff2:	430a      	orrs	r2, r1
 8006ff4:	605a      	str	r2, [r3, #4]
             ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | \
               (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | \
               I2C_CR2_START | I2C_CR2_STOP)), tmp);
}
 8006ff6:	bf00      	nop
 8006ff8:	371c      	adds	r7, #28
 8006ffa:	46bd      	mov	sp, r7
 8006ffc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007000:	4770      	bx	lr
 8007002:	bf00      	nop
 8007004:	03ff63ff 	.word	0x03ff63ff

08007008 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 8007008:	b480      	push	{r7}
 800700a:	b083      	sub	sp, #12
 800700c:	af00      	add	r7, sp, #0
 800700e:	6078      	str	r0, [r7, #4]
 8007010:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8007012:	687b      	ldr	r3, [r7, #4]
 8007014:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 8007018:	b2db      	uxtb	r3, r3
 800701a:	2b20      	cmp	r3, #32
 800701c:	d138      	bne.n	8007090 <HAL_I2CEx_ConfigAnalogFilter+0x88>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 800701e:	687b      	ldr	r3, [r7, #4]
 8007020:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 8007024:	2b01      	cmp	r3, #1
 8007026:	d101      	bne.n	800702c <HAL_I2CEx_ConfigAnalogFilter+0x24>
 8007028:	2302      	movs	r3, #2
 800702a:	e032      	b.n	8007092 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
 800702c:	687b      	ldr	r3, [r7, #4]
 800702e:	2201      	movs	r2, #1
 8007030:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
 8007034:	687b      	ldr	r3, [r7, #4]
 8007036:	2224      	movs	r2, #36	@ 0x24
 8007038:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 800703c:	687b      	ldr	r3, [r7, #4]
 800703e:	681b      	ldr	r3, [r3, #0]
 8007040:	681a      	ldr	r2, [r3, #0]
 8007042:	687b      	ldr	r3, [r7, #4]
 8007044:	681b      	ldr	r3, [r3, #0]
 8007046:	f022 0201 	bic.w	r2, r2, #1
 800704a:	601a      	str	r2, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 800704c:	687b      	ldr	r3, [r7, #4]
 800704e:	681b      	ldr	r3, [r3, #0]
 8007050:	681a      	ldr	r2, [r3, #0]
 8007052:	687b      	ldr	r3, [r7, #4]
 8007054:	681b      	ldr	r3, [r3, #0]
 8007056:	f422 5280 	bic.w	r2, r2, #4096	@ 0x1000
 800705a:	601a      	str	r2, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 800705c:	687b      	ldr	r3, [r7, #4]
 800705e:	681b      	ldr	r3, [r3, #0]
 8007060:	6819      	ldr	r1, [r3, #0]
 8007062:	687b      	ldr	r3, [r7, #4]
 8007064:	681b      	ldr	r3, [r3, #0]
 8007066:	683a      	ldr	r2, [r7, #0]
 8007068:	430a      	orrs	r2, r1
 800706a:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 800706c:	687b      	ldr	r3, [r7, #4]
 800706e:	681b      	ldr	r3, [r3, #0]
 8007070:	681a      	ldr	r2, [r3, #0]
 8007072:	687b      	ldr	r3, [r7, #4]
 8007074:	681b      	ldr	r3, [r3, #0]
 8007076:	f042 0201 	orr.w	r2, r2, #1
 800707a:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 800707c:	687b      	ldr	r3, [r7, #4]
 800707e:	2220      	movs	r2, #32
 8007080:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8007084:	687b      	ldr	r3, [r7, #4]
 8007086:	2200      	movs	r2, #0
 8007088:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
 800708c:	2300      	movs	r3, #0
 800708e:	e000      	b.n	8007092 <HAL_I2CEx_ConfigAnalogFilter+0x8a>
  }
  else
  {
    return HAL_BUSY;
 8007090:	2302      	movs	r3, #2
  }
}
 8007092:	4618      	mov	r0, r3
 8007094:	370c      	adds	r7, #12
 8007096:	46bd      	mov	sp, r7
 8007098:	f85d 7b04 	ldr.w	r7, [sp], #4
 800709c:	4770      	bx	lr

0800709e <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 800709e:	b480      	push	{r7}
 80070a0:	b085      	sub	sp, #20
 80070a2:	af00      	add	r7, sp, #0
 80070a4:	6078      	str	r0, [r7, #4]
 80070a6:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 80070a8:	687b      	ldr	r3, [r7, #4]
 80070aa:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
 80070ae:	b2db      	uxtb	r3, r3
 80070b0:	2b20      	cmp	r3, #32
 80070b2:	d139      	bne.n	8007128 <HAL_I2CEx_ConfigDigitalFilter+0x8a>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 80070b4:	687b      	ldr	r3, [r7, #4]
 80070b6:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
 80070ba:	2b01      	cmp	r3, #1
 80070bc:	d101      	bne.n	80070c2 <HAL_I2CEx_ConfigDigitalFilter+0x24>
 80070be:	2302      	movs	r3, #2
 80070c0:	e033      	b.n	800712a <HAL_I2CEx_ConfigDigitalFilter+0x8c>
 80070c2:	687b      	ldr	r3, [r7, #4]
 80070c4:	2201      	movs	r2, #1
 80070c6:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    hi2c->State = HAL_I2C_STATE_BUSY;
 80070ca:	687b      	ldr	r3, [r7, #4]
 80070cc:	2224      	movs	r2, #36	@ 0x24
 80070ce:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 80070d2:	687b      	ldr	r3, [r7, #4]
 80070d4:	681b      	ldr	r3, [r3, #0]
 80070d6:	681a      	ldr	r2, [r3, #0]
 80070d8:	687b      	ldr	r3, [r7, #4]
 80070da:	681b      	ldr	r3, [r3, #0]
 80070dc:	f022 0201 	bic.w	r2, r2, #1
 80070e0:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 80070e2:	687b      	ldr	r3, [r7, #4]
 80070e4:	681b      	ldr	r3, [r3, #0]
 80070e6:	681b      	ldr	r3, [r3, #0]
 80070e8:	60fb      	str	r3, [r7, #12]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 80070ea:	68fb      	ldr	r3, [r7, #12]
 80070ec:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 80070f0:	60fb      	str	r3, [r7, #12]

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 80070f2:	683b      	ldr	r3, [r7, #0]
 80070f4:	021b      	lsls	r3, r3, #8
 80070f6:	68fa      	ldr	r2, [r7, #12]
 80070f8:	4313      	orrs	r3, r2
 80070fa:	60fb      	str	r3, [r7, #12]

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 80070fc:	687b      	ldr	r3, [r7, #4]
 80070fe:	681b      	ldr	r3, [r3, #0]
 8007100:	68fa      	ldr	r2, [r7, #12]
 8007102:	601a      	str	r2, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 8007104:	687b      	ldr	r3, [r7, #4]
 8007106:	681b      	ldr	r3, [r3, #0]
 8007108:	681a      	ldr	r2, [r3, #0]
 800710a:	687b      	ldr	r3, [r7, #4]
 800710c:	681b      	ldr	r3, [r3, #0]
 800710e:	f042 0201 	orr.w	r2, r2, #1
 8007112:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 8007114:	687b      	ldr	r3, [r7, #4]
 8007116:	2220      	movs	r2, #32
 8007118:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800711c:	687b      	ldr	r3, [r7, #4]
 800711e:	2200      	movs	r2, #0
 8007120:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

    return HAL_OK;
 8007124:	2300      	movs	r3, #0
 8007126:	e000      	b.n	800712a <HAL_I2CEx_ConfigDigitalFilter+0x8c>
  }
  else
  {
    return HAL_BUSY;
 8007128:	2302      	movs	r3, #2
  }
}
 800712a:	4618      	mov	r0, r3
 800712c:	3714      	adds	r7, #20
 800712e:	46bd      	mov	sp, r7
 8007130:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007134:	4770      	bx	lr
	...

08007138 <HAL_PWREx_ConfigSupply>:
  *         process during startup.
  *         For more details, please refer to the power control chapter in the reference manual
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
 8007138:	b580      	push	{r7, lr}
 800713a:	b084      	sub	sp, #16
 800713c:	af00      	add	r7, sp, #0
 800713e:	6078      	str	r0, [r7, #4]

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
 8007140:	4b29      	ldr	r3, [pc, #164]	@ (80071e8 <HAL_PWREx_ConfigSupply+0xb0>)
 8007142:	68db      	ldr	r3, [r3, #12]
 8007144:	f003 0307 	and.w	r3, r3, #7
 8007148:	2b06      	cmp	r3, #6
 800714a:	d00a      	beq.n	8007162 <HAL_PWREx_ConfigSupply+0x2a>
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
 800714c:	4b26      	ldr	r3, [pc, #152]	@ (80071e8 <HAL_PWREx_ConfigSupply+0xb0>)
 800714e:	68db      	ldr	r3, [r3, #12]
 8007150:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8007154:	687a      	ldr	r2, [r7, #4]
 8007156:	429a      	cmp	r2, r3
 8007158:	d001      	beq.n	800715e <HAL_PWREx_ConfigSupply+0x26>
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
 800715a:	2301      	movs	r3, #1
 800715c:	e040      	b.n	80071e0 <HAL_PWREx_ConfigSupply+0xa8>
    else
    {
      /* Supply configuration update locked, but new supply configuration
         matches with old supply configuration : nothing to do
      */
      return HAL_OK;
 800715e:	2300      	movs	r3, #0
 8007160:	e03e      	b.n	80071e0 <HAL_PWREx_ConfigSupply+0xa8>
    }
  }

  /* Set the power supply configuration */
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
 8007162:	4b21      	ldr	r3, [pc, #132]	@ (80071e8 <HAL_PWREx_ConfigSupply+0xb0>)
 8007164:	68db      	ldr	r3, [r3, #12]
 8007166:	f023 023f 	bic.w	r2, r3, #63	@ 0x3f
 800716a:	491f      	ldr	r1, [pc, #124]	@ (80071e8 <HAL_PWREx_ConfigSupply+0xb0>)
 800716c:	687b      	ldr	r3, [r7, #4]
 800716e:	4313      	orrs	r3, r2
 8007170:	60cb      	str	r3, [r1, #12]

  /* Get tick */
  tickstart = HAL_GetTick ();
 8007172:	f7fa feff 	bl	8001f74 <HAL_GetTick>
 8007176:	60f8      	str	r0, [r7, #12]

  /* Wait till voltage level flag is set */
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 8007178:	e009      	b.n	800718e <HAL_PWREx_ConfigSupply+0x56>
  {
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
 800717a:	f7fa fefb 	bl	8001f74 <HAL_GetTick>
 800717e:	4602      	mov	r2, r0
 8007180:	68fb      	ldr	r3, [r7, #12]
 8007182:	1ad3      	subs	r3, r2, r3
 8007184:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 8007188:	d901      	bls.n	800718e <HAL_PWREx_ConfigSupply+0x56>
    {
      return HAL_ERROR;
 800718a:	2301      	movs	r3, #1
 800718c:	e028      	b.n	80071e0 <HAL_PWREx_ConfigSupply+0xa8>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 800718e:	4b16      	ldr	r3, [pc, #88]	@ (80071e8 <HAL_PWREx_ConfigSupply+0xb0>)
 8007190:	685b      	ldr	r3, [r3, #4]
 8007192:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8007196:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800719a:	d1ee      	bne.n	800717a <HAL_PWREx_ConfigSupply+0x42>
    }
  }

#if defined (SMPS)
  /* When the SMPS supplies external circuits verify that SDEXTRDY flag is set */
  if ((SupplySource == PWR_SMPS_1V8_SUPPLIES_EXT_AND_LDO) ||
 800719c:	687b      	ldr	r3, [r7, #4]
 800719e:	2b1e      	cmp	r3, #30
 80071a0:	d008      	beq.n	80071b4 <HAL_PWREx_ConfigSupply+0x7c>
 80071a2:	687b      	ldr	r3, [r7, #4]
 80071a4:	2b2e      	cmp	r3, #46	@ 0x2e
 80071a6:	d005      	beq.n	80071b4 <HAL_PWREx_ConfigSupply+0x7c>
      (SupplySource == PWR_SMPS_2V5_SUPPLIES_EXT_AND_LDO) ||
 80071a8:	687b      	ldr	r3, [r7, #4]
 80071aa:	2b1d      	cmp	r3, #29
 80071ac:	d002      	beq.n	80071b4 <HAL_PWREx_ConfigSupply+0x7c>
      (SupplySource == PWR_SMPS_1V8_SUPPLIES_EXT)         ||
 80071ae:	687b      	ldr	r3, [r7, #4]
 80071b0:	2b2d      	cmp	r3, #45	@ 0x2d
 80071b2:	d114      	bne.n	80071de <HAL_PWREx_ConfigSupply+0xa6>
      (SupplySource == PWR_SMPS_2V5_SUPPLIES_EXT))
  {
    /* Get the current tick number */
    tickstart = HAL_GetTick ();
 80071b4:	f7fa fede 	bl	8001f74 <HAL_GetTick>
 80071b8:	60f8      	str	r0, [r7, #12]

    /* Wait till SMPS external supply ready flag is set */
    while (__HAL_PWR_GET_FLAG (PWR_FLAG_SMPSEXTRDY) == 0U)
 80071ba:	e009      	b.n	80071d0 <HAL_PWREx_ConfigSupply+0x98>
    {
      if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
 80071bc:	f7fa feda 	bl	8001f74 <HAL_GetTick>
 80071c0:	4602      	mov	r2, r0
 80071c2:	68fb      	ldr	r3, [r7, #12]
 80071c4:	1ad3      	subs	r3, r2, r3
 80071c6:	f5b3 7f7a 	cmp.w	r3, #1000	@ 0x3e8
 80071ca:	d901      	bls.n	80071d0 <HAL_PWREx_ConfigSupply+0x98>
      {
        return HAL_ERROR;
 80071cc:	2301      	movs	r3, #1
 80071ce:	e007      	b.n	80071e0 <HAL_PWREx_ConfigSupply+0xa8>
    while (__HAL_PWR_GET_FLAG (PWR_FLAG_SMPSEXTRDY) == 0U)
 80071d0:	4b05      	ldr	r3, [pc, #20]	@ (80071e8 <HAL_PWREx_ConfigSupply+0xb0>)
 80071d2:	68db      	ldr	r3, [r3, #12]
 80071d4:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 80071d8:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80071dc:	d1ee      	bne.n	80071bc <HAL_PWREx_ConfigSupply+0x84>
      }
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
 80071de:	2300      	movs	r3, #0
}
 80071e0:	4618      	mov	r0, r3
 80071e2:	3710      	adds	r7, #16
 80071e4:	46bd      	mov	sp, r7
 80071e6:	bd80      	pop	{r7, pc}
 80071e8:	58024800 	.word	0x58024800

080071ec <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80071ec:	b580      	push	{r7, lr}
 80071ee:	b08c      	sub	sp, #48	@ 0x30
 80071f0:	af00      	add	r7, sp, #0
 80071f2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 80071f4:	687b      	ldr	r3, [r7, #4]
 80071f6:	2b00      	cmp	r3, #0
 80071f8:	d102      	bne.n	8007200 <HAL_RCC_OscConfig+0x14>
  {
    return HAL_ERROR;
 80071fa:	2301      	movs	r3, #1
 80071fc:	f000 bc48 	b.w	8007a90 <HAL_RCC_OscConfig+0x8a4>
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8007200:	687b      	ldr	r3, [r7, #4]
 8007202:	681b      	ldr	r3, [r3, #0]
 8007204:	f003 0301 	and.w	r3, r3, #1
 8007208:	2b00      	cmp	r3, #0
 800720a:	f000 8088 	beq.w	800731e <HAL_RCC_OscConfig+0x132>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800720e:	4b99      	ldr	r3, [pc, #612]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 8007210:	691b      	ldr	r3, [r3, #16]
 8007212:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 8007216:	62fb      	str	r3, [r7, #44]	@ 0x2c
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8007218:	4b96      	ldr	r3, [pc, #600]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 800721a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800721c:	62bb      	str	r3, [r7, #40]	@ 0x28
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if ((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
 800721e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007220:	2b10      	cmp	r3, #16
 8007222:	d007      	beq.n	8007234 <HAL_RCC_OscConfig+0x48>
 8007224:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8007226:	2b18      	cmp	r3, #24
 8007228:	d111      	bne.n	800724e <HAL_RCC_OscConfig+0x62>
 800722a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800722c:	f003 0303 	and.w	r3, r3, #3
 8007230:	2b02      	cmp	r3, #2
 8007232:	d10c      	bne.n	800724e <HAL_RCC_OscConfig+0x62>
    {
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8007234:	4b8f      	ldr	r3, [pc, #572]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 8007236:	681b      	ldr	r3, [r3, #0]
 8007238:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800723c:	2b00      	cmp	r3, #0
 800723e:	d06d      	beq.n	800731c <HAL_RCC_OscConfig+0x130>
 8007240:	687b      	ldr	r3, [r7, #4]
 8007242:	685b      	ldr	r3, [r3, #4]
 8007244:	2b00      	cmp	r3, #0
 8007246:	d169      	bne.n	800731c <HAL_RCC_OscConfig+0x130>
      {
        return HAL_ERROR;
 8007248:	2301      	movs	r3, #1
 800724a:	f000 bc21 	b.w	8007a90 <HAL_RCC_OscConfig+0x8a4>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800724e:	687b      	ldr	r3, [r7, #4]
 8007250:	685b      	ldr	r3, [r3, #4]
 8007252:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8007256:	d106      	bne.n	8007266 <HAL_RCC_OscConfig+0x7a>
 8007258:	4b86      	ldr	r3, [pc, #536]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 800725a:	681b      	ldr	r3, [r3, #0]
 800725c:	4a85      	ldr	r2, [pc, #532]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 800725e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8007262:	6013      	str	r3, [r2, #0]
 8007264:	e02e      	b.n	80072c4 <HAL_RCC_OscConfig+0xd8>
 8007266:	687b      	ldr	r3, [r7, #4]
 8007268:	685b      	ldr	r3, [r3, #4]
 800726a:	2b00      	cmp	r3, #0
 800726c:	d10c      	bne.n	8007288 <HAL_RCC_OscConfig+0x9c>
 800726e:	4b81      	ldr	r3, [pc, #516]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 8007270:	681b      	ldr	r3, [r3, #0]
 8007272:	4a80      	ldr	r2, [pc, #512]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 8007274:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8007278:	6013      	str	r3, [r2, #0]
 800727a:	4b7e      	ldr	r3, [pc, #504]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 800727c:	681b      	ldr	r3, [r3, #0]
 800727e:	4a7d      	ldr	r2, [pc, #500]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 8007280:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 8007284:	6013      	str	r3, [r2, #0]
 8007286:	e01d      	b.n	80072c4 <HAL_RCC_OscConfig+0xd8>
 8007288:	687b      	ldr	r3, [r7, #4]
 800728a:	685b      	ldr	r3, [r3, #4]
 800728c:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8007290:	d10c      	bne.n	80072ac <HAL_RCC_OscConfig+0xc0>
 8007292:	4b78      	ldr	r3, [pc, #480]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 8007294:	681b      	ldr	r3, [r3, #0]
 8007296:	4a77      	ldr	r2, [pc, #476]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 8007298:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 800729c:	6013      	str	r3, [r2, #0]
 800729e:	4b75      	ldr	r3, [pc, #468]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 80072a0:	681b      	ldr	r3, [r3, #0]
 80072a2:	4a74      	ldr	r2, [pc, #464]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 80072a4:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80072a8:	6013      	str	r3, [r2, #0]
 80072aa:	e00b      	b.n	80072c4 <HAL_RCC_OscConfig+0xd8>
 80072ac:	4b71      	ldr	r3, [pc, #452]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 80072ae:	681b      	ldr	r3, [r3, #0]
 80072b0:	4a70      	ldr	r2, [pc, #448]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 80072b2:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 80072b6:	6013      	str	r3, [r2, #0]
 80072b8:	4b6e      	ldr	r3, [pc, #440]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 80072ba:	681b      	ldr	r3, [r3, #0]
 80072bc:	4a6d      	ldr	r2, [pc, #436]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 80072be:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 80072c2:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80072c4:	687b      	ldr	r3, [r7, #4]
 80072c6:	685b      	ldr	r3, [r3, #4]
 80072c8:	2b00      	cmp	r3, #0
 80072ca:	d013      	beq.n	80072f4 <HAL_RCC_OscConfig+0x108>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80072cc:	f7fa fe52 	bl	8001f74 <HAL_GetTick>
 80072d0:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 80072d2:	e008      	b.n	80072e6 <HAL_RCC_OscConfig+0xfa>
        {
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80072d4:	f7fa fe4e 	bl	8001f74 <HAL_GetTick>
 80072d8:	4602      	mov	r2, r0
 80072da:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80072dc:	1ad3      	subs	r3, r2, r3
 80072de:	2b64      	cmp	r3, #100	@ 0x64
 80072e0:	d901      	bls.n	80072e6 <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 80072e2:	2303      	movs	r3, #3
 80072e4:	e3d4      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 80072e6:	4b63      	ldr	r3, [pc, #396]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 80072e8:	681b      	ldr	r3, [r3, #0]
 80072ea:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80072ee:	2b00      	cmp	r3, #0
 80072f0:	d0f0      	beq.n	80072d4 <HAL_RCC_OscConfig+0xe8>
 80072f2:	e014      	b.n	800731e <HAL_RCC_OscConfig+0x132>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80072f4:	f7fa fe3e 	bl	8001f74 <HAL_GetTick>
 80072f8:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till HSE is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 80072fa:	e008      	b.n	800730e <HAL_RCC_OscConfig+0x122>
        {
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80072fc:	f7fa fe3a 	bl	8001f74 <HAL_GetTick>
 8007300:	4602      	mov	r2, r0
 8007302:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007304:	1ad3      	subs	r3, r2, r3
 8007306:	2b64      	cmp	r3, #100	@ 0x64
 8007308:	d901      	bls.n	800730e <HAL_RCC_OscConfig+0x122>
          {
            return HAL_TIMEOUT;
 800730a:	2303      	movs	r3, #3
 800730c:	e3c0      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 800730e:	4b59      	ldr	r3, [pc, #356]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 8007310:	681b      	ldr	r3, [r3, #0]
 8007312:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8007316:	2b00      	cmp	r3, #0
 8007318:	d1f0      	bne.n	80072fc <HAL_RCC_OscConfig+0x110>
 800731a:	e000      	b.n	800731e <HAL_RCC_OscConfig+0x132>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800731c:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800731e:	687b      	ldr	r3, [r7, #4]
 8007320:	681b      	ldr	r3, [r3, #0]
 8007322:	f003 0302 	and.w	r3, r3, #2
 8007326:	2b00      	cmp	r3, #0
 8007328:	f000 80ca 	beq.w	80074c0 <HAL_RCC_OscConfig+0x2d4>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* When the HSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800732c:	4b51      	ldr	r3, [pc, #324]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 800732e:	691b      	ldr	r3, [r3, #16]
 8007330:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 8007334:	623b      	str	r3, [r7, #32]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8007336:	4b4f      	ldr	r3, [pc, #316]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 8007338:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800733a:	61fb      	str	r3, [r7, #28]
    if ((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 800733c:	6a3b      	ldr	r3, [r7, #32]
 800733e:	2b00      	cmp	r3, #0
 8007340:	d007      	beq.n	8007352 <HAL_RCC_OscConfig+0x166>
 8007342:	6a3b      	ldr	r3, [r7, #32]
 8007344:	2b18      	cmp	r3, #24
 8007346:	d156      	bne.n	80073f6 <HAL_RCC_OscConfig+0x20a>
 8007348:	69fb      	ldr	r3, [r7, #28]
 800734a:	f003 0303 	and.w	r3, r3, #3
 800734e:	2b00      	cmp	r3, #0
 8007350:	d151      	bne.n	80073f6 <HAL_RCC_OscConfig+0x20a>
    {
      /* When HSI is used as system clock it will not be disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8007352:	4b48      	ldr	r3, [pc, #288]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 8007354:	681b      	ldr	r3, [r3, #0]
 8007356:	f003 0304 	and.w	r3, r3, #4
 800735a:	2b00      	cmp	r3, #0
 800735c:	d005      	beq.n	800736a <HAL_RCC_OscConfig+0x17e>
 800735e:	687b      	ldr	r3, [r7, #4]
 8007360:	68db      	ldr	r3, [r3, #12]
 8007362:	2b00      	cmp	r3, #0
 8007364:	d101      	bne.n	800736a <HAL_RCC_OscConfig+0x17e>
      {
        return HAL_ERROR;
 8007366:	2301      	movs	r3, #1
 8007368:	e392      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
      }
      /* Otherwise, only HSI division and calibration are allowed */
      else
      {
        /* Enable the Internal High Speed oscillator (HSI, HSIDIV2, HSIDIV4, or HSIDIV8) */
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 800736a:	4b42      	ldr	r3, [pc, #264]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 800736c:	681b      	ldr	r3, [r3, #0]
 800736e:	f023 0219 	bic.w	r2, r3, #25
 8007372:	687b      	ldr	r3, [r7, #4]
 8007374:	68db      	ldr	r3, [r3, #12]
 8007376:	493f      	ldr	r1, [pc, #252]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 8007378:	4313      	orrs	r3, r2
 800737a:	600b      	str	r3, [r1, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800737c:	f7fa fdfa 	bl	8001f74 <HAL_GetTick>
 8007380:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8007382:	e008      	b.n	8007396 <HAL_RCC_OscConfig+0x1aa>
        {
          if ((uint32_t)(HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8007384:	f7fa fdf6 	bl	8001f74 <HAL_GetTick>
 8007388:	4602      	mov	r2, r0
 800738a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800738c:	1ad3      	subs	r3, r2, r3
 800738e:	2b02      	cmp	r3, #2
 8007390:	d901      	bls.n	8007396 <HAL_RCC_OscConfig+0x1aa>
          {
            return HAL_TIMEOUT;
 8007392:	2303      	movs	r3, #3
 8007394:	e37c      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8007396:	4b37      	ldr	r3, [pc, #220]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 8007398:	681b      	ldr	r3, [r3, #0]
 800739a:	f003 0304 	and.w	r3, r3, #4
 800739e:	2b00      	cmp	r3, #0
 80073a0:	d0f0      	beq.n	8007384 <HAL_RCC_OscConfig+0x198>
          }
        }
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80073a2:	f7fa fdf3 	bl	8001f8c <HAL_GetREVID>
 80073a6:	4603      	mov	r3, r0
 80073a8:	f241 0203 	movw	r2, #4099	@ 0x1003
 80073ac:	4293      	cmp	r3, r2
 80073ae:	d817      	bhi.n	80073e0 <HAL_RCC_OscConfig+0x1f4>
 80073b0:	687b      	ldr	r3, [r7, #4]
 80073b2:	691b      	ldr	r3, [r3, #16]
 80073b4:	2b40      	cmp	r3, #64	@ 0x40
 80073b6:	d108      	bne.n	80073ca <HAL_RCC_OscConfig+0x1de>
 80073b8:	4b2e      	ldr	r3, [pc, #184]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 80073ba:	685b      	ldr	r3, [r3, #4]
 80073bc:	f423 337c 	bic.w	r3, r3, #258048	@ 0x3f000
 80073c0:	4a2c      	ldr	r2, [pc, #176]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 80073c2:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80073c6:	6053      	str	r3, [r2, #4]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80073c8:	e07a      	b.n	80074c0 <HAL_RCC_OscConfig+0x2d4>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80073ca:	4b2a      	ldr	r3, [pc, #168]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 80073cc:	685b      	ldr	r3, [r3, #4]
 80073ce:	f423 327c 	bic.w	r2, r3, #258048	@ 0x3f000
 80073d2:	687b      	ldr	r3, [r7, #4]
 80073d4:	691b      	ldr	r3, [r3, #16]
 80073d6:	031b      	lsls	r3, r3, #12
 80073d8:	4926      	ldr	r1, [pc, #152]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 80073da:	4313      	orrs	r3, r2
 80073dc:	604b      	str	r3, [r1, #4]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80073de:	e06f      	b.n	80074c0 <HAL_RCC_OscConfig+0x2d4>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80073e0:	4b24      	ldr	r3, [pc, #144]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 80073e2:	685b      	ldr	r3, [r3, #4]
 80073e4:	f023 42fe 	bic.w	r2, r3, #2130706432	@ 0x7f000000
 80073e8:	687b      	ldr	r3, [r7, #4]
 80073ea:	691b      	ldr	r3, [r3, #16]
 80073ec:	061b      	lsls	r3, r3, #24
 80073ee:	4921      	ldr	r1, [pc, #132]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 80073f0:	4313      	orrs	r3, r2
 80073f2:	604b      	str	r3, [r1, #4]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80073f4:	e064      	b.n	80074c0 <HAL_RCC_OscConfig+0x2d4>
    }

    else
    {
      /* Check the HSI State */
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
 80073f6:	687b      	ldr	r3, [r7, #4]
 80073f8:	68db      	ldr	r3, [r3, #12]
 80073fa:	2b00      	cmp	r3, #0
 80073fc:	d047      	beq.n	800748e <HAL_RCC_OscConfig+0x2a2>
      {
        /* Enable the Internal High Speed oscillator (HSI, HSIDIV2,HSIDIV4, or HSIDIV8) */
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 80073fe:	4b1d      	ldr	r3, [pc, #116]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 8007400:	681b      	ldr	r3, [r3, #0]
 8007402:	f023 0219 	bic.w	r2, r3, #25
 8007406:	687b      	ldr	r3, [r7, #4]
 8007408:	68db      	ldr	r3, [r3, #12]
 800740a:	491a      	ldr	r1, [pc, #104]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 800740c:	4313      	orrs	r3, r2
 800740e:	600b      	str	r3, [r1, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8007410:	f7fa fdb0 	bl	8001f74 <HAL_GetTick>
 8007414:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8007416:	e008      	b.n	800742a <HAL_RCC_OscConfig+0x23e>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8007418:	f7fa fdac 	bl	8001f74 <HAL_GetTick>
 800741c:	4602      	mov	r2, r0
 800741e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007420:	1ad3      	subs	r3, r2, r3
 8007422:	2b02      	cmp	r3, #2
 8007424:	d901      	bls.n	800742a <HAL_RCC_OscConfig+0x23e>
          {
            return HAL_TIMEOUT;
 8007426:	2303      	movs	r3, #3
 8007428:	e332      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800742a:	4b12      	ldr	r3, [pc, #72]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 800742c:	681b      	ldr	r3, [r3, #0]
 800742e:	f003 0304 	and.w	r3, r3, #4
 8007432:	2b00      	cmp	r3, #0
 8007434:	d0f0      	beq.n	8007418 <HAL_RCC_OscConfig+0x22c>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8007436:	f7fa fda9 	bl	8001f8c <HAL_GetREVID>
 800743a:	4603      	mov	r3, r0
 800743c:	f241 0203 	movw	r2, #4099	@ 0x1003
 8007440:	4293      	cmp	r3, r2
 8007442:	d819      	bhi.n	8007478 <HAL_RCC_OscConfig+0x28c>
 8007444:	687b      	ldr	r3, [r7, #4]
 8007446:	691b      	ldr	r3, [r3, #16]
 8007448:	2b40      	cmp	r3, #64	@ 0x40
 800744a:	d108      	bne.n	800745e <HAL_RCC_OscConfig+0x272>
 800744c:	4b09      	ldr	r3, [pc, #36]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 800744e:	685b      	ldr	r3, [r3, #4]
 8007450:	f423 337c 	bic.w	r3, r3, #258048	@ 0x3f000
 8007454:	4a07      	ldr	r2, [pc, #28]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 8007456:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800745a:	6053      	str	r3, [r2, #4]
 800745c:	e030      	b.n	80074c0 <HAL_RCC_OscConfig+0x2d4>
 800745e:	4b05      	ldr	r3, [pc, #20]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 8007460:	685b      	ldr	r3, [r3, #4]
 8007462:	f423 327c 	bic.w	r2, r3, #258048	@ 0x3f000
 8007466:	687b      	ldr	r3, [r7, #4]
 8007468:	691b      	ldr	r3, [r3, #16]
 800746a:	031b      	lsls	r3, r3, #12
 800746c:	4901      	ldr	r1, [pc, #4]	@ (8007474 <HAL_RCC_OscConfig+0x288>)
 800746e:	4313      	orrs	r3, r2
 8007470:	604b      	str	r3, [r1, #4]
 8007472:	e025      	b.n	80074c0 <HAL_RCC_OscConfig+0x2d4>
 8007474:	58024400 	.word	0x58024400
 8007478:	4b9a      	ldr	r3, [pc, #616]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 800747a:	685b      	ldr	r3, [r3, #4]
 800747c:	f023 42fe 	bic.w	r2, r3, #2130706432	@ 0x7f000000
 8007480:	687b      	ldr	r3, [r7, #4]
 8007482:	691b      	ldr	r3, [r3, #16]
 8007484:	061b      	lsls	r3, r3, #24
 8007486:	4997      	ldr	r1, [pc, #604]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 8007488:	4313      	orrs	r3, r2
 800748a:	604b      	str	r3, [r1, #4]
 800748c:	e018      	b.n	80074c0 <HAL_RCC_OscConfig+0x2d4>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 800748e:	4b95      	ldr	r3, [pc, #596]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 8007490:	681b      	ldr	r3, [r3, #0]
 8007492:	4a94      	ldr	r2, [pc, #592]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 8007494:	f023 0301 	bic.w	r3, r3, #1
 8007498:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800749a:	f7fa fd6b 	bl	8001f74 <HAL_GetTick>
 800749e:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till HSI is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 80074a0:	e008      	b.n	80074b4 <HAL_RCC_OscConfig+0x2c8>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80074a2:	f7fa fd67 	bl	8001f74 <HAL_GetTick>
 80074a6:	4602      	mov	r2, r0
 80074a8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80074aa:	1ad3      	subs	r3, r2, r3
 80074ac:	2b02      	cmp	r3, #2
 80074ae:	d901      	bls.n	80074b4 <HAL_RCC_OscConfig+0x2c8>
          {
            return HAL_TIMEOUT;
 80074b0:	2303      	movs	r3, #3
 80074b2:	e2ed      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 80074b4:	4b8b      	ldr	r3, [pc, #556]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 80074b6:	681b      	ldr	r3, [r3, #0]
 80074b8:	f003 0304 	and.w	r3, r3, #4
 80074bc:	2b00      	cmp	r3, #0
 80074be:	d1f0      	bne.n	80074a2 <HAL_RCC_OscConfig+0x2b6>
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
 80074c0:	687b      	ldr	r3, [r7, #4]
 80074c2:	681b      	ldr	r3, [r3, #0]
 80074c4:	f003 0310 	and.w	r3, r3, #16
 80074c8:	2b00      	cmp	r3, #0
 80074ca:	f000 80a9 	beq.w	8007620 <HAL_RCC_OscConfig+0x434>
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80074ce:	4b85      	ldr	r3, [pc, #532]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 80074d0:	691b      	ldr	r3, [r3, #16]
 80074d2:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 80074d6:	61bb      	str	r3, [r7, #24]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 80074d8:	4b82      	ldr	r3, [pc, #520]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 80074da:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80074dc:	617b      	str	r3, [r7, #20]
    if ((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
 80074de:	69bb      	ldr	r3, [r7, #24]
 80074e0:	2b08      	cmp	r3, #8
 80074e2:	d007      	beq.n	80074f4 <HAL_RCC_OscConfig+0x308>
 80074e4:	69bb      	ldr	r3, [r7, #24]
 80074e6:	2b18      	cmp	r3, #24
 80074e8:	d13a      	bne.n	8007560 <HAL_RCC_OscConfig+0x374>
 80074ea:	697b      	ldr	r3, [r7, #20]
 80074ec:	f003 0303 	and.w	r3, r3, #3
 80074f0:	2b01      	cmp	r3, #1
 80074f2:	d135      	bne.n	8007560 <HAL_RCC_OscConfig+0x374>
    {
      /* When CSI is used as system clock it will not disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 80074f4:	4b7b      	ldr	r3, [pc, #492]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 80074f6:	681b      	ldr	r3, [r3, #0]
 80074f8:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80074fc:	2b00      	cmp	r3, #0
 80074fe:	d005      	beq.n	800750c <HAL_RCC_OscConfig+0x320>
 8007500:	687b      	ldr	r3, [r7, #4]
 8007502:	69db      	ldr	r3, [r3, #28]
 8007504:	2b80      	cmp	r3, #128	@ 0x80
 8007506:	d001      	beq.n	800750c <HAL_RCC_OscConfig+0x320>
      {
        return HAL_ERROR;
 8007508:	2301      	movs	r3, #1
 800750a:	e2c1      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800750c:	f7fa fd3e 	bl	8001f8c <HAL_GetREVID>
 8007510:	4603      	mov	r3, r0
 8007512:	f241 0203 	movw	r2, #4099	@ 0x1003
 8007516:	4293      	cmp	r3, r2
 8007518:	d817      	bhi.n	800754a <HAL_RCC_OscConfig+0x35e>
 800751a:	687b      	ldr	r3, [r7, #4]
 800751c:	6a1b      	ldr	r3, [r3, #32]
 800751e:	2b20      	cmp	r3, #32
 8007520:	d108      	bne.n	8007534 <HAL_RCC_OscConfig+0x348>
 8007522:	4b70      	ldr	r3, [pc, #448]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 8007524:	685b      	ldr	r3, [r3, #4]
 8007526:	f023 43f8 	bic.w	r3, r3, #2080374784	@ 0x7c000000
 800752a:	4a6e      	ldr	r2, [pc, #440]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 800752c:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8007530:	6053      	str	r3, [r2, #4]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 8007532:	e075      	b.n	8007620 <HAL_RCC_OscConfig+0x434>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 8007534:	4b6b      	ldr	r3, [pc, #428]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 8007536:	685b      	ldr	r3, [r3, #4]
 8007538:	f023 42f8 	bic.w	r2, r3, #2080374784	@ 0x7c000000
 800753c:	687b      	ldr	r3, [r7, #4]
 800753e:	6a1b      	ldr	r3, [r3, #32]
 8007540:	069b      	lsls	r3, r3, #26
 8007542:	4968      	ldr	r1, [pc, #416]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 8007544:	4313      	orrs	r3, r2
 8007546:	604b      	str	r3, [r1, #4]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 8007548:	e06a      	b.n	8007620 <HAL_RCC_OscConfig+0x434>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800754a:	4b66      	ldr	r3, [pc, #408]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 800754c:	68db      	ldr	r3, [r3, #12]
 800754e:	f023 527c 	bic.w	r2, r3, #1056964608	@ 0x3f000000
 8007552:	687b      	ldr	r3, [r7, #4]
 8007554:	6a1b      	ldr	r3, [r3, #32]
 8007556:	061b      	lsls	r3, r3, #24
 8007558:	4962      	ldr	r1, [pc, #392]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 800755a:	4313      	orrs	r3, r2
 800755c:	60cb      	str	r3, [r1, #12]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 800755e:	e05f      	b.n	8007620 <HAL_RCC_OscConfig+0x434>
      }
    }
    else
    {
      /* Check the CSI State */
      if ((RCC_OscInitStruct->CSIState) != RCC_CSI_OFF)
 8007560:	687b      	ldr	r3, [r7, #4]
 8007562:	69db      	ldr	r3, [r3, #28]
 8007564:	2b00      	cmp	r3, #0
 8007566:	d042      	beq.n	80075ee <HAL_RCC_OscConfig+0x402>
      {
        /* Enable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_ENABLE();
 8007568:	4b5e      	ldr	r3, [pc, #376]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 800756a:	681b      	ldr	r3, [r3, #0]
 800756c:	4a5d      	ldr	r2, [pc, #372]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 800756e:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8007572:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8007574:	f7fa fcfe 	bl	8001f74 <HAL_GetTick>
 8007578:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till CSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 800757a:	e008      	b.n	800758e <HAL_RCC_OscConfig+0x3a2>
        {
          if ((HAL_GetTick() - tickstart) > CSI_TIMEOUT_VALUE)
 800757c:	f7fa fcfa 	bl	8001f74 <HAL_GetTick>
 8007580:	4602      	mov	r2, r0
 8007582:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007584:	1ad3      	subs	r3, r2, r3
 8007586:	2b02      	cmp	r3, #2
 8007588:	d901      	bls.n	800758e <HAL_RCC_OscConfig+0x3a2>
          {
            return HAL_TIMEOUT;
 800758a:	2303      	movs	r3, #3
 800758c:	e280      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 800758e:	4b55      	ldr	r3, [pc, #340]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 8007590:	681b      	ldr	r3, [r3, #0]
 8007592:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8007596:	2b00      	cmp	r3, #0
 8007598:	d0f0      	beq.n	800757c <HAL_RCC_OscConfig+0x390>
          }
        }

        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800759a:	f7fa fcf7 	bl	8001f8c <HAL_GetREVID>
 800759e:	4603      	mov	r3, r0
 80075a0:	f241 0203 	movw	r2, #4099	@ 0x1003
 80075a4:	4293      	cmp	r3, r2
 80075a6:	d817      	bhi.n	80075d8 <HAL_RCC_OscConfig+0x3ec>
 80075a8:	687b      	ldr	r3, [r7, #4]
 80075aa:	6a1b      	ldr	r3, [r3, #32]
 80075ac:	2b20      	cmp	r3, #32
 80075ae:	d108      	bne.n	80075c2 <HAL_RCC_OscConfig+0x3d6>
 80075b0:	4b4c      	ldr	r3, [pc, #304]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 80075b2:	685b      	ldr	r3, [r3, #4]
 80075b4:	f023 43f8 	bic.w	r3, r3, #2080374784	@ 0x7c000000
 80075b8:	4a4a      	ldr	r2, [pc, #296]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 80075ba:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 80075be:	6053      	str	r3, [r2, #4]
 80075c0:	e02e      	b.n	8007620 <HAL_RCC_OscConfig+0x434>
 80075c2:	4b48      	ldr	r3, [pc, #288]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 80075c4:	685b      	ldr	r3, [r3, #4]
 80075c6:	f023 42f8 	bic.w	r2, r3, #2080374784	@ 0x7c000000
 80075ca:	687b      	ldr	r3, [r7, #4]
 80075cc:	6a1b      	ldr	r3, [r3, #32]
 80075ce:	069b      	lsls	r3, r3, #26
 80075d0:	4944      	ldr	r1, [pc, #272]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 80075d2:	4313      	orrs	r3, r2
 80075d4:	604b      	str	r3, [r1, #4]
 80075d6:	e023      	b.n	8007620 <HAL_RCC_OscConfig+0x434>
 80075d8:	4b42      	ldr	r3, [pc, #264]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 80075da:	68db      	ldr	r3, [r3, #12]
 80075dc:	f023 527c 	bic.w	r2, r3, #1056964608	@ 0x3f000000
 80075e0:	687b      	ldr	r3, [r7, #4]
 80075e2:	6a1b      	ldr	r3, [r3, #32]
 80075e4:	061b      	lsls	r3, r3, #24
 80075e6:	493f      	ldr	r1, [pc, #252]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 80075e8:	4313      	orrs	r3, r2
 80075ea:	60cb      	str	r3, [r1, #12]
 80075ec:	e018      	b.n	8007620 <HAL_RCC_OscConfig+0x434>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_DISABLE();
 80075ee:	4b3d      	ldr	r3, [pc, #244]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 80075f0:	681b      	ldr	r3, [r3, #0]
 80075f2:	4a3c      	ldr	r2, [pc, #240]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 80075f4:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 80075f8:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80075fa:	f7fa fcbb 	bl	8001f74 <HAL_GetTick>
 80075fe:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till CSI is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 8007600:	e008      	b.n	8007614 <HAL_RCC_OscConfig+0x428>
        {
          if ((HAL_GetTick() - tickstart) > CSI_TIMEOUT_VALUE)
 8007602:	f7fa fcb7 	bl	8001f74 <HAL_GetTick>
 8007606:	4602      	mov	r2, r0
 8007608:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800760a:	1ad3      	subs	r3, r2, r3
 800760c:	2b02      	cmp	r3, #2
 800760e:	d901      	bls.n	8007614 <HAL_RCC_OscConfig+0x428>
          {
            return HAL_TIMEOUT;
 8007610:	2303      	movs	r3, #3
 8007612:	e23d      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 8007614:	4b33      	ldr	r3, [pc, #204]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 8007616:	681b      	ldr	r3, [r3, #0]
 8007618:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800761c:	2b00      	cmp	r3, #0
 800761e:	d1f0      	bne.n	8007602 <HAL_RCC_OscConfig+0x416>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8007620:	687b      	ldr	r3, [r7, #4]
 8007622:	681b      	ldr	r3, [r3, #0]
 8007624:	f003 0308 	and.w	r3, r3, #8
 8007628:	2b00      	cmp	r3, #0
 800762a:	d036      	beq.n	800769a <HAL_RCC_OscConfig+0x4ae>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
 800762c:	687b      	ldr	r3, [r7, #4]
 800762e:	695b      	ldr	r3, [r3, #20]
 8007630:	2b00      	cmp	r3, #0
 8007632:	d019      	beq.n	8007668 <HAL_RCC_OscConfig+0x47c>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8007634:	4b2b      	ldr	r3, [pc, #172]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 8007636:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8007638:	4a2a      	ldr	r2, [pc, #168]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 800763a:	f043 0301 	orr.w	r3, r3, #1
 800763e:	6753      	str	r3, [r2, #116]	@ 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8007640:	f7fa fc98 	bl	8001f74 <HAL_GetTick>
 8007644:	6278      	str	r0, [r7, #36]	@ 0x24

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8007646:	e008      	b.n	800765a <HAL_RCC_OscConfig+0x46e>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8007648:	f7fa fc94 	bl	8001f74 <HAL_GetTick>
 800764c:	4602      	mov	r2, r0
 800764e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007650:	1ad3      	subs	r3, r2, r3
 8007652:	2b02      	cmp	r3, #2
 8007654:	d901      	bls.n	800765a <HAL_RCC_OscConfig+0x46e>
        {
          return HAL_TIMEOUT;
 8007656:	2303      	movs	r3, #3
 8007658:	e21a      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 800765a:	4b22      	ldr	r3, [pc, #136]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 800765c:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800765e:	f003 0302 	and.w	r3, r3, #2
 8007662:	2b00      	cmp	r3, #0
 8007664:	d0f0      	beq.n	8007648 <HAL_RCC_OscConfig+0x45c>
 8007666:	e018      	b.n	800769a <HAL_RCC_OscConfig+0x4ae>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8007668:	4b1e      	ldr	r3, [pc, #120]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 800766a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 800766c:	4a1d      	ldr	r2, [pc, #116]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 800766e:	f023 0301 	bic.w	r3, r3, #1
 8007672:	6753      	str	r3, [r2, #116]	@ 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8007674:	f7fa fc7e 	bl	8001f74 <HAL_GetTick>
 8007678:	6278      	str	r0, [r7, #36]	@ 0x24

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 800767a:	e008      	b.n	800768e <HAL_RCC_OscConfig+0x4a2>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800767c:	f7fa fc7a 	bl	8001f74 <HAL_GetTick>
 8007680:	4602      	mov	r2, r0
 8007682:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007684:	1ad3      	subs	r3, r2, r3
 8007686:	2b02      	cmp	r3, #2
 8007688:	d901      	bls.n	800768e <HAL_RCC_OscConfig+0x4a2>
        {
          return HAL_TIMEOUT;
 800768a:	2303      	movs	r3, #3
 800768c:	e200      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 800768e:	4b15      	ldr	r3, [pc, #84]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 8007690:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 8007692:	f003 0302 	and.w	r3, r3, #2
 8007696:	2b00      	cmp	r3, #0
 8007698:	d1f0      	bne.n	800767c <HAL_RCC_OscConfig+0x490>
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 800769a:	687b      	ldr	r3, [r7, #4]
 800769c:	681b      	ldr	r3, [r3, #0]
 800769e:	f003 0320 	and.w	r3, r3, #32
 80076a2:	2b00      	cmp	r3, #0
 80076a4:	d039      	beq.n	800771a <HAL_RCC_OscConfig+0x52e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if ((RCC_OscInitStruct->HSI48State) != RCC_HSI48_OFF)
 80076a6:	687b      	ldr	r3, [r7, #4]
 80076a8:	699b      	ldr	r3, [r3, #24]
 80076aa:	2b00      	cmp	r3, #0
 80076ac:	d01c      	beq.n	80076e8 <HAL_RCC_OscConfig+0x4fc>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 80076ae:	4b0d      	ldr	r3, [pc, #52]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 80076b0:	681b      	ldr	r3, [r3, #0]
 80076b2:	4a0c      	ldr	r2, [pc, #48]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 80076b4:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 80076b8:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
 80076ba:	f7fa fc5b 	bl	8001f74 <HAL_GetTick>
 80076be:	6278      	str	r0, [r7, #36]	@ 0x24

      /* Wait till HSI48 is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 80076c0:	e008      	b.n	80076d4 <HAL_RCC_OscConfig+0x4e8>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80076c2:	f7fa fc57 	bl	8001f74 <HAL_GetTick>
 80076c6:	4602      	mov	r2, r0
 80076c8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80076ca:	1ad3      	subs	r3, r2, r3
 80076cc:	2b02      	cmp	r3, #2
 80076ce:	d901      	bls.n	80076d4 <HAL_RCC_OscConfig+0x4e8>
        {
          return HAL_TIMEOUT;
 80076d0:	2303      	movs	r3, #3
 80076d2:	e1dd      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 80076d4:	4b03      	ldr	r3, [pc, #12]	@ (80076e4 <HAL_RCC_OscConfig+0x4f8>)
 80076d6:	681b      	ldr	r3, [r3, #0]
 80076d8:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 80076dc:	2b00      	cmp	r3, #0
 80076de:	d0f0      	beq.n	80076c2 <HAL_RCC_OscConfig+0x4d6>
 80076e0:	e01b      	b.n	800771a <HAL_RCC_OscConfig+0x52e>
 80076e2:	bf00      	nop
 80076e4:	58024400 	.word	0x58024400
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_DISABLE();
 80076e8:	4b9b      	ldr	r3, [pc, #620]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 80076ea:	681b      	ldr	r3, [r3, #0]
 80076ec:	4a9a      	ldr	r2, [pc, #616]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 80076ee:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 80076f2:	6013      	str	r3, [r2, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();
 80076f4:	f7fa fc3e 	bl	8001f74 <HAL_GetTick>
 80076f8:	6278      	str	r0, [r7, #36]	@ 0x24

      /* Wait till HSI48 is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 80076fa:	e008      	b.n	800770e <HAL_RCC_OscConfig+0x522>
      {
        if ((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80076fc:	f7fa fc3a 	bl	8001f74 <HAL_GetTick>
 8007700:	4602      	mov	r2, r0
 8007702:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007704:	1ad3      	subs	r3, r2, r3
 8007706:	2b02      	cmp	r3, #2
 8007708:	d901      	bls.n	800770e <HAL_RCC_OscConfig+0x522>
        {
          return HAL_TIMEOUT;
 800770a:	2303      	movs	r3, #3
 800770c:	e1c0      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 800770e:	4b92      	ldr	r3, [pc, #584]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007710:	681b      	ldr	r3, [r3, #0]
 8007712:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8007716:	2b00      	cmp	r3, #0
 8007718:	d1f0      	bne.n	80076fc <HAL_RCC_OscConfig+0x510>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800771a:	687b      	ldr	r3, [r7, #4]
 800771c:	681b      	ldr	r3, [r3, #0]
 800771e:	f003 0304 	and.w	r3, r3, #4
 8007722:	2b00      	cmp	r3, #0
 8007724:	f000 8081 	beq.w	800782a <HAL_RCC_OscConfig+0x63e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 8007728:	4b8c      	ldr	r3, [pc, #560]	@ (800795c <HAL_RCC_OscConfig+0x770>)
 800772a:	681b      	ldr	r3, [r3, #0]
 800772c:	4a8b      	ldr	r2, [pc, #556]	@ (800795c <HAL_RCC_OscConfig+0x770>)
 800772e:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8007732:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8007734:	f7fa fc1e 	bl	8001f74 <HAL_GetTick>
 8007738:	6278      	str	r0, [r7, #36]	@ 0x24

    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800773a:	e008      	b.n	800774e <HAL_RCC_OscConfig+0x562>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800773c:	f7fa fc1a 	bl	8001f74 <HAL_GetTick>
 8007740:	4602      	mov	r2, r0
 8007742:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007744:	1ad3      	subs	r3, r2, r3
 8007746:	2b64      	cmp	r3, #100	@ 0x64
 8007748:	d901      	bls.n	800774e <HAL_RCC_OscConfig+0x562>
      {
        return HAL_TIMEOUT;
 800774a:	2303      	movs	r3, #3
 800774c:	e1a0      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800774e:	4b83      	ldr	r3, [pc, #524]	@ (800795c <HAL_RCC_OscConfig+0x770>)
 8007750:	681b      	ldr	r3, [r3, #0]
 8007752:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8007756:	2b00      	cmp	r3, #0
 8007758:	d0f0      	beq.n	800773c <HAL_RCC_OscConfig+0x550>
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800775a:	687b      	ldr	r3, [r7, #4]
 800775c:	689b      	ldr	r3, [r3, #8]
 800775e:	2b01      	cmp	r3, #1
 8007760:	d106      	bne.n	8007770 <HAL_RCC_OscConfig+0x584>
 8007762:	4b7d      	ldr	r3, [pc, #500]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007764:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8007766:	4a7c      	ldr	r2, [pc, #496]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007768:	f043 0301 	orr.w	r3, r3, #1
 800776c:	6713      	str	r3, [r2, #112]	@ 0x70
 800776e:	e02d      	b.n	80077cc <HAL_RCC_OscConfig+0x5e0>
 8007770:	687b      	ldr	r3, [r7, #4]
 8007772:	689b      	ldr	r3, [r3, #8]
 8007774:	2b00      	cmp	r3, #0
 8007776:	d10c      	bne.n	8007792 <HAL_RCC_OscConfig+0x5a6>
 8007778:	4b77      	ldr	r3, [pc, #476]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 800777a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800777c:	4a76      	ldr	r2, [pc, #472]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 800777e:	f023 0301 	bic.w	r3, r3, #1
 8007782:	6713      	str	r3, [r2, #112]	@ 0x70
 8007784:	4b74      	ldr	r3, [pc, #464]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007786:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8007788:	4a73      	ldr	r2, [pc, #460]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 800778a:	f023 0304 	bic.w	r3, r3, #4
 800778e:	6713      	str	r3, [r2, #112]	@ 0x70
 8007790:	e01c      	b.n	80077cc <HAL_RCC_OscConfig+0x5e0>
 8007792:	687b      	ldr	r3, [r7, #4]
 8007794:	689b      	ldr	r3, [r3, #8]
 8007796:	2b05      	cmp	r3, #5
 8007798:	d10c      	bne.n	80077b4 <HAL_RCC_OscConfig+0x5c8>
 800779a:	4b6f      	ldr	r3, [pc, #444]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 800779c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800779e:	4a6e      	ldr	r2, [pc, #440]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 80077a0:	f043 0304 	orr.w	r3, r3, #4
 80077a4:	6713      	str	r3, [r2, #112]	@ 0x70
 80077a6:	4b6c      	ldr	r3, [pc, #432]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 80077a8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80077aa:	4a6b      	ldr	r2, [pc, #428]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 80077ac:	f043 0301 	orr.w	r3, r3, #1
 80077b0:	6713      	str	r3, [r2, #112]	@ 0x70
 80077b2:	e00b      	b.n	80077cc <HAL_RCC_OscConfig+0x5e0>
 80077b4:	4b68      	ldr	r3, [pc, #416]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 80077b6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80077b8:	4a67      	ldr	r2, [pc, #412]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 80077ba:	f023 0301 	bic.w	r3, r3, #1
 80077be:	6713      	str	r3, [r2, #112]	@ 0x70
 80077c0:	4b65      	ldr	r3, [pc, #404]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 80077c2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80077c4:	4a64      	ldr	r2, [pc, #400]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 80077c6:	f023 0304 	bic.w	r3, r3, #4
 80077ca:	6713      	str	r3, [r2, #112]	@ 0x70
    /* Check the LSE State */
    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80077cc:	687b      	ldr	r3, [r7, #4]
 80077ce:	689b      	ldr	r3, [r3, #8]
 80077d0:	2b00      	cmp	r3, #0
 80077d2:	d015      	beq.n	8007800 <HAL_RCC_OscConfig+0x614>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80077d4:	f7fa fbce 	bl	8001f74 <HAL_GetTick>
 80077d8:	6278      	str	r0, [r7, #36]	@ 0x24

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 80077da:	e00a      	b.n	80077f2 <HAL_RCC_OscConfig+0x606>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80077dc:	f7fa fbca 	bl	8001f74 <HAL_GetTick>
 80077e0:	4602      	mov	r2, r0
 80077e2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80077e4:	1ad3      	subs	r3, r2, r3
 80077e6:	f241 3288 	movw	r2, #5000	@ 0x1388
 80077ea:	4293      	cmp	r3, r2
 80077ec:	d901      	bls.n	80077f2 <HAL_RCC_OscConfig+0x606>
        {
          return HAL_TIMEOUT;
 80077ee:	2303      	movs	r3, #3
 80077f0:	e14e      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 80077f2:	4b59      	ldr	r3, [pc, #356]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 80077f4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 80077f6:	f003 0302 	and.w	r3, r3, #2
 80077fa:	2b00      	cmp	r3, #0
 80077fc:	d0ee      	beq.n	80077dc <HAL_RCC_OscConfig+0x5f0>
 80077fe:	e014      	b.n	800782a <HAL_RCC_OscConfig+0x63e>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8007800:	f7fa fbb8 	bl	8001f74 <HAL_GetTick>
 8007804:	6278      	str	r0, [r7, #36]	@ 0x24

      /* Wait till LSE is disabled */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 8007806:	e00a      	b.n	800781e <HAL_RCC_OscConfig+0x632>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8007808:	f7fa fbb4 	bl	8001f74 <HAL_GetTick>
 800780c:	4602      	mov	r2, r0
 800780e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007810:	1ad3      	subs	r3, r2, r3
 8007812:	f241 3288 	movw	r2, #5000	@ 0x1388
 8007816:	4293      	cmp	r3, r2
 8007818:	d901      	bls.n	800781e <HAL_RCC_OscConfig+0x632>
        {
          return HAL_TIMEOUT;
 800781a:	2303      	movs	r3, #3
 800781c:	e138      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 800781e:	4b4e      	ldr	r3, [pc, #312]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007820:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8007822:	f003 0302 	and.w	r3, r3, #2
 8007826:	2b00      	cmp	r3, #0
 8007828:	d1ee      	bne.n	8007808 <HAL_RCC_OscConfig+0x61c>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800782a:	687b      	ldr	r3, [r7, #4]
 800782c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800782e:	2b00      	cmp	r3, #0
 8007830:	f000 812d 	beq.w	8007a8e <HAL_RCC_OscConfig+0x8a2>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
 8007834:	4b48      	ldr	r3, [pc, #288]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007836:	691b      	ldr	r3, [r3, #16]
 8007838:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 800783c:	2b18      	cmp	r3, #24
 800783e:	f000 80bd 	beq.w	80079bc <HAL_RCC_OscConfig+0x7d0>
    {
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8007842:	687b      	ldr	r3, [r7, #4]
 8007844:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8007846:	2b02      	cmp	r3, #2
 8007848:	f040 809e 	bne.w	8007988 <HAL_RCC_OscConfig+0x79c>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800784c:	4b42      	ldr	r3, [pc, #264]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 800784e:	681b      	ldr	r3, [r3, #0]
 8007850:	4a41      	ldr	r2, [pc, #260]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007852:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 8007856:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8007858:	f7fa fb8c 	bl	8001f74 <HAL_GetTick>
 800785c:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800785e:	e008      	b.n	8007872 <HAL_RCC_OscConfig+0x686>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8007860:	f7fa fb88 	bl	8001f74 <HAL_GetTick>
 8007864:	4602      	mov	r2, r0
 8007866:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007868:	1ad3      	subs	r3, r2, r3
 800786a:	2b02      	cmp	r3, #2
 800786c:	d901      	bls.n	8007872 <HAL_RCC_OscConfig+0x686>
          {
            return HAL_TIMEOUT;
 800786e:	2303      	movs	r3, #3
 8007870:	e10e      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 8007872:	4b39      	ldr	r3, [pc, #228]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007874:	681b      	ldr	r3, [r3, #0]
 8007876:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800787a:	2b00      	cmp	r3, #0
 800787c:	d1f0      	bne.n	8007860 <HAL_RCC_OscConfig+0x674>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800787e:	4b36      	ldr	r3, [pc, #216]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007880:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
 8007882:	4b37      	ldr	r3, [pc, #220]	@ (8007960 <HAL_RCC_OscConfig+0x774>)
 8007884:	4013      	ands	r3, r2
 8007886:	687a      	ldr	r2, [r7, #4]
 8007888:	6a91      	ldr	r1, [r2, #40]	@ 0x28
 800788a:	687a      	ldr	r2, [r7, #4]
 800788c:	6ad2      	ldr	r2, [r2, #44]	@ 0x2c
 800788e:	0112      	lsls	r2, r2, #4
 8007890:	430a      	orrs	r2, r1
 8007892:	4931      	ldr	r1, [pc, #196]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007894:	4313      	orrs	r3, r2
 8007896:	628b      	str	r3, [r1, #40]	@ 0x28
 8007898:	687b      	ldr	r3, [r7, #4]
 800789a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800789c:	3b01      	subs	r3, #1
 800789e:	f3c3 0208 	ubfx	r2, r3, #0, #9
 80078a2:	687b      	ldr	r3, [r7, #4]
 80078a4:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 80078a6:	3b01      	subs	r3, #1
 80078a8:	025b      	lsls	r3, r3, #9
 80078aa:	b29b      	uxth	r3, r3
 80078ac:	431a      	orrs	r2, r3
 80078ae:	687b      	ldr	r3, [r7, #4]
 80078b0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 80078b2:	3b01      	subs	r3, #1
 80078b4:	041b      	lsls	r3, r3, #16
 80078b6:	f403 03fe 	and.w	r3, r3, #8323072	@ 0x7f0000
 80078ba:	431a      	orrs	r2, r3
 80078bc:	687b      	ldr	r3, [r7, #4]
 80078be:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 80078c0:	3b01      	subs	r3, #1
 80078c2:	061b      	lsls	r3, r3, #24
 80078c4:	f003 43fe 	and.w	r3, r3, #2130706432	@ 0x7f000000
 80078c8:	4923      	ldr	r1, [pc, #140]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 80078ca:	4313      	orrs	r3, r2
 80078cc:	630b      	str	r3, [r1, #48]	@ 0x30
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);

        /* Disable PLLFRACN . */
        __HAL_RCC_PLLFRACN_DISABLE();
 80078ce:	4b22      	ldr	r3, [pc, #136]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 80078d0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80078d2:	4a21      	ldr	r2, [pc, #132]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 80078d4:	f023 0301 	bic.w	r3, r3, #1
 80078d8:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* Configure PLL PLL1FRACN */
        __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 80078da:	4b1f      	ldr	r3, [pc, #124]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 80078dc:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 80078de:	4b21      	ldr	r3, [pc, #132]	@ (8007964 <HAL_RCC_OscConfig+0x778>)
 80078e0:	4013      	ands	r3, r2
 80078e2:	687a      	ldr	r2, [r7, #4]
 80078e4:	6c92      	ldr	r2, [r2, #72]	@ 0x48
 80078e6:	00d2      	lsls	r2, r2, #3
 80078e8:	491b      	ldr	r1, [pc, #108]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 80078ea:	4313      	orrs	r3, r2
 80078ec:	634b      	str	r3, [r1, #52]	@ 0x34

        /* Select PLL1 input reference frequency range: VCI */
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
 80078ee:	4b1a      	ldr	r3, [pc, #104]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 80078f0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80078f2:	f023 020c 	bic.w	r2, r3, #12
 80078f6:	687b      	ldr	r3, [r7, #4]
 80078f8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 80078fa:	4917      	ldr	r1, [pc, #92]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 80078fc:	4313      	orrs	r3, r2
 80078fe:	62cb      	str	r3, [r1, #44]	@ 0x2c

        /* Select PLL1 output frequency range : VCO */
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
 8007900:	4b15      	ldr	r3, [pc, #84]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007902:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007904:	f023 0202 	bic.w	r2, r3, #2
 8007908:	687b      	ldr	r3, [r7, #4]
 800790a:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800790c:	4912      	ldr	r1, [pc, #72]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 800790e:	4313      	orrs	r3, r2
 8007910:	62cb      	str	r3, [r1, #44]	@ 0x2c

        /* Enable PLL System Clock output. */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 8007912:	4b11      	ldr	r3, [pc, #68]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007914:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007916:	4a10      	ldr	r2, [pc, #64]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007918:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 800791c:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* Enable PLL1Q Clock output. */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800791e:	4b0e      	ldr	r3, [pc, #56]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007920:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007922:	4a0d      	ldr	r2, [pc, #52]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007924:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8007928:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* Enable PLL1R  Clock output. */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
 800792a:	4b0b      	ldr	r3, [pc, #44]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 800792c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800792e:	4a0a      	ldr	r2, [pc, #40]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007930:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8007934:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* Enable PLL1FRACN . */
        __HAL_RCC_PLLFRACN_ENABLE();
 8007936:	4b08      	ldr	r3, [pc, #32]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007938:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800793a:	4a07      	ldr	r2, [pc, #28]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 800793c:	f043 0301 	orr.w	r3, r3, #1
 8007940:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 8007942:	4b05      	ldr	r3, [pc, #20]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007944:	681b      	ldr	r3, [r3, #0]
 8007946:	4a04      	ldr	r2, [pc, #16]	@ (8007958 <HAL_RCC_OscConfig+0x76c>)
 8007948:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 800794c:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800794e:	f7fa fb11 	bl	8001f74 <HAL_GetTick>
 8007952:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 8007954:	e011      	b.n	800797a <HAL_RCC_OscConfig+0x78e>
 8007956:	bf00      	nop
 8007958:	58024400 	.word	0x58024400
 800795c:	58024800 	.word	0x58024800
 8007960:	fffffc0c 	.word	0xfffffc0c
 8007964:	ffff0007 	.word	0xffff0007
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8007968:	f7fa fb04 	bl	8001f74 <HAL_GetTick>
 800796c:	4602      	mov	r2, r0
 800796e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007970:	1ad3      	subs	r3, r2, r3
 8007972:	2b02      	cmp	r3, #2
 8007974:	d901      	bls.n	800797a <HAL_RCC_OscConfig+0x78e>
          {
            return HAL_TIMEOUT;
 8007976:	2303      	movs	r3, #3
 8007978:	e08a      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800797a:	4b47      	ldr	r3, [pc, #284]	@ (8007a98 <HAL_RCC_OscConfig+0x8ac>)
 800797c:	681b      	ldr	r3, [r3, #0]
 800797e:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8007982:	2b00      	cmp	r3, #0
 8007984:	d0f0      	beq.n	8007968 <HAL_RCC_OscConfig+0x77c>
 8007986:	e082      	b.n	8007a8e <HAL_RCC_OscConfig+0x8a2>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8007988:	4b43      	ldr	r3, [pc, #268]	@ (8007a98 <HAL_RCC_OscConfig+0x8ac>)
 800798a:	681b      	ldr	r3, [r3, #0]
 800798c:	4a42      	ldr	r2, [pc, #264]	@ (8007a98 <HAL_RCC_OscConfig+0x8ac>)
 800798e:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 8007992:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8007994:	f7fa faee 	bl	8001f74 <HAL_GetTick>
 8007998:	6278      	str	r0, [r7, #36]	@ 0x24

        /* Wait till PLL is disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800799a:	e008      	b.n	80079ae <HAL_RCC_OscConfig+0x7c2>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800799c:	f7fa faea 	bl	8001f74 <HAL_GetTick>
 80079a0:	4602      	mov	r2, r0
 80079a2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 80079a4:	1ad3      	subs	r3, r2, r3
 80079a6:	2b02      	cmp	r3, #2
 80079a8:	d901      	bls.n	80079ae <HAL_RCC_OscConfig+0x7c2>
          {
            return HAL_TIMEOUT;
 80079aa:	2303      	movs	r3, #3
 80079ac:	e070      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 80079ae:	4b3a      	ldr	r3, [pc, #232]	@ (8007a98 <HAL_RCC_OscConfig+0x8ac>)
 80079b0:	681b      	ldr	r3, [r3, #0]
 80079b2:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80079b6:	2b00      	cmp	r3, #0
 80079b8:	d1f0      	bne.n	800799c <HAL_RCC_OscConfig+0x7b0>
 80079ba:	e068      	b.n	8007a8e <HAL_RCC_OscConfig+0x8a2>
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      temp1_pllckcfg = RCC->PLLCKSELR;
 80079bc:	4b36      	ldr	r3, [pc, #216]	@ (8007a98 <HAL_RCC_OscConfig+0x8ac>)
 80079be:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 80079c0:	613b      	str	r3, [r7, #16]
      temp2_pllckcfg = RCC->PLL1DIVR;
 80079c2:	4b35      	ldr	r3, [pc, #212]	@ (8007a98 <HAL_RCC_OscConfig+0x8ac>)
 80079c4:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80079c6:	60fb      	str	r3, [r7, #12]
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80079c8:	687b      	ldr	r3, [r7, #4]
 80079ca:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 80079cc:	2b01      	cmp	r3, #1
 80079ce:	d031      	beq.n	8007a34 <HAL_RCC_OscConfig+0x848>
          (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80079d0:	693b      	ldr	r3, [r7, #16]
 80079d2:	f003 0203 	and.w	r2, r3, #3
 80079d6:	687b      	ldr	r3, [r7, #4]
 80079d8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 80079da:	429a      	cmp	r2, r3
 80079dc:	d12a      	bne.n	8007a34 <HAL_RCC_OscConfig+0x848>
          ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 80079de:	693b      	ldr	r3, [r7, #16]
 80079e0:	091b      	lsrs	r3, r3, #4
 80079e2:	f003 023f 	and.w	r2, r3, #63	@ 0x3f
 80079e6:	687b      	ldr	r3, [r7, #4]
 80079e8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
          (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 80079ea:	429a      	cmp	r2, r3
 80079ec:	d122      	bne.n	8007a34 <HAL_RCC_OscConfig+0x848>
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 80079ee:	68fb      	ldr	r3, [r7, #12]
 80079f0:	f3c3 0208 	ubfx	r2, r3, #0, #9
 80079f4:	687b      	ldr	r3, [r7, #4]
 80079f6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 80079f8:	3b01      	subs	r3, #1
          ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 80079fa:	429a      	cmp	r2, r3
 80079fc:	d11a      	bne.n	8007a34 <HAL_RCC_OscConfig+0x848>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 80079fe:	68fb      	ldr	r3, [r7, #12]
 8007a00:	0a5b      	lsrs	r3, r3, #9
 8007a02:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 8007a06:	687b      	ldr	r3, [r7, #4]
 8007a08:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8007a0a:	3b01      	subs	r3, #1
          (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 8007a0c:	429a      	cmp	r2, r3
 8007a0e:	d111      	bne.n	8007a34 <HAL_RCC_OscConfig+0x848>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 8007a10:	68fb      	ldr	r3, [r7, #12]
 8007a12:	0c1b      	lsrs	r3, r3, #16
 8007a14:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 8007a18:	687b      	ldr	r3, [r7, #4]
 8007a1a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8007a1c:	3b01      	subs	r3, #1
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 8007a1e:	429a      	cmp	r2, r3
 8007a20:	d108      	bne.n	8007a34 <HAL_RCC_OscConfig+0x848>
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
 8007a22:	68fb      	ldr	r3, [r7, #12]
 8007a24:	0e1b      	lsrs	r3, r3, #24
 8007a26:	f003 027f 	and.w	r2, r3, #127	@ 0x7f
 8007a2a:	687b      	ldr	r3, [r7, #4]
 8007a2c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8007a2e:	3b01      	subs	r3, #1
          ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 8007a30:	429a      	cmp	r2, r3
 8007a32:	d001      	beq.n	8007a38 <HAL_RCC_OscConfig+0x84c>
      {
        return HAL_ERROR;
 8007a34:	2301      	movs	r3, #1
 8007a36:	e02b      	b.n	8007a90 <HAL_RCC_OscConfig+0x8a4>
      }
      else
      {
        /* Check if only fractional part needs to be updated  */
        temp1_pllckcfg = ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> RCC_PLL1FRACR_FRACN1_Pos);
 8007a38:	4b17      	ldr	r3, [pc, #92]	@ (8007a98 <HAL_RCC_OscConfig+0x8ac>)
 8007a3a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8007a3c:	08db      	lsrs	r3, r3, #3
 8007a3e:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8007a42:	613b      	str	r3, [r7, #16]
        if (RCC_OscInitStruct->PLL.PLLFRACN != temp1_pllckcfg)
 8007a44:	687b      	ldr	r3, [r7, #4]
 8007a46:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8007a48:	693a      	ldr	r2, [r7, #16]
 8007a4a:	429a      	cmp	r2, r3
 8007a4c:	d01f      	beq.n	8007a8e <HAL_RCC_OscConfig+0x8a2>
        {
          assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
          /* Disable PLL1FRACEN */
          __HAL_RCC_PLLFRACN_DISABLE();
 8007a4e:	4b12      	ldr	r3, [pc, #72]	@ (8007a98 <HAL_RCC_OscConfig+0x8ac>)
 8007a50:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007a52:	4a11      	ldr	r2, [pc, #68]	@ (8007a98 <HAL_RCC_OscConfig+0x8ac>)
 8007a54:	f023 0301 	bic.w	r3, r3, #1
 8007a58:	62d3      	str	r3, [r2, #44]	@ 0x2c
          /* Get Start Tick*/
          tickstart = HAL_GetTick();
 8007a5a:	f7fa fa8b 	bl	8001f74 <HAL_GetTick>
 8007a5e:	6278      	str	r0, [r7, #36]	@ 0x24
          /* Wait at least 2 CK_REF (PLL input source divided by M) period to make sure next latched value will be taken into account. */
          while ((HAL_GetTick() - tickstart) < PLL_FRAC_TIMEOUT_VALUE)
 8007a60:	bf00      	nop
 8007a62:	f7fa fa87 	bl	8001f74 <HAL_GetTick>
 8007a66:	4602      	mov	r2, r0
 8007a68:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8007a6a:	4293      	cmp	r3, r2
 8007a6c:	d0f9      	beq.n	8007a62 <HAL_RCC_OscConfig+0x876>
          {
          }
          /* Configure PLL1 PLL1FRACN */
          __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 8007a6e:	4b0a      	ldr	r3, [pc, #40]	@ (8007a98 <HAL_RCC_OscConfig+0x8ac>)
 8007a70:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8007a72:	4b0a      	ldr	r3, [pc, #40]	@ (8007a9c <HAL_RCC_OscConfig+0x8b0>)
 8007a74:	4013      	ands	r3, r2
 8007a76:	687a      	ldr	r2, [r7, #4]
 8007a78:	6c92      	ldr	r2, [r2, #72]	@ 0x48
 8007a7a:	00d2      	lsls	r2, r2, #3
 8007a7c:	4906      	ldr	r1, [pc, #24]	@ (8007a98 <HAL_RCC_OscConfig+0x8ac>)
 8007a7e:	4313      	orrs	r3, r2
 8007a80:	634b      	str	r3, [r1, #52]	@ 0x34
          /* Enable PLL1FRACEN to latch new value. */
          __HAL_RCC_PLLFRACN_ENABLE();
 8007a82:	4b05      	ldr	r3, [pc, #20]	@ (8007a98 <HAL_RCC_OscConfig+0x8ac>)
 8007a84:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007a86:	4a04      	ldr	r2, [pc, #16]	@ (8007a98 <HAL_RCC_OscConfig+0x8ac>)
 8007a88:	f043 0301 	orr.w	r3, r3, #1
 8007a8c:	62d3      	str	r3, [r2, #44]	@ 0x2c
        }
      }
    }
  }
  return HAL_OK;
 8007a8e:	2300      	movs	r3, #0
}
 8007a90:	4618      	mov	r0, r3
 8007a92:	3730      	adds	r7, #48	@ 0x30
 8007a94:	46bd      	mov	sp, r7
 8007a96:	bd80      	pop	{r7, pc}
 8007a98:	58024400 	.word	0x58024400
 8007a9c:	ffff0007 	.word	0xffff0007

08007aa0 <HAL_RCC_ClockConfig>:
  *         D1CPRE[3:0] bits to ensure that  Domain1 core clock not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(const RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8007aa0:	b580      	push	{r7, lr}
 8007aa2:	b086      	sub	sp, #24
 8007aa4:	af00      	add	r7, sp, #0
 8007aa6:	6078      	str	r0, [r7, #4]
 8007aa8:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef halstatus;
  uint32_t tickstart;
  uint32_t common_system_clock;

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
 8007aaa:	687b      	ldr	r3, [r7, #4]
 8007aac:	2b00      	cmp	r3, #0
 8007aae:	d101      	bne.n	8007ab4 <HAL_RCC_ClockConfig+0x14>
  {
    return HAL_ERROR;
 8007ab0:	2301      	movs	r3, #1
 8007ab2:	e19c      	b.n	8007dee <HAL_RCC_ClockConfig+0x34e>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
    must be correctly programmed according to the frequency of the CPU clock
    (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8007ab4:	4b8a      	ldr	r3, [pc, #552]	@ (8007ce0 <HAL_RCC_ClockConfig+0x240>)
 8007ab6:	681b      	ldr	r3, [r3, #0]
 8007ab8:	f003 030f 	and.w	r3, r3, #15
 8007abc:	683a      	ldr	r2, [r7, #0]
 8007abe:	429a      	cmp	r2, r3
 8007ac0:	d910      	bls.n	8007ae4 <HAL_RCC_ClockConfig+0x44>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8007ac2:	4b87      	ldr	r3, [pc, #540]	@ (8007ce0 <HAL_RCC_ClockConfig+0x240>)
 8007ac4:	681b      	ldr	r3, [r3, #0]
 8007ac6:	f023 020f 	bic.w	r2, r3, #15
 8007aca:	4985      	ldr	r1, [pc, #532]	@ (8007ce0 <HAL_RCC_ClockConfig+0x240>)
 8007acc:	683b      	ldr	r3, [r7, #0]
 8007ace:	4313      	orrs	r3, r2
 8007ad0:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8007ad2:	4b83      	ldr	r3, [pc, #524]	@ (8007ce0 <HAL_RCC_ClockConfig+0x240>)
 8007ad4:	681b      	ldr	r3, [r3, #0]
 8007ad6:	f003 030f 	and.w	r3, r3, #15
 8007ada:	683a      	ldr	r2, [r7, #0]
 8007adc:	429a      	cmp	r2, r3
 8007ade:	d001      	beq.n	8007ae4 <HAL_RCC_ClockConfig+0x44>
    {
      return HAL_ERROR;
 8007ae0:	2301      	movs	r3, #1
 8007ae2:	e184      	b.n	8007dee <HAL_RCC_ClockConfig+0x34e>

  }

  /* Increasing the BUS frequency divider */
  /*-------------------------- D1PCLK1/CDPCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 8007ae4:	687b      	ldr	r3, [r7, #4]
 8007ae6:	681b      	ldr	r3, [r3, #0]
 8007ae8:	f003 0304 	and.w	r3, r3, #4
 8007aec:	2b00      	cmp	r3, #0
 8007aee:	d010      	beq.n	8007b12 <HAL_RCC_ClockConfig+0x72>
  {
#if defined (RCC_D1CFGR_D1PPRE)
    if ((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 8007af0:	687b      	ldr	r3, [r7, #4]
 8007af2:	691a      	ldr	r2, [r3, #16]
 8007af4:	4b7b      	ldr	r3, [pc, #492]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007af6:	699b      	ldr	r3, [r3, #24]
 8007af8:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8007afc:	429a      	cmp	r2, r3
 8007afe:	d908      	bls.n	8007b12 <HAL_RCC_ClockConfig+0x72>
    {
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 8007b00:	4b78      	ldr	r3, [pc, #480]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007b02:	699b      	ldr	r3, [r3, #24]
 8007b04:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 8007b08:	687b      	ldr	r3, [r7, #4]
 8007b0a:	691b      	ldr	r3, [r3, #16]
 8007b0c:	4975      	ldr	r1, [pc, #468]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007b0e:	4313      	orrs	r3, r2
 8007b10:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8007b12:	687b      	ldr	r3, [r7, #4]
 8007b14:	681b      	ldr	r3, [r3, #0]
 8007b16:	f003 0308 	and.w	r3, r3, #8
 8007b1a:	2b00      	cmp	r3, #0
 8007b1c:	d010      	beq.n	8007b40 <HAL_RCC_ClockConfig+0xa0>
  {
#if defined (RCC_D2CFGR_D2PPRE1)
    if ((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 8007b1e:	687b      	ldr	r3, [r7, #4]
 8007b20:	695a      	ldr	r2, [r3, #20]
 8007b22:	4b70      	ldr	r3, [pc, #448]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007b24:	69db      	ldr	r3, [r3, #28]
 8007b26:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8007b2a:	429a      	cmp	r2, r3
 8007b2c:	d908      	bls.n	8007b40 <HAL_RCC_ClockConfig+0xa0>
    {
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 8007b2e:	4b6d      	ldr	r3, [pc, #436]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007b30:	69db      	ldr	r3, [r3, #28]
 8007b32:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 8007b36:	687b      	ldr	r3, [r7, #4]
 8007b38:	695b      	ldr	r3, [r3, #20]
 8007b3a:	496a      	ldr	r1, [pc, #424]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007b3c:	4313      	orrs	r3, r2
 8007b3e:	61cb      	str	r3, [r1, #28]
      MODIFY_REG(RCC->CDCFGR2, RCC_CDCFGR2_CDPPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
    }
#endif
  }
  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8007b40:	687b      	ldr	r3, [r7, #4]
 8007b42:	681b      	ldr	r3, [r3, #0]
 8007b44:	f003 0310 	and.w	r3, r3, #16
 8007b48:	2b00      	cmp	r3, #0
 8007b4a:	d010      	beq.n	8007b6e <HAL_RCC_ClockConfig+0xce>
  {
#if defined(RCC_D2CFGR_D2PPRE2)
    if ((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 8007b4c:	687b      	ldr	r3, [r7, #4]
 8007b4e:	699a      	ldr	r2, [r3, #24]
 8007b50:	4b64      	ldr	r3, [pc, #400]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007b52:	69db      	ldr	r3, [r3, #28]
 8007b54:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 8007b58:	429a      	cmp	r2, r3
 8007b5a:	d908      	bls.n	8007b6e <HAL_RCC_ClockConfig+0xce>
    {
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 8007b5c:	4b61      	ldr	r3, [pc, #388]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007b5e:	69db      	ldr	r3, [r3, #28]
 8007b60:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
 8007b64:	687b      	ldr	r3, [r7, #4]
 8007b66:	699b      	ldr	r3, [r3, #24]
 8007b68:	495e      	ldr	r1, [pc, #376]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007b6a:	4313      	orrs	r3, r2
 8007b6c:	61cb      	str	r3, [r1, #28]
    }
#endif
  }

  /*-------------------------- D3PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 8007b6e:	687b      	ldr	r3, [r7, #4]
 8007b70:	681b      	ldr	r3, [r3, #0]
 8007b72:	f003 0320 	and.w	r3, r3, #32
 8007b76:	2b00      	cmp	r3, #0
 8007b78:	d010      	beq.n	8007b9c <HAL_RCC_ClockConfig+0xfc>
  {
#if defined(RCC_D3CFGR_D3PPRE)
    if ((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 8007b7a:	687b      	ldr	r3, [r7, #4]
 8007b7c:	69da      	ldr	r2, [r3, #28]
 8007b7e:	4b59      	ldr	r3, [pc, #356]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007b80:	6a1b      	ldr	r3, [r3, #32]
 8007b82:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8007b86:	429a      	cmp	r2, r3
 8007b88:	d908      	bls.n	8007b9c <HAL_RCC_ClockConfig+0xfc>
    {
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider));
 8007b8a:	4b56      	ldr	r3, [pc, #344]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007b8c:	6a1b      	ldr	r3, [r3, #32]
 8007b8e:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 8007b92:	687b      	ldr	r3, [r7, #4]
 8007b94:	69db      	ldr	r3, [r3, #28]
 8007b96:	4953      	ldr	r1, [pc, #332]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007b98:	4313      	orrs	r3, r2
 8007b9a:	620b      	str	r3, [r1, #32]
    }
#endif
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8007b9c:	687b      	ldr	r3, [r7, #4]
 8007b9e:	681b      	ldr	r3, [r3, #0]
 8007ba0:	f003 0302 	and.w	r3, r3, #2
 8007ba4:	2b00      	cmp	r3, #0
 8007ba6:	d010      	beq.n	8007bca <HAL_RCC_ClockConfig+0x12a>
  {
#if defined (RCC_D1CFGR_HPRE)
    if ((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 8007ba8:	687b      	ldr	r3, [r7, #4]
 8007baa:	68da      	ldr	r2, [r3, #12]
 8007bac:	4b4d      	ldr	r3, [pc, #308]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007bae:	699b      	ldr	r3, [r3, #24]
 8007bb0:	f003 030f 	and.w	r3, r3, #15
 8007bb4:	429a      	cmp	r2, r3
 8007bb6:	d908      	bls.n	8007bca <HAL_RCC_ClockConfig+0x12a>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8007bb8:	4b4a      	ldr	r3, [pc, #296]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007bba:	699b      	ldr	r3, [r3, #24]
 8007bbc:	f023 020f 	bic.w	r2, r3, #15
 8007bc0:	687b      	ldr	r3, [r7, #4]
 8007bc2:	68db      	ldr	r3, [r3, #12]
 8007bc4:	4947      	ldr	r1, [pc, #284]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007bc6:	4313      	orrs	r3, r2
 8007bc8:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /*------------------------- SYSCLK Configuration -------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8007bca:	687b      	ldr	r3, [r7, #4]
 8007bcc:	681b      	ldr	r3, [r3, #0]
 8007bce:	f003 0301 	and.w	r3, r3, #1
 8007bd2:	2b00      	cmp	r3, #0
 8007bd4:	d055      	beq.n	8007c82 <HAL_RCC_ClockConfig+0x1e2>
  {
    assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
#if defined(RCC_D1CFGR_D1CPRE)
    MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
 8007bd6:	4b43      	ldr	r3, [pc, #268]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007bd8:	699b      	ldr	r3, [r3, #24]
 8007bda:	f423 6270 	bic.w	r2, r3, #3840	@ 0xf00
 8007bde:	687b      	ldr	r3, [r7, #4]
 8007be0:	689b      	ldr	r3, [r3, #8]
 8007be2:	4940      	ldr	r1, [pc, #256]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007be4:	4313      	orrs	r3, r2
 8007be6:	618b      	str	r3, [r1, #24]
#else
    MODIFY_REG(RCC->CDCFGR1, RCC_CDCFGR1_CDCPRE, RCC_ClkInitStruct->SYSCLKDivider);
#endif
    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8007be8:	687b      	ldr	r3, [r7, #4]
 8007bea:	685b      	ldr	r3, [r3, #4]
 8007bec:	2b02      	cmp	r3, #2
 8007bee:	d107      	bne.n	8007c00 <HAL_RCC_ClockConfig+0x160>
    {
      /* Check the HSE ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8007bf0:	4b3c      	ldr	r3, [pc, #240]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007bf2:	681b      	ldr	r3, [r3, #0]
 8007bf4:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8007bf8:	2b00      	cmp	r3, #0
 8007bfa:	d121      	bne.n	8007c40 <HAL_RCC_ClockConfig+0x1a0>
      {
        return HAL_ERROR;
 8007bfc:	2301      	movs	r3, #1
 8007bfe:	e0f6      	b.n	8007dee <HAL_RCC_ClockConfig+0x34e>
      }
    }
    /* PLL is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8007c00:	687b      	ldr	r3, [r7, #4]
 8007c02:	685b      	ldr	r3, [r3, #4]
 8007c04:	2b03      	cmp	r3, #3
 8007c06:	d107      	bne.n	8007c18 <HAL_RCC_ClockConfig+0x178>
    {
      /* Check the PLL ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 8007c08:	4b36      	ldr	r3, [pc, #216]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007c0a:	681b      	ldr	r3, [r3, #0]
 8007c0c:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8007c10:	2b00      	cmp	r3, #0
 8007c12:	d115      	bne.n	8007c40 <HAL_RCC_ClockConfig+0x1a0>
      {
        return HAL_ERROR;
 8007c14:	2301      	movs	r3, #1
 8007c16:	e0ea      	b.n	8007dee <HAL_RCC_ClockConfig+0x34e>
      }
    }
    /* CSI is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
 8007c18:	687b      	ldr	r3, [r7, #4]
 8007c1a:	685b      	ldr	r3, [r3, #4]
 8007c1c:	2b01      	cmp	r3, #1
 8007c1e:	d107      	bne.n	8007c30 <HAL_RCC_ClockConfig+0x190>
    {
      /* Check the PLL ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 8007c20:	4b30      	ldr	r3, [pc, #192]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007c22:	681b      	ldr	r3, [r3, #0]
 8007c24:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8007c28:	2b00      	cmp	r3, #0
 8007c2a:	d109      	bne.n	8007c40 <HAL_RCC_ClockConfig+0x1a0>
      {
        return HAL_ERROR;
 8007c2c:	2301      	movs	r3, #1
 8007c2e:	e0de      	b.n	8007dee <HAL_RCC_ClockConfig+0x34e>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8007c30:	4b2c      	ldr	r3, [pc, #176]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007c32:	681b      	ldr	r3, [r3, #0]
 8007c34:	f003 0304 	and.w	r3, r3, #4
 8007c38:	2b00      	cmp	r3, #0
 8007c3a:	d101      	bne.n	8007c40 <HAL_RCC_ClockConfig+0x1a0>
      {
        return HAL_ERROR;
 8007c3c:	2301      	movs	r3, #1
 8007c3e:	e0d6      	b.n	8007dee <HAL_RCC_ClockConfig+0x34e>
      }
    }
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8007c40:	4b28      	ldr	r3, [pc, #160]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007c42:	691b      	ldr	r3, [r3, #16]
 8007c44:	f023 0207 	bic.w	r2, r3, #7
 8007c48:	687b      	ldr	r3, [r7, #4]
 8007c4a:	685b      	ldr	r3, [r3, #4]
 8007c4c:	4925      	ldr	r1, [pc, #148]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007c4e:	4313      	orrs	r3, r2
 8007c50:	610b      	str	r3, [r1, #16]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8007c52:	f7fa f98f 	bl	8001f74 <HAL_GetTick>
 8007c56:	6178      	str	r0, [r7, #20]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8007c58:	e00a      	b.n	8007c70 <HAL_RCC_ClockConfig+0x1d0>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8007c5a:	f7fa f98b 	bl	8001f74 <HAL_GetTick>
 8007c5e:	4602      	mov	r2, r0
 8007c60:	697b      	ldr	r3, [r7, #20]
 8007c62:	1ad3      	subs	r3, r2, r3
 8007c64:	f241 3288 	movw	r2, #5000	@ 0x1388
 8007c68:	4293      	cmp	r3, r2
 8007c6a:	d901      	bls.n	8007c70 <HAL_RCC_ClockConfig+0x1d0>
      {
        return HAL_TIMEOUT;
 8007c6c:	2303      	movs	r3, #3
 8007c6e:	e0be      	b.n	8007dee <HAL_RCC_ClockConfig+0x34e>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8007c70:	4b1c      	ldr	r3, [pc, #112]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007c72:	691b      	ldr	r3, [r3, #16]
 8007c74:	f003 0238 	and.w	r2, r3, #56	@ 0x38
 8007c78:	687b      	ldr	r3, [r7, #4]
 8007c7a:	685b      	ldr	r3, [r3, #4]
 8007c7c:	00db      	lsls	r3, r3, #3
 8007c7e:	429a      	cmp	r2, r3
 8007c80:	d1eb      	bne.n	8007c5a <HAL_RCC_ClockConfig+0x1ba>

  }

  /* Decreasing the BUS frequency divider */
  /*-------------------------- HCLK Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8007c82:	687b      	ldr	r3, [r7, #4]
 8007c84:	681b      	ldr	r3, [r3, #0]
 8007c86:	f003 0302 	and.w	r3, r3, #2
 8007c8a:	2b00      	cmp	r3, #0
 8007c8c:	d010      	beq.n	8007cb0 <HAL_RCC_ClockConfig+0x210>
  {
#if defined(RCC_D1CFGR_HPRE)
    if ((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 8007c8e:	687b      	ldr	r3, [r7, #4]
 8007c90:	68da      	ldr	r2, [r3, #12]
 8007c92:	4b14      	ldr	r3, [pc, #80]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007c94:	699b      	ldr	r3, [r3, #24]
 8007c96:	f003 030f 	and.w	r3, r3, #15
 8007c9a:	429a      	cmp	r2, r3
 8007c9c:	d208      	bcs.n	8007cb0 <HAL_RCC_ClockConfig+0x210>
    {
      /* Set the new HCLK clock divider */
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8007c9e:	4b11      	ldr	r3, [pc, #68]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007ca0:	699b      	ldr	r3, [r3, #24]
 8007ca2:	f023 020f 	bic.w	r2, r3, #15
 8007ca6:	687b      	ldr	r3, [r7, #4]
 8007ca8:	68db      	ldr	r3, [r3, #12]
 8007caa:	490e      	ldr	r1, [pc, #56]	@ (8007ce4 <HAL_RCC_ClockConfig+0x244>)
 8007cac:	4313      	orrs	r3, r2
 8007cae:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8007cb0:	4b0b      	ldr	r3, [pc, #44]	@ (8007ce0 <HAL_RCC_ClockConfig+0x240>)
 8007cb2:	681b      	ldr	r3, [r3, #0]
 8007cb4:	f003 030f 	and.w	r3, r3, #15
 8007cb8:	683a      	ldr	r2, [r7, #0]
 8007cba:	429a      	cmp	r2, r3
 8007cbc:	d214      	bcs.n	8007ce8 <HAL_RCC_ClockConfig+0x248>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8007cbe:	4b08      	ldr	r3, [pc, #32]	@ (8007ce0 <HAL_RCC_ClockConfig+0x240>)
 8007cc0:	681b      	ldr	r3, [r3, #0]
 8007cc2:	f023 020f 	bic.w	r2, r3, #15
 8007cc6:	4906      	ldr	r1, [pc, #24]	@ (8007ce0 <HAL_RCC_ClockConfig+0x240>)
 8007cc8:	683b      	ldr	r3, [r7, #0]
 8007cca:	4313      	orrs	r3, r2
 8007ccc:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8007cce:	4b04      	ldr	r3, [pc, #16]	@ (8007ce0 <HAL_RCC_ClockConfig+0x240>)
 8007cd0:	681b      	ldr	r3, [r3, #0]
 8007cd2:	f003 030f 	and.w	r3, r3, #15
 8007cd6:	683a      	ldr	r2, [r7, #0]
 8007cd8:	429a      	cmp	r2, r3
 8007cda:	d005      	beq.n	8007ce8 <HAL_RCC_ClockConfig+0x248>
    {
      return HAL_ERROR;
 8007cdc:	2301      	movs	r3, #1
 8007cde:	e086      	b.n	8007dee <HAL_RCC_ClockConfig+0x34e>
 8007ce0:	52002000 	.word	0x52002000
 8007ce4:	58024400 	.word	0x58024400
    }
  }

  /*-------------------------- D1PCLK1/CDPCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 8007ce8:	687b      	ldr	r3, [r7, #4]
 8007cea:	681b      	ldr	r3, [r3, #0]
 8007cec:	f003 0304 	and.w	r3, r3, #4
 8007cf0:	2b00      	cmp	r3, #0
 8007cf2:	d010      	beq.n	8007d16 <HAL_RCC_ClockConfig+0x276>
  {
#if defined(RCC_D1CFGR_D1PPRE)
    if ((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 8007cf4:	687b      	ldr	r3, [r7, #4]
 8007cf6:	691a      	ldr	r2, [r3, #16]
 8007cf8:	4b3f      	ldr	r3, [pc, #252]	@ (8007df8 <HAL_RCC_ClockConfig+0x358>)
 8007cfa:	699b      	ldr	r3, [r3, #24]
 8007cfc:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8007d00:	429a      	cmp	r2, r3
 8007d02:	d208      	bcs.n	8007d16 <HAL_RCC_ClockConfig+0x276>
    {
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 8007d04:	4b3c      	ldr	r3, [pc, #240]	@ (8007df8 <HAL_RCC_ClockConfig+0x358>)
 8007d06:	699b      	ldr	r3, [r3, #24]
 8007d08:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 8007d0c:	687b      	ldr	r3, [r7, #4]
 8007d0e:	691b      	ldr	r3, [r3, #16]
 8007d10:	4939      	ldr	r1, [pc, #228]	@ (8007df8 <HAL_RCC_ClockConfig+0x358>)
 8007d12:	4313      	orrs	r3, r2
 8007d14:	618b      	str	r3, [r1, #24]
    }
#endif
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8007d16:	687b      	ldr	r3, [r7, #4]
 8007d18:	681b      	ldr	r3, [r3, #0]
 8007d1a:	f003 0308 	and.w	r3, r3, #8
 8007d1e:	2b00      	cmp	r3, #0
 8007d20:	d010      	beq.n	8007d44 <HAL_RCC_ClockConfig+0x2a4>
  {
#if defined(RCC_D2CFGR_D2PPRE1)
    if ((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 8007d22:	687b      	ldr	r3, [r7, #4]
 8007d24:	695a      	ldr	r2, [r3, #20]
 8007d26:	4b34      	ldr	r3, [pc, #208]	@ (8007df8 <HAL_RCC_ClockConfig+0x358>)
 8007d28:	69db      	ldr	r3, [r3, #28]
 8007d2a:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8007d2e:	429a      	cmp	r2, r3
 8007d30:	d208      	bcs.n	8007d44 <HAL_RCC_ClockConfig+0x2a4>
    {
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 8007d32:	4b31      	ldr	r3, [pc, #196]	@ (8007df8 <HAL_RCC_ClockConfig+0x358>)
 8007d34:	69db      	ldr	r3, [r3, #28]
 8007d36:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 8007d3a:	687b      	ldr	r3, [r7, #4]
 8007d3c:	695b      	ldr	r3, [r3, #20]
 8007d3e:	492e      	ldr	r1, [pc, #184]	@ (8007df8 <HAL_RCC_ClockConfig+0x358>)
 8007d40:	4313      	orrs	r3, r2
 8007d42:	61cb      	str	r3, [r1, #28]
    }
#endif
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8007d44:	687b      	ldr	r3, [r7, #4]
 8007d46:	681b      	ldr	r3, [r3, #0]
 8007d48:	f003 0310 	and.w	r3, r3, #16
 8007d4c:	2b00      	cmp	r3, #0
 8007d4e:	d010      	beq.n	8007d72 <HAL_RCC_ClockConfig+0x2d2>
  {
#if defined (RCC_D2CFGR_D2PPRE2)
    if ((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 8007d50:	687b      	ldr	r3, [r7, #4]
 8007d52:	699a      	ldr	r2, [r3, #24]
 8007d54:	4b28      	ldr	r3, [pc, #160]	@ (8007df8 <HAL_RCC_ClockConfig+0x358>)
 8007d56:	69db      	ldr	r3, [r3, #28]
 8007d58:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 8007d5c:	429a      	cmp	r2, r3
 8007d5e:	d208      	bcs.n	8007d72 <HAL_RCC_ClockConfig+0x2d2>
    {
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 8007d60:	4b25      	ldr	r3, [pc, #148]	@ (8007df8 <HAL_RCC_ClockConfig+0x358>)
 8007d62:	69db      	ldr	r3, [r3, #28]
 8007d64:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
 8007d68:	687b      	ldr	r3, [r7, #4]
 8007d6a:	699b      	ldr	r3, [r3, #24]
 8007d6c:	4922      	ldr	r1, [pc, #136]	@ (8007df8 <HAL_RCC_ClockConfig+0x358>)
 8007d6e:	4313      	orrs	r3, r2
 8007d70:	61cb      	str	r3, [r1, #28]
    }
#endif
  }

  /*-------------------------- D3PCLK1/SRDPCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 8007d72:	687b      	ldr	r3, [r7, #4]
 8007d74:	681b      	ldr	r3, [r3, #0]
 8007d76:	f003 0320 	and.w	r3, r3, #32
 8007d7a:	2b00      	cmp	r3, #0
 8007d7c:	d010      	beq.n	8007da0 <HAL_RCC_ClockConfig+0x300>
  {
#if defined(RCC_D3CFGR_D3PPRE)
    if ((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 8007d7e:	687b      	ldr	r3, [r7, #4]
 8007d80:	69da      	ldr	r2, [r3, #28]
 8007d82:	4b1d      	ldr	r3, [pc, #116]	@ (8007df8 <HAL_RCC_ClockConfig+0x358>)
 8007d84:	6a1b      	ldr	r3, [r3, #32]
 8007d86:	f003 0370 	and.w	r3, r3, #112	@ 0x70
 8007d8a:	429a      	cmp	r2, r3
 8007d8c:	d208      	bcs.n	8007da0 <HAL_RCC_ClockConfig+0x300>
    {
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider));
 8007d8e:	4b1a      	ldr	r3, [pc, #104]	@ (8007df8 <HAL_RCC_ClockConfig+0x358>)
 8007d90:	6a1b      	ldr	r3, [r3, #32]
 8007d92:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
 8007d96:	687b      	ldr	r3, [r7, #4]
 8007d98:	69db      	ldr	r3, [r3, #28]
 8007d9a:	4917      	ldr	r1, [pc, #92]	@ (8007df8 <HAL_RCC_ClockConfig+0x358>)
 8007d9c:	4313      	orrs	r3, r2
 8007d9e:	620b      	str	r3, [r1, #32]
#endif
  }

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8007da0:	f000 f834 	bl	8007e0c <HAL_RCC_GetSysClockFreq>
 8007da4:	4602      	mov	r2, r0
 8007da6:	4b14      	ldr	r3, [pc, #80]	@ (8007df8 <HAL_RCC_ClockConfig+0x358>)
 8007da8:	699b      	ldr	r3, [r3, #24]
 8007daa:	0a1b      	lsrs	r3, r3, #8
 8007dac:	f003 030f 	and.w	r3, r3, #15
 8007db0:	4912      	ldr	r1, [pc, #72]	@ (8007dfc <HAL_RCC_ClockConfig+0x35c>)
 8007db2:	5ccb      	ldrb	r3, [r1, r3]
 8007db4:	f003 031f 	and.w	r3, r3, #31
 8007db8:	fa22 f303 	lsr.w	r3, r2, r3
 8007dbc:	613b      	str	r3, [r7, #16]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE) >> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8007dbe:	4b0e      	ldr	r3, [pc, #56]	@ (8007df8 <HAL_RCC_ClockConfig+0x358>)
 8007dc0:	699b      	ldr	r3, [r3, #24]
 8007dc2:	f003 030f 	and.w	r3, r3, #15
 8007dc6:	4a0d      	ldr	r2, [pc, #52]	@ (8007dfc <HAL_RCC_ClockConfig+0x35c>)
 8007dc8:	5cd3      	ldrb	r3, [r2, r3]
 8007dca:	f003 031f 	and.w	r3, r3, #31
 8007dce:	693a      	ldr	r2, [r7, #16]
 8007dd0:	fa22 f303 	lsr.w	r3, r2, r3
 8007dd4:	4a0a      	ldr	r2, [pc, #40]	@ (8007e00 <HAL_RCC_ClockConfig+0x360>)
 8007dd6:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 8007dd8:	4a0a      	ldr	r2, [pc, #40]	@ (8007e04 <HAL_RCC_ClockConfig+0x364>)
 8007dda:	693b      	ldr	r3, [r7, #16]
 8007ddc:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  /* Configure the source of time base considering new system clocks settings*/
  halstatus = HAL_InitTick(uwTickPrio);
 8007dde:	4b0a      	ldr	r3, [pc, #40]	@ (8007e08 <HAL_RCC_ClockConfig+0x368>)
 8007de0:	681b      	ldr	r3, [r3, #0]
 8007de2:	4618      	mov	r0, r3
 8007de4:	f7f9 fd14 	bl	8001810 <HAL_InitTick>
 8007de8:	4603      	mov	r3, r0
 8007dea:	73fb      	strb	r3, [r7, #15]

  return halstatus;
 8007dec:	7bfb      	ldrb	r3, [r7, #15]
}
 8007dee:	4618      	mov	r0, r3
 8007df0:	3718      	adds	r7, #24
 8007df2:	46bd      	mov	sp, r7
 8007df4:	bd80      	pop	{r7, pc}
 8007df6:	bf00      	nop
 8007df8:	58024400 	.word	0x58024400
 8007dfc:	0801860c 	.word	0x0801860c
 8007e00:	24000004 	.word	0x24000004
 8007e04:	24000000 	.word	0x24000000
 8007e08:	24000020 	.word	0x24000020

08007e0c <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8007e0c:	b480      	push	{r7}
 8007e0e:	b089      	sub	sp, #36	@ 0x24
 8007e10:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
 8007e12:	4bb3      	ldr	r3, [pc, #716]	@ (80080e0 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8007e14:	691b      	ldr	r3, [r3, #16]
 8007e16:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 8007e1a:	2b18      	cmp	r3, #24
 8007e1c:	f200 8155 	bhi.w	80080ca <HAL_RCC_GetSysClockFreq+0x2be>
 8007e20:	a201      	add	r2, pc, #4	@ (adr r2, 8007e28 <HAL_RCC_GetSysClockFreq+0x1c>)
 8007e22:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8007e26:	bf00      	nop
 8007e28:	08007e8d 	.word	0x08007e8d
 8007e2c:	080080cb 	.word	0x080080cb
 8007e30:	080080cb 	.word	0x080080cb
 8007e34:	080080cb 	.word	0x080080cb
 8007e38:	080080cb 	.word	0x080080cb
 8007e3c:	080080cb 	.word	0x080080cb
 8007e40:	080080cb 	.word	0x080080cb
 8007e44:	080080cb 	.word	0x080080cb
 8007e48:	08007eb3 	.word	0x08007eb3
 8007e4c:	080080cb 	.word	0x080080cb
 8007e50:	080080cb 	.word	0x080080cb
 8007e54:	080080cb 	.word	0x080080cb
 8007e58:	080080cb 	.word	0x080080cb
 8007e5c:	080080cb 	.word	0x080080cb
 8007e60:	080080cb 	.word	0x080080cb
 8007e64:	080080cb 	.word	0x080080cb
 8007e68:	08007eb9 	.word	0x08007eb9
 8007e6c:	080080cb 	.word	0x080080cb
 8007e70:	080080cb 	.word	0x080080cb
 8007e74:	080080cb 	.word	0x080080cb
 8007e78:	080080cb 	.word	0x080080cb
 8007e7c:	080080cb 	.word	0x080080cb
 8007e80:	080080cb 	.word	0x080080cb
 8007e84:	080080cb 	.word	0x080080cb
 8007e88:	08007ebf 	.word	0x08007ebf
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8007e8c:	4b94      	ldr	r3, [pc, #592]	@ (80080e0 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8007e8e:	681b      	ldr	r3, [r3, #0]
 8007e90:	f003 0320 	and.w	r3, r3, #32
 8007e94:	2b00      	cmp	r3, #0
 8007e96:	d009      	beq.n	8007eac <HAL_RCC_GetSysClockFreq+0xa0>
      {
        sysclockfreq = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8007e98:	4b91      	ldr	r3, [pc, #580]	@ (80080e0 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8007e9a:	681b      	ldr	r3, [r3, #0]
 8007e9c:	08db      	lsrs	r3, r3, #3
 8007e9e:	f003 0303 	and.w	r3, r3, #3
 8007ea2:	4a90      	ldr	r2, [pc, #576]	@ (80080e4 <HAL_RCC_GetSysClockFreq+0x2d8>)
 8007ea4:	fa22 f303 	lsr.w	r3, r2, r3
 8007ea8:	61bb      	str	r3, [r7, #24]
      else
      {
        sysclockfreq = (uint32_t) HSI_VALUE;
      }

      break;
 8007eaa:	e111      	b.n	80080d0 <HAL_RCC_GetSysClockFreq+0x2c4>
        sysclockfreq = (uint32_t) HSI_VALUE;
 8007eac:	4b8d      	ldr	r3, [pc, #564]	@ (80080e4 <HAL_RCC_GetSysClockFreq+0x2d8>)
 8007eae:	61bb      	str	r3, [r7, #24]
      break;
 8007eb0:	e10e      	b.n	80080d0 <HAL_RCC_GetSysClockFreq+0x2c4>

    case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
      sysclockfreq = CSI_VALUE;
 8007eb2:	4b8d      	ldr	r3, [pc, #564]	@ (80080e8 <HAL_RCC_GetSysClockFreq+0x2dc>)
 8007eb4:	61bb      	str	r3, [r7, #24]
      break;
 8007eb6:	e10b      	b.n	80080d0 <HAL_RCC_GetSysClockFreq+0x2c4>

    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
      sysclockfreq = HSE_VALUE;
 8007eb8:	4b8c      	ldr	r3, [pc, #560]	@ (80080ec <HAL_RCC_GetSysClockFreq+0x2e0>)
 8007eba:	61bb      	str	r3, [r7, #24]
      break;
 8007ebc:	e108      	b.n	80080d0 <HAL_RCC_GetSysClockFreq+0x2c4>
    case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLR
      */
      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8007ebe:	4b88      	ldr	r3, [pc, #544]	@ (80080e0 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8007ec0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8007ec2:	f003 0303 	and.w	r3, r3, #3
 8007ec6:	617b      	str	r3, [r7, #20]
      pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4)  ;
 8007ec8:	4b85      	ldr	r3, [pc, #532]	@ (80080e0 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8007eca:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8007ecc:	091b      	lsrs	r3, r3, #4
 8007ece:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8007ed2:	613b      	str	r3, [r7, #16]
      pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);
 8007ed4:	4b82      	ldr	r3, [pc, #520]	@ (80080e0 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8007ed6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8007ed8:	f003 0301 	and.w	r3, r3, #1
 8007edc:	60fb      	str	r3, [r7, #12]
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 8007ede:	4b80      	ldr	r3, [pc, #512]	@ (80080e0 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8007ee0:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8007ee2:	08db      	lsrs	r3, r3, #3
 8007ee4:	f3c3 030c 	ubfx	r3, r3, #0, #13
 8007ee8:	68fa      	ldr	r2, [r7, #12]
 8007eea:	fb02 f303 	mul.w	r3, r2, r3
 8007eee:	ee07 3a90 	vmov	s15, r3
 8007ef2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8007ef6:	edc7 7a02 	vstr	s15, [r7, #8]

      if (pllm != 0U)
 8007efa:	693b      	ldr	r3, [r7, #16]
 8007efc:	2b00      	cmp	r3, #0
 8007efe:	f000 80e1 	beq.w	80080c4 <HAL_RCC_GetSysClockFreq+0x2b8>
 8007f02:	697b      	ldr	r3, [r7, #20]
 8007f04:	2b02      	cmp	r3, #2
 8007f06:	f000 8083 	beq.w	8008010 <HAL_RCC_GetSysClockFreq+0x204>
 8007f0a:	697b      	ldr	r3, [r7, #20]
 8007f0c:	2b02      	cmp	r3, #2
 8007f0e:	f200 80a1 	bhi.w	8008054 <HAL_RCC_GetSysClockFreq+0x248>
 8007f12:	697b      	ldr	r3, [r7, #20]
 8007f14:	2b00      	cmp	r3, #0
 8007f16:	d003      	beq.n	8007f20 <HAL_RCC_GetSysClockFreq+0x114>
 8007f18:	697b      	ldr	r3, [r7, #20]
 8007f1a:	2b01      	cmp	r3, #1
 8007f1c:	d056      	beq.n	8007fcc <HAL_RCC_GetSysClockFreq+0x1c0>
 8007f1e:	e099      	b.n	8008054 <HAL_RCC_GetSysClockFreq+0x248>
      {
        switch (pllsource)
        {
          case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

            if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8007f20:	4b6f      	ldr	r3, [pc, #444]	@ (80080e0 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8007f22:	681b      	ldr	r3, [r3, #0]
 8007f24:	f003 0320 	and.w	r3, r3, #32
 8007f28:	2b00      	cmp	r3, #0
 8007f2a:	d02d      	beq.n	8007f88 <HAL_RCC_GetSysClockFreq+0x17c>
            {
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8007f2c:	4b6c      	ldr	r3, [pc, #432]	@ (80080e0 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8007f2e:	681b      	ldr	r3, [r3, #0]
 8007f30:	08db      	lsrs	r3, r3, #3
 8007f32:	f003 0303 	and.w	r3, r3, #3
 8007f36:	4a6b      	ldr	r2, [pc, #428]	@ (80080e4 <HAL_RCC_GetSysClockFreq+0x2d8>)
 8007f38:	fa22 f303 	lsr.w	r3, r2, r3
 8007f3c:	607b      	str	r3, [r7, #4]
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8007f3e:	687b      	ldr	r3, [r7, #4]
 8007f40:	ee07 3a90 	vmov	s15, r3
 8007f44:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8007f48:	693b      	ldr	r3, [r7, #16]
 8007f4a:	ee07 3a90 	vmov	s15, r3
 8007f4e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8007f52:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8007f56:	4b62      	ldr	r3, [pc, #392]	@ (80080e0 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8007f58:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8007f5a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8007f5e:	ee07 3a90 	vmov	s15, r3
 8007f62:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8007f66:	ed97 6a02 	vldr	s12, [r7, #8]
 8007f6a:	eddf 5a61 	vldr	s11, [pc, #388]	@ 80080f0 <HAL_RCC_GetSysClockFreq+0x2e4>
 8007f6e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8007f72:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8007f76:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8007f7a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8007f7e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8007f82:	edc7 7a07 	vstr	s15, [r7, #28]
            }
            else
            {
              pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
            }
            break;
 8007f86:	e087      	b.n	8008098 <HAL_RCC_GetSysClockFreq+0x28c>
              pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8007f88:	693b      	ldr	r3, [r7, #16]
 8007f8a:	ee07 3a90 	vmov	s15, r3
 8007f8e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8007f92:	eddf 6a58 	vldr	s13, [pc, #352]	@ 80080f4 <HAL_RCC_GetSysClockFreq+0x2e8>
 8007f96:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8007f9a:	4b51      	ldr	r3, [pc, #324]	@ (80080e0 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8007f9c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8007f9e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8007fa2:	ee07 3a90 	vmov	s15, r3
 8007fa6:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8007faa:	ed97 6a02 	vldr	s12, [r7, #8]
 8007fae:	eddf 5a50 	vldr	s11, [pc, #320]	@ 80080f0 <HAL_RCC_GetSysClockFreq+0x2e4>
 8007fb2:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8007fb6:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8007fba:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8007fbe:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8007fc2:	ee67 7a27 	vmul.f32	s15, s14, s15
 8007fc6:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 8007fca:	e065      	b.n	8008098 <HAL_RCC_GetSysClockFreq+0x28c>

          case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8007fcc:	693b      	ldr	r3, [r7, #16]
 8007fce:	ee07 3a90 	vmov	s15, r3
 8007fd2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8007fd6:	eddf 6a48 	vldr	s13, [pc, #288]	@ 80080f8 <HAL_RCC_GetSysClockFreq+0x2ec>
 8007fda:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8007fde:	4b40      	ldr	r3, [pc, #256]	@ (80080e0 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8007fe0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8007fe2:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8007fe6:	ee07 3a90 	vmov	s15, r3
 8007fea:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8007fee:	ed97 6a02 	vldr	s12, [r7, #8]
 8007ff2:	eddf 5a3f 	vldr	s11, [pc, #252]	@ 80080f0 <HAL_RCC_GetSysClockFreq+0x2e4>
 8007ff6:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8007ffa:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8007ffe:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8008002:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8008006:	ee67 7a27 	vmul.f32	s15, s14, s15
 800800a:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 800800e:	e043      	b.n	8008098 <HAL_RCC_GetSysClockFreq+0x28c>

          case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
            pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8008010:	693b      	ldr	r3, [r7, #16]
 8008012:	ee07 3a90 	vmov	s15, r3
 8008016:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800801a:	eddf 6a38 	vldr	s13, [pc, #224]	@ 80080fc <HAL_RCC_GetSysClockFreq+0x2f0>
 800801e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8008022:	4b2f      	ldr	r3, [pc, #188]	@ (80080e0 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8008024:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8008026:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800802a:	ee07 3a90 	vmov	s15, r3
 800802e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8008032:	ed97 6a02 	vldr	s12, [r7, #8]
 8008036:	eddf 5a2e 	vldr	s11, [pc, #184]	@ 80080f0 <HAL_RCC_GetSysClockFreq+0x2e4>
 800803a:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800803e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8008042:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8008046:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800804a:	ee67 7a27 	vmul.f32	s15, s14, s15
 800804e:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 8008052:	e021      	b.n	8008098 <HAL_RCC_GetSysClockFreq+0x28c>

          default:
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8008054:	693b      	ldr	r3, [r7, #16]
 8008056:	ee07 3a90 	vmov	s15, r3
 800805a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800805e:	eddf 6a26 	vldr	s13, [pc, #152]	@ 80080f8 <HAL_RCC_GetSysClockFreq+0x2ec>
 8008062:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8008066:	4b1e      	ldr	r3, [pc, #120]	@ (80080e0 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8008068:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800806a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800806e:	ee07 3a90 	vmov	s15, r3
 8008072:	eef8 6a67 	vcvt.f32.u32	s13, s15
 8008076:	ed97 6a02 	vldr	s12, [r7, #8]
 800807a:	eddf 5a1d 	vldr	s11, [pc, #116]	@ 80080f0 <HAL_RCC_GetSysClockFreq+0x2e4>
 800807e:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8008082:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8008086:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800808a:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800808e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8008092:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 8008096:	bf00      	nop
        }
        pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> 9) + 1U) ;
 8008098:	4b11      	ldr	r3, [pc, #68]	@ (80080e0 <HAL_RCC_GetSysClockFreq+0x2d4>)
 800809a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800809c:	0a5b      	lsrs	r3, r3, #9
 800809e:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 80080a2:	3301      	adds	r3, #1
 80080a4:	603b      	str	r3, [r7, #0]
        sysclockfreq = (uint32_t)(float_t)(pllvco / (float_t)pllp);
 80080a6:	683b      	ldr	r3, [r7, #0]
 80080a8:	ee07 3a90 	vmov	s15, r3
 80080ac:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 80080b0:	edd7 6a07 	vldr	s13, [r7, #28]
 80080b4:	eec6 7a87 	vdiv.f32	s15, s13, s14
 80080b8:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80080bc:	ee17 3a90 	vmov	r3, s15
 80080c0:	61bb      	str	r3, [r7, #24]
      }
      else
      {
        sysclockfreq = 0U;
      }
      break;
 80080c2:	e005      	b.n	80080d0 <HAL_RCC_GetSysClockFreq+0x2c4>
        sysclockfreq = 0U;
 80080c4:	2300      	movs	r3, #0
 80080c6:	61bb      	str	r3, [r7, #24]
      break;
 80080c8:	e002      	b.n	80080d0 <HAL_RCC_GetSysClockFreq+0x2c4>

    default:
      sysclockfreq = CSI_VALUE;
 80080ca:	4b07      	ldr	r3, [pc, #28]	@ (80080e8 <HAL_RCC_GetSysClockFreq+0x2dc>)
 80080cc:	61bb      	str	r3, [r7, #24]
      break;
 80080ce:	bf00      	nop
  }

  return sysclockfreq;
 80080d0:	69bb      	ldr	r3, [r7, #24]
}
 80080d2:	4618      	mov	r0, r3
 80080d4:	3724      	adds	r7, #36	@ 0x24
 80080d6:	46bd      	mov	sp, r7
 80080d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80080dc:	4770      	bx	lr
 80080de:	bf00      	nop
 80080e0:	58024400 	.word	0x58024400
 80080e4:	03d09000 	.word	0x03d09000
 80080e8:	003d0900 	.word	0x003d0900
 80080ec:	007a1200 	.word	0x007a1200
 80080f0:	46000000 	.word	0x46000000
 80080f4:	4c742400 	.word	0x4c742400
 80080f8:	4a742400 	.word	0x4a742400
 80080fc:	4af42400 	.word	0x4af42400

08008100 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8008100:	b580      	push	{r7, lr}
 8008102:	b082      	sub	sp, #8
 8008104:	af00      	add	r7, sp, #0
  uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8008106:	f7ff fe81 	bl	8007e0c <HAL_RCC_GetSysClockFreq>
 800810a:	4602      	mov	r2, r0
 800810c:	4b10      	ldr	r3, [pc, #64]	@ (8008150 <HAL_RCC_GetHCLKFreq+0x50>)
 800810e:	699b      	ldr	r3, [r3, #24]
 8008110:	0a1b      	lsrs	r3, r3, #8
 8008112:	f003 030f 	and.w	r3, r3, #15
 8008116:	490f      	ldr	r1, [pc, #60]	@ (8008154 <HAL_RCC_GetHCLKFreq+0x54>)
 8008118:	5ccb      	ldrb	r3, [r1, r3]
 800811a:	f003 031f 	and.w	r3, r3, #31
 800811e:	fa22 f303 	lsr.w	r3, r2, r3
 8008122:	607b      	str	r3, [r7, #4]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE) >> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8008124:	4b0a      	ldr	r3, [pc, #40]	@ (8008150 <HAL_RCC_GetHCLKFreq+0x50>)
 8008126:	699b      	ldr	r3, [r3, #24]
 8008128:	f003 030f 	and.w	r3, r3, #15
 800812c:	4a09      	ldr	r2, [pc, #36]	@ (8008154 <HAL_RCC_GetHCLKFreq+0x54>)
 800812e:	5cd3      	ldrb	r3, [r2, r3]
 8008130:	f003 031f 	and.w	r3, r3, #31
 8008134:	687a      	ldr	r2, [r7, #4]
 8008136:	fa22 f303 	lsr.w	r3, r2, r3
 800813a:	4a07      	ldr	r2, [pc, #28]	@ (8008158 <HAL_RCC_GetHCLKFreq+0x58>)
 800813c:	6013      	str	r3, [r2, #0]
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 800813e:	4a07      	ldr	r2, [pc, #28]	@ (800815c <HAL_RCC_GetHCLKFreq+0x5c>)
 8008140:	687b      	ldr	r3, [r7, #4]
 8008142:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
 8008144:	4b04      	ldr	r3, [pc, #16]	@ (8008158 <HAL_RCC_GetHCLKFreq+0x58>)
 8008146:	681b      	ldr	r3, [r3, #0]
}
 8008148:	4618      	mov	r0, r3
 800814a:	3708      	adds	r7, #8
 800814c:	46bd      	mov	sp, r7
 800814e:	bd80      	pop	{r7, pc}
 8008150:	58024400 	.word	0x58024400
 8008154:	0801860c 	.word	0x0801860c
 8008158:	24000004 	.word	0x24000004
 800815c:	24000000 	.word	0x24000000

08008160 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8008160:	b580      	push	{r7, lr}
 8008162:	af00      	add	r7, sp, #0
#if defined (RCC_D2CFGR_D2PPRE1)
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1) >> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
 8008164:	f7ff ffcc 	bl	8008100 <HAL_RCC_GetHCLKFreq>
 8008168:	4602      	mov	r2, r0
 800816a:	4b06      	ldr	r3, [pc, #24]	@ (8008184 <HAL_RCC_GetPCLK1Freq+0x24>)
 800816c:	69db      	ldr	r3, [r3, #28]
 800816e:	091b      	lsrs	r3, r3, #4
 8008170:	f003 0307 	and.w	r3, r3, #7
 8008174:	4904      	ldr	r1, [pc, #16]	@ (8008188 <HAL_RCC_GetPCLK1Freq+0x28>)
 8008176:	5ccb      	ldrb	r3, [r1, r3]
 8008178:	f003 031f 	and.w	r3, r3, #31
 800817c:	fa22 f303 	lsr.w	r3, r2, r3
#else
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1) >> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
#endif
}
 8008180:	4618      	mov	r0, r3
 8008182:	bd80      	pop	{r7, pc}
 8008184:	58024400 	.word	0x58024400
 8008188:	0801860c 	.word	0x0801860c

0800818c <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 800818c:	b580      	push	{r7, lr}
 800818e:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
#if defined(RCC_D2CFGR_D2PPRE2)
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2) >> RCC_D2CFGR_D2PPRE2_Pos]) & 0x1FU));
 8008190:	f7ff ffb6 	bl	8008100 <HAL_RCC_GetHCLKFreq>
 8008194:	4602      	mov	r2, r0
 8008196:	4b06      	ldr	r3, [pc, #24]	@ (80081b0 <HAL_RCC_GetPCLK2Freq+0x24>)
 8008198:	69db      	ldr	r3, [r3, #28]
 800819a:	0a1b      	lsrs	r3, r3, #8
 800819c:	f003 0307 	and.w	r3, r3, #7
 80081a0:	4904      	ldr	r1, [pc, #16]	@ (80081b4 <HAL_RCC_GetPCLK2Freq+0x28>)
 80081a2:	5ccb      	ldrb	r3, [r1, r3]
 80081a4:	f003 031f 	and.w	r3, r3, #31
 80081a8:	fa22 f303 	lsr.w	r3, r2, r3
#else
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE2) >> RCC_CDCFGR2_CDPPRE2_Pos]) & 0x1FU));
#endif
}
 80081ac:	4618      	mov	r0, r3
 80081ae:	bd80      	pop	{r7, pc}
 80081b0:	58024400 	.word	0x58024400
 80081b4:	0801860c 	.word	0x0801860c

080081b8 <HAL_RCC_GetClockConfig>:
  * will be configured.
  * @param  pFLatency: Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
 80081b8:	b480      	push	{r7}
 80081ba:	b083      	sub	sp, #12
 80081bc:	af00      	add	r7, sp, #0
 80081be:	6078      	str	r0, [r7, #4]
 80081c0:	6039      	str	r1, [r7, #0]
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 |
 80081c2:	687b      	ldr	r3, [r7, #4]
 80081c4:	223f      	movs	r2, #63	@ 0x3f
 80081c6:	601a      	str	r2, [r3, #0]
                                 RCC_CLOCKTYPE_PCLK2 |  RCC_CLOCKTYPE_D3PCLK1  ;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 80081c8:	4b1a      	ldr	r3, [pc, #104]	@ (8008234 <HAL_RCC_GetClockConfig+0x7c>)
 80081ca:	691b      	ldr	r3, [r3, #16]
 80081cc:	f003 0207 	and.w	r2, r3, #7
 80081d0:	687b      	ldr	r3, [r7, #4]
 80081d2:	605a      	str	r2, [r3, #4]

#if defined(RCC_D1CFGR_D1CPRE)
  /* Get the SYSCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1CPRE);
 80081d4:	4b17      	ldr	r3, [pc, #92]	@ (8008234 <HAL_RCC_GetClockConfig+0x7c>)
 80081d6:	699b      	ldr	r3, [r3, #24]
 80081d8:	f403 6270 	and.w	r2, r3, #3840	@ 0xf00
 80081dc:	687b      	ldr	r3, [r7, #4]
 80081de:	609a      	str	r2, [r3, #8]

  /* Get the D1HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_HPRE);
 80081e0:	4b14      	ldr	r3, [pc, #80]	@ (8008234 <HAL_RCC_GetClockConfig+0x7c>)
 80081e2:	699b      	ldr	r3, [r3, #24]
 80081e4:	f003 020f 	and.w	r2, r3, #15
 80081e8:	687b      	ldr	r3, [r7, #4]
 80081ea:	60da      	str	r2, [r3, #12]

  /* Get the APB3 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1PPRE);
 80081ec:	4b11      	ldr	r3, [pc, #68]	@ (8008234 <HAL_RCC_GetClockConfig+0x7c>)
 80081ee:	699b      	ldr	r3, [r3, #24]
 80081f0:	f003 0270 	and.w	r2, r3, #112	@ 0x70
 80081f4:	687b      	ldr	r3, [r7, #4]
 80081f6:	611a      	str	r2, [r3, #16]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1);
 80081f8:	4b0e      	ldr	r3, [pc, #56]	@ (8008234 <HAL_RCC_GetClockConfig+0x7c>)
 80081fa:	69db      	ldr	r3, [r3, #28]
 80081fc:	f003 0270 	and.w	r2, r3, #112	@ 0x70
 8008200:	687b      	ldr	r3, [r7, #4]
 8008202:	615a      	str	r2, [r3, #20]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2);
 8008204:	4b0b      	ldr	r3, [pc, #44]	@ (8008234 <HAL_RCC_GetClockConfig+0x7c>)
 8008206:	69db      	ldr	r3, [r3, #28]
 8008208:	f403 62e0 	and.w	r2, r3, #1792	@ 0x700
 800820c:	687b      	ldr	r3, [r7, #4]
 800820e:	619a      	str	r2, [r3, #24]

  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);
 8008210:	4b08      	ldr	r3, [pc, #32]	@ (8008234 <HAL_RCC_GetClockConfig+0x7c>)
 8008212:	6a1b      	ldr	r3, [r3, #32]
 8008214:	f003 0270 	and.w	r2, r3, #112	@ 0x70
 8008218:	687b      	ldr	r3, [r7, #4]
 800821a:	61da      	str	r2, [r3, #28]
  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE);
#endif

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 800821c:	4b06      	ldr	r3, [pc, #24]	@ (8008238 <HAL_RCC_GetClockConfig+0x80>)
 800821e:	681b      	ldr	r3, [r3, #0]
 8008220:	f003 020f 	and.w	r2, r3, #15
 8008224:	683b      	ldr	r3, [r7, #0]
 8008226:	601a      	str	r2, [r3, #0]
}
 8008228:	bf00      	nop
 800822a:	370c      	adds	r7, #12
 800822c:	46bd      	mov	sp, r7
 800822e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008232:	4770      	bx	lr
 8008234:	58024400 	.word	0x58024400
 8008238:	52002000 	.word	0x52002000

0800823c <HAL_RCCEx_PeriphCLKConfig>:
  * (*) : Available on some STM32H7 lines only.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 800823c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8008240:	b0ca      	sub	sp, #296	@ 0x128
 8008242:	af00      	add	r7, sp, #0
 8008244:	f8c7 0114 	str.w	r0, [r7, #276]	@ 0x114
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 8008248:	2300      	movs	r3, #0
 800824a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 800824e:	2300      	movs	r3, #0
 8008250:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126

  /*---------------------------- SPDIFRX configuration -------------------------------*/

  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8008254:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008258:	e9d3 2300 	ldrd	r2, r3, [r3]
 800825c:	f002 6400 	and.w	r4, r2, #134217728	@ 0x8000000
 8008260:	2500      	movs	r5, #0
 8008262:	ea54 0305 	orrs.w	r3, r4, r5
 8008266:	d049      	beq.n	80082fc <HAL_RCCEx_PeriphCLKConfig+0xc0>
  {

    switch (PeriphClkInit->SpdifrxClockSelection)
 8008268:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800826c:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 800826e:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 8008272:	d02f      	beq.n	80082d4 <HAL_RCCEx_PeriphCLKConfig+0x98>
 8008274:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 8008278:	d828      	bhi.n	80082cc <HAL_RCCEx_PeriphCLKConfig+0x90>
 800827a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 800827e:	d01a      	beq.n	80082b6 <HAL_RCCEx_PeriphCLKConfig+0x7a>
 8008280:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8008284:	d822      	bhi.n	80082cc <HAL_RCCEx_PeriphCLKConfig+0x90>
 8008286:	2b00      	cmp	r3, #0
 8008288:	d003      	beq.n	8008292 <HAL_RCCEx_PeriphCLKConfig+0x56>
 800828a:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 800828e:	d007      	beq.n	80082a0 <HAL_RCCEx_PeriphCLKConfig+0x64>
 8008290:	e01c      	b.n	80082cc <HAL_RCCEx_PeriphCLKConfig+0x90>
    {
      case RCC_SPDIFRXCLKSOURCE_PLL:      /* PLL is used as clock source for SPDIFRX*/
        /* Enable PLL1Q Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8008292:	4bb8      	ldr	r3, [pc, #736]	@ (8008574 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8008294:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8008296:	4ab7      	ldr	r2, [pc, #732]	@ (8008574 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8008298:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 800829c:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
 800829e:	e01a      	b.n	80082d6 <HAL_RCCEx_PeriphCLKConfig+0x9a>

      case RCC_SPDIFRXCLKSOURCE_PLL2: /* PLL2 is used as clock source for SPDIFRX*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 80082a0:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80082a4:	3308      	adds	r3, #8
 80082a6:	2102      	movs	r1, #2
 80082a8:	4618      	mov	r0, r3
 80082aa:	f002 fb61 	bl	800a970 <RCCEx_PLL2_Config>
 80082ae:	4603      	mov	r3, r0
 80082b0:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
 80082b4:	e00f      	b.n	80082d6 <HAL_RCCEx_PeriphCLKConfig+0x9a>

      case RCC_SPDIFRXCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPDIFRX*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 80082b6:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80082ba:	3328      	adds	r3, #40	@ 0x28
 80082bc:	2102      	movs	r1, #2
 80082be:	4618      	mov	r0, r3
 80082c0:	f002 fc08 	bl	800aad4 <RCCEx_PLL3_Config>
 80082c4:	4603      	mov	r3, r0
 80082c6:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
 80082ca:	e004      	b.n	80082d6 <HAL_RCCEx_PeriphCLKConfig+0x9a>
        /* Internal OSC clock is used as source of SPDIFRX clock*/
        /* SPDIFRX clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 80082cc:	2301      	movs	r3, #1
 80082ce:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 80082d2:	e000      	b.n	80082d6 <HAL_RCCEx_PeriphCLKConfig+0x9a>
        break;
 80082d4:	bf00      	nop
    }

    if (ret == HAL_OK)
 80082d6:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80082da:	2b00      	cmp	r3, #0
 80082dc:	d10a      	bne.n	80082f4 <HAL_RCCEx_PeriphCLKConfig+0xb8>
    {
      /* Set the source of SPDIFRX clock*/
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
 80082de:	4ba5      	ldr	r3, [pc, #660]	@ (8008574 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 80082e0:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80082e2:	f423 1140 	bic.w	r1, r3, #3145728	@ 0x300000
 80082e6:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80082ea:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 80082ec:	4aa1      	ldr	r2, [pc, #644]	@ (8008574 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 80082ee:	430b      	orrs	r3, r1
 80082f0:	6513      	str	r3, [r2, #80]	@ 0x50
 80082f2:	e003      	b.n	80082fc <HAL_RCCEx_PeriphCLKConfig+0xc0>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80082f4:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80082f8:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- SAI1 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 80082fc:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008300:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008304:	f402 7880 	and.w	r8, r2, #256	@ 0x100
 8008308:	f04f 0900 	mov.w	r9, #0
 800830c:	ea58 0309 	orrs.w	r3, r8, r9
 8008310:	d047      	beq.n	80083a2 <HAL_RCCEx_PeriphCLKConfig+0x166>
  {
    switch (PeriphClkInit->Sai1ClockSelection)
 8008312:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008316:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008318:	2b04      	cmp	r3, #4
 800831a:	d82a      	bhi.n	8008372 <HAL_RCCEx_PeriphCLKConfig+0x136>
 800831c:	a201      	add	r2, pc, #4	@ (adr r2, 8008324 <HAL_RCCEx_PeriphCLKConfig+0xe8>)
 800831e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008322:	bf00      	nop
 8008324:	08008339 	.word	0x08008339
 8008328:	08008347 	.word	0x08008347
 800832c:	0800835d 	.word	0x0800835d
 8008330:	0800837b 	.word	0x0800837b
 8008334:	0800837b 	.word	0x0800837b
    {
      case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8008338:	4b8e      	ldr	r3, [pc, #568]	@ (8008574 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 800833a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800833c:	4a8d      	ldr	r2, [pc, #564]	@ (8008574 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 800833e:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8008342:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 8008344:	e01a      	b.n	800837c <HAL_RCCEx_PeriphCLKConfig+0x140>

      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI1*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8008346:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800834a:	3308      	adds	r3, #8
 800834c:	2100      	movs	r1, #0
 800834e:	4618      	mov	r0, r3
 8008350:	f002 fb0e 	bl	800a970 <RCCEx_PLL2_Config>
 8008354:	4603      	mov	r3, r0
 8008356:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 800835a:	e00f      	b.n	800837c <HAL_RCCEx_PeriphCLKConfig+0x140>

      case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 800835c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008360:	3328      	adds	r3, #40	@ 0x28
 8008362:	2100      	movs	r1, #0
 8008364:	4618      	mov	r0, r3
 8008366:	f002 fbb5 	bl	800aad4 <RCCEx_PLL3_Config>
 800836a:	4603      	mov	r3, r0
 800836c:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 8008370:	e004      	b.n	800837c <HAL_RCCEx_PeriphCLKConfig+0x140>
        /* HSI, HSE, or CSI oscillator is used as source of SAI1 clock */
        /* SAI1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8008372:	2301      	movs	r3, #1
 8008374:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8008378:	e000      	b.n	800837c <HAL_RCCEx_PeriphCLKConfig+0x140>
        break;
 800837a:	bf00      	nop
    }

    if (ret == HAL_OK)
 800837c:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008380:	2b00      	cmp	r3, #0
 8008382:	d10a      	bne.n	800839a <HAL_RCCEx_PeriphCLKConfig+0x15e>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8008384:	4b7b      	ldr	r3, [pc, #492]	@ (8008574 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8008386:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8008388:	f023 0107 	bic.w	r1, r3, #7
 800838c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008390:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008392:	4a78      	ldr	r2, [pc, #480]	@ (8008574 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8008394:	430b      	orrs	r3, r1
 8008396:	6513      	str	r3, [r2, #80]	@ 0x50
 8008398:	e003      	b.n	80083a2 <HAL_RCCEx_PeriphCLKConfig+0x166>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800839a:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 800839e:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

#if defined(SAI3)
  /*---------------------------- SAI2/3 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
 80083a2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80083a6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80083aa:	f402 7a00 	and.w	sl, r2, #512	@ 0x200
 80083ae:	f04f 0b00 	mov.w	fp, #0
 80083b2:	ea5a 030b 	orrs.w	r3, sl, fp
 80083b6:	d04c      	beq.n	8008452 <HAL_RCCEx_PeriphCLKConfig+0x216>
  {
    switch (PeriphClkInit->Sai23ClockSelection)
 80083b8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80083bc:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 80083be:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80083c2:	d030      	beq.n	8008426 <HAL_RCCEx_PeriphCLKConfig+0x1ea>
 80083c4:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80083c8:	d829      	bhi.n	800841e <HAL_RCCEx_PeriphCLKConfig+0x1e2>
 80083ca:	2bc0      	cmp	r3, #192	@ 0xc0
 80083cc:	d02d      	beq.n	800842a <HAL_RCCEx_PeriphCLKConfig+0x1ee>
 80083ce:	2bc0      	cmp	r3, #192	@ 0xc0
 80083d0:	d825      	bhi.n	800841e <HAL_RCCEx_PeriphCLKConfig+0x1e2>
 80083d2:	2b80      	cmp	r3, #128	@ 0x80
 80083d4:	d018      	beq.n	8008408 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
 80083d6:	2b80      	cmp	r3, #128	@ 0x80
 80083d8:	d821      	bhi.n	800841e <HAL_RCCEx_PeriphCLKConfig+0x1e2>
 80083da:	2b00      	cmp	r3, #0
 80083dc:	d002      	beq.n	80083e4 <HAL_RCCEx_PeriphCLKConfig+0x1a8>
 80083de:	2b40      	cmp	r3, #64	@ 0x40
 80083e0:	d007      	beq.n	80083f2 <HAL_RCCEx_PeriphCLKConfig+0x1b6>
 80083e2:	e01c      	b.n	800841e <HAL_RCCEx_PeriphCLKConfig+0x1e2>
    {
      case RCC_SAI23CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2/3 */
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80083e4:	4b63      	ldr	r3, [pc, #396]	@ (8008574 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 80083e6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80083e8:	4a62      	ldr	r2, [pc, #392]	@ (8008574 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 80083ea:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80083ee:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SAI2/3 clock source configuration done later after clock selection check */
        break;
 80083f0:	e01c      	b.n	800842c <HAL_RCCEx_PeriphCLKConfig+0x1f0>

      case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2/3 */

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 80083f2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80083f6:	3308      	adds	r3, #8
 80083f8:	2100      	movs	r1, #0
 80083fa:	4618      	mov	r0, r3
 80083fc:	f002 fab8 	bl	800a970 <RCCEx_PLL2_Config>
 8008400:	4603      	mov	r3, r0
 8008402:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI2/3 clock source configuration done later after clock selection check */
        break;
 8008406:	e011      	b.n	800842c <HAL_RCCEx_PeriphCLKConfig+0x1f0>

      case RCC_SAI23CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2/3 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 8008408:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800840c:	3328      	adds	r3, #40	@ 0x28
 800840e:	2100      	movs	r1, #0
 8008410:	4618      	mov	r0, r3
 8008412:	f002 fb5f 	bl	800aad4 <RCCEx_PLL3_Config>
 8008416:	4603      	mov	r3, r0
 8008418:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI2/3 clock source configuration done later after clock selection check */
        break;
 800841c:	e006      	b.n	800842c <HAL_RCCEx_PeriphCLKConfig+0x1f0>
        /* HSI, HSE, or CSI oscillator is used as source of SAI2/3 clock */
        /* SAI2/3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800841e:	2301      	movs	r3, #1
 8008420:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8008424:	e002      	b.n	800842c <HAL_RCCEx_PeriphCLKConfig+0x1f0>
        break;
 8008426:	bf00      	nop
 8008428:	e000      	b.n	800842c <HAL_RCCEx_PeriphCLKConfig+0x1f0>
        break;
 800842a:	bf00      	nop
    }

    if (ret == HAL_OK)
 800842c:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008430:	2b00      	cmp	r3, #0
 8008432:	d10a      	bne.n	800844a <HAL_RCCEx_PeriphCLKConfig+0x20e>
    {
      /* Set the source of SAI2/3 clock*/
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
 8008434:	4b4f      	ldr	r3, [pc, #316]	@ (8008574 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8008436:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8008438:	f423 71e0 	bic.w	r1, r3, #448	@ 0x1c0
 800843c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008440:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8008442:	4a4c      	ldr	r2, [pc, #304]	@ (8008574 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8008444:	430b      	orrs	r3, r1
 8008446:	6513      	str	r3, [r2, #80]	@ 0x50
 8008448:	e003      	b.n	8008452 <HAL_RCCEx_PeriphCLKConfig+0x216>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800844a:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 800844e:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
  }
#endif  /*SAI2B*/

#if defined(SAI4)
  /*---------------------------- SAI4A configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
 8008452:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008456:	e9d3 2300 	ldrd	r2, r3, [r3]
 800845a:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
 800845e:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 8008462:	2300      	movs	r3, #0
 8008464:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
 8008468:	e9d7 1242 	ldrd	r1, r2, [r7, #264]	@ 0x108
 800846c:	460b      	mov	r3, r1
 800846e:	4313      	orrs	r3, r2
 8008470:	d053      	beq.n	800851a <HAL_RCCEx_PeriphCLKConfig+0x2de>
  {
    switch (PeriphClkInit->Sai4AClockSelection)
 8008472:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008476:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 800847a:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 800847e:	d035      	beq.n	80084ec <HAL_RCCEx_PeriphCLKConfig+0x2b0>
 8008480:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 8008484:	d82e      	bhi.n	80084e4 <HAL_RCCEx_PeriphCLKConfig+0x2a8>
 8008486:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
 800848a:	d031      	beq.n	80084f0 <HAL_RCCEx_PeriphCLKConfig+0x2b4>
 800848c:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
 8008490:	d828      	bhi.n	80084e4 <HAL_RCCEx_PeriphCLKConfig+0x2a8>
 8008492:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8008496:	d01a      	beq.n	80084ce <HAL_RCCEx_PeriphCLKConfig+0x292>
 8008498:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 800849c:	d822      	bhi.n	80084e4 <HAL_RCCEx_PeriphCLKConfig+0x2a8>
 800849e:	2b00      	cmp	r3, #0
 80084a0:	d003      	beq.n	80084aa <HAL_RCCEx_PeriphCLKConfig+0x26e>
 80084a2:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 80084a6:	d007      	beq.n	80084b8 <HAL_RCCEx_PeriphCLKConfig+0x27c>
 80084a8:	e01c      	b.n	80084e4 <HAL_RCCEx_PeriphCLKConfig+0x2a8>
    {
      case RCC_SAI4ACLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80084aa:	4b32      	ldr	r3, [pc, #200]	@ (8008574 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 80084ac:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80084ae:	4a31      	ldr	r2, [pc, #196]	@ (8008574 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 80084b0:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80084b4:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 80084b6:	e01c      	b.n	80084f2 <HAL_RCCEx_PeriphCLKConfig+0x2b6>

      case RCC_SAI4ACLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 80084b8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80084bc:	3308      	adds	r3, #8
 80084be:	2100      	movs	r1, #0
 80084c0:	4618      	mov	r0, r3
 80084c2:	f002 fa55 	bl	800a970 <RCCEx_PLL2_Config>
 80084c6:	4603      	mov	r3, r0
 80084c8:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI2 clock source configuration done later after clock selection check */
        break;
 80084cc:	e011      	b.n	80084f2 <HAL_RCCEx_PeriphCLKConfig+0x2b6>

      case RCC_SAI4ACLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 80084ce:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80084d2:	3328      	adds	r3, #40	@ 0x28
 80084d4:	2100      	movs	r1, #0
 80084d6:	4618      	mov	r0, r3
 80084d8:	f002 fafc 	bl	800aad4 <RCCEx_PLL3_Config>
 80084dc:	4603      	mov	r3, r0
 80084de:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 80084e2:	e006      	b.n	80084f2 <HAL_RCCEx_PeriphCLKConfig+0x2b6>
        /* SAI4A clock source configuration done later after clock selection check */
        break;
#endif /* RCC_VER_3_0 */

      default:
        ret = HAL_ERROR;
 80084e4:	2301      	movs	r3, #1
 80084e6:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 80084ea:	e002      	b.n	80084f2 <HAL_RCCEx_PeriphCLKConfig+0x2b6>
        break;
 80084ec:	bf00      	nop
 80084ee:	e000      	b.n	80084f2 <HAL_RCCEx_PeriphCLKConfig+0x2b6>
        break;
 80084f0:	bf00      	nop
    }

    if (ret == HAL_OK)
 80084f2:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80084f6:	2b00      	cmp	r3, #0
 80084f8:	d10b      	bne.n	8008512 <HAL_RCCEx_PeriphCLKConfig+0x2d6>
    {
      /* Set the source of SAI4A clock*/
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
 80084fa:	4b1e      	ldr	r3, [pc, #120]	@ (8008574 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 80084fc:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80084fe:	f423 0160 	bic.w	r1, r3, #14680064	@ 0xe00000
 8008502:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008506:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 800850a:	4a1a      	ldr	r2, [pc, #104]	@ (8008574 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 800850c:	430b      	orrs	r3, r1
 800850e:	6593      	str	r3, [r2, #88]	@ 0x58
 8008510:	e003      	b.n	800851a <HAL_RCCEx_PeriphCLKConfig+0x2de>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8008512:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008516:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
  /*---------------------------- SAI4B configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
 800851a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800851e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008522:	f402 6300 	and.w	r3, r2, #2048	@ 0x800
 8008526:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
 800852a:	2300      	movs	r3, #0
 800852c:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
 8008530:	e9d7 1240 	ldrd	r1, r2, [r7, #256]	@ 0x100
 8008534:	460b      	mov	r3, r1
 8008536:	4313      	orrs	r3, r2
 8008538:	d056      	beq.n	80085e8 <HAL_RCCEx_PeriphCLKConfig+0x3ac>
  {
    switch (PeriphClkInit->Sai4BClockSelection)
 800853a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800853e:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 8008542:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 8008546:	d038      	beq.n	80085ba <HAL_RCCEx_PeriphCLKConfig+0x37e>
 8008548:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 800854c:	d831      	bhi.n	80085b2 <HAL_RCCEx_PeriphCLKConfig+0x376>
 800854e:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 8008552:	d034      	beq.n	80085be <HAL_RCCEx_PeriphCLKConfig+0x382>
 8008554:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 8008558:	d82b      	bhi.n	80085b2 <HAL_RCCEx_PeriphCLKConfig+0x376>
 800855a:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 800855e:	d01d      	beq.n	800859c <HAL_RCCEx_PeriphCLKConfig+0x360>
 8008560:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8008564:	d825      	bhi.n	80085b2 <HAL_RCCEx_PeriphCLKConfig+0x376>
 8008566:	2b00      	cmp	r3, #0
 8008568:	d006      	beq.n	8008578 <HAL_RCCEx_PeriphCLKConfig+0x33c>
 800856a:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 800856e:	d00a      	beq.n	8008586 <HAL_RCCEx_PeriphCLKConfig+0x34a>
 8008570:	e01f      	b.n	80085b2 <HAL_RCCEx_PeriphCLKConfig+0x376>
 8008572:	bf00      	nop
 8008574:	58024400 	.word	0x58024400
    {
      case RCC_SAI4BCLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8008578:	4ba2      	ldr	r3, [pc, #648]	@ (8008804 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 800857a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800857c:	4aa1      	ldr	r2, [pc, #644]	@ (8008804 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 800857e:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8008582:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 8008584:	e01c      	b.n	80085c0 <HAL_RCCEx_PeriphCLKConfig+0x384>

      case RCC_SAI4BCLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8008586:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800858a:	3308      	adds	r3, #8
 800858c:	2100      	movs	r1, #0
 800858e:	4618      	mov	r0, r3
 8008590:	f002 f9ee 	bl	800a970 <RCCEx_PLL2_Config>
 8008594:	4603      	mov	r3, r0
 8008596:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI2 clock source configuration done later after clock selection check */
        break;
 800859a:	e011      	b.n	80085c0 <HAL_RCCEx_PeriphCLKConfig+0x384>

      case RCC_SAI4BCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 800859c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80085a0:	3328      	adds	r3, #40	@ 0x28
 80085a2:	2100      	movs	r1, #0
 80085a4:	4618      	mov	r0, r3
 80085a6:	f002 fa95 	bl	800aad4 <RCCEx_PLL3_Config>
 80085aa:	4603      	mov	r3, r0
 80085ac:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 80085b0:	e006      	b.n	80085c0 <HAL_RCCEx_PeriphCLKConfig+0x384>
        /* SAI4B clock source configuration done later after clock selection check */
        break;
#endif /* RCC_VER_3_0 */

      default:
        ret = HAL_ERROR;
 80085b2:	2301      	movs	r3, #1
 80085b4:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 80085b8:	e002      	b.n	80085c0 <HAL_RCCEx_PeriphCLKConfig+0x384>
        break;
 80085ba:	bf00      	nop
 80085bc:	e000      	b.n	80085c0 <HAL_RCCEx_PeriphCLKConfig+0x384>
        break;
 80085be:	bf00      	nop
    }

    if (ret == HAL_OK)
 80085c0:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80085c4:	2b00      	cmp	r3, #0
 80085c6:	d10b      	bne.n	80085e0 <HAL_RCCEx_PeriphCLKConfig+0x3a4>
    {
      /* Set the source of SAI4B clock*/
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
 80085c8:	4b8e      	ldr	r3, [pc, #568]	@ (8008804 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 80085ca:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80085cc:	f023 61e0 	bic.w	r1, r3, #117440512	@ 0x7000000
 80085d0:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80085d4:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 80085d8:	4a8a      	ldr	r2, [pc, #552]	@ (8008804 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 80085da:	430b      	orrs	r3, r1
 80085dc:	6593      	str	r3, [r2, #88]	@ 0x58
 80085de:	e003      	b.n	80085e8 <HAL_RCCEx_PeriphCLKConfig+0x3ac>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80085e0:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80085e4:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
  }
#endif  /*SAI4*/

#if defined(QUADSPI)
  /*---------------------------- QSPI configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
 80085e8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80085ec:	e9d3 2300 	ldrd	r2, r3, [r3]
 80085f0:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
 80085f4:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 80085f8:	2300      	movs	r3, #0
 80085fa:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
 80085fe:	e9d7 123e 	ldrd	r1, r2, [r7, #248]	@ 0xf8
 8008602:	460b      	mov	r3, r1
 8008604:	4313      	orrs	r3, r2
 8008606:	d03a      	beq.n	800867e <HAL_RCCEx_PeriphCLKConfig+0x442>
  {
    switch (PeriphClkInit->QspiClockSelection)
 8008608:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800860c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800860e:	2b30      	cmp	r3, #48	@ 0x30
 8008610:	d01f      	beq.n	8008652 <HAL_RCCEx_PeriphCLKConfig+0x416>
 8008612:	2b30      	cmp	r3, #48	@ 0x30
 8008614:	d819      	bhi.n	800864a <HAL_RCCEx_PeriphCLKConfig+0x40e>
 8008616:	2b20      	cmp	r3, #32
 8008618:	d00c      	beq.n	8008634 <HAL_RCCEx_PeriphCLKConfig+0x3f8>
 800861a:	2b20      	cmp	r3, #32
 800861c:	d815      	bhi.n	800864a <HAL_RCCEx_PeriphCLKConfig+0x40e>
 800861e:	2b00      	cmp	r3, #0
 8008620:	d019      	beq.n	8008656 <HAL_RCCEx_PeriphCLKConfig+0x41a>
 8008622:	2b10      	cmp	r3, #16
 8008624:	d111      	bne.n	800864a <HAL_RCCEx_PeriphCLKConfig+0x40e>
    {
      case RCC_QSPICLKSOURCE_PLL:      /* PLL is used as clock source for QSPI*/
        /* Enable QSPI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8008626:	4b77      	ldr	r3, [pc, #476]	@ (8008804 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8008628:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800862a:	4a76      	ldr	r2, [pc, #472]	@ (8008804 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 800862c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8008630:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* QSPI clock source configuration done later after clock selection check */
        break;
 8008632:	e011      	b.n	8008658 <HAL_RCCEx_PeriphCLKConfig+0x41c>

      case RCC_QSPICLKSOURCE_PLL2: /* PLL2 is used as clock source for QSPI*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 8008634:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008638:	3308      	adds	r3, #8
 800863a:	2102      	movs	r1, #2
 800863c:	4618      	mov	r0, r3
 800863e:	f002 f997 	bl	800a970 <RCCEx_PLL2_Config>
 8008642:	4603      	mov	r3, r0
 8008644:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* QSPI clock source configuration done later after clock selection check */
        break;
 8008648:	e006      	b.n	8008658 <HAL_RCCEx_PeriphCLKConfig+0x41c>
      case RCC_QSPICLKSOURCE_D1HCLK:
        /* Domain1 HCLK  clock selected as QSPI kernel peripheral clock */
        break;

      default:
        ret = HAL_ERROR;
 800864a:	2301      	movs	r3, #1
 800864c:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8008650:	e002      	b.n	8008658 <HAL_RCCEx_PeriphCLKConfig+0x41c>
        break;
 8008652:	bf00      	nop
 8008654:	e000      	b.n	8008658 <HAL_RCCEx_PeriphCLKConfig+0x41c>
        break;
 8008656:	bf00      	nop
    }

    if (ret == HAL_OK)
 8008658:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 800865c:	2b00      	cmp	r3, #0
 800865e:	d10a      	bne.n	8008676 <HAL_RCCEx_PeriphCLKConfig+0x43a>
    {
      /* Set the source of QSPI clock*/
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
 8008660:	4b68      	ldr	r3, [pc, #416]	@ (8008804 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8008662:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8008664:	f023 0130 	bic.w	r1, r3, #48	@ 0x30
 8008668:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800866c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800866e:	4a65      	ldr	r2, [pc, #404]	@ (8008804 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8008670:	430b      	orrs	r3, r1
 8008672:	64d3      	str	r3, [r2, #76]	@ 0x4c
 8008674:	e003      	b.n	800867e <HAL_RCCEx_PeriphCLKConfig+0x442>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8008676:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 800867a:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
#endif  /*OCTOSPI*/

  /*---------------------------- SPI1/2/3 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
 800867e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008682:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008686:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
 800868a:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 800868e:	2300      	movs	r3, #0
 8008690:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
 8008694:	e9d7 123c 	ldrd	r1, r2, [r7, #240]	@ 0xf0
 8008698:	460b      	mov	r3, r1
 800869a:	4313      	orrs	r3, r2
 800869c:	d051      	beq.n	8008742 <HAL_RCCEx_PeriphCLKConfig+0x506>
  {
    switch (PeriphClkInit->Spi123ClockSelection)
 800869e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80086a2:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 80086a4:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 80086a8:	d035      	beq.n	8008716 <HAL_RCCEx_PeriphCLKConfig+0x4da>
 80086aa:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 80086ae:	d82e      	bhi.n	800870e <HAL_RCCEx_PeriphCLKConfig+0x4d2>
 80086b0:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 80086b4:	d031      	beq.n	800871a <HAL_RCCEx_PeriphCLKConfig+0x4de>
 80086b6:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 80086ba:	d828      	bhi.n	800870e <HAL_RCCEx_PeriphCLKConfig+0x4d2>
 80086bc:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 80086c0:	d01a      	beq.n	80086f8 <HAL_RCCEx_PeriphCLKConfig+0x4bc>
 80086c2:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 80086c6:	d822      	bhi.n	800870e <HAL_RCCEx_PeriphCLKConfig+0x4d2>
 80086c8:	2b00      	cmp	r3, #0
 80086ca:	d003      	beq.n	80086d4 <HAL_RCCEx_PeriphCLKConfig+0x498>
 80086cc:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 80086d0:	d007      	beq.n	80086e2 <HAL_RCCEx_PeriphCLKConfig+0x4a6>
 80086d2:	e01c      	b.n	800870e <HAL_RCCEx_PeriphCLKConfig+0x4d2>
    {
      case RCC_SPI123CLKSOURCE_PLL:      /* PLL is used as clock source for SPI1/2/3 */
        /* Enable SPI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80086d4:	4b4b      	ldr	r3, [pc, #300]	@ (8008804 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 80086d6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80086d8:	4a4a      	ldr	r2, [pc, #296]	@ (8008804 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 80086da:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80086de:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
 80086e0:	e01c      	b.n	800871c <HAL_RCCEx_PeriphCLKConfig+0x4e0>

      case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI1/2/3 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 80086e2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80086e6:	3308      	adds	r3, #8
 80086e8:	2100      	movs	r1, #0
 80086ea:	4618      	mov	r0, r3
 80086ec:	f002 f940 	bl	800a970 <RCCEx_PLL2_Config>
 80086f0:	4603      	mov	r3, r0
 80086f2:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
 80086f6:	e011      	b.n	800871c <HAL_RCCEx_PeriphCLKConfig+0x4e0>

      case RCC_SPI123CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI1/2/3 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 80086f8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80086fc:	3328      	adds	r3, #40	@ 0x28
 80086fe:	2100      	movs	r1, #0
 8008700:	4618      	mov	r0, r3
 8008702:	f002 f9e7 	bl	800aad4 <RCCEx_PLL3_Config>
 8008706:	4603      	mov	r3, r0
 8008708:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
 800870c:	e006      	b.n	800871c <HAL_RCCEx_PeriphCLKConfig+0x4e0>
        /* HSI, HSE, or CSI oscillator is used as source of SPI1/2/3 clock */
        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800870e:	2301      	movs	r3, #1
 8008710:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8008714:	e002      	b.n	800871c <HAL_RCCEx_PeriphCLKConfig+0x4e0>
        break;
 8008716:	bf00      	nop
 8008718:	e000      	b.n	800871c <HAL_RCCEx_PeriphCLKConfig+0x4e0>
        break;
 800871a:	bf00      	nop
    }

    if (ret == HAL_OK)
 800871c:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008720:	2b00      	cmp	r3, #0
 8008722:	d10a      	bne.n	800873a <HAL_RCCEx_PeriphCLKConfig+0x4fe>
    {
      /* Set the source of SPI1/2/3 clock*/
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
 8008724:	4b37      	ldr	r3, [pc, #220]	@ (8008804 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8008726:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8008728:	f423 41e0 	bic.w	r1, r3, #28672	@ 0x7000
 800872c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008730:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8008732:	4a34      	ldr	r2, [pc, #208]	@ (8008804 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8008734:	430b      	orrs	r3, r1
 8008736:	6513      	str	r3, [r2, #80]	@ 0x50
 8008738:	e003      	b.n	8008742 <HAL_RCCEx_PeriphCLKConfig+0x506>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800873a:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 800873e:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- SPI4/5 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
 8008742:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008746:	e9d3 2300 	ldrd	r2, r3, [r3]
 800874a:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
 800874e:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
 8008752:	2300      	movs	r3, #0
 8008754:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
 8008758:	e9d7 123a 	ldrd	r1, r2, [r7, #232]	@ 0xe8
 800875c:	460b      	mov	r3, r1
 800875e:	4313      	orrs	r3, r2
 8008760:	d056      	beq.n	8008810 <HAL_RCCEx_PeriphCLKConfig+0x5d4>
  {
    switch (PeriphClkInit->Spi45ClockSelection)
 8008762:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008766:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8008768:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 800876c:	d033      	beq.n	80087d6 <HAL_RCCEx_PeriphCLKConfig+0x59a>
 800876e:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8008772:	d82c      	bhi.n	80087ce <HAL_RCCEx_PeriphCLKConfig+0x592>
 8008774:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8008778:	d02f      	beq.n	80087da <HAL_RCCEx_PeriphCLKConfig+0x59e>
 800877a:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 800877e:	d826      	bhi.n	80087ce <HAL_RCCEx_PeriphCLKConfig+0x592>
 8008780:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8008784:	d02b      	beq.n	80087de <HAL_RCCEx_PeriphCLKConfig+0x5a2>
 8008786:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 800878a:	d820      	bhi.n	80087ce <HAL_RCCEx_PeriphCLKConfig+0x592>
 800878c:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8008790:	d012      	beq.n	80087b8 <HAL_RCCEx_PeriphCLKConfig+0x57c>
 8008792:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8008796:	d81a      	bhi.n	80087ce <HAL_RCCEx_PeriphCLKConfig+0x592>
 8008798:	2b00      	cmp	r3, #0
 800879a:	d022      	beq.n	80087e2 <HAL_RCCEx_PeriphCLKConfig+0x5a6>
 800879c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 80087a0:	d115      	bne.n	80087ce <HAL_RCCEx_PeriphCLKConfig+0x592>
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI4/5 */

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 80087a2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80087a6:	3308      	adds	r3, #8
 80087a8:	2101      	movs	r1, #1
 80087aa:	4618      	mov	r0, r3
 80087ac:	f002 f8e0 	bl	800a970 <RCCEx_PLL2_Config>
 80087b0:	4603      	mov	r3, r0
 80087b2:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPI4/5 clock source configuration done later after clock selection check */
        break;
 80087b6:	e015      	b.n	80087e4 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
      case RCC_SPI45CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI4/5 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 80087b8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80087bc:	3328      	adds	r3, #40	@ 0x28
 80087be:	2101      	movs	r1, #1
 80087c0:	4618      	mov	r0, r3
 80087c2:	f002 f987 	bl	800aad4 <RCCEx_PLL3_Config>
 80087c6:	4603      	mov	r3, r0
 80087c8:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;
 80087cc:	e00a      	b.n	80087e4 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        /* HSE,  oscillator is used as source of SPI4/5 clock */
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 80087ce:	2301      	movs	r3, #1
 80087d0:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 80087d4:	e006      	b.n	80087e4 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
 80087d6:	bf00      	nop
 80087d8:	e004      	b.n	80087e4 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
 80087da:	bf00      	nop
 80087dc:	e002      	b.n	80087e4 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
 80087de:	bf00      	nop
 80087e0:	e000      	b.n	80087e4 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
 80087e2:	bf00      	nop
    }

    if (ret == HAL_OK)
 80087e4:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80087e8:	2b00      	cmp	r3, #0
 80087ea:	d10d      	bne.n	8008808 <HAL_RCCEx_PeriphCLKConfig+0x5cc>
    {
      /* Set the source of SPI4/5 clock*/
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
 80087ec:	4b05      	ldr	r3, [pc, #20]	@ (8008804 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 80087ee:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80087f0:	f423 21e0 	bic.w	r1, r3, #458752	@ 0x70000
 80087f4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80087f8:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 80087fa:	4a02      	ldr	r2, [pc, #8]	@ (8008804 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 80087fc:	430b      	orrs	r3, r1
 80087fe:	6513      	str	r3, [r2, #80]	@ 0x50
 8008800:	e006      	b.n	8008810 <HAL_RCCEx_PeriphCLKConfig+0x5d4>
 8008802:	bf00      	nop
 8008804:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 8008808:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 800880c:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- SPI6 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
 8008810:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008814:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008818:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
 800881c:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 8008820:	2300      	movs	r3, #0
 8008822:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 8008826:	e9d7 1238 	ldrd	r1, r2, [r7, #224]	@ 0xe0
 800882a:	460b      	mov	r3, r1
 800882c:	4313      	orrs	r3, r2
 800882e:	d055      	beq.n	80088dc <HAL_RCCEx_PeriphCLKConfig+0x6a0>
  {
    switch (PeriphClkInit->Spi6ClockSelection)
 8008830:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008834:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 8008838:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 800883c:	d033      	beq.n	80088a6 <HAL_RCCEx_PeriphCLKConfig+0x66a>
 800883e:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8008842:	d82c      	bhi.n	800889e <HAL_RCCEx_PeriphCLKConfig+0x662>
 8008844:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8008848:	d02f      	beq.n	80088aa <HAL_RCCEx_PeriphCLKConfig+0x66e>
 800884a:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800884e:	d826      	bhi.n	800889e <HAL_RCCEx_PeriphCLKConfig+0x662>
 8008850:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8008854:	d02b      	beq.n	80088ae <HAL_RCCEx_PeriphCLKConfig+0x672>
 8008856:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 800885a:	d820      	bhi.n	800889e <HAL_RCCEx_PeriphCLKConfig+0x662>
 800885c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8008860:	d012      	beq.n	8008888 <HAL_RCCEx_PeriphCLKConfig+0x64c>
 8008862:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8008866:	d81a      	bhi.n	800889e <HAL_RCCEx_PeriphCLKConfig+0x662>
 8008868:	2b00      	cmp	r3, #0
 800886a:	d022      	beq.n	80088b2 <HAL_RCCEx_PeriphCLKConfig+0x676>
 800886c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8008870:	d115      	bne.n	800889e <HAL_RCCEx_PeriphCLKConfig+0x662>
        /* SPI6 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI6*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8008872:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008876:	3308      	adds	r3, #8
 8008878:	2101      	movs	r1, #1
 800887a:	4618      	mov	r0, r3
 800887c:	f002 f878 	bl	800a970 <RCCEx_PLL2_Config>
 8008880:	4603      	mov	r3, r0
 8008882:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPI6 clock source configuration done later after clock selection check */
        break;
 8008886:	e015      	b.n	80088b4 <HAL_RCCEx_PeriphCLKConfig+0x678>
      case RCC_SPI6CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI6*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8008888:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800888c:	3328      	adds	r3, #40	@ 0x28
 800888e:	2101      	movs	r1, #1
 8008890:	4618      	mov	r0, r3
 8008892:	f002 f91f 	bl	800aad4 <RCCEx_PLL3_Config>
 8008896:	4603      	mov	r3, r0
 8008898:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* SPI6 clock source configuration done later after clock selection check */
        break;
 800889c:	e00a      	b.n	80088b4 <HAL_RCCEx_PeriphCLKConfig+0x678>
        /* SPI6 clock source configuration done later after clock selection check */
        break;
#endif

      default:
        ret = HAL_ERROR;
 800889e:	2301      	movs	r3, #1
 80088a0:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 80088a4:	e006      	b.n	80088b4 <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
 80088a6:	bf00      	nop
 80088a8:	e004      	b.n	80088b4 <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
 80088aa:	bf00      	nop
 80088ac:	e002      	b.n	80088b4 <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
 80088ae:	bf00      	nop
 80088b0:	e000      	b.n	80088b4 <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
 80088b2:	bf00      	nop
    }

    if (ret == HAL_OK)
 80088b4:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80088b8:	2b00      	cmp	r3, #0
 80088ba:	d10b      	bne.n	80088d4 <HAL_RCCEx_PeriphCLKConfig+0x698>
    {
      /* Set the source of SPI6 clock*/
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
 80088bc:	4ba3      	ldr	r3, [pc, #652]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 80088be:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80088c0:	f023 41e0 	bic.w	r1, r3, #1879048192	@ 0x70000000
 80088c4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80088c8:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 80088cc:	4a9f      	ldr	r2, [pc, #636]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 80088ce:	430b      	orrs	r3, r1
 80088d0:	6593      	str	r3, [r2, #88]	@ 0x58
 80088d2:	e003      	b.n	80088dc <HAL_RCCEx_PeriphCLKConfig+0x6a0>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80088d4:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80088d8:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
  }
#endif /*DSI*/

#if defined(FDCAN1) || defined(FDCAN2)
  /*---------------------------- FDCAN configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 80088dc:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80088e0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80088e4:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
 80088e8:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 80088ec:	2300      	movs	r3, #0
 80088ee:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
 80088f2:	e9d7 1236 	ldrd	r1, r2, [r7, #216]	@ 0xd8
 80088f6:	460b      	mov	r3, r1
 80088f8:	4313      	orrs	r3, r2
 80088fa:	d037      	beq.n	800896c <HAL_RCCEx_PeriphCLKConfig+0x730>
  {
    switch (PeriphClkInit->FdcanClockSelection)
 80088fc:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008900:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8008902:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8008906:	d00e      	beq.n	8008926 <HAL_RCCEx_PeriphCLKConfig+0x6ea>
 8008908:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800890c:	d816      	bhi.n	800893c <HAL_RCCEx_PeriphCLKConfig+0x700>
 800890e:	2b00      	cmp	r3, #0
 8008910:	d018      	beq.n	8008944 <HAL_RCCEx_PeriphCLKConfig+0x708>
 8008912:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8008916:	d111      	bne.n	800893c <HAL_RCCEx_PeriphCLKConfig+0x700>
    {
      case RCC_FDCANCLKSOURCE_PLL:      /* PLL is used as clock source for FDCAN*/
        /* Enable FDCAN Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8008918:	4b8c      	ldr	r3, [pc, #560]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 800891a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800891c:	4a8b      	ldr	r2, [pc, #556]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 800891e:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8008922:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* FDCAN clock source configuration done later after clock selection check */
        break;
 8008924:	e00f      	b.n	8008946 <HAL_RCCEx_PeriphCLKConfig+0x70a>

      case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is used as clock source for FDCAN*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8008926:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800892a:	3308      	adds	r3, #8
 800892c:	2101      	movs	r1, #1
 800892e:	4618      	mov	r0, r3
 8008930:	f002 f81e 	bl	800a970 <RCCEx_PLL2_Config>
 8008934:	4603      	mov	r3, r0
 8008936:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* FDCAN clock source configuration done later after clock selection check */
        break;
 800893a:	e004      	b.n	8008946 <HAL_RCCEx_PeriphCLKConfig+0x70a>
        /* HSE is used as clock source for FDCAN*/
        /* FDCAN clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800893c:	2301      	movs	r3, #1
 800893e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8008942:	e000      	b.n	8008946 <HAL_RCCEx_PeriphCLKConfig+0x70a>
        break;
 8008944:	bf00      	nop
    }

    if (ret == HAL_OK)
 8008946:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 800894a:	2b00      	cmp	r3, #0
 800894c:	d10a      	bne.n	8008964 <HAL_RCCEx_PeriphCLKConfig+0x728>
    {
      /* Set the source of FDCAN clock*/
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 800894e:	4b7f      	ldr	r3, [pc, #508]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 8008950:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8008952:	f023 5140 	bic.w	r1, r3, #805306368	@ 0x30000000
 8008956:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800895a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 800895c:	4a7b      	ldr	r2, [pc, #492]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 800895e:	430b      	orrs	r3, r1
 8008960:	6513      	str	r3, [r2, #80]	@ 0x50
 8008962:	e003      	b.n	800896c <HAL_RCCEx_PeriphCLKConfig+0x730>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8008964:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008968:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
#endif /*FDCAN1 || FDCAN2*/

  /*---------------------------- FMC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
 800896c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008970:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008974:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
 8008978:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 800897c:	2300      	movs	r3, #0
 800897e:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 8008982:	e9d7 1234 	ldrd	r1, r2, [r7, #208]	@ 0xd0
 8008986:	460b      	mov	r3, r1
 8008988:	4313      	orrs	r3, r2
 800898a:	d039      	beq.n	8008a00 <HAL_RCCEx_PeriphCLKConfig+0x7c4>
  {
    switch (PeriphClkInit->FmcClockSelection)
 800898c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008990:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8008992:	2b03      	cmp	r3, #3
 8008994:	d81c      	bhi.n	80089d0 <HAL_RCCEx_PeriphCLKConfig+0x794>
 8008996:	a201      	add	r2, pc, #4	@ (adr r2, 800899c <HAL_RCCEx_PeriphCLKConfig+0x760>)
 8008998:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800899c:	080089d9 	.word	0x080089d9
 80089a0:	080089ad 	.word	0x080089ad
 80089a4:	080089bb 	.word	0x080089bb
 80089a8:	080089d9 	.word	0x080089d9
    {
      case RCC_FMCCLKSOURCE_PLL:      /* PLL is used as clock source for FMC*/
        /* Enable FMC Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80089ac:	4b67      	ldr	r3, [pc, #412]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 80089ae:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80089b0:	4a66      	ldr	r2, [pc, #408]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 80089b2:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80089b6:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* FMC clock source configuration done later after clock selection check */
        break;
 80089b8:	e00f      	b.n	80089da <HAL_RCCEx_PeriphCLKConfig+0x79e>

      case RCC_FMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for FMC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 80089ba:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80089be:	3308      	adds	r3, #8
 80089c0:	2102      	movs	r1, #2
 80089c2:	4618      	mov	r0, r3
 80089c4:	f001 ffd4 	bl	800a970 <RCCEx_PLL2_Config>
 80089c8:	4603      	mov	r3, r0
 80089ca:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* FMC clock source configuration done later after clock selection check */
        break;
 80089ce:	e004      	b.n	80089da <HAL_RCCEx_PeriphCLKConfig+0x79e>
      case RCC_FMCCLKSOURCE_HCLK:
        /* D1/CD HCLK  clock selected as FMC kernel peripheral clock */
        break;

      default:
        ret = HAL_ERROR;
 80089d0:	2301      	movs	r3, #1
 80089d2:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 80089d6:	e000      	b.n	80089da <HAL_RCCEx_PeriphCLKConfig+0x79e>
        break;
 80089d8:	bf00      	nop
    }

    if (ret == HAL_OK)
 80089da:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80089de:	2b00      	cmp	r3, #0
 80089e0:	d10a      	bne.n	80089f8 <HAL_RCCEx_PeriphCLKConfig+0x7bc>
    {
      /* Set the source of FMC clock*/
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
 80089e2:	4b5a      	ldr	r3, [pc, #360]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 80089e4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80089e6:	f023 0103 	bic.w	r1, r3, #3
 80089ea:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80089ee:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 80089f0:	4a56      	ldr	r2, [pc, #344]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 80089f2:	430b      	orrs	r3, r1
 80089f4:	64d3      	str	r3, [r2, #76]	@ 0x4c
 80089f6:	e003      	b.n	8008a00 <HAL_RCCEx_PeriphCLKConfig+0x7c4>
    }
    else
    {
      /* set overall return value */
      status = ret;
 80089f8:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80089fc:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- RTC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8008a00:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008a04:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008a08:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
 8008a0c:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8008a10:	2300      	movs	r3, #0
 8008a12:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 8008a16:	e9d7 1232 	ldrd	r1, r2, [r7, #200]	@ 0xc8
 8008a1a:	460b      	mov	r3, r1
 8008a1c:	4313      	orrs	r3, r2
 8008a1e:	f000 809f 	beq.w	8008b60 <HAL_RCCEx_PeriphCLKConfig+0x924>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8008a22:	4b4b      	ldr	r3, [pc, #300]	@ (8008b50 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8008a24:	681b      	ldr	r3, [r3, #0]
 8008a26:	4a4a      	ldr	r2, [pc, #296]	@ (8008b50 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8008a28:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8008a2c:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8008a2e:	f7f9 faa1 	bl	8001f74 <HAL_GetTick>
 8008a32:	f8c7 0120 	str.w	r0, [r7, #288]	@ 0x120

    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8008a36:	e00b      	b.n	8008a50 <HAL_RCCEx_PeriphCLKConfig+0x814>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8008a38:	f7f9 fa9c 	bl	8001f74 <HAL_GetTick>
 8008a3c:	4602      	mov	r2, r0
 8008a3e:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8008a42:	1ad3      	subs	r3, r2, r3
 8008a44:	2b64      	cmp	r3, #100	@ 0x64
 8008a46:	d903      	bls.n	8008a50 <HAL_RCCEx_PeriphCLKConfig+0x814>
      {
        ret = HAL_TIMEOUT;
 8008a48:	2303      	movs	r3, #3
 8008a4a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8008a4e:	e005      	b.n	8008a5c <HAL_RCCEx_PeriphCLKConfig+0x820>
    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8008a50:	4b3f      	ldr	r3, [pc, #252]	@ (8008b50 <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8008a52:	681b      	ldr	r3, [r3, #0]
 8008a54:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8008a58:	2b00      	cmp	r3, #0
 8008a5a:	d0ed      	beq.n	8008a38 <HAL_RCCEx_PeriphCLKConfig+0x7fc>
      }
    }

    if (ret == HAL_OK)
 8008a5c:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008a60:	2b00      	cmp	r3, #0
 8008a62:	d179      	bne.n	8008b58 <HAL_RCCEx_PeriphCLKConfig+0x91c>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if ((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 8008a64:	4b39      	ldr	r3, [pc, #228]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 8008a66:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 8008a68:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008a6c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 8008a70:	4053      	eors	r3, r2
 8008a72:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8008a76:	2b00      	cmp	r3, #0
 8008a78:	d015      	beq.n	8008aa6 <HAL_RCCEx_PeriphCLKConfig+0x86a>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8008a7a:	4b34      	ldr	r3, [pc, #208]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 8008a7c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8008a7e:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8008a82:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 8008a86:	4b31      	ldr	r3, [pc, #196]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 8008a88:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8008a8a:	4a30      	ldr	r2, [pc, #192]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 8008a8c:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8008a90:	6713      	str	r3, [r2, #112]	@ 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
 8008a92:	4b2e      	ldr	r3, [pc, #184]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 8008a94:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8008a96:	4a2d      	ldr	r2, [pc, #180]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 8008a98:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8008a9c:	6713      	str	r3, [r2, #112]	@ 0x70
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpreg;
 8008a9e:	4a2b      	ldr	r2, [pc, #172]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 8008aa0:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8008aa4:	6713      	str	r3, [r2, #112]	@ 0x70
      }

      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
 8008aa6:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008aaa:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 8008aae:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8008ab2:	d118      	bne.n	8008ae6 <HAL_RCCEx_PeriphCLKConfig+0x8aa>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8008ab4:	f7f9 fa5e 	bl	8001f74 <HAL_GetTick>
 8008ab8:	f8c7 0120 	str.w	r0, [r7, #288]	@ 0x120

        /* Wait till LSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8008abc:	e00d      	b.n	8008ada <HAL_RCCEx_PeriphCLKConfig+0x89e>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8008abe:	f7f9 fa59 	bl	8001f74 <HAL_GetTick>
 8008ac2:	4602      	mov	r2, r0
 8008ac4:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8008ac8:	1ad2      	subs	r2, r2, r3
 8008aca:	f241 3388 	movw	r3, #5000	@ 0x1388
 8008ace:	429a      	cmp	r2, r3
 8008ad0:	d903      	bls.n	8008ada <HAL_RCCEx_PeriphCLKConfig+0x89e>
          {
            ret = HAL_TIMEOUT;
 8008ad2:	2303      	movs	r3, #3
 8008ad4:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
            break;
 8008ad8:	e005      	b.n	8008ae6 <HAL_RCCEx_PeriphCLKConfig+0x8aa>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8008ada:	4b1c      	ldr	r3, [pc, #112]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 8008adc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8008ade:	f003 0302 	and.w	r3, r3, #2
 8008ae2:	2b00      	cmp	r3, #0
 8008ae4:	d0eb      	beq.n	8008abe <HAL_RCCEx_PeriphCLKConfig+0x882>
          }
        }
      }

      if (ret == HAL_OK)
 8008ae6:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008aea:	2b00      	cmp	r3, #0
 8008aec:	d129      	bne.n	8008b42 <HAL_RCCEx_PeriphCLKConfig+0x906>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8008aee:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008af2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 8008af6:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8008afa:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8008afe:	d10e      	bne.n	8008b1e <HAL_RCCEx_PeriphCLKConfig+0x8e2>
 8008b00:	4b12      	ldr	r3, [pc, #72]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 8008b02:	691b      	ldr	r3, [r3, #16]
 8008b04:	f423 517c 	bic.w	r1, r3, #16128	@ 0x3f00
 8008b08:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008b0c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 8008b10:	091a      	lsrs	r2, r3, #4
 8008b12:	4b10      	ldr	r3, [pc, #64]	@ (8008b54 <HAL_RCCEx_PeriphCLKConfig+0x918>)
 8008b14:	4013      	ands	r3, r2
 8008b16:	4a0d      	ldr	r2, [pc, #52]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 8008b18:	430b      	orrs	r3, r1
 8008b1a:	6113      	str	r3, [r2, #16]
 8008b1c:	e005      	b.n	8008b2a <HAL_RCCEx_PeriphCLKConfig+0x8ee>
 8008b1e:	4b0b      	ldr	r3, [pc, #44]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 8008b20:	691b      	ldr	r3, [r3, #16]
 8008b22:	4a0a      	ldr	r2, [pc, #40]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 8008b24:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
 8008b28:	6113      	str	r3, [r2, #16]
 8008b2a:	4b08      	ldr	r3, [pc, #32]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 8008b2c:	6f19      	ldr	r1, [r3, #112]	@ 0x70
 8008b2e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008b32:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 8008b36:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8008b3a:	4a04      	ldr	r2, [pc, #16]	@ (8008b4c <HAL_RCCEx_PeriphCLKConfig+0x910>)
 8008b3c:	430b      	orrs	r3, r1
 8008b3e:	6713      	str	r3, [r2, #112]	@ 0x70
 8008b40:	e00e      	b.n	8008b60 <HAL_RCCEx_PeriphCLKConfig+0x924>
      }
      else
      {
        /* set overall return value */
        status = ret;
 8008b42:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008b46:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
 8008b4a:	e009      	b.n	8008b60 <HAL_RCCEx_PeriphCLKConfig+0x924>
 8008b4c:	58024400 	.word	0x58024400
 8008b50:	58024800 	.word	0x58024800
 8008b54:	00ffffcf 	.word	0x00ffffcf
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 8008b58:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008b5c:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }


  /*-------------------------- USART1/6 configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
 8008b60:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008b64:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008b68:	f002 0301 	and.w	r3, r2, #1
 8008b6c:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 8008b70:	2300      	movs	r3, #0
 8008b72:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 8008b76:	e9d7 1230 	ldrd	r1, r2, [r7, #192]	@ 0xc0
 8008b7a:	460b      	mov	r3, r1
 8008b7c:	4313      	orrs	r3, r2
 8008b7e:	f000 8089 	beq.w	8008c94 <HAL_RCCEx_PeriphCLKConfig+0xa58>
  {
    switch (PeriphClkInit->Usart16ClockSelection)
 8008b82:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008b86:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 8008b88:	2b28      	cmp	r3, #40	@ 0x28
 8008b8a:	d86b      	bhi.n	8008c64 <HAL_RCCEx_PeriphCLKConfig+0xa28>
 8008b8c:	a201      	add	r2, pc, #4	@ (adr r2, 8008b94 <HAL_RCCEx_PeriphCLKConfig+0x958>)
 8008b8e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008b92:	bf00      	nop
 8008b94:	08008c6d 	.word	0x08008c6d
 8008b98:	08008c65 	.word	0x08008c65
 8008b9c:	08008c65 	.word	0x08008c65
 8008ba0:	08008c65 	.word	0x08008c65
 8008ba4:	08008c65 	.word	0x08008c65
 8008ba8:	08008c65 	.word	0x08008c65
 8008bac:	08008c65 	.word	0x08008c65
 8008bb0:	08008c65 	.word	0x08008c65
 8008bb4:	08008c39 	.word	0x08008c39
 8008bb8:	08008c65 	.word	0x08008c65
 8008bbc:	08008c65 	.word	0x08008c65
 8008bc0:	08008c65 	.word	0x08008c65
 8008bc4:	08008c65 	.word	0x08008c65
 8008bc8:	08008c65 	.word	0x08008c65
 8008bcc:	08008c65 	.word	0x08008c65
 8008bd0:	08008c65 	.word	0x08008c65
 8008bd4:	08008c4f 	.word	0x08008c4f
 8008bd8:	08008c65 	.word	0x08008c65
 8008bdc:	08008c65 	.word	0x08008c65
 8008be0:	08008c65 	.word	0x08008c65
 8008be4:	08008c65 	.word	0x08008c65
 8008be8:	08008c65 	.word	0x08008c65
 8008bec:	08008c65 	.word	0x08008c65
 8008bf0:	08008c65 	.word	0x08008c65
 8008bf4:	08008c6d 	.word	0x08008c6d
 8008bf8:	08008c65 	.word	0x08008c65
 8008bfc:	08008c65 	.word	0x08008c65
 8008c00:	08008c65 	.word	0x08008c65
 8008c04:	08008c65 	.word	0x08008c65
 8008c08:	08008c65 	.word	0x08008c65
 8008c0c:	08008c65 	.word	0x08008c65
 8008c10:	08008c65 	.word	0x08008c65
 8008c14:	08008c6d 	.word	0x08008c6d
 8008c18:	08008c65 	.word	0x08008c65
 8008c1c:	08008c65 	.word	0x08008c65
 8008c20:	08008c65 	.word	0x08008c65
 8008c24:	08008c65 	.word	0x08008c65
 8008c28:	08008c65 	.word	0x08008c65
 8008c2c:	08008c65 	.word	0x08008c65
 8008c30:	08008c65 	.word	0x08008c65
 8008c34:	08008c6d 	.word	0x08008c6d
      case RCC_USART16CLKSOURCE_PCLK2: /* CD/D2 PCLK2 as clock source for USART1/6 */
        /* USART1/6 clock source configuration done later after clock selection check */
        break;

      case RCC_USART16CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART1/6 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8008c38:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008c3c:	3308      	adds	r3, #8
 8008c3e:	2101      	movs	r1, #1
 8008c40:	4618      	mov	r0, r3
 8008c42:	f001 fe95 	bl	800a970 <RCCEx_PLL2_Config>
 8008c46:	4603      	mov	r3, r0
 8008c48:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* USART1/6 clock source configuration done later after clock selection check */
        break;
 8008c4c:	e00f      	b.n	8008c6e <HAL_RCCEx_PeriphCLKConfig+0xa32>

      case RCC_USART16CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART1/6 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8008c4e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008c52:	3328      	adds	r3, #40	@ 0x28
 8008c54:	2101      	movs	r1, #1
 8008c56:	4618      	mov	r0, r3
 8008c58:	f001 ff3c 	bl	800aad4 <RCCEx_PLL3_Config>
 8008c5c:	4603      	mov	r3, r0
 8008c5e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* USART1/6 clock source configuration done later after clock selection check */
        break;
 8008c62:	e004      	b.n	8008c6e <HAL_RCCEx_PeriphCLKConfig+0xa32>
        /* LSE,  oscillator is used as source of USART1/6 clock */
        /* USART1/6 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8008c64:	2301      	movs	r3, #1
 8008c66:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8008c6a:	e000      	b.n	8008c6e <HAL_RCCEx_PeriphCLKConfig+0xa32>
        break;
 8008c6c:	bf00      	nop
    }

    if (ret == HAL_OK)
 8008c6e:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008c72:	2b00      	cmp	r3, #0
 8008c74:	d10a      	bne.n	8008c8c <HAL_RCCEx_PeriphCLKConfig+0xa50>
    {
      /* Set the source of USART1/6 clock */
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
 8008c76:	4bbf      	ldr	r3, [pc, #764]	@ (8008f74 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8008c78:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8008c7a:	f023 0138 	bic.w	r1, r3, #56	@ 0x38
 8008c7e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008c82:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 8008c84:	4abb      	ldr	r2, [pc, #748]	@ (8008f74 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8008c86:	430b      	orrs	r3, r1
 8008c88:	6553      	str	r3, [r2, #84]	@ 0x54
 8008c8a:	e003      	b.n	8008c94 <HAL_RCCEx_PeriphCLKConfig+0xa58>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8008c8c:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008c90:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*-------------------------- USART2/3/4/5/7/8 Configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
 8008c94:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008c98:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008c9c:	f002 0302 	and.w	r3, r2, #2
 8008ca0:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 8008ca4:	2300      	movs	r3, #0
 8008ca6:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
 8008caa:	e9d7 122e 	ldrd	r1, r2, [r7, #184]	@ 0xb8
 8008cae:	460b      	mov	r3, r1
 8008cb0:	4313      	orrs	r3, r2
 8008cb2:	d041      	beq.n	8008d38 <HAL_RCCEx_PeriphCLKConfig+0xafc>
  {
    switch (PeriphClkInit->Usart234578ClockSelection)
 8008cb4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008cb8:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 8008cba:	2b05      	cmp	r3, #5
 8008cbc:	d824      	bhi.n	8008d08 <HAL_RCCEx_PeriphCLKConfig+0xacc>
 8008cbe:	a201      	add	r2, pc, #4	@ (adr r2, 8008cc4 <HAL_RCCEx_PeriphCLKConfig+0xa88>)
 8008cc0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008cc4:	08008d11 	.word	0x08008d11
 8008cc8:	08008cdd 	.word	0x08008cdd
 8008ccc:	08008cf3 	.word	0x08008cf3
 8008cd0:	08008d11 	.word	0x08008d11
 8008cd4:	08008d11 	.word	0x08008d11
 8008cd8:	08008d11 	.word	0x08008d11
      case RCC_USART234578CLKSOURCE_PCLK1: /* CD/D2 PCLK1 as clock source for USART2/3/4/5/7/8 */
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;

      case RCC_USART234578CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART2/3/4/5/7/8 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8008cdc:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008ce0:	3308      	adds	r3, #8
 8008ce2:	2101      	movs	r1, #1
 8008ce4:	4618      	mov	r0, r3
 8008ce6:	f001 fe43 	bl	800a970 <RCCEx_PLL2_Config>
 8008cea:	4603      	mov	r3, r0
 8008cec:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;
 8008cf0:	e00f      	b.n	8008d12 <HAL_RCCEx_PeriphCLKConfig+0xad6>

      case RCC_USART234578CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART2/3/4/5/7/8 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8008cf2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008cf6:	3328      	adds	r3, #40	@ 0x28
 8008cf8:	2101      	movs	r1, #1
 8008cfa:	4618      	mov	r0, r3
 8008cfc:	f001 feea 	bl	800aad4 <RCCEx_PLL3_Config>
 8008d00:	4603      	mov	r3, r0
 8008d02:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;
 8008d06:	e004      	b.n	8008d12 <HAL_RCCEx_PeriphCLKConfig+0xad6>
        /* LSE,  oscillator is used as source of USART2/3/4/5/7/8 clock */
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8008d08:	2301      	movs	r3, #1
 8008d0a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8008d0e:	e000      	b.n	8008d12 <HAL_RCCEx_PeriphCLKConfig+0xad6>
        break;
 8008d10:	bf00      	nop
    }

    if (ret == HAL_OK)
 8008d12:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008d16:	2b00      	cmp	r3, #0
 8008d18:	d10a      	bne.n	8008d30 <HAL_RCCEx_PeriphCLKConfig+0xaf4>
    {
      /* Set the source of USART2/3/4/5/7/8 clock */
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
 8008d1a:	4b96      	ldr	r3, [pc, #600]	@ (8008f74 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8008d1c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8008d1e:	f023 0107 	bic.w	r1, r3, #7
 8008d22:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008d26:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 8008d28:	4a92      	ldr	r2, [pc, #584]	@ (8008f74 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8008d2a:	430b      	orrs	r3, r1
 8008d2c:	6553      	str	r3, [r2, #84]	@ 0x54
 8008d2e:	e003      	b.n	8008d38 <HAL_RCCEx_PeriphCLKConfig+0xafc>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8008d30:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008d34:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8008d38:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008d3c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008d40:	f002 0304 	and.w	r3, r2, #4
 8008d44:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 8008d48:	2300      	movs	r3, #0
 8008d4a:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
 8008d4e:	e9d7 122c 	ldrd	r1, r2, [r7, #176]	@ 0xb0
 8008d52:	460b      	mov	r3, r1
 8008d54:	4313      	orrs	r3, r2
 8008d56:	d044      	beq.n	8008de2 <HAL_RCCEx_PeriphCLKConfig+0xba6>
  {
    switch (PeriphClkInit->Lpuart1ClockSelection)
 8008d58:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008d5c:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8008d60:	2b05      	cmp	r3, #5
 8008d62:	d825      	bhi.n	8008db0 <HAL_RCCEx_PeriphCLKConfig+0xb74>
 8008d64:	a201      	add	r2, pc, #4	@ (adr r2, 8008d6c <HAL_RCCEx_PeriphCLKConfig+0xb30>)
 8008d66:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008d6a:	bf00      	nop
 8008d6c:	08008db9 	.word	0x08008db9
 8008d70:	08008d85 	.word	0x08008d85
 8008d74:	08008d9b 	.word	0x08008d9b
 8008d78:	08008db9 	.word	0x08008db9
 8008d7c:	08008db9 	.word	0x08008db9
 8008d80:	08008db9 	.word	0x08008db9
      case RCC_LPUART1CLKSOURCE_PCLK4: /* SRD/D3 PCLK1 (PCLK4) as clock source for LPUART1 */
        /* LPUART1 clock source configuration done later after clock selection check */
        break;

      case RCC_LPUART1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPUART1 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8008d84:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008d88:	3308      	adds	r3, #8
 8008d8a:	2101      	movs	r1, #1
 8008d8c:	4618      	mov	r0, r3
 8008d8e:	f001 fdef 	bl	800a970 <RCCEx_PLL2_Config>
 8008d92:	4603      	mov	r3, r0
 8008d94:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* LPUART1 clock source configuration done later after clock selection check */
        break;
 8008d98:	e00f      	b.n	8008dba <HAL_RCCEx_PeriphCLKConfig+0xb7e>

      case RCC_LPUART1CLKSOURCE_PLL3: /* PLL3 is used as clock source for LPUART1 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8008d9a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008d9e:	3328      	adds	r3, #40	@ 0x28
 8008da0:	2101      	movs	r1, #1
 8008da2:	4618      	mov	r0, r3
 8008da4:	f001 fe96 	bl	800aad4 <RCCEx_PLL3_Config>
 8008da8:	4603      	mov	r3, r0
 8008daa:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* LPUART1 clock source configuration done later after clock selection check */
        break;
 8008dae:	e004      	b.n	8008dba <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        /* LSE,  oscillator is used as source of LPUART1 clock */
        /* LPUART1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8008db0:	2301      	movs	r3, #1
 8008db2:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8008db6:	e000      	b.n	8008dba <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        break;
 8008db8:	bf00      	nop
    }

    if (ret == HAL_OK)
 8008dba:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008dbe:	2b00      	cmp	r3, #0
 8008dc0:	d10b      	bne.n	8008dda <HAL_RCCEx_PeriphCLKConfig+0xb9e>
    {
      /* Set the source of LPUART1 clock */
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8008dc2:	4b6c      	ldr	r3, [pc, #432]	@ (8008f74 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8008dc4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008dc6:	f023 0107 	bic.w	r1, r3, #7
 8008dca:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008dce:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8008dd2:	4a68      	ldr	r2, [pc, #416]	@ (8008f74 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8008dd4:	430b      	orrs	r3, r1
 8008dd6:	6593      	str	r3, [r2, #88]	@ 0x58
 8008dd8:	e003      	b.n	8008de2 <HAL_RCCEx_PeriphCLKConfig+0xba6>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8008dda:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008dde:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- LPTIM1 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 8008de2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008de6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008dea:	f002 0320 	and.w	r3, r2, #32
 8008dee:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
 8008df2:	2300      	movs	r3, #0
 8008df4:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
 8008df8:	e9d7 122a 	ldrd	r1, r2, [r7, #168]	@ 0xa8
 8008dfc:	460b      	mov	r3, r1
 8008dfe:	4313      	orrs	r3, r2
 8008e00:	d055      	beq.n	8008eae <HAL_RCCEx_PeriphCLKConfig+0xc72>
  {
    switch (PeriphClkInit->Lptim1ClockSelection)
 8008e02:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008e06:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8008e0a:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8008e0e:	d033      	beq.n	8008e78 <HAL_RCCEx_PeriphCLKConfig+0xc3c>
 8008e10:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8008e14:	d82c      	bhi.n	8008e70 <HAL_RCCEx_PeriphCLKConfig+0xc34>
 8008e16:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8008e1a:	d02f      	beq.n	8008e7c <HAL_RCCEx_PeriphCLKConfig+0xc40>
 8008e1c:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8008e20:	d826      	bhi.n	8008e70 <HAL_RCCEx_PeriphCLKConfig+0xc34>
 8008e22:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8008e26:	d02b      	beq.n	8008e80 <HAL_RCCEx_PeriphCLKConfig+0xc44>
 8008e28:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8008e2c:	d820      	bhi.n	8008e70 <HAL_RCCEx_PeriphCLKConfig+0xc34>
 8008e2e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8008e32:	d012      	beq.n	8008e5a <HAL_RCCEx_PeriphCLKConfig+0xc1e>
 8008e34:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8008e38:	d81a      	bhi.n	8008e70 <HAL_RCCEx_PeriphCLKConfig+0xc34>
 8008e3a:	2b00      	cmp	r3, #0
 8008e3c:	d022      	beq.n	8008e84 <HAL_RCCEx_PeriphCLKConfig+0xc48>
 8008e3e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8008e42:	d115      	bne.n	8008e70 <HAL_RCCEx_PeriphCLKConfig+0xc34>
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM1*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8008e44:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008e48:	3308      	adds	r3, #8
 8008e4a:	2100      	movs	r1, #0
 8008e4c:	4618      	mov	r0, r3
 8008e4e:	f001 fd8f 	bl	800a970 <RCCEx_PLL2_Config>
 8008e52:	4603      	mov	r3, r0
 8008e54:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM1 clock source configuration done later after clock selection check */
        break;
 8008e58:	e015      	b.n	8008e86 <HAL_RCCEx_PeriphCLKConfig+0xc4a>

      case RCC_LPTIM1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM1*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8008e5a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008e5e:	3328      	adds	r3, #40	@ 0x28
 8008e60:	2102      	movs	r1, #2
 8008e62:	4618      	mov	r0, r3
 8008e64:	f001 fe36 	bl	800aad4 <RCCEx_PLL3_Config>
 8008e68:	4603      	mov	r3, r0
 8008e6a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM1 clock source configuration done later after clock selection check */
        break;
 8008e6e:	e00a      	b.n	8008e86 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM1 clock */
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8008e70:	2301      	movs	r3, #1
 8008e72:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8008e76:	e006      	b.n	8008e86 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
 8008e78:	bf00      	nop
 8008e7a:	e004      	b.n	8008e86 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
 8008e7c:	bf00      	nop
 8008e7e:	e002      	b.n	8008e86 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
 8008e80:	bf00      	nop
 8008e82:	e000      	b.n	8008e86 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
 8008e84:	bf00      	nop
    }

    if (ret == HAL_OK)
 8008e86:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008e8a:	2b00      	cmp	r3, #0
 8008e8c:	d10b      	bne.n	8008ea6 <HAL_RCCEx_PeriphCLKConfig+0xc6a>
    {
      /* Set the source of LPTIM1 clock*/
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8008e8e:	4b39      	ldr	r3, [pc, #228]	@ (8008f74 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8008e90:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8008e92:	f023 41e0 	bic.w	r1, r3, #1879048192	@ 0x70000000
 8008e96:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008e9a:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8008e9e:	4a35      	ldr	r2, [pc, #212]	@ (8008f74 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8008ea0:	430b      	orrs	r3, r1
 8008ea2:	6553      	str	r3, [r2, #84]	@ 0x54
 8008ea4:	e003      	b.n	8008eae <HAL_RCCEx_PeriphCLKConfig+0xc72>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8008ea6:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008eaa:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- LPTIM2 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
 8008eae:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008eb2:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008eb6:	f002 0340 	and.w	r3, r2, #64	@ 0x40
 8008eba:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 8008ebe:	2300      	movs	r3, #0
 8008ec0:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
 8008ec4:	e9d7 1228 	ldrd	r1, r2, [r7, #160]	@ 0xa0
 8008ec8:	460b      	mov	r3, r1
 8008eca:	4313      	orrs	r3, r2
 8008ecc:	d058      	beq.n	8008f80 <HAL_RCCEx_PeriphCLKConfig+0xd44>
  {
    switch (PeriphClkInit->Lptim2ClockSelection)
 8008ece:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008ed2:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8008ed6:	f5b3 5fa0 	cmp.w	r3, #5120	@ 0x1400
 8008eda:	d033      	beq.n	8008f44 <HAL_RCCEx_PeriphCLKConfig+0xd08>
 8008edc:	f5b3 5fa0 	cmp.w	r3, #5120	@ 0x1400
 8008ee0:	d82c      	bhi.n	8008f3c <HAL_RCCEx_PeriphCLKConfig+0xd00>
 8008ee2:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8008ee6:	d02f      	beq.n	8008f48 <HAL_RCCEx_PeriphCLKConfig+0xd0c>
 8008ee8:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8008eec:	d826      	bhi.n	8008f3c <HAL_RCCEx_PeriphCLKConfig+0xd00>
 8008eee:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 8008ef2:	d02b      	beq.n	8008f4c <HAL_RCCEx_PeriphCLKConfig+0xd10>
 8008ef4:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 8008ef8:	d820      	bhi.n	8008f3c <HAL_RCCEx_PeriphCLKConfig+0xd00>
 8008efa:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8008efe:	d012      	beq.n	8008f26 <HAL_RCCEx_PeriphCLKConfig+0xcea>
 8008f00:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8008f04:	d81a      	bhi.n	8008f3c <HAL_RCCEx_PeriphCLKConfig+0xd00>
 8008f06:	2b00      	cmp	r3, #0
 8008f08:	d022      	beq.n	8008f50 <HAL_RCCEx_PeriphCLKConfig+0xd14>
 8008f0a:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 8008f0e:	d115      	bne.n	8008f3c <HAL_RCCEx_PeriphCLKConfig+0xd00>
        /* LPTIM2 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM2CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM2*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8008f10:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008f14:	3308      	adds	r3, #8
 8008f16:	2100      	movs	r1, #0
 8008f18:	4618      	mov	r0, r3
 8008f1a:	f001 fd29 	bl	800a970 <RCCEx_PLL2_Config>
 8008f1e:	4603      	mov	r3, r0
 8008f20:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM2 clock source configuration done later after clock selection check */
        break;
 8008f24:	e015      	b.n	8008f52 <HAL_RCCEx_PeriphCLKConfig+0xd16>

      case RCC_LPTIM2CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM2*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8008f26:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008f2a:	3328      	adds	r3, #40	@ 0x28
 8008f2c:	2102      	movs	r1, #2
 8008f2e:	4618      	mov	r0, r3
 8008f30:	f001 fdd0 	bl	800aad4 <RCCEx_PLL3_Config>
 8008f34:	4603      	mov	r3, r0
 8008f36:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM2 clock source configuration done later after clock selection check */
        break;
 8008f3a:	e00a      	b.n	8008f52 <HAL_RCCEx_PeriphCLKConfig+0xd16>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM2 clock */
        /* LPTIM2 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8008f3c:	2301      	movs	r3, #1
 8008f3e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8008f42:	e006      	b.n	8008f52 <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
 8008f44:	bf00      	nop
 8008f46:	e004      	b.n	8008f52 <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
 8008f48:	bf00      	nop
 8008f4a:	e002      	b.n	8008f52 <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
 8008f4c:	bf00      	nop
 8008f4e:	e000      	b.n	8008f52 <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
 8008f50:	bf00      	nop
    }

    if (ret == HAL_OK)
 8008f52:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008f56:	2b00      	cmp	r3, #0
 8008f58:	d10e      	bne.n	8008f78 <HAL_RCCEx_PeriphCLKConfig+0xd3c>
    {
      /* Set the source of LPTIM2 clock*/
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8008f5a:	4b06      	ldr	r3, [pc, #24]	@ (8008f74 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8008f5c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008f5e:	f423 51e0 	bic.w	r1, r3, #7168	@ 0x1c00
 8008f62:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008f66:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8008f6a:	4a02      	ldr	r2, [pc, #8]	@ (8008f74 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8008f6c:	430b      	orrs	r3, r1
 8008f6e:	6593      	str	r3, [r2, #88]	@ 0x58
 8008f70:	e006      	b.n	8008f80 <HAL_RCCEx_PeriphCLKConfig+0xd44>
 8008f72:	bf00      	nop
 8008f74:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 8008f78:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8008f7c:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- LPTIM345 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
 8008f80:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008f84:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008f88:	f002 0380 	and.w	r3, r2, #128	@ 0x80
 8008f8c:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 8008f90:	2300      	movs	r3, #0
 8008f92:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
 8008f96:	e9d7 1226 	ldrd	r1, r2, [r7, #152]	@ 0x98
 8008f9a:	460b      	mov	r3, r1
 8008f9c:	4313      	orrs	r3, r2
 8008f9e:	d055      	beq.n	800904c <HAL_RCCEx_PeriphCLKConfig+0xe10>
  {
    switch (PeriphClkInit->Lptim345ClockSelection)
 8008fa0:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008fa4:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 8008fa8:	f5b3 4f20 	cmp.w	r3, #40960	@ 0xa000
 8008fac:	d033      	beq.n	8009016 <HAL_RCCEx_PeriphCLKConfig+0xdda>
 8008fae:	f5b3 4f20 	cmp.w	r3, #40960	@ 0xa000
 8008fb2:	d82c      	bhi.n	800900e <HAL_RCCEx_PeriphCLKConfig+0xdd2>
 8008fb4:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8008fb8:	d02f      	beq.n	800901a <HAL_RCCEx_PeriphCLKConfig+0xdde>
 8008fba:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8008fbe:	d826      	bhi.n	800900e <HAL_RCCEx_PeriphCLKConfig+0xdd2>
 8008fc0:	f5b3 4fc0 	cmp.w	r3, #24576	@ 0x6000
 8008fc4:	d02b      	beq.n	800901e <HAL_RCCEx_PeriphCLKConfig+0xde2>
 8008fc6:	f5b3 4fc0 	cmp.w	r3, #24576	@ 0x6000
 8008fca:	d820      	bhi.n	800900e <HAL_RCCEx_PeriphCLKConfig+0xdd2>
 8008fcc:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8008fd0:	d012      	beq.n	8008ff8 <HAL_RCCEx_PeriphCLKConfig+0xdbc>
 8008fd2:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8008fd6:	d81a      	bhi.n	800900e <HAL_RCCEx_PeriphCLKConfig+0xdd2>
 8008fd8:	2b00      	cmp	r3, #0
 8008fda:	d022      	beq.n	8009022 <HAL_RCCEx_PeriphCLKConfig+0xde6>
 8008fdc:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8008fe0:	d115      	bne.n	800900e <HAL_RCCEx_PeriphCLKConfig+0xdd2>
      case RCC_LPTIM345CLKSOURCE_PCLK4:      /* SRD/D3 PCLK1 (PCLK4) as clock source for LPTIM3/4/5 */
        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM345CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM3/4/5 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8008fe2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008fe6:	3308      	adds	r3, #8
 8008fe8:	2100      	movs	r1, #0
 8008fea:	4618      	mov	r0, r3
 8008fec:	f001 fcc0 	bl	800a970 <RCCEx_PLL2_Config>
 8008ff0:	4603      	mov	r3, r0
 8008ff2:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;
 8008ff6:	e015      	b.n	8009024 <HAL_RCCEx_PeriphCLKConfig+0xde8>

      case RCC_LPTIM345CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM3/4/5 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8008ff8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8008ffc:	3328      	adds	r3, #40	@ 0x28
 8008ffe:	2102      	movs	r1, #2
 8009000:	4618      	mov	r0, r3
 8009002:	f001 fd67 	bl	800aad4 <RCCEx_PLL3_Config>
 8009006:	4603      	mov	r3, r0
 8009008:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;
 800900c:	e00a      	b.n	8009024 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM3/4/5 clock */
        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800900e:	2301      	movs	r3, #1
 8009010:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8009014:	e006      	b.n	8009024 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
 8009016:	bf00      	nop
 8009018:	e004      	b.n	8009024 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
 800901a:	bf00      	nop
 800901c:	e002      	b.n	8009024 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
 800901e:	bf00      	nop
 8009020:	e000      	b.n	8009024 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
 8009022:	bf00      	nop
    }

    if (ret == HAL_OK)
 8009024:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8009028:	2b00      	cmp	r3, #0
 800902a:	d10b      	bne.n	8009044 <HAL_RCCEx_PeriphCLKConfig+0xe08>
    {
      /* Set the source of LPTIM3/4/5 clock */
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
 800902c:	4ba1      	ldr	r3, [pc, #644]	@ (80092b4 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 800902e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8009030:	f423 4160 	bic.w	r1, r3, #57344	@ 0xe000
 8009034:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009038:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 800903c:	4a9d      	ldr	r2, [pc, #628]	@ (80092b4 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 800903e:	430b      	orrs	r3, r1
 8009040:	6593      	str	r3, [r2, #88]	@ 0x58
 8009042:	e003      	b.n	800904c <HAL_RCCEx_PeriphCLKConfig+0xe10>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8009044:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8009048:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126

    __HAL_RCC_I2C1235_CONFIG(PeriphClkInit->I2c1235ClockSelection);

  }
#else
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
 800904c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009050:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009054:	f002 0308 	and.w	r3, r2, #8
 8009058:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 800905c:	2300      	movs	r3, #0
 800905e:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 8009062:	e9d7 1224 	ldrd	r1, r2, [r7, #144]	@ 0x90
 8009066:	460b      	mov	r3, r1
 8009068:	4313      	orrs	r3, r2
 800906a:	d01e      	beq.n	80090aa <HAL_RCCEx_PeriphCLKConfig+0xe6e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));

    if ((PeriphClkInit->I2c123ClockSelection) == RCC_I2C123CLKSOURCE_PLL3)
 800906c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009070:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8009074:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8009078:	d10c      	bne.n	8009094 <HAL_RCCEx_PeriphCLKConfig+0xe58>
    {
      if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 800907a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800907e:	3328      	adds	r3, #40	@ 0x28
 8009080:	2102      	movs	r1, #2
 8009082:	4618      	mov	r0, r3
 8009084:	f001 fd26 	bl	800aad4 <RCCEx_PLL3_Config>
 8009088:	4603      	mov	r3, r0
 800908a:	2b00      	cmp	r3, #0
 800908c:	d002      	beq.n	8009094 <HAL_RCCEx_PeriphCLKConfig+0xe58>
      {
        status = HAL_ERROR;
 800908e:	2301      	movs	r3, #1
 8009090:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
      }
    }

    __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
 8009094:	4b87      	ldr	r3, [pc, #540]	@ (80092b4 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8009096:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8009098:	f423 5140 	bic.w	r1, r3, #12288	@ 0x3000
 800909c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80090a0:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 80090a4:	4a83      	ldr	r2, [pc, #524]	@ (80092b4 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 80090a6:	430b      	orrs	r3, r1
 80090a8:	6553      	str	r3, [r2, #84]	@ 0x54

  }
#endif /* I2C5 */

  /*------------------------------ I2C4 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 80090aa:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80090ae:	e9d3 2300 	ldrd	r2, r3, [r3]
 80090b2:	f002 0310 	and.w	r3, r2, #16
 80090b6:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 80090ba:	2300      	movs	r3, #0
 80090bc:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 80090c0:	e9d7 1222 	ldrd	r1, r2, [r7, #136]	@ 0x88
 80090c4:	460b      	mov	r3, r1
 80090c6:	4313      	orrs	r3, r2
 80090c8:	d01e      	beq.n	8009108 <HAL_RCCEx_PeriphCLKConfig+0xecc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3)
 80090ca:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80090ce:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 80090d2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80090d6:	d10c      	bne.n	80090f2 <HAL_RCCEx_PeriphCLKConfig+0xeb6>
    {
      if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 80090d8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80090dc:	3328      	adds	r3, #40	@ 0x28
 80090de:	2102      	movs	r1, #2
 80090e0:	4618      	mov	r0, r3
 80090e2:	f001 fcf7 	bl	800aad4 <RCCEx_PLL3_Config>
 80090e6:	4603      	mov	r3, r0
 80090e8:	2b00      	cmp	r3, #0
 80090ea:	d002      	beq.n	80090f2 <HAL_RCCEx_PeriphCLKConfig+0xeb6>
      {
        status = HAL_ERROR;
 80090ec:	2301      	movs	r3, #1
 80090ee:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
      }
    }

    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 80090f2:	4b70      	ldr	r3, [pc, #448]	@ (80092b4 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 80090f4:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80090f6:	f423 7140 	bic.w	r1, r3, #768	@ 0x300
 80090fa:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80090fe:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 8009102:	4a6c      	ldr	r2, [pc, #432]	@ (80092b4 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8009104:	430b      	orrs	r3, r1
 8009106:	6593      	str	r3, [r2, #88]	@ 0x58

  }

  /*---------------------------- ADC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8009108:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800910c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009110:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
 8009114:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 8009118:	2300      	movs	r3, #0
 800911a:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 800911e:	e9d7 1220 	ldrd	r1, r2, [r7, #128]	@ 0x80
 8009122:	460b      	mov	r3, r1
 8009124:	4313      	orrs	r3, r2
 8009126:	d03e      	beq.n	80091a6 <HAL_RCCEx_PeriphCLKConfig+0xf6a>
  {
    switch (PeriphClkInit->AdcClockSelection)
 8009128:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800912c:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8009130:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8009134:	d022      	beq.n	800917c <HAL_RCCEx_PeriphCLKConfig+0xf40>
 8009136:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800913a:	d81b      	bhi.n	8009174 <HAL_RCCEx_PeriphCLKConfig+0xf38>
 800913c:	2b00      	cmp	r3, #0
 800913e:	d003      	beq.n	8009148 <HAL_RCCEx_PeriphCLKConfig+0xf0c>
 8009140:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8009144:	d00b      	beq.n	800915e <HAL_RCCEx_PeriphCLKConfig+0xf22>
 8009146:	e015      	b.n	8009174 <HAL_RCCEx_PeriphCLKConfig+0xf38>
    {

      case RCC_ADCCLKSOURCE_PLL2: /* PLL2 is used as clock source for ADC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8009148:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800914c:	3308      	adds	r3, #8
 800914e:	2100      	movs	r1, #0
 8009150:	4618      	mov	r0, r3
 8009152:	f001 fc0d 	bl	800a970 <RCCEx_PLL2_Config>
 8009156:	4603      	mov	r3, r0
 8009158:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* ADC clock source configuration done later after clock selection check */
        break;
 800915c:	e00f      	b.n	800917e <HAL_RCCEx_PeriphCLKConfig+0xf42>

      case RCC_ADCCLKSOURCE_PLL3:  /* PLL3 is used as clock source for ADC*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 800915e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009162:	3328      	adds	r3, #40	@ 0x28
 8009164:	2102      	movs	r1, #2
 8009166:	4618      	mov	r0, r3
 8009168:	f001 fcb4 	bl	800aad4 <RCCEx_PLL3_Config>
 800916c:	4603      	mov	r3, r0
 800916e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* ADC clock source configuration done later after clock selection check */
        break;
 8009172:	e004      	b.n	800917e <HAL_RCCEx_PeriphCLKConfig+0xf42>
        /* HSI, HSE, or CSI oscillator is used as source of ADC clock */
        /* ADC clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8009174:	2301      	movs	r3, #1
 8009176:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 800917a:	e000      	b.n	800917e <HAL_RCCEx_PeriphCLKConfig+0xf42>
        break;
 800917c:	bf00      	nop
    }

    if (ret == HAL_OK)
 800917e:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8009182:	2b00      	cmp	r3, #0
 8009184:	d10b      	bne.n	800919e <HAL_RCCEx_PeriphCLKConfig+0xf62>
    {
      /* Set the source of ADC clock*/
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8009186:	4b4b      	ldr	r3, [pc, #300]	@ (80092b4 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8009188:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800918a:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
 800918e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009192:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8009196:	4a47      	ldr	r2, [pc, #284]	@ (80092b4 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8009198:	430b      	orrs	r3, r1
 800919a:	6593      	str	r3, [r2, #88]	@ 0x58
 800919c:	e003      	b.n	80091a6 <HAL_RCCEx_PeriphCLKConfig+0xf6a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800919e:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80091a2:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*------------------------------ USB Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 80091a6:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80091aa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80091ae:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
 80091b2:	67bb      	str	r3, [r7, #120]	@ 0x78
 80091b4:	2300      	movs	r3, #0
 80091b6:	67fb      	str	r3, [r7, #124]	@ 0x7c
 80091b8:	e9d7 121e 	ldrd	r1, r2, [r7, #120]	@ 0x78
 80091bc:	460b      	mov	r3, r1
 80091be:	4313      	orrs	r3, r2
 80091c0:	d03b      	beq.n	800923a <HAL_RCCEx_PeriphCLKConfig+0xffe>
  {

    switch (PeriphClkInit->UsbClockSelection)
 80091c2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80091c6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 80091ca:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 80091ce:	d01f      	beq.n	8009210 <HAL_RCCEx_PeriphCLKConfig+0xfd4>
 80091d0:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 80091d4:	d818      	bhi.n	8009208 <HAL_RCCEx_PeriphCLKConfig+0xfcc>
 80091d6:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 80091da:	d003      	beq.n	80091e4 <HAL_RCCEx_PeriphCLKConfig+0xfa8>
 80091dc:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 80091e0:	d007      	beq.n	80091f2 <HAL_RCCEx_PeriphCLKConfig+0xfb6>
 80091e2:	e011      	b.n	8009208 <HAL_RCCEx_PeriphCLKConfig+0xfcc>
    {
      case RCC_USBCLKSOURCE_PLL:      /* PLL is used as clock source for USB*/
        /* Enable USB Clock output generated form System USB . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80091e4:	4b33      	ldr	r3, [pc, #204]	@ (80092b4 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 80091e6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 80091e8:	4a32      	ldr	r2, [pc, #200]	@ (80092b4 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 80091ea:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 80091ee:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* USB clock source configuration done later after clock selection check */
        break;
 80091f0:	e00f      	b.n	8009212 <HAL_RCCEx_PeriphCLKConfig+0xfd6>

      case RCC_USBCLKSOURCE_PLL3: /* PLL3 is used as clock source for USB*/

        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 80091f2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80091f6:	3328      	adds	r3, #40	@ 0x28
 80091f8:	2101      	movs	r1, #1
 80091fa:	4618      	mov	r0, r3
 80091fc:	f001 fc6a 	bl	800aad4 <RCCEx_PLL3_Config>
 8009200:	4603      	mov	r3, r0
 8009202:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* USB clock source configuration done later after clock selection check */
        break;
 8009206:	e004      	b.n	8009212 <HAL_RCCEx_PeriphCLKConfig+0xfd6>
        /* HSI48 oscillator is used as source of USB clock */
        /* USB clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8009208:	2301      	movs	r3, #1
 800920a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 800920e:	e000      	b.n	8009212 <HAL_RCCEx_PeriphCLKConfig+0xfd6>
        break;
 8009210:	bf00      	nop
    }

    if (ret == HAL_OK)
 8009212:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8009216:	2b00      	cmp	r3, #0
 8009218:	d10b      	bne.n	8009232 <HAL_RCCEx_PeriphCLKConfig+0xff6>
    {
      /* Set the source of USB clock*/
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800921a:	4b26      	ldr	r3, [pc, #152]	@ (80092b4 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 800921c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800921e:	f423 1140 	bic.w	r1, r3, #3145728	@ 0x300000
 8009222:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009226:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800922a:	4a22      	ldr	r2, [pc, #136]	@ (80092b4 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 800922c:	430b      	orrs	r3, r1
 800922e:	6553      	str	r3, [r2, #84]	@ 0x54
 8009230:	e003      	b.n	800923a <HAL_RCCEx_PeriphCLKConfig+0xffe>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8009232:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8009236:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }

  }

  /*------------------------------------- SDMMC Configuration ------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
 800923a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800923e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009242:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
 8009246:	673b      	str	r3, [r7, #112]	@ 0x70
 8009248:	2300      	movs	r3, #0
 800924a:	677b      	str	r3, [r7, #116]	@ 0x74
 800924c:	e9d7 121c 	ldrd	r1, r2, [r7, #112]	@ 0x70
 8009250:	460b      	mov	r3, r1
 8009252:	4313      	orrs	r3, r2
 8009254:	d034      	beq.n	80092c0 <HAL_RCCEx_PeriphCLKConfig+0x1084>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));

    switch (PeriphClkInit->SdmmcClockSelection)
 8009256:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800925a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800925c:	2b00      	cmp	r3, #0
 800925e:	d003      	beq.n	8009268 <HAL_RCCEx_PeriphCLKConfig+0x102c>
 8009260:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8009264:	d007      	beq.n	8009276 <HAL_RCCEx_PeriphCLKConfig+0x103a>
 8009266:	e011      	b.n	800928c <HAL_RCCEx_PeriphCLKConfig+0x1050>
    {
      case RCC_SDMMCCLKSOURCE_PLL:      /* PLL is used as clock source for SDMMC*/
        /* Enable SDMMC Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8009268:	4b12      	ldr	r3, [pc, #72]	@ (80092b4 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 800926a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800926c:	4a11      	ldr	r2, [pc, #68]	@ (80092b4 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 800926e:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8009272:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SDMMC clock source configuration done later after clock selection check */
        break;
 8009274:	e00e      	b.n	8009294 <HAL_RCCEx_PeriphCLKConfig+0x1058>

      case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for SDMMC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 8009276:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800927a:	3308      	adds	r3, #8
 800927c:	2102      	movs	r1, #2
 800927e:	4618      	mov	r0, r3
 8009280:	f001 fb76 	bl	800a970 <RCCEx_PLL2_Config>
 8009284:	4603      	mov	r3, r0
 8009286:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SDMMC clock source configuration done later after clock selection check */
        break;
 800928a:	e003      	b.n	8009294 <HAL_RCCEx_PeriphCLKConfig+0x1058>

      default:
        ret = HAL_ERROR;
 800928c:	2301      	movs	r3, #1
 800928e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8009292:	bf00      	nop
    }

    if (ret == HAL_OK)
 8009294:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8009298:	2b00      	cmp	r3, #0
 800929a:	d10d      	bne.n	80092b8 <HAL_RCCEx_PeriphCLKConfig+0x107c>
    {
      /* Set the source of SDMMC clock*/
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
 800929c:	4b05      	ldr	r3, [pc, #20]	@ (80092b4 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 800929e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80092a0:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
 80092a4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80092a8:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80092aa:	4a02      	ldr	r2, [pc, #8]	@ (80092b4 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 80092ac:	430b      	orrs	r3, r1
 80092ae:	64d3      	str	r3, [r2, #76]	@ 0x4c
 80092b0:	e006      	b.n	80092c0 <HAL_RCCEx_PeriphCLKConfig+0x1084>
 80092b2:	bf00      	nop
 80092b4:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 80092b8:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80092bc:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

#if defined(LTDC)
  /*-------------------------------------- LTDC Configuration -----------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 80092c0:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80092c4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80092c8:	f002 5300 	and.w	r3, r2, #536870912	@ 0x20000000
 80092cc:	66bb      	str	r3, [r7, #104]	@ 0x68
 80092ce:	2300      	movs	r3, #0
 80092d0:	66fb      	str	r3, [r7, #108]	@ 0x6c
 80092d2:	e9d7 121a 	ldrd	r1, r2, [r7, #104]	@ 0x68
 80092d6:	460b      	mov	r3, r1
 80092d8:	4313      	orrs	r3, r2
 80092da:	d00c      	beq.n	80092f6 <HAL_RCCEx_PeriphCLKConfig+0x10ba>
  {
    if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 80092dc:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80092e0:	3328      	adds	r3, #40	@ 0x28
 80092e2:	2102      	movs	r1, #2
 80092e4:	4618      	mov	r0, r3
 80092e6:	f001 fbf5 	bl	800aad4 <RCCEx_PLL3_Config>
 80092ea:	4603      	mov	r3, r0
 80092ec:	2b00      	cmp	r3, #0
 80092ee:	d002      	beq.n	80092f6 <HAL_RCCEx_PeriphCLKConfig+0x10ba>
    {
      status = HAL_ERROR;
 80092f0:	2301      	movs	r3, #1
 80092f2:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
#endif /* LTDC */

  /*------------------------------ RNG Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
 80092f6:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80092fa:	e9d3 2300 	ldrd	r2, r3, [r3]
 80092fe:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
 8009302:	663b      	str	r3, [r7, #96]	@ 0x60
 8009304:	2300      	movs	r3, #0
 8009306:	667b      	str	r3, [r7, #100]	@ 0x64
 8009308:	e9d7 1218 	ldrd	r1, r2, [r7, #96]	@ 0x60
 800930c:	460b      	mov	r3, r1
 800930e:	4313      	orrs	r3, r2
 8009310:	d038      	beq.n	8009384 <HAL_RCCEx_PeriphCLKConfig+0x1148>
  {

    switch (PeriphClkInit->RngClockSelection)
 8009312:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009316:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 800931a:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 800931e:	d018      	beq.n	8009352 <HAL_RCCEx_PeriphCLKConfig+0x1116>
 8009320:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8009324:	d811      	bhi.n	800934a <HAL_RCCEx_PeriphCLKConfig+0x110e>
 8009326:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 800932a:	d014      	beq.n	8009356 <HAL_RCCEx_PeriphCLKConfig+0x111a>
 800932c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8009330:	d80b      	bhi.n	800934a <HAL_RCCEx_PeriphCLKConfig+0x110e>
 8009332:	2b00      	cmp	r3, #0
 8009334:	d011      	beq.n	800935a <HAL_RCCEx_PeriphCLKConfig+0x111e>
 8009336:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800933a:	d106      	bne.n	800934a <HAL_RCCEx_PeriphCLKConfig+0x110e>
    {
      case RCC_RNGCLKSOURCE_PLL:     /* PLL is used as clock source for RNG*/
        /* Enable RNG Clock output generated form System RNG . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800933c:	4bc3      	ldr	r3, [pc, #780]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 800933e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8009340:	4ac2      	ldr	r2, [pc, #776]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8009342:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8009346:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* RNG clock source configuration done later after clock selection check */
        break;
 8009348:	e008      	b.n	800935c <HAL_RCCEx_PeriphCLKConfig+0x1120>
        /* HSI48 oscillator is used as source of RNG clock */
        /* RNG clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 800934a:	2301      	movs	r3, #1
 800934c:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8009350:	e004      	b.n	800935c <HAL_RCCEx_PeriphCLKConfig+0x1120>
        break;
 8009352:	bf00      	nop
 8009354:	e002      	b.n	800935c <HAL_RCCEx_PeriphCLKConfig+0x1120>
        break;
 8009356:	bf00      	nop
 8009358:	e000      	b.n	800935c <HAL_RCCEx_PeriphCLKConfig+0x1120>
        break;
 800935a:	bf00      	nop
    }

    if (ret == HAL_OK)
 800935c:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8009360:	2b00      	cmp	r3, #0
 8009362:	d10b      	bne.n	800937c <HAL_RCCEx_PeriphCLKConfig+0x1140>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8009364:	4bb9      	ldr	r3, [pc, #740]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8009366:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8009368:	f423 7140 	bic.w	r1, r3, #768	@ 0x300
 800936c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009370:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8009374:	4ab5      	ldr	r2, [pc, #724]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8009376:	430b      	orrs	r3, r1
 8009378:	6553      	str	r3, [r2, #84]	@ 0x54
 800937a:	e003      	b.n	8009384 <HAL_RCCEx_PeriphCLKConfig+0x1148>
    }
    else
    {
      /* set overall return value */
      status = ret;
 800937c:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8009380:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }

  }

  /*------------------------------ SWPMI1 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 8009384:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009388:	e9d3 2300 	ldrd	r2, r3, [r3]
 800938c:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
 8009390:	65bb      	str	r3, [r7, #88]	@ 0x58
 8009392:	2300      	movs	r3, #0
 8009394:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8009396:	e9d7 1216 	ldrd	r1, r2, [r7, #88]	@ 0x58
 800939a:	460b      	mov	r3, r1
 800939c:	4313      	orrs	r3, r2
 800939e:	d009      	beq.n	80093b4 <HAL_RCCEx_PeriphCLKConfig+0x1178>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));

    /* Configure the SWPMI1 interface clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 80093a0:	4baa      	ldr	r3, [pc, #680]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 80093a2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80093a4:	f023 4100 	bic.w	r1, r3, #2147483648	@ 0x80000000
 80093a8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80093ac:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 80093ae:	4aa7      	ldr	r2, [pc, #668]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 80093b0:	430b      	orrs	r3, r1
 80093b2:	6513      	str	r3, [r2, #80]	@ 0x50
  }
#if defined(HRTIM1)
  /*------------------------------ HRTIM1 clock Configuration ----------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_HRTIM1) == RCC_PERIPHCLK_HRTIM1)
 80093b4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80093b8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80093bc:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
 80093c0:	653b      	str	r3, [r7, #80]	@ 0x50
 80093c2:	2300      	movs	r3, #0
 80093c4:	657b      	str	r3, [r7, #84]	@ 0x54
 80093c6:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	@ 0x50
 80093ca:	460b      	mov	r3, r1
 80093cc:	4313      	orrs	r3, r2
 80093ce:	d00a      	beq.n	80093e6 <HAL_RCCEx_PeriphCLKConfig+0x11aa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HRTIM1CLKSOURCE(PeriphClkInit->Hrtim1ClockSelection));

    /* Configure the HRTIM1 clock source */
    __HAL_RCC_HRTIM1_CONFIG(PeriphClkInit->Hrtim1ClockSelection);
 80093d0:	4b9e      	ldr	r3, [pc, #632]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 80093d2:	691b      	ldr	r3, [r3, #16]
 80093d4:	f423 4180 	bic.w	r1, r3, #16384	@ 0x4000
 80093d8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80093dc:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
 80093e0:	4a9a      	ldr	r2, [pc, #616]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 80093e2:	430b      	orrs	r3, r1
 80093e4:	6113      	str	r3, [r2, #16]
  }
#endif  /*HRTIM1*/
  /*------------------------------ DFSDM1 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 80093e6:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80093ea:	e9d3 2300 	ldrd	r2, r3, [r3]
 80093ee:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
 80093f2:	64bb      	str	r3, [r7, #72]	@ 0x48
 80093f4:	2300      	movs	r3, #0
 80093f6:	64fb      	str	r3, [r7, #76]	@ 0x4c
 80093f8:	e9d7 1212 	ldrd	r1, r2, [r7, #72]	@ 0x48
 80093fc:	460b      	mov	r3, r1
 80093fe:	4313      	orrs	r3, r2
 8009400:	d009      	beq.n	8009416 <HAL_RCCEx_PeriphCLKConfig+0x11da>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8009402:	4b92      	ldr	r3, [pc, #584]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8009404:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8009406:	f023 7180 	bic.w	r1, r3, #16777216	@ 0x1000000
 800940a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800940e:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 8009410:	4a8e      	ldr	r2, [pc, #568]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8009412:	430b      	orrs	r3, r1
 8009414:	6513      	str	r3, [r2, #80]	@ 0x50
    __HAL_RCC_DFSDM2_CONFIG(PeriphClkInit->Dfsdm2ClockSelection);
  }
#endif  /* DFSDM2 */

  /*------------------------------------ TIM configuration --------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
 8009416:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 800941a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800941e:	f002 4380 	and.w	r3, r2, #1073741824	@ 0x40000000
 8009422:	643b      	str	r3, [r7, #64]	@ 0x40
 8009424:	2300      	movs	r3, #0
 8009426:	647b      	str	r3, [r7, #68]	@ 0x44
 8009428:	e9d7 1210 	ldrd	r1, r2, [r7, #64]	@ 0x40
 800942c:	460b      	mov	r3, r1
 800942e:	4313      	orrs	r3, r2
 8009430:	d00e      	beq.n	8009450 <HAL_RCCEx_PeriphCLKConfig+0x1214>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8009432:	4b86      	ldr	r3, [pc, #536]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8009434:	691b      	ldr	r3, [r3, #16]
 8009436:	4a85      	ldr	r2, [pc, #532]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8009438:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 800943c:	6113      	str	r3, [r2, #16]
 800943e:	4b83      	ldr	r3, [pc, #524]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8009440:	6919      	ldr	r1, [r3, #16]
 8009442:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009446:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 800944a:	4a80      	ldr	r2, [pc, #512]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 800944c:	430b      	orrs	r3, r1
 800944e:	6113      	str	r3, [r2, #16]
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
 8009450:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009454:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009458:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
 800945c:	63bb      	str	r3, [r7, #56]	@ 0x38
 800945e:	2300      	movs	r3, #0
 8009460:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8009462:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	@ 0x38
 8009466:	460b      	mov	r3, r1
 8009468:	4313      	orrs	r3, r2
 800946a:	d009      	beq.n	8009480 <HAL_RCCEx_PeriphCLKConfig+0x1244>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
 800946c:	4b77      	ldr	r3, [pc, #476]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 800946e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8009470:	f023 5140 	bic.w	r1, r3, #805306368	@ 0x30000000
 8009474:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009478:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800947a:	4a74      	ldr	r2, [pc, #464]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 800947c:	430b      	orrs	r3, r1
 800947e:	64d3      	str	r3, [r2, #76]	@ 0x4c
  }

  /*------------------------------ CEC Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8009480:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009484:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009488:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
 800948c:	633b      	str	r3, [r7, #48]	@ 0x30
 800948e:	2300      	movs	r3, #0
 8009490:	637b      	str	r3, [r7, #52]	@ 0x34
 8009492:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	@ 0x30
 8009496:	460b      	mov	r3, r1
 8009498:	4313      	orrs	r3, r2
 800949a:	d00a      	beq.n	80094b2 <HAL_RCCEx_PeriphCLKConfig+0x1276>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC interface clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 800949c:	4b6b      	ldr	r3, [pc, #428]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 800949e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 80094a0:	f423 0140 	bic.w	r1, r3, #12582912	@ 0xc00000
 80094a4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80094a8:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 80094ac:	4a67      	ldr	r2, [pc, #412]	@ (800964c <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 80094ae:	430b      	orrs	r3, r1
 80094b0:	6553      	str	r3, [r2, #84]	@ 0x54
  }

  /*---------------------------- PLL2 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVP) == RCC_PERIPHCLK_PLL2_DIVP)
 80094b2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80094b6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80094ba:	2100      	movs	r1, #0
 80094bc:	62b9      	str	r1, [r7, #40]	@ 0x28
 80094be:	f003 0301 	and.w	r3, r3, #1
 80094c2:	62fb      	str	r3, [r7, #44]	@ 0x2c
 80094c4:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	@ 0x28
 80094c8:	460b      	mov	r3, r1
 80094ca:	4313      	orrs	r3, r2
 80094cc:	d011      	beq.n	80094f2 <HAL_RCCEx_PeriphCLKConfig+0x12b6>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 80094ce:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80094d2:	3308      	adds	r3, #8
 80094d4:	2100      	movs	r1, #0
 80094d6:	4618      	mov	r0, r3
 80094d8:	f001 fa4a 	bl	800a970 <RCCEx_PLL2_Config>
 80094dc:	4603      	mov	r3, r0
 80094de:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
    
    if (ret == HAL_OK)
 80094e2:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80094e6:	2b00      	cmp	r3, #0
 80094e8:	d003      	beq.n	80094f2 <HAL_RCCEx_PeriphCLKConfig+0x12b6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 80094ea:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80094ee:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    } 
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVQ) == RCC_PERIPHCLK_PLL2_DIVQ)
 80094f2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80094f6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80094fa:	2100      	movs	r1, #0
 80094fc:	6239      	str	r1, [r7, #32]
 80094fe:	f003 0302 	and.w	r3, r3, #2
 8009502:	627b      	str	r3, [r7, #36]	@ 0x24
 8009504:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
 8009508:	460b      	mov	r3, r1
 800950a:	4313      	orrs	r3, r2
 800950c:	d011      	beq.n	8009532 <HAL_RCCEx_PeriphCLKConfig+0x12f6>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 800950e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009512:	3308      	adds	r3, #8
 8009514:	2101      	movs	r1, #1
 8009516:	4618      	mov	r0, r3
 8009518:	f001 fa2a 	bl	800a970 <RCCEx_PLL2_Config>
 800951c:	4603      	mov	r3, r0
 800951e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
    
    if (ret == HAL_OK)
 8009522:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8009526:	2b00      	cmp	r3, #0
 8009528:	d003      	beq.n	8009532 <HAL_RCCEx_PeriphCLKConfig+0x12f6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 800952a:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 800952e:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVR) == RCC_PERIPHCLK_PLL2_DIVR)
 8009532:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009536:	e9d3 2300 	ldrd	r2, r3, [r3]
 800953a:	2100      	movs	r1, #0
 800953c:	61b9      	str	r1, [r7, #24]
 800953e:	f003 0304 	and.w	r3, r3, #4
 8009542:	61fb      	str	r3, [r7, #28]
 8009544:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 8009548:	460b      	mov	r3, r1
 800954a:	4313      	orrs	r3, r2
 800954c:	d011      	beq.n	8009572 <HAL_RCCEx_PeriphCLKConfig+0x1336>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 800954e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009552:	3308      	adds	r3, #8
 8009554:	2102      	movs	r1, #2
 8009556:	4618      	mov	r0, r3
 8009558:	f001 fa0a 	bl	800a970 <RCCEx_PLL2_Config>
 800955c:	4603      	mov	r3, r0
 800955e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
    
    if (ret == HAL_OK)
 8009562:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8009566:	2b00      	cmp	r3, #0
 8009568:	d003      	beq.n	8009572 <HAL_RCCEx_PeriphCLKConfig+0x1336>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 800956a:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 800956e:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
  

  /*---------------------------- PLL3 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVP) == RCC_PERIPHCLK_PLL3_DIVP)
 8009572:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009576:	e9d3 2300 	ldrd	r2, r3, [r3]
 800957a:	2100      	movs	r1, #0
 800957c:	6139      	str	r1, [r7, #16]
 800957e:	f003 0308 	and.w	r3, r3, #8
 8009582:	617b      	str	r3, [r7, #20]
 8009584:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 8009588:	460b      	mov	r3, r1
 800958a:	4313      	orrs	r3, r2
 800958c:	d011      	beq.n	80095b2 <HAL_RCCEx_PeriphCLKConfig+0x1376>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 800958e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009592:	3328      	adds	r3, #40	@ 0x28
 8009594:	2100      	movs	r1, #0
 8009596:	4618      	mov	r0, r3
 8009598:	f001 fa9c 	bl	800aad4 <RCCEx_PLL3_Config>
 800959c:	4603      	mov	r3, r0
 800959e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
  
    if (ret == HAL_OK)
 80095a2:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80095a6:	2b00      	cmp	r3, #0
 80095a8:	d003      	beq.n	80095b2 <HAL_RCCEx_PeriphCLKConfig+0x1376>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 80095aa:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80095ae:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVQ) == RCC_PERIPHCLK_PLL3_DIVQ)
 80095b2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80095b6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80095ba:	2100      	movs	r1, #0
 80095bc:	60b9      	str	r1, [r7, #8]
 80095be:	f003 0310 	and.w	r3, r3, #16
 80095c2:	60fb      	str	r3, [r7, #12]
 80095c4:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 80095c8:	460b      	mov	r3, r1
 80095ca:	4313      	orrs	r3, r2
 80095cc:	d011      	beq.n	80095f2 <HAL_RCCEx_PeriphCLKConfig+0x13b6>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 80095ce:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80095d2:	3328      	adds	r3, #40	@ 0x28
 80095d4:	2101      	movs	r1, #1
 80095d6:	4618      	mov	r0, r3
 80095d8:	f001 fa7c 	bl	800aad4 <RCCEx_PLL3_Config>
 80095dc:	4603      	mov	r3, r0
 80095de:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
    
    if (ret == HAL_OK)
 80095e2:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80095e6:	2b00      	cmp	r3, #0
 80095e8:	d003      	beq.n	80095f2 <HAL_RCCEx_PeriphCLKConfig+0x13b6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 80095ea:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 80095ee:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVR) == RCC_PERIPHCLK_PLL3_DIVR)
 80095f2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 80095f6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80095fa:	2100      	movs	r1, #0
 80095fc:	6039      	str	r1, [r7, #0]
 80095fe:	f003 0320 	and.w	r3, r3, #32
 8009602:	607b      	str	r3, [r7, #4]
 8009604:	e9d7 1200 	ldrd	r1, r2, [r7]
 8009608:	460b      	mov	r3, r1
 800960a:	4313      	orrs	r3, r2
 800960c:	d011      	beq.n	8009632 <HAL_RCCEx_PeriphCLKConfig+0x13f6>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 800960e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8009612:	3328      	adds	r3, #40	@ 0x28
 8009614:	2102      	movs	r1, #2
 8009616:	4618      	mov	r0, r3
 8009618:	f001 fa5c 	bl	800aad4 <RCCEx_PLL3_Config>
 800961c:	4603      	mov	r3, r0
 800961e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
    
    if (ret == HAL_OK)
 8009622:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8009626:	2b00      	cmp	r3, #0
 8009628:	d003      	beq.n	8009632 <HAL_RCCEx_PeriphCLKConfig+0x13f6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 800962a:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 800962e:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    } 
  }

  if (status == HAL_OK)
 8009632:	f897 3126 	ldrb.w	r3, [r7, #294]	@ 0x126
 8009636:	2b00      	cmp	r3, #0
 8009638:	d101      	bne.n	800963e <HAL_RCCEx_PeriphCLKConfig+0x1402>
  {
    return HAL_OK;
 800963a:	2300      	movs	r3, #0
 800963c:	e000      	b.n	8009640 <HAL_RCCEx_PeriphCLKConfig+0x1404>
  }
  return HAL_ERROR;
 800963e:	2301      	movs	r3, #1
}
 8009640:	4618      	mov	r0, r3
 8009642:	f507 7794 	add.w	r7, r7, #296	@ 0x128
 8009646:	46bd      	mov	sp, r7
 8009648:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 800964c:	58024400 	.word	0x58024400

08009650 <HAL_RCCEx_GetPeriphCLKFreq>:
  * @retval Frequency in KHz
  *
  *  (*) : Available on some STM32H7 lines only.
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint64_t PeriphClk)
{
 8009650:	b580      	push	{r7, lr}
 8009652:	b090      	sub	sp, #64	@ 0x40
 8009654:	af00      	add	r7, sp, #0
 8009656:	e9c7 0100 	strd	r0, r1, [r7]
  /* This variable is used to store the SAI and CKP clock source */
  uint32_t saiclocksource;
  uint32_t ckpclocksource;
  uint32_t srcclk;

  if (PeriphClk == RCC_PERIPHCLK_SAI1)
 800965a:	e9d7 2300 	ldrd	r2, r3, [r7]
 800965e:	f5a2 7180 	sub.w	r1, r2, #256	@ 0x100
 8009662:	430b      	orrs	r3, r1
 8009664:	f040 8094 	bne.w	8009790 <HAL_RCCEx_GetPeriphCLKFreq+0x140>
  {

    saiclocksource = __HAL_RCC_GET_SAI1_SOURCE();
 8009668:	4b9e      	ldr	r3, [pc, #632]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 800966a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800966c:	f003 0307 	and.w	r3, r3, #7
 8009670:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (saiclocksource)
 8009672:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8009674:	2b04      	cmp	r3, #4
 8009676:	f200 8087 	bhi.w	8009788 <HAL_RCCEx_GetPeriphCLKFreq+0x138>
 800967a:	a201      	add	r2, pc, #4	@ (adr r2, 8009680 <HAL_RCCEx_GetPeriphCLKFreq+0x30>)
 800967c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8009680:	08009695 	.word	0x08009695
 8009684:	080096bd 	.word	0x080096bd
 8009688:	080096e5 	.word	0x080096e5
 800968c:	08009781 	.word	0x08009781
 8009690:	0800970d 	.word	0x0800970d
    {
      case RCC_SAI1CLKSOURCE_PLL: /* PLL1 is the clock source for SAI1 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 8009694:	4b93      	ldr	r3, [pc, #588]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8009696:	681b      	ldr	r3, [r3, #0]
 8009698:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800969c:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 80096a0:	d108      	bne.n	80096b4 <HAL_RCCEx_GetPeriphCLKFreq+0x64>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 80096a2:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80096a6:	4618      	mov	r0, r3
 80096a8:	f001 f810 	bl	800a6cc <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 80096ac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 80096ae:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 80096b0:	f000 bd45 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 80096b4:	2300      	movs	r3, #0
 80096b6:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 80096b8:	f000 bd41 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI1 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 80096bc:	4b89      	ldr	r3, [pc, #548]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 80096be:	681b      	ldr	r3, [r3, #0]
 80096c0:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 80096c4:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 80096c8:	d108      	bne.n	80096dc <HAL_RCCEx_GetPeriphCLKFreq+0x8c>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 80096ca:	f107 0318 	add.w	r3, r7, #24
 80096ce:	4618      	mov	r0, r3
 80096d0:	f000 fd54 	bl	800a17c <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 80096d4:	69bb      	ldr	r3, [r7, #24]
 80096d6:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 80096d8:	f000 bd31 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 80096dc:	2300      	movs	r3, #0
 80096de:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 80096e0:	f000 bd2d 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI1CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI1 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 80096e4:	4b7f      	ldr	r3, [pc, #508]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 80096e6:	681b      	ldr	r3, [r3, #0]
 80096e8:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 80096ec:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 80096f0:	d108      	bne.n	8009704 <HAL_RCCEx_GetPeriphCLKFreq+0xb4>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 80096f2:	f107 030c 	add.w	r3, r7, #12
 80096f6:	4618      	mov	r0, r3
 80096f8:	f000 fe94 	bl	800a424 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 80096fc:	68fb      	ldr	r3, [r7, #12]
 80096fe:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009700:	f000 bd1d 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009704:	2300      	movs	r3, #0
 8009706:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009708:	f000 bd19 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI1CLKSOURCE_CLKP: /* CKPER is the clock source for SAI1*/
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 800970c:	4b75      	ldr	r3, [pc, #468]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 800970e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8009710:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 8009714:	637b      	str	r3, [r7, #52]	@ 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8009716:	4b73      	ldr	r3, [pc, #460]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8009718:	681b      	ldr	r3, [r3, #0]
 800971a:	f003 0304 	and.w	r3, r3, #4
 800971e:	2b04      	cmp	r3, #4
 8009720:	d10c      	bne.n	800973c <HAL_RCCEx_GetPeriphCLKFreq+0xec>
 8009722:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8009724:	2b00      	cmp	r3, #0
 8009726:	d109      	bne.n	800973c <HAL_RCCEx_GetPeriphCLKFreq+0xec>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8009728:	4b6e      	ldr	r3, [pc, #440]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 800972a:	681b      	ldr	r3, [r3, #0]
 800972c:	08db      	lsrs	r3, r3, #3
 800972e:	f003 0303 	and.w	r3, r3, #3
 8009732:	4a6d      	ldr	r2, [pc, #436]	@ (80098e8 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
 8009734:	fa22 f303 	lsr.w	r3, r2, r3
 8009738:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800973a:	e01f      	b.n	800977c <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 800973c:	4b69      	ldr	r3, [pc, #420]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 800973e:	681b      	ldr	r3, [r3, #0]
 8009740:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8009744:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8009748:	d106      	bne.n	8009758 <HAL_RCCEx_GetPeriphCLKFreq+0x108>
 800974a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800974c:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8009750:	d102      	bne.n	8009758 <HAL_RCCEx_GetPeriphCLKFreq+0x108>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 8009752:	4b66      	ldr	r3, [pc, #408]	@ (80098ec <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
 8009754:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8009756:	e011      	b.n	800977c <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8009758:	4b62      	ldr	r3, [pc, #392]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 800975a:	681b      	ldr	r3, [r3, #0]
 800975c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8009760:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8009764:	d106      	bne.n	8009774 <HAL_RCCEx_GetPeriphCLKFreq+0x124>
 8009766:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8009768:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800976c:	d102      	bne.n	8009774 <HAL_RCCEx_GetPeriphCLKFreq+0x124>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 800976e:	4b60      	ldr	r3, [pc, #384]	@ (80098f0 <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
 8009770:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8009772:	e003      	b.n	800977c <HAL_RCCEx_GetPeriphCLKFreq+0x12c>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 8009774:	2300      	movs	r3, #0
 8009776:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        break;
 8009778:	f000 bce1 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 800977c:	f000 bcdf 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case (RCC_SAI1CLKSOURCE_PIN): /* External clock is the clock source for SAI1 */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 8009780:	4b5c      	ldr	r3, [pc, #368]	@ (80098f4 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
 8009782:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009784:	f000 bcdb 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
 8009788:	2300      	movs	r3, #0
 800978a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800978c:	f000 bcd7 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }

#if defined(SAI3)
  else if (PeriphClk == RCC_PERIPHCLK_SAI23)
 8009790:	e9d7 2300 	ldrd	r2, r3, [r7]
 8009794:	f5a2 7100 	sub.w	r1, r2, #512	@ 0x200
 8009798:	430b      	orrs	r3, r1
 800979a:	f040 80ad 	bne.w	80098f8 <HAL_RCCEx_GetPeriphCLKFreq+0x2a8>
  {

    saiclocksource = __HAL_RCC_GET_SAI23_SOURCE();
 800979e:	4b51      	ldr	r3, [pc, #324]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 80097a0:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 80097a2:	f403 73e0 	and.w	r3, r3, #448	@ 0x1c0
 80097a6:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (saiclocksource)
 80097a8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80097aa:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80097ae:	d056      	beq.n	800985e <HAL_RCCEx_GetPeriphCLKFreq+0x20e>
 80097b0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80097b2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80097b6:	f200 8090 	bhi.w	80098da <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
 80097ba:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80097bc:	2bc0      	cmp	r3, #192	@ 0xc0
 80097be:	f000 8088 	beq.w	80098d2 <HAL_RCCEx_GetPeriphCLKFreq+0x282>
 80097c2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80097c4:	2bc0      	cmp	r3, #192	@ 0xc0
 80097c6:	f200 8088 	bhi.w	80098da <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
 80097ca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80097cc:	2b80      	cmp	r3, #128	@ 0x80
 80097ce:	d032      	beq.n	8009836 <HAL_RCCEx_GetPeriphCLKFreq+0x1e6>
 80097d0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80097d2:	2b80      	cmp	r3, #128	@ 0x80
 80097d4:	f200 8081 	bhi.w	80098da <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
 80097d8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80097da:	2b00      	cmp	r3, #0
 80097dc:	d003      	beq.n	80097e6 <HAL_RCCEx_GetPeriphCLKFreq+0x196>
 80097de:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 80097e0:	2b40      	cmp	r3, #64	@ 0x40
 80097e2:	d014      	beq.n	800980e <HAL_RCCEx_GetPeriphCLKFreq+0x1be>
 80097e4:	e079      	b.n	80098da <HAL_RCCEx_GetPeriphCLKFreq+0x28a>
    {
      case RCC_SAI23CLKSOURCE_PLL: /* PLL1 is the clock source for SAI2/3 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 80097e6:	4b3f      	ldr	r3, [pc, #252]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 80097e8:	681b      	ldr	r3, [r3, #0]
 80097ea:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 80097ee:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 80097f2:	d108      	bne.n	8009806 <HAL_RCCEx_GetPeriphCLKFreq+0x1b6>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 80097f4:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 80097f8:	4618      	mov	r0, r3
 80097fa:	f000 ff67 	bl	800a6cc <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 80097fe:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8009800:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009802:	f000 bc9c 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009806:	2300      	movs	r3, #0
 8009808:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800980a:	f000 bc98 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is the clock source for SAI2/3 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 800980e:	4b35      	ldr	r3, [pc, #212]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8009810:	681b      	ldr	r3, [r3, #0]
 8009812:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8009816:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 800981a:	d108      	bne.n	800982e <HAL_RCCEx_GetPeriphCLKFreq+0x1de>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800981c:	f107 0318 	add.w	r3, r7, #24
 8009820:	4618      	mov	r0, r3
 8009822:	f000 fcab 	bl	800a17c <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 8009826:	69bb      	ldr	r3, [r7, #24]
 8009828:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800982a:	f000 bc88 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 800982e:	2300      	movs	r3, #0
 8009830:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009832:	f000 bc84 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI23CLKSOURCE_PLL3: /* PLL3 is the clock source for SAI2/3 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 8009836:	4b2b      	ldr	r3, [pc, #172]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8009838:	681b      	ldr	r3, [r3, #0]
 800983a:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 800983e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8009842:	d108      	bne.n	8009856 <HAL_RCCEx_GetPeriphCLKFreq+0x206>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8009844:	f107 030c 	add.w	r3, r7, #12
 8009848:	4618      	mov	r0, r3
 800984a:	f000 fdeb 	bl	800a424 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 800984e:	68fb      	ldr	r3, [r7, #12]
 8009850:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009852:	f000 bc74 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009856:	2300      	movs	r3, #0
 8009858:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800985a:	f000 bc70 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI23CLKSOURCE_CLKP: /* CKPER is the clock source for SAI2/3 */
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 800985e:	4b21      	ldr	r3, [pc, #132]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8009860:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8009862:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 8009866:	637b      	str	r3, [r7, #52]	@ 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8009868:	4b1e      	ldr	r3, [pc, #120]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 800986a:	681b      	ldr	r3, [r3, #0]
 800986c:	f003 0304 	and.w	r3, r3, #4
 8009870:	2b04      	cmp	r3, #4
 8009872:	d10c      	bne.n	800988e <HAL_RCCEx_GetPeriphCLKFreq+0x23e>
 8009874:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8009876:	2b00      	cmp	r3, #0
 8009878:	d109      	bne.n	800988e <HAL_RCCEx_GetPeriphCLKFreq+0x23e>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800987a:	4b1a      	ldr	r3, [pc, #104]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 800987c:	681b      	ldr	r3, [r3, #0]
 800987e:	08db      	lsrs	r3, r3, #3
 8009880:	f003 0303 	and.w	r3, r3, #3
 8009884:	4a18      	ldr	r2, [pc, #96]	@ (80098e8 <HAL_RCCEx_GetPeriphCLKFreq+0x298>)
 8009886:	fa22 f303 	lsr.w	r3, r2, r3
 800988a:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800988c:	e01f      	b.n	80098ce <HAL_RCCEx_GetPeriphCLKFreq+0x27e>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 800988e:	4b15      	ldr	r3, [pc, #84]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 8009890:	681b      	ldr	r3, [r3, #0]
 8009892:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8009896:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800989a:	d106      	bne.n	80098aa <HAL_RCCEx_GetPeriphCLKFreq+0x25a>
 800989c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800989e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 80098a2:	d102      	bne.n	80098aa <HAL_RCCEx_GetPeriphCLKFreq+0x25a>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 80098a4:	4b11      	ldr	r3, [pc, #68]	@ (80098ec <HAL_RCCEx_GetPeriphCLKFreq+0x29c>)
 80098a6:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80098a8:	e011      	b.n	80098ce <HAL_RCCEx_GetPeriphCLKFreq+0x27e>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 80098aa:	4b0e      	ldr	r3, [pc, #56]	@ (80098e4 <HAL_RCCEx_GetPeriphCLKFreq+0x294>)
 80098ac:	681b      	ldr	r3, [r3, #0]
 80098ae:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 80098b2:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 80098b6:	d106      	bne.n	80098c6 <HAL_RCCEx_GetPeriphCLKFreq+0x276>
 80098b8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80098ba:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 80098be:	d102      	bne.n	80098c6 <HAL_RCCEx_GetPeriphCLKFreq+0x276>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 80098c0:	4b0b      	ldr	r3, [pc, #44]	@ (80098f0 <HAL_RCCEx_GetPeriphCLKFreq+0x2a0>)
 80098c2:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80098c4:	e003      	b.n	80098ce <HAL_RCCEx_GetPeriphCLKFreq+0x27e>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 80098c6:	2300      	movs	r3, #0
 80098c8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        break;
 80098ca:	f000 bc38 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 80098ce:	f000 bc36 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case (RCC_SAI23CLKSOURCE_PIN): /* External clock is the clock source for SAI2/3 */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 80098d2:	4b08      	ldr	r3, [pc, #32]	@ (80098f4 <HAL_RCCEx_GetPeriphCLKFreq+0x2a4>)
 80098d4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 80098d6:	f000 bc32 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
 80098da:	2300      	movs	r3, #0
 80098dc:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 80098de:	f000 bc2e 	b.w	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 80098e2:	bf00      	nop
 80098e4:	58024400 	.word	0x58024400
 80098e8:	03d09000 	.word	0x03d09000
 80098ec:	003d0900 	.word	0x003d0900
 80098f0:	007a1200 	.word	0x007a1200
 80098f4:	00bb8000 	.word	0x00bb8000
    }
  }
#endif

#if defined(SAI4)
  else if (PeriphClk == RCC_PERIPHCLK_SAI4A)
 80098f8:	e9d7 2300 	ldrd	r2, r3, [r7]
 80098fc:	f5a2 6180 	sub.w	r1, r2, #1024	@ 0x400
 8009900:	430b      	orrs	r3, r1
 8009902:	f040 809c 	bne.w	8009a3e <HAL_RCCEx_GetPeriphCLKFreq+0x3ee>
  {

    saiclocksource = __HAL_RCC_GET_SAI4A_SOURCE();
 8009906:	4b9e      	ldr	r3, [pc, #632]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8009908:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800990a:	f403 0360 	and.w	r3, r3, #14680064	@ 0xe00000
 800990e:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (saiclocksource)
 8009910:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8009912:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 8009916:	d054      	beq.n	80099c2 <HAL_RCCEx_GetPeriphCLKFreq+0x372>
 8009918:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800991a:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 800991e:	f200 808b 	bhi.w	8009a38 <HAL_RCCEx_GetPeriphCLKFreq+0x3e8>
 8009922:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8009924:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
 8009928:	f000 8083 	beq.w	8009a32 <HAL_RCCEx_GetPeriphCLKFreq+0x3e2>
 800992c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800992e:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
 8009932:	f200 8081 	bhi.w	8009a38 <HAL_RCCEx_GetPeriphCLKFreq+0x3e8>
 8009936:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8009938:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 800993c:	d02f      	beq.n	800999e <HAL_RCCEx_GetPeriphCLKFreq+0x34e>
 800993e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8009940:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8009944:	d878      	bhi.n	8009a38 <HAL_RCCEx_GetPeriphCLKFreq+0x3e8>
 8009946:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8009948:	2b00      	cmp	r3, #0
 800994a:	d004      	beq.n	8009956 <HAL_RCCEx_GetPeriphCLKFreq+0x306>
 800994c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800994e:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8009952:	d012      	beq.n	800997a <HAL_RCCEx_GetPeriphCLKFreq+0x32a>
 8009954:	e070      	b.n	8009a38 <HAL_RCCEx_GetPeriphCLKFreq+0x3e8>
    {
      case RCC_SAI4ACLKSOURCE_PLL: /* PLL1 is the clock source for SAI4A */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 8009956:	4b8a      	ldr	r3, [pc, #552]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8009958:	681b      	ldr	r3, [r3, #0]
 800995a:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800995e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8009962:	d107      	bne.n	8009974 <HAL_RCCEx_GetPeriphCLKFreq+0x324>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8009964:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8009968:	4618      	mov	r0, r3
 800996a:	f000 feaf 	bl	800a6cc <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 800996e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8009970:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009972:	e3e4      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009974:	2300      	movs	r3, #0
 8009976:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009978:	e3e1      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SAI4ACLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI4A */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 800997a:	4b81      	ldr	r3, [pc, #516]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 800997c:	681b      	ldr	r3, [r3, #0]
 800997e:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8009982:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8009986:	d107      	bne.n	8009998 <HAL_RCCEx_GetPeriphCLKFreq+0x348>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8009988:	f107 0318 	add.w	r3, r7, #24
 800998c:	4618      	mov	r0, r3
 800998e:	f000 fbf5 	bl	800a17c <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 8009992:	69bb      	ldr	r3, [r7, #24]
 8009994:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009996:	e3d2      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009998:	2300      	movs	r3, #0
 800999a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800999c:	e3cf      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4ACLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI4A */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 800999e:	4b78      	ldr	r3, [pc, #480]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 80099a0:	681b      	ldr	r3, [r3, #0]
 80099a2:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 80099a6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 80099aa:	d107      	bne.n	80099bc <HAL_RCCEx_GetPeriphCLKFreq+0x36c>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 80099ac:	f107 030c 	add.w	r3, r7, #12
 80099b0:	4618      	mov	r0, r3
 80099b2:	f000 fd37 	bl	800a424 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 80099b6:	68fb      	ldr	r3, [r7, #12]
 80099b8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 80099ba:	e3c0      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 80099bc:	2300      	movs	r3, #0
 80099be:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 80099c0:	e3bd      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4ACLKSOURCE_CLKP: /* CKPER is the clock source for SAI4A*/
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 80099c2:	4b6f      	ldr	r3, [pc, #444]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 80099c4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80099c6:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 80099ca:	637b      	str	r3, [r7, #52]	@ 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 80099cc:	4b6c      	ldr	r3, [pc, #432]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 80099ce:	681b      	ldr	r3, [r3, #0]
 80099d0:	f003 0304 	and.w	r3, r3, #4
 80099d4:	2b04      	cmp	r3, #4
 80099d6:	d10c      	bne.n	80099f2 <HAL_RCCEx_GetPeriphCLKFreq+0x3a2>
 80099d8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 80099da:	2b00      	cmp	r3, #0
 80099dc:	d109      	bne.n	80099f2 <HAL_RCCEx_GetPeriphCLKFreq+0x3a2>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 80099de:	4b68      	ldr	r3, [pc, #416]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 80099e0:	681b      	ldr	r3, [r3, #0]
 80099e2:	08db      	lsrs	r3, r3, #3
 80099e4:	f003 0303 	and.w	r3, r3, #3
 80099e8:	4a66      	ldr	r2, [pc, #408]	@ (8009b84 <HAL_RCCEx_GetPeriphCLKFreq+0x534>)
 80099ea:	fa22 f303 	lsr.w	r3, r2, r3
 80099ee:	63fb      	str	r3, [r7, #60]	@ 0x3c
 80099f0:	e01e      	b.n	8009a30 <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 80099f2:	4b63      	ldr	r3, [pc, #396]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 80099f4:	681b      	ldr	r3, [r3, #0]
 80099f6:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 80099fa:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 80099fe:	d106      	bne.n	8009a0e <HAL_RCCEx_GetPeriphCLKFreq+0x3be>
 8009a00:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8009a02:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8009a06:	d102      	bne.n	8009a0e <HAL_RCCEx_GetPeriphCLKFreq+0x3be>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 8009a08:	4b5f      	ldr	r3, [pc, #380]	@ (8009b88 <HAL_RCCEx_GetPeriphCLKFreq+0x538>)
 8009a0a:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8009a0c:	e010      	b.n	8009a30 <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8009a0e:	4b5c      	ldr	r3, [pc, #368]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8009a10:	681b      	ldr	r3, [r3, #0]
 8009a12:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8009a16:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8009a1a:	d106      	bne.n	8009a2a <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
 8009a1c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8009a1e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8009a22:	d102      	bne.n	8009a2a <HAL_RCCEx_GetPeriphCLKFreq+0x3da>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 8009a24:	4b59      	ldr	r3, [pc, #356]	@ (8009b8c <HAL_RCCEx_GetPeriphCLKFreq+0x53c>)
 8009a26:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8009a28:	e002      	b.n	8009a30 <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 8009a2a:	2300      	movs	r3, #0
 8009a2c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        break;
 8009a2e:	e386      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 8009a30:	e385      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4ACLKSOURCE_PIN: /* External clock is the clock source for SAI4A */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 8009a32:	4b57      	ldr	r3, [pc, #348]	@ (8009b90 <HAL_RCCEx_GetPeriphCLKFreq+0x540>)
 8009a34:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009a36:	e382      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      default :
      {
        frequency = 0;
 8009a38:	2300      	movs	r3, #0
 8009a3a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009a3c:	e37f      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }

  else if (PeriphClk == RCC_PERIPHCLK_SAI4B)
 8009a3e:	e9d7 2300 	ldrd	r2, r3, [r7]
 8009a42:	f5a2 6100 	sub.w	r1, r2, #2048	@ 0x800
 8009a46:	430b      	orrs	r3, r1
 8009a48:	f040 80a7 	bne.w	8009b9a <HAL_RCCEx_GetPeriphCLKFreq+0x54a>
  {

    saiclocksource = __HAL_RCC_GET_SAI4B_SOURCE();
 8009a4c:	4b4c      	ldr	r3, [pc, #304]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8009a4e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8009a50:	f003 63e0 	and.w	r3, r3, #117440512	@ 0x7000000
 8009a54:	633b      	str	r3, [r7, #48]	@ 0x30

    switch (saiclocksource)
 8009a56:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8009a58:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 8009a5c:	d055      	beq.n	8009b0a <HAL_RCCEx_GetPeriphCLKFreq+0x4ba>
 8009a5e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8009a60:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 8009a64:	f200 8096 	bhi.w	8009b94 <HAL_RCCEx_GetPeriphCLKFreq+0x544>
 8009a68:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8009a6a:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 8009a6e:	f000 8084 	beq.w	8009b7a <HAL_RCCEx_GetPeriphCLKFreq+0x52a>
 8009a72:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8009a74:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 8009a78:	f200 808c 	bhi.w	8009b94 <HAL_RCCEx_GetPeriphCLKFreq+0x544>
 8009a7c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8009a7e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8009a82:	d030      	beq.n	8009ae6 <HAL_RCCEx_GetPeriphCLKFreq+0x496>
 8009a84:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8009a86:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8009a8a:	f200 8083 	bhi.w	8009b94 <HAL_RCCEx_GetPeriphCLKFreq+0x544>
 8009a8e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8009a90:	2b00      	cmp	r3, #0
 8009a92:	d004      	beq.n	8009a9e <HAL_RCCEx_GetPeriphCLKFreq+0x44e>
 8009a94:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 8009a96:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 8009a9a:	d012      	beq.n	8009ac2 <HAL_RCCEx_GetPeriphCLKFreq+0x472>
 8009a9c:	e07a      	b.n	8009b94 <HAL_RCCEx_GetPeriphCLKFreq+0x544>
    {
      case RCC_SAI4BCLKSOURCE_PLL: /* PLL1 is the clock source for SAI4B */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 8009a9e:	4b38      	ldr	r3, [pc, #224]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8009aa0:	681b      	ldr	r3, [r3, #0]
 8009aa2:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8009aa6:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8009aaa:	d107      	bne.n	8009abc <HAL_RCCEx_GetPeriphCLKFreq+0x46c>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8009aac:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8009ab0:	4618      	mov	r0, r3
 8009ab2:	f000 fe0b 	bl	800a6cc <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 8009ab6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8009ab8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009aba:	e340      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009abc:	2300      	movs	r3, #0
 8009abe:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009ac0:	e33d      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SAI4BCLKSOURCE_PLL2: /* PLLI2 is the clock source for SAI4B */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8009ac2:	4b2f      	ldr	r3, [pc, #188]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8009ac4:	681b      	ldr	r3, [r3, #0]
 8009ac6:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8009aca:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8009ace:	d107      	bne.n	8009ae0 <HAL_RCCEx_GetPeriphCLKFreq+0x490>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8009ad0:	f107 0318 	add.w	r3, r7, #24
 8009ad4:	4618      	mov	r0, r3
 8009ad6:	f000 fb51 	bl	800a17c <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 8009ada:	69bb      	ldr	r3, [r7, #24]
 8009adc:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009ade:	e32e      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009ae0:	2300      	movs	r3, #0
 8009ae2:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009ae4:	e32b      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4BCLKSOURCE_PLL3: /* PLLI3 is the clock source for SAI4B */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 8009ae6:	4b26      	ldr	r3, [pc, #152]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8009ae8:	681b      	ldr	r3, [r3, #0]
 8009aea:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8009aee:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8009af2:	d107      	bne.n	8009b04 <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8009af4:	f107 030c 	add.w	r3, r7, #12
 8009af8:	4618      	mov	r0, r3
 8009afa:	f000 fc93 	bl	800a424 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 8009afe:	68fb      	ldr	r3, [r7, #12]
 8009b00:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009b02:	e31c      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009b04:	2300      	movs	r3, #0
 8009b06:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009b08:	e319      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4BCLKSOURCE_CLKP: /* CKPER is the clock source for SAI4B*/
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8009b0a:	4b1d      	ldr	r3, [pc, #116]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8009b0c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8009b0e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 8009b12:	637b      	str	r3, [r7, #52]	@ 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8009b14:	4b1a      	ldr	r3, [pc, #104]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8009b16:	681b      	ldr	r3, [r3, #0]
 8009b18:	f003 0304 	and.w	r3, r3, #4
 8009b1c:	2b04      	cmp	r3, #4
 8009b1e:	d10c      	bne.n	8009b3a <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
 8009b20:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8009b22:	2b00      	cmp	r3, #0
 8009b24:	d109      	bne.n	8009b3a <HAL_RCCEx_GetPeriphCLKFreq+0x4ea>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8009b26:	4b16      	ldr	r3, [pc, #88]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8009b28:	681b      	ldr	r3, [r3, #0]
 8009b2a:	08db      	lsrs	r3, r3, #3
 8009b2c:	f003 0303 	and.w	r3, r3, #3
 8009b30:	4a14      	ldr	r2, [pc, #80]	@ (8009b84 <HAL_RCCEx_GetPeriphCLKFreq+0x534>)
 8009b32:	fa22 f303 	lsr.w	r3, r2, r3
 8009b36:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8009b38:	e01e      	b.n	8009b78 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8009b3a:	4b11      	ldr	r3, [pc, #68]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8009b3c:	681b      	ldr	r3, [r3, #0]
 8009b3e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8009b42:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8009b46:	d106      	bne.n	8009b56 <HAL_RCCEx_GetPeriphCLKFreq+0x506>
 8009b48:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8009b4a:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8009b4e:	d102      	bne.n	8009b56 <HAL_RCCEx_GetPeriphCLKFreq+0x506>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 8009b50:	4b0d      	ldr	r3, [pc, #52]	@ (8009b88 <HAL_RCCEx_GetPeriphCLKFreq+0x538>)
 8009b52:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8009b54:	e010      	b.n	8009b78 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8009b56:	4b0a      	ldr	r3, [pc, #40]	@ (8009b80 <HAL_RCCEx_GetPeriphCLKFreq+0x530>)
 8009b58:	681b      	ldr	r3, [r3, #0]
 8009b5a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8009b5e:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8009b62:	d106      	bne.n	8009b72 <HAL_RCCEx_GetPeriphCLKFreq+0x522>
 8009b64:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8009b66:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8009b6a:	d102      	bne.n	8009b72 <HAL_RCCEx_GetPeriphCLKFreq+0x522>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 8009b6c:	4b07      	ldr	r3, [pc, #28]	@ (8009b8c <HAL_RCCEx_GetPeriphCLKFreq+0x53c>)
 8009b6e:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8009b70:	e002      	b.n	8009b78 <HAL_RCCEx_GetPeriphCLKFreq+0x528>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 8009b72:	2300      	movs	r3, #0
 8009b74:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        break;
 8009b76:	e2e2      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 8009b78:	e2e1      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SAI4BCLKSOURCE_PIN: /* External clock is the clock source for SAI4B */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 8009b7a:	4b05      	ldr	r3, [pc, #20]	@ (8009b90 <HAL_RCCEx_GetPeriphCLKFreq+0x540>)
 8009b7c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009b7e:	e2de      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 8009b80:	58024400 	.word	0x58024400
 8009b84:	03d09000 	.word	0x03d09000
 8009b88:	003d0900 	.word	0x003d0900
 8009b8c:	007a1200 	.word	0x007a1200
 8009b90:	00bb8000 	.word	0x00bb8000
      }

      default :
      {
        frequency = 0;
 8009b94:	2300      	movs	r3, #0
 8009b96:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009b98:	e2d1      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
#endif /*SAI4*/
  else if (PeriphClk == RCC_PERIPHCLK_SPI123)
 8009b9a:	e9d7 2300 	ldrd	r2, r3, [r7]
 8009b9e:	f5a2 5180 	sub.w	r1, r2, #4096	@ 0x1000
 8009ba2:	430b      	orrs	r3, r1
 8009ba4:	f040 809c 	bne.w	8009ce0 <HAL_RCCEx_GetPeriphCLKFreq+0x690>
  {
    /* Get SPI1/2/3 clock source */
    srcclk = __HAL_RCC_GET_SPI123_SOURCE();
 8009ba8:	4b93      	ldr	r3, [pc, #588]	@ (8009df8 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8009baa:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8009bac:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
 8009bb0:	63bb      	str	r3, [r7, #56]	@ 0x38

    switch (srcclk)
 8009bb2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009bb4:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8009bb8:	d054      	beq.n	8009c64 <HAL_RCCEx_GetPeriphCLKFreq+0x614>
 8009bba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009bbc:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8009bc0:	f200 808b 	bhi.w	8009cda <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
 8009bc4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009bc6:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8009bca:	f000 8083 	beq.w	8009cd4 <HAL_RCCEx_GetPeriphCLKFreq+0x684>
 8009bce:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009bd0:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8009bd4:	f200 8081 	bhi.w	8009cda <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
 8009bd8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009bda:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8009bde:	d02f      	beq.n	8009c40 <HAL_RCCEx_GetPeriphCLKFreq+0x5f0>
 8009be0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009be2:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8009be6:	d878      	bhi.n	8009cda <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
 8009be8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009bea:	2b00      	cmp	r3, #0
 8009bec:	d004      	beq.n	8009bf8 <HAL_RCCEx_GetPeriphCLKFreq+0x5a8>
 8009bee:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009bf0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8009bf4:	d012      	beq.n	8009c1c <HAL_RCCEx_GetPeriphCLKFreq+0x5cc>
 8009bf6:	e070      	b.n	8009cda <HAL_RCCEx_GetPeriphCLKFreq+0x68a>
    {
      case RCC_SPI123CLKSOURCE_PLL: /* PLL1 is the clock source for SPI123 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 8009bf8:	4b7f      	ldr	r3, [pc, #508]	@ (8009df8 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8009bfa:	681b      	ldr	r3, [r3, #0]
 8009bfc:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8009c00:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8009c04:	d107      	bne.n	8009c16 <HAL_RCCEx_GetPeriphCLKFreq+0x5c6>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8009c06:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8009c0a:	4618      	mov	r0, r3
 8009c0c:	f000 fd5e 	bl	800a6cc <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 8009c10:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8009c12:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009c14:	e293      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009c16:	2300      	movs	r3, #0
 8009c18:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009c1a:	e290      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI123 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8009c1c:	4b76      	ldr	r3, [pc, #472]	@ (8009df8 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8009c1e:	681b      	ldr	r3, [r3, #0]
 8009c20:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8009c24:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8009c28:	d107      	bne.n	8009c3a <HAL_RCCEx_GetPeriphCLKFreq+0x5ea>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8009c2a:	f107 0318 	add.w	r3, r7, #24
 8009c2e:	4618      	mov	r0, r3
 8009c30:	f000 faa4 	bl	800a17c <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 8009c34:	69bb      	ldr	r3, [r7, #24]
 8009c36:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009c38:	e281      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009c3a:	2300      	movs	r3, #0
 8009c3c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009c3e:	e27e      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SPI123CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI123 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 8009c40:	4b6d      	ldr	r3, [pc, #436]	@ (8009df8 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8009c42:	681b      	ldr	r3, [r3, #0]
 8009c44:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8009c48:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8009c4c:	d107      	bne.n	8009c5e <HAL_RCCEx_GetPeriphCLKFreq+0x60e>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8009c4e:	f107 030c 	add.w	r3, r7, #12
 8009c52:	4618      	mov	r0, r3
 8009c54:	f000 fbe6 	bl	800a424 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 8009c58:	68fb      	ldr	r3, [r7, #12]
 8009c5a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009c5c:	e26f      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009c5e:	2300      	movs	r3, #0
 8009c60:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009c62:	e26c      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_SPI123CLKSOURCE_CLKP: /* CKPER is the clock source for SPI123 */
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8009c64:	4b64      	ldr	r3, [pc, #400]	@ (8009df8 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8009c66:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8009c68:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 8009c6c:	637b      	str	r3, [r7, #52]	@ 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8009c6e:	4b62      	ldr	r3, [pc, #392]	@ (8009df8 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8009c70:	681b      	ldr	r3, [r3, #0]
 8009c72:	f003 0304 	and.w	r3, r3, #4
 8009c76:	2b04      	cmp	r3, #4
 8009c78:	d10c      	bne.n	8009c94 <HAL_RCCEx_GetPeriphCLKFreq+0x644>
 8009c7a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8009c7c:	2b00      	cmp	r3, #0
 8009c7e:	d109      	bne.n	8009c94 <HAL_RCCEx_GetPeriphCLKFreq+0x644>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8009c80:	4b5d      	ldr	r3, [pc, #372]	@ (8009df8 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8009c82:	681b      	ldr	r3, [r3, #0]
 8009c84:	08db      	lsrs	r3, r3, #3
 8009c86:	f003 0303 	and.w	r3, r3, #3
 8009c8a:	4a5c      	ldr	r2, [pc, #368]	@ (8009dfc <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>)
 8009c8c:	fa22 f303 	lsr.w	r3, r2, r3
 8009c90:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8009c92:	e01e      	b.n	8009cd2 <HAL_RCCEx_GetPeriphCLKFreq+0x682>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8009c94:	4b58      	ldr	r3, [pc, #352]	@ (8009df8 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8009c96:	681b      	ldr	r3, [r3, #0]
 8009c98:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8009c9c:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8009ca0:	d106      	bne.n	8009cb0 <HAL_RCCEx_GetPeriphCLKFreq+0x660>
 8009ca2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8009ca4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8009ca8:	d102      	bne.n	8009cb0 <HAL_RCCEx_GetPeriphCLKFreq+0x660>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 8009caa:	4b55      	ldr	r3, [pc, #340]	@ (8009e00 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 8009cac:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8009cae:	e010      	b.n	8009cd2 <HAL_RCCEx_GetPeriphCLKFreq+0x682>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8009cb0:	4b51      	ldr	r3, [pc, #324]	@ (8009df8 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8009cb2:	681b      	ldr	r3, [r3, #0]
 8009cb4:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8009cb8:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8009cbc:	d106      	bne.n	8009ccc <HAL_RCCEx_GetPeriphCLKFreq+0x67c>
 8009cbe:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8009cc0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8009cc4:	d102      	bne.n	8009ccc <HAL_RCCEx_GetPeriphCLKFreq+0x67c>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 8009cc6:	4b4f      	ldr	r3, [pc, #316]	@ (8009e04 <HAL_RCCEx_GetPeriphCLKFreq+0x7b4>)
 8009cc8:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8009cca:	e002      	b.n	8009cd2 <HAL_RCCEx_GetPeriphCLKFreq+0x682>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 8009ccc:	2300      	movs	r3, #0
 8009cce:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        break;
 8009cd0:	e235      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 8009cd2:	e234      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case (RCC_SPI123CLKSOURCE_PIN): /* External clock is the clock source for I2S */
      {
        frequency = EXTERNAL_CLOCK_VALUE;
 8009cd4:	4b4c      	ldr	r3, [pc, #304]	@ (8009e08 <HAL_RCCEx_GetPeriphCLKFreq+0x7b8>)
 8009cd6:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009cd8:	e231      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
 8009cda:	2300      	movs	r3, #0
 8009cdc:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009cde:	e22e      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI45)
 8009ce0:	e9d7 2300 	ldrd	r2, r3, [r7]
 8009ce4:	f5a2 5100 	sub.w	r1, r2, #8192	@ 0x2000
 8009ce8:	430b      	orrs	r3, r1
 8009cea:	f040 808f 	bne.w	8009e0c <HAL_RCCEx_GetPeriphCLKFreq+0x7bc>
  {
    /* Get SPI45 clock source */
    srcclk = __HAL_RCC_GET_SPI45_SOURCE();
 8009cee:	4b42      	ldr	r3, [pc, #264]	@ (8009df8 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8009cf0:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8009cf2:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
 8009cf6:	63bb      	str	r3, [r7, #56]	@ 0x38
    switch (srcclk)
 8009cf8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009cfa:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8009cfe:	d06b      	beq.n	8009dd8 <HAL_RCCEx_GetPeriphCLKFreq+0x788>
 8009d00:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009d02:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8009d06:	d874      	bhi.n	8009df2 <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
 8009d08:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009d0a:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8009d0e:	d056      	beq.n	8009dbe <HAL_RCCEx_GetPeriphCLKFreq+0x76e>
 8009d10:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009d12:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8009d16:	d86c      	bhi.n	8009df2 <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
 8009d18:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009d1a:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8009d1e:	d03b      	beq.n	8009d98 <HAL_RCCEx_GetPeriphCLKFreq+0x748>
 8009d20:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009d22:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8009d26:	d864      	bhi.n	8009df2 <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
 8009d28:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009d2a:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8009d2e:	d021      	beq.n	8009d74 <HAL_RCCEx_GetPeriphCLKFreq+0x724>
 8009d30:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009d32:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8009d36:	d85c      	bhi.n	8009df2 <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
 8009d38:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009d3a:	2b00      	cmp	r3, #0
 8009d3c:	d004      	beq.n	8009d48 <HAL_RCCEx_GetPeriphCLKFreq+0x6f8>
 8009d3e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009d40:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8009d44:	d004      	beq.n	8009d50 <HAL_RCCEx_GetPeriphCLKFreq+0x700>
 8009d46:	e054      	b.n	8009df2 <HAL_RCCEx_GetPeriphCLKFreq+0x7a2>
    {
      case RCC_SPI45CLKSOURCE_PCLK2: /* CD/D2 PCLK2 is the clock source for SPI4/5 */
      {
        frequency = HAL_RCC_GetPCLK1Freq();
 8009d48:	f7fe fa0a 	bl	8008160 <HAL_RCC_GetPCLK1Freq>
 8009d4c:	63f8      	str	r0, [r7, #60]	@ 0x3c
        break;
 8009d4e:	e1f6      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8009d50:	4b29      	ldr	r3, [pc, #164]	@ (8009df8 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8009d52:	681b      	ldr	r3, [r3, #0]
 8009d54:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8009d58:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8009d5c:	d107      	bne.n	8009d6e <HAL_RCCEx_GetPeriphCLKFreq+0x71e>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8009d5e:	f107 0318 	add.w	r3, r7, #24
 8009d62:	4618      	mov	r0, r3
 8009d64:	f000 fa0a 	bl	800a17c <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8009d68:	69fb      	ldr	r3, [r7, #28]
 8009d6a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009d6c:	e1e7      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009d6e:	2300      	movs	r3, #0
 8009d70:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009d72:	e1e4      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 8009d74:	4b20      	ldr	r3, [pc, #128]	@ (8009df8 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8009d76:	681b      	ldr	r3, [r3, #0]
 8009d78:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8009d7c:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8009d80:	d107      	bne.n	8009d92 <HAL_RCCEx_GetPeriphCLKFreq+0x742>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8009d82:	f107 030c 	add.w	r3, r7, #12
 8009d86:	4618      	mov	r0, r3
 8009d88:	f000 fb4c 	bl	800a424 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 8009d8c:	693b      	ldr	r3, [r7, #16]
 8009d8e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009d90:	e1d5      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009d92:	2300      	movs	r3, #0
 8009d94:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009d96:	e1d2      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_HSI: /* HSI is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 8009d98:	4b17      	ldr	r3, [pc, #92]	@ (8009df8 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8009d9a:	681b      	ldr	r3, [r3, #0]
 8009d9c:	f003 0304 	and.w	r3, r3, #4
 8009da0:	2b04      	cmp	r3, #4
 8009da2:	d109      	bne.n	8009db8 <HAL_RCCEx_GetPeriphCLKFreq+0x768>
        {
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8009da4:	4b14      	ldr	r3, [pc, #80]	@ (8009df8 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8009da6:	681b      	ldr	r3, [r3, #0]
 8009da8:	08db      	lsrs	r3, r3, #3
 8009daa:	f003 0303 	and.w	r3, r3, #3
 8009dae:	4a13      	ldr	r2, [pc, #76]	@ (8009dfc <HAL_RCCEx_GetPeriphCLKFreq+0x7ac>)
 8009db0:	fa22 f303 	lsr.w	r3, r2, r3
 8009db4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009db6:	e1c2      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009db8:	2300      	movs	r3, #0
 8009dba:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009dbc:	e1bf      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_CSI: /* CSI is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY))
 8009dbe:	4b0e      	ldr	r3, [pc, #56]	@ (8009df8 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8009dc0:	681b      	ldr	r3, [r3, #0]
 8009dc2:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8009dc6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8009dca:	d102      	bne.n	8009dd2 <HAL_RCCEx_GetPeriphCLKFreq+0x782>
        {
          frequency = CSI_VALUE;
 8009dcc:	4b0c      	ldr	r3, [pc, #48]	@ (8009e00 <HAL_RCCEx_GetPeriphCLKFreq+0x7b0>)
 8009dce:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009dd0:	e1b5      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009dd2:	2300      	movs	r3, #0
 8009dd4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009dd6:	e1b2      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI45CLKSOURCE_HSE: /* HSE is the clock source for SPI45 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 8009dd8:	4b07      	ldr	r3, [pc, #28]	@ (8009df8 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>)
 8009dda:	681b      	ldr	r3, [r3, #0]
 8009ddc:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8009de0:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8009de4:	d102      	bne.n	8009dec <HAL_RCCEx_GetPeriphCLKFreq+0x79c>
        {
          frequency = HSE_VALUE;
 8009de6:	4b07      	ldr	r3, [pc, #28]	@ (8009e04 <HAL_RCCEx_GetPeriphCLKFreq+0x7b4>)
 8009de8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009dea:	e1a8      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009dec:	2300      	movs	r3, #0
 8009dee:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009df0:	e1a5      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
 8009df2:	2300      	movs	r3, #0
 8009df4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009df6:	e1a2      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 8009df8:	58024400 	.word	0x58024400
 8009dfc:	03d09000 	.word	0x03d09000
 8009e00:	003d0900 	.word	0x003d0900
 8009e04:	007a1200 	.word	0x007a1200
 8009e08:	00bb8000 	.word	0x00bb8000
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
 8009e0c:	e9d7 2300 	ldrd	r2, r3, [r7]
 8009e10:	f5a2 2100 	sub.w	r1, r2, #524288	@ 0x80000
 8009e14:	430b      	orrs	r3, r1
 8009e16:	d173      	bne.n	8009f00 <HAL_RCCEx_GetPeriphCLKFreq+0x8b0>
  {
    /* Get ADC clock source */
    srcclk = __HAL_RCC_GET_ADC_SOURCE();
 8009e18:	4b9c      	ldr	r3, [pc, #624]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8009e1a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8009e1c:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 8009e20:	63bb      	str	r3, [r7, #56]	@ 0x38

    switch (srcclk)
 8009e22:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009e24:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8009e28:	d02f      	beq.n	8009e8a <HAL_RCCEx_GetPeriphCLKFreq+0x83a>
 8009e2a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009e2c:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8009e30:	d863      	bhi.n	8009efa <HAL_RCCEx_GetPeriphCLKFreq+0x8aa>
 8009e32:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009e34:	2b00      	cmp	r3, #0
 8009e36:	d004      	beq.n	8009e42 <HAL_RCCEx_GetPeriphCLKFreq+0x7f2>
 8009e38:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009e3a:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8009e3e:	d012      	beq.n	8009e66 <HAL_RCCEx_GetPeriphCLKFreq+0x816>
 8009e40:	e05b      	b.n	8009efa <HAL_RCCEx_GetPeriphCLKFreq+0x8aa>
    {
      case RCC_ADCCLKSOURCE_PLL2:
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8009e42:	4b92      	ldr	r3, [pc, #584]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8009e44:	681b      	ldr	r3, [r3, #0]
 8009e46:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8009e4a:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8009e4e:	d107      	bne.n	8009e60 <HAL_RCCEx_GetPeriphCLKFreq+0x810>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8009e50:	f107 0318 	add.w	r3, r7, #24
 8009e54:	4618      	mov	r0, r3
 8009e56:	f000 f991 	bl	800a17c <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 8009e5a:	69bb      	ldr	r3, [r7, #24]
 8009e5c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009e5e:	e16e      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009e60:	2300      	movs	r3, #0
 8009e62:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009e64:	e16b      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_ADCCLKSOURCE_PLL3:
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 8009e66:	4b89      	ldr	r3, [pc, #548]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8009e68:	681b      	ldr	r3, [r3, #0]
 8009e6a:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8009e6e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8009e72:	d107      	bne.n	8009e84 <HAL_RCCEx_GetPeriphCLKFreq+0x834>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 8009e74:	f107 030c 	add.w	r3, r7, #12
 8009e78:	4618      	mov	r0, r3
 8009e7a:	f000 fad3 	bl	800a424 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
 8009e7e:	697b      	ldr	r3, [r7, #20]
 8009e80:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009e82:	e15c      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009e84:	2300      	movs	r3, #0
 8009e86:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009e88:	e159      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      case RCC_ADCCLKSOURCE_CLKP:
      {

        ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
 8009e8a:	4b80      	ldr	r3, [pc, #512]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8009e8c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8009e8e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 8009e92:	637b      	str	r3, [r7, #52]	@ 0x34

        if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSI))
 8009e94:	4b7d      	ldr	r3, [pc, #500]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8009e96:	681b      	ldr	r3, [r3, #0]
 8009e98:	f003 0304 	and.w	r3, r3, #4
 8009e9c:	2b04      	cmp	r3, #4
 8009e9e:	d10c      	bne.n	8009eba <HAL_RCCEx_GetPeriphCLKFreq+0x86a>
 8009ea0:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8009ea2:	2b00      	cmp	r3, #0
 8009ea4:	d109      	bne.n	8009eba <HAL_RCCEx_GetPeriphCLKFreq+0x86a>
        {
          /* In Case the CKPER Source is HSI */
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 8009ea6:	4b79      	ldr	r3, [pc, #484]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8009ea8:	681b      	ldr	r3, [r3, #0]
 8009eaa:	08db      	lsrs	r3, r3, #3
 8009eac:	f003 0303 	and.w	r3, r3, #3
 8009eb0:	4a77      	ldr	r2, [pc, #476]	@ (800a090 <HAL_RCCEx_GetPeriphCLKFreq+0xa40>)
 8009eb2:	fa22 f303 	lsr.w	r3, r2, r3
 8009eb6:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8009eb8:	e01e      	b.n	8009ef8 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY)) && (ckpclocksource == RCC_CLKPSOURCE_CSI))
 8009eba:	4b74      	ldr	r3, [pc, #464]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8009ebc:	681b      	ldr	r3, [r3, #0]
 8009ebe:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8009ec2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8009ec6:	d106      	bne.n	8009ed6 <HAL_RCCEx_GetPeriphCLKFreq+0x886>
 8009ec8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8009eca:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8009ece:	d102      	bne.n	8009ed6 <HAL_RCCEx_GetPeriphCLKFreq+0x886>
        {
          /* In Case the CKPER Source is CSI */
          frequency = CSI_VALUE;
 8009ed0:	4b70      	ldr	r3, [pc, #448]	@ (800a094 <HAL_RCCEx_GetPeriphCLKFreq+0xa44>)
 8009ed2:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8009ed4:	e010      	b.n	8009ef8 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>
        }

        else if ((HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY)) && (ckpclocksource == RCC_CLKPSOURCE_HSE))
 8009ed6:	4b6d      	ldr	r3, [pc, #436]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8009ed8:	681b      	ldr	r3, [r3, #0]
 8009eda:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8009ede:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8009ee2:	d106      	bne.n	8009ef2 <HAL_RCCEx_GetPeriphCLKFreq+0x8a2>
 8009ee4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8009ee6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8009eea:	d102      	bne.n	8009ef2 <HAL_RCCEx_GetPeriphCLKFreq+0x8a2>
        {
          /* In Case the CKPER Source is HSE */
          frequency = HSE_VALUE;
 8009eec:	4b6a      	ldr	r3, [pc, #424]	@ (800a098 <HAL_RCCEx_GetPeriphCLKFreq+0xa48>)
 8009eee:	63fb      	str	r3, [r7, #60]	@ 0x3c
 8009ef0:	e002      	b.n	8009ef8 <HAL_RCCEx_GetPeriphCLKFreq+0x8a8>
        }

        else
        {
          /* In Case the CKPER is disabled*/
          frequency = 0;
 8009ef2:	2300      	movs	r3, #0
 8009ef4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }

        break;
 8009ef6:	e122      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 8009ef8:	e121      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      default :
      {
        frequency = 0;
 8009efa:	2300      	movs	r3, #0
 8009efc:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009efe:	e11e      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
 8009f00:	e9d7 2300 	ldrd	r2, r3, [r7]
 8009f04:	f5a2 3180 	sub.w	r1, r2, #65536	@ 0x10000
 8009f08:	430b      	orrs	r3, r1
 8009f0a:	d133      	bne.n	8009f74 <HAL_RCCEx_GetPeriphCLKFreq+0x924>
  {
    /* Get SDMMC clock source */
    srcclk = __HAL_RCC_GET_SDMMC_SOURCE();
 8009f0c:	4b5f      	ldr	r3, [pc, #380]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8009f0e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8009f10:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8009f14:	63bb      	str	r3, [r7, #56]	@ 0x38

    switch (srcclk)
 8009f16:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009f18:	2b00      	cmp	r3, #0
 8009f1a:	d004      	beq.n	8009f26 <HAL_RCCEx_GetPeriphCLKFreq+0x8d6>
 8009f1c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009f1e:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8009f22:	d012      	beq.n	8009f4a <HAL_RCCEx_GetPeriphCLKFreq+0x8fa>
 8009f24:	e023      	b.n	8009f6e <HAL_RCCEx_GetPeriphCLKFreq+0x91e>
    {
      case RCC_SDMMCCLKSOURCE_PLL: /* PLL1 is the clock source for SDMMC */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 8009f26:	4b59      	ldr	r3, [pc, #356]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8009f28:	681b      	ldr	r3, [r3, #0]
 8009f2a:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8009f2e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 8009f32:	d107      	bne.n	8009f44 <HAL_RCCEx_GetPeriphCLKFreq+0x8f4>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 8009f34:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 8009f38:	4618      	mov	r0, r3
 8009f3a:	f000 fbc7 	bl	800a6cc <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 8009f3e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8009f40:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009f42:	e0fc      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009f44:	2300      	movs	r3, #0
 8009f46:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009f48:	e0f9      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is the clock source for SDMMC */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8009f4a:	4b50      	ldr	r3, [pc, #320]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8009f4c:	681b      	ldr	r3, [r3, #0]
 8009f4e:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8009f52:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8009f56:	d107      	bne.n	8009f68 <HAL_RCCEx_GetPeriphCLKFreq+0x918>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8009f58:	f107 0318 	add.w	r3, r7, #24
 8009f5c:	4618      	mov	r0, r3
 8009f5e:	f000 f90d 	bl	800a17c <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
 8009f62:	6a3b      	ldr	r3, [r7, #32]
 8009f64:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 8009f66:	e0ea      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 8009f68:	2300      	movs	r3, #0
 8009f6a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009f6c:	e0e7      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }

      default :
      {
        frequency = 0;
 8009f6e:	2300      	movs	r3, #0
 8009f70:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 8009f72:	e0e4      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_SPI6)
 8009f74:	e9d7 2300 	ldrd	r2, r3, [r7]
 8009f78:	f5a2 4180 	sub.w	r1, r2, #16384	@ 0x4000
 8009f7c:	430b      	orrs	r3, r1
 8009f7e:	f040 808d 	bne.w	800a09c <HAL_RCCEx_GetPeriphCLKFreq+0xa4c>
  {
    /* Get SPI6 clock source */
    srcclk = __HAL_RCC_GET_SPI6_SOURCE();
 8009f82:	4b42      	ldr	r3, [pc, #264]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8009f84:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8009f86:	f003 43e0 	and.w	r3, r3, #1879048192	@ 0x70000000
 8009f8a:	63bb      	str	r3, [r7, #56]	@ 0x38

    switch (srcclk)
 8009f8c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009f8e:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8009f92:	d06b      	beq.n	800a06c <HAL_RCCEx_GetPeriphCLKFreq+0xa1c>
 8009f94:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009f96:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8009f9a:	d874      	bhi.n	800a086 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
 8009f9c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009f9e:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8009fa2:	d056      	beq.n	800a052 <HAL_RCCEx_GetPeriphCLKFreq+0xa02>
 8009fa4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009fa6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8009faa:	d86c      	bhi.n	800a086 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
 8009fac:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009fae:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8009fb2:	d03b      	beq.n	800a02c <HAL_RCCEx_GetPeriphCLKFreq+0x9dc>
 8009fb4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009fb6:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8009fba:	d864      	bhi.n	800a086 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
 8009fbc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009fbe:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8009fc2:	d021      	beq.n	800a008 <HAL_RCCEx_GetPeriphCLKFreq+0x9b8>
 8009fc4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009fc6:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8009fca:	d85c      	bhi.n	800a086 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
 8009fcc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009fce:	2b00      	cmp	r3, #0
 8009fd0:	d004      	beq.n	8009fdc <HAL_RCCEx_GetPeriphCLKFreq+0x98c>
 8009fd2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8009fd4:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8009fd8:	d004      	beq.n	8009fe4 <HAL_RCCEx_GetPeriphCLKFreq+0x994>
 8009fda:	e054      	b.n	800a086 <HAL_RCCEx_GetPeriphCLKFreq+0xa36>
    {
      case RCC_SPI6CLKSOURCE_D3PCLK1: /* D3PCLK1 (PCLK4) is the clock source for SPI6 */
      {
        frequency = HAL_RCCEx_GetD3PCLK1Freq();
 8009fdc:	f000 f8b8 	bl	800a150 <HAL_RCCEx_GetD3PCLK1Freq>
 8009fe0:	63f8      	str	r0, [r7, #60]	@ 0x3c
        break;
 8009fe2:	e0ac      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 8009fe4:	4b29      	ldr	r3, [pc, #164]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 8009fe6:	681b      	ldr	r3, [r3, #0]
 8009fe8:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8009fec:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 8009ff0:	d107      	bne.n	800a002 <HAL_RCCEx_GetPeriphCLKFreq+0x9b2>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 8009ff2:	f107 0318 	add.w	r3, r7, #24
 8009ff6:	4618      	mov	r0, r3
 8009ff8:	f000 f8c0 	bl	800a17c <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 8009ffc:	69fb      	ldr	r3, [r7, #28]
 8009ffe:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800a000:	e09d      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 800a002:	2300      	movs	r3, #0
 800a004:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800a006:	e09a      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_PLL3: /* PLL3 is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL3RDY))
 800a008:	4b20      	ldr	r3, [pc, #128]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 800a00a:	681b      	ldr	r3, [r3, #0]
 800a00c:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 800a010:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800a014:	d107      	bne.n	800a026 <HAL_RCCEx_GetPeriphCLKFreq+0x9d6>
        {
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800a016:	f107 030c 	add.w	r3, r7, #12
 800a01a:	4618      	mov	r0, r3
 800a01c:	f000 fa02 	bl	800a424 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 800a020:	693b      	ldr	r3, [r7, #16]
 800a022:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800a024:	e08b      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 800a026:	2300      	movs	r3, #0
 800a028:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800a02a:	e088      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_HSI: /* HSI is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSIRDY))
 800a02c:	4b17      	ldr	r3, [pc, #92]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 800a02e:	681b      	ldr	r3, [r3, #0]
 800a030:	f003 0304 	and.w	r3, r3, #4
 800a034:	2b04      	cmp	r3, #4
 800a036:	d109      	bne.n	800a04c <HAL_RCCEx_GetPeriphCLKFreq+0x9fc>
        {
          frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800a038:	4b14      	ldr	r3, [pc, #80]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 800a03a:	681b      	ldr	r3, [r3, #0]
 800a03c:	08db      	lsrs	r3, r3, #3
 800a03e:	f003 0303 	and.w	r3, r3, #3
 800a042:	4a13      	ldr	r2, [pc, #76]	@ (800a090 <HAL_RCCEx_GetPeriphCLKFreq+0xa40>)
 800a044:	fa22 f303 	lsr.w	r3, r2, r3
 800a048:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800a04a:	e078      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 800a04c:	2300      	movs	r3, #0
 800a04e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800a050:	e075      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_CSI: /* CSI is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_CSIRDY))
 800a052:	4b0e      	ldr	r3, [pc, #56]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 800a054:	681b      	ldr	r3, [r3, #0]
 800a056:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800a05a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 800a05e:	d102      	bne.n	800a066 <HAL_RCCEx_GetPeriphCLKFreq+0xa16>
        {
          frequency = CSI_VALUE;
 800a060:	4b0c      	ldr	r3, [pc, #48]	@ (800a094 <HAL_RCCEx_GetPeriphCLKFreq+0xa44>)
 800a062:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800a064:	e06b      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 800a066:	2300      	movs	r3, #0
 800a068:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800a06a:	e068      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_SPI6CLKSOURCE_HSE: /* HSE is the clock source for SPI6 */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 800a06c:	4b07      	ldr	r3, [pc, #28]	@ (800a08c <HAL_RCCEx_GetPeriphCLKFreq+0xa3c>)
 800a06e:	681b      	ldr	r3, [r3, #0]
 800a070:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800a074:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800a078:	d102      	bne.n	800a080 <HAL_RCCEx_GetPeriphCLKFreq+0xa30>
        {
          frequency = HSE_VALUE;
 800a07a:	4b07      	ldr	r3, [pc, #28]	@ (800a098 <HAL_RCCEx_GetPeriphCLKFreq+0xa48>)
 800a07c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800a07e:	e05e      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 800a080:	2300      	movs	r3, #0
 800a082:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800a084:	e05b      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
        break;
      }
#endif /* RCC_SPI6CLKSOURCE_PIN */
      default :
      {
        frequency = 0;
 800a086:	2300      	movs	r3, #0
 800a088:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800a08a:	e058      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
 800a08c:	58024400 	.word	0x58024400
 800a090:	03d09000 	.word	0x03d09000
 800a094:	003d0900 	.word	0x003d0900
 800a098:	007a1200 	.word	0x007a1200
      }
    }
  }
  else if (PeriphClk == RCC_PERIPHCLK_FDCAN)
 800a09c:	e9d7 2300 	ldrd	r2, r3, [r7]
 800a0a0:	f5a2 4100 	sub.w	r1, r2, #32768	@ 0x8000
 800a0a4:	430b      	orrs	r3, r1
 800a0a6:	d148      	bne.n	800a13a <HAL_RCCEx_GetPeriphCLKFreq+0xaea>
  {
    /* Get FDCAN clock source */
    srcclk = __HAL_RCC_GET_FDCAN_SOURCE();
 800a0a8:	4b27      	ldr	r3, [pc, #156]	@ (800a148 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
 800a0aa:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800a0ac:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
 800a0b0:	63bb      	str	r3, [r7, #56]	@ 0x38

    switch (srcclk)
 800a0b2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800a0b4:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800a0b8:	d02a      	beq.n	800a110 <HAL_RCCEx_GetPeriphCLKFreq+0xac0>
 800a0ba:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800a0bc:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 800a0c0:	d838      	bhi.n	800a134 <HAL_RCCEx_GetPeriphCLKFreq+0xae4>
 800a0c2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800a0c4:	2b00      	cmp	r3, #0
 800a0c6:	d004      	beq.n	800a0d2 <HAL_RCCEx_GetPeriphCLKFreq+0xa82>
 800a0c8:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800a0ca:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 800a0ce:	d00d      	beq.n	800a0ec <HAL_RCCEx_GetPeriphCLKFreq+0xa9c>
 800a0d0:	e030      	b.n	800a134 <HAL_RCCEx_GetPeriphCLKFreq+0xae4>
    {
      case RCC_FDCANCLKSOURCE_HSE: /* HSE is the clock source for FDCAN */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_HSERDY))
 800a0d2:	4b1d      	ldr	r3, [pc, #116]	@ (800a148 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
 800a0d4:	681b      	ldr	r3, [r3, #0]
 800a0d6:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 800a0da:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 800a0de:	d102      	bne.n	800a0e6 <HAL_RCCEx_GetPeriphCLKFreq+0xa96>
        {
          frequency = HSE_VALUE;
 800a0e0:	4b1a      	ldr	r3, [pc, #104]	@ (800a14c <HAL_RCCEx_GetPeriphCLKFreq+0xafc>)
 800a0e2:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800a0e4:	e02b      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 800a0e6:	2300      	movs	r3, #0
 800a0e8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800a0ea:	e028      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_FDCANCLKSOURCE_PLL: /* PLL is the clock source for FDCAN */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL1RDY))
 800a0ec:	4b16      	ldr	r3, [pc, #88]	@ (800a148 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
 800a0ee:	681b      	ldr	r3, [r3, #0]
 800a0f0:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 800a0f4:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 800a0f8:	d107      	bne.n	800a10a <HAL_RCCEx_GetPeriphCLKFreq+0xaba>
        {
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 800a0fa:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800a0fe:	4618      	mov	r0, r3
 800a100:	f000 fae4 	bl	800a6cc <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 800a104:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800a106:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800a108:	e019      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 800a10a:	2300      	movs	r3, #0
 800a10c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800a10e:	e016      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is the clock source for FDCAN */
      {
        if (HAL_IS_BIT_SET(RCC->CR, RCC_CR_PLL2RDY))
 800a110:	4b0d      	ldr	r3, [pc, #52]	@ (800a148 <HAL_RCCEx_GetPeriphCLKFreq+0xaf8>)
 800a112:	681b      	ldr	r3, [r3, #0]
 800a114:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800a118:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
 800a11c:	d107      	bne.n	800a12e <HAL_RCCEx_GetPeriphCLKFreq+0xade>
        {
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800a11e:	f107 0318 	add.w	r3, r7, #24
 800a122:	4618      	mov	r0, r3
 800a124:	f000 f82a 	bl	800a17c <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 800a128:	69fb      	ldr	r3, [r7, #28]
 800a12a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          frequency = 0;
        }
        break;
 800a12c:	e007      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
          frequency = 0;
 800a12e:	2300      	movs	r3, #0
 800a130:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800a132:	e004      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
      default :
      {
        frequency = 0;
 800a134:	2300      	movs	r3, #0
 800a136:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800a138:	e001      	b.n	800a13e <HAL_RCCEx_GetPeriphCLKFreq+0xaee>
      }
    }
  }
  else
  {
    frequency = 0;
 800a13a:	2300      	movs	r3, #0
 800a13c:	63fb      	str	r3, [r7, #60]	@ 0x3c
  }

  return frequency;
 800a13e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
}
 800a140:	4618      	mov	r0, r3
 800a142:	3740      	adds	r7, #64	@ 0x40
 800a144:	46bd      	mov	sp, r7
 800a146:	bd80      	pop	{r7, pc}
 800a148:	58024400 	.word	0x58024400
 800a14c:	007a1200 	.word	0x007a1200

0800a150 <HAL_RCCEx_GetD3PCLK1Freq>:
  * @note   Each time D3PCLK1 changes, this function must be called to update the
  *         right D3PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval D3PCLK1 frequency
  */
uint32_t HAL_RCCEx_GetD3PCLK1Freq(void)
{
 800a150:	b580      	push	{r7, lr}
 800a152:	af00      	add	r7, sp, #0
#if defined(RCC_D3CFGR_D3PPRE)
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE) >> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
 800a154:	f7fd ffd4 	bl	8008100 <HAL_RCC_GetHCLKFreq>
 800a158:	4602      	mov	r2, r0
 800a15a:	4b06      	ldr	r3, [pc, #24]	@ (800a174 <HAL_RCCEx_GetD3PCLK1Freq+0x24>)
 800a15c:	6a1b      	ldr	r3, [r3, #32]
 800a15e:	091b      	lsrs	r3, r3, #4
 800a160:	f003 0307 	and.w	r3, r3, #7
 800a164:	4904      	ldr	r1, [pc, #16]	@ (800a178 <HAL_RCCEx_GetD3PCLK1Freq+0x28>)
 800a166:	5ccb      	ldrb	r3, [r1, r3]
 800a168:	f003 031f 	and.w	r3, r3, #31
 800a16c:	fa22 f303 	lsr.w	r3, r2, r3
#else
  /* Get HCLK source and Compute D3PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE) >> RCC_SRDCFGR_SRDPPRE_Pos] & 0x1FU));
#endif
}
 800a170:	4618      	mov	r0, r3
 800a172:	bd80      	pop	{r7, pc}
 800a174:	58024400 	.word	0x58024400
 800a178:	0801860c 	.word	0x0801860c

0800a17c <HAL_RCCEx_GetPLL2ClockFreq>:
  *         right PLL2CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL2_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL2ClockFreq(PLL2_ClocksTypeDef *PLL2_Clocks)
{
 800a17c:	b480      	push	{r7}
 800a17e:	b089      	sub	sp, #36	@ 0x24
 800a180:	af00      	add	r7, sp, #0
 800a182:	6078      	str	r0, [r7, #4]
  float_t fracn2, pll2vco;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL2M) * PLL2N
     PLL2xCLK = PLL2_VCO / PLL2x
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800a184:	4ba1      	ldr	r3, [pc, #644]	@ (800a40c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800a186:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800a188:	f003 0303 	and.w	r3, r3, #3
 800a18c:	61bb      	str	r3, [r7, #24]
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2) >> 12);
 800a18e:	4b9f      	ldr	r3, [pc, #636]	@ (800a40c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800a190:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800a192:	0b1b      	lsrs	r3, r3, #12
 800a194:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800a198:	617b      	str	r3, [r7, #20]
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
 800a19a:	4b9c      	ldr	r3, [pc, #624]	@ (800a40c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800a19c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800a19e:	091b      	lsrs	r3, r3, #4
 800a1a0:	f003 0301 	and.w	r3, r3, #1
 800a1a4:	613b      	str	r3, [r7, #16]
  fracn2 = (float_t)(uint32_t)(pll2fracen * ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2) >> 3));
 800a1a6:	4b99      	ldr	r3, [pc, #612]	@ (800a40c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800a1a8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800a1aa:	08db      	lsrs	r3, r3, #3
 800a1ac:	f3c3 030c 	ubfx	r3, r3, #0, #13
 800a1b0:	693a      	ldr	r2, [r7, #16]
 800a1b2:	fb02 f303 	mul.w	r3, r2, r3
 800a1b6:	ee07 3a90 	vmov	s15, r3
 800a1ba:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a1be:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll2m != 0U)
 800a1c2:	697b      	ldr	r3, [r7, #20]
 800a1c4:	2b00      	cmp	r3, #0
 800a1c6:	f000 8111 	beq.w	800a3ec <HAL_RCCEx_GetPLL2ClockFreq+0x270>
  {
    switch (pllsource)
 800a1ca:	69bb      	ldr	r3, [r7, #24]
 800a1cc:	2b02      	cmp	r3, #2
 800a1ce:	f000 8083 	beq.w	800a2d8 <HAL_RCCEx_GetPLL2ClockFreq+0x15c>
 800a1d2:	69bb      	ldr	r3, [r7, #24]
 800a1d4:	2b02      	cmp	r3, #2
 800a1d6:	f200 80a1 	bhi.w	800a31c <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
 800a1da:	69bb      	ldr	r3, [r7, #24]
 800a1dc:	2b00      	cmp	r3, #0
 800a1de:	d003      	beq.n	800a1e8 <HAL_RCCEx_GetPLL2ClockFreq+0x6c>
 800a1e0:	69bb      	ldr	r3, [r7, #24]
 800a1e2:	2b01      	cmp	r3, #1
 800a1e4:	d056      	beq.n	800a294 <HAL_RCCEx_GetPLL2ClockFreq+0x118>
 800a1e6:	e099      	b.n	800a31c <HAL_RCCEx_GetPLL2ClockFreq+0x1a0>
    {

      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800a1e8:	4b88      	ldr	r3, [pc, #544]	@ (800a40c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800a1ea:	681b      	ldr	r3, [r3, #0]
 800a1ec:	f003 0320 	and.w	r3, r3, #32
 800a1f0:	2b00      	cmp	r3, #0
 800a1f2:	d02d      	beq.n	800a250 <HAL_RCCEx_GetPLL2ClockFreq+0xd4>
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800a1f4:	4b85      	ldr	r3, [pc, #532]	@ (800a40c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800a1f6:	681b      	ldr	r3, [r3, #0]
 800a1f8:	08db      	lsrs	r3, r3, #3
 800a1fa:	f003 0303 	and.w	r3, r3, #3
 800a1fe:	4a84      	ldr	r2, [pc, #528]	@ (800a410 <HAL_RCCEx_GetPLL2ClockFreq+0x294>)
 800a200:	fa22 f303 	lsr.w	r3, r2, r3
 800a204:	60bb      	str	r3, [r7, #8]
          pll2vco = ((float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800a206:	68bb      	ldr	r3, [r7, #8]
 800a208:	ee07 3a90 	vmov	s15, r3
 800a20c:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a210:	697b      	ldr	r3, [r7, #20]
 800a212:	ee07 3a90 	vmov	s15, r3
 800a216:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a21a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a21e:	4b7b      	ldr	r3, [pc, #492]	@ (800a40c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800a220:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800a222:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a226:	ee07 3a90 	vmov	s15, r3
 800a22a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a22e:	ed97 6a03 	vldr	s12, [r7, #12]
 800a232:	eddf 5a78 	vldr	s11, [pc, #480]	@ 800a414 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 800a236:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a23a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a23e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a242:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a246:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a24a:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
        }
        break;
 800a24e:	e087      	b.n	800a360 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>
          pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800a250:	697b      	ldr	r3, [r7, #20]
 800a252:	ee07 3a90 	vmov	s15, r3
 800a256:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a25a:	eddf 6a6f 	vldr	s13, [pc, #444]	@ 800a418 <HAL_RCCEx_GetPLL2ClockFreq+0x29c>
 800a25e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a262:	4b6a      	ldr	r3, [pc, #424]	@ (800a40c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800a264:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800a266:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a26a:	ee07 3a90 	vmov	s15, r3
 800a26e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a272:	ed97 6a03 	vldr	s12, [r7, #12]
 800a276:	eddf 5a67 	vldr	s11, [pc, #412]	@ 800a414 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 800a27a:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a27e:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a282:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a286:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a28a:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a28e:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800a292:	e065      	b.n	800a360 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800a294:	697b      	ldr	r3, [r7, #20]
 800a296:	ee07 3a90 	vmov	s15, r3
 800a29a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a29e:	eddf 6a5f 	vldr	s13, [pc, #380]	@ 800a41c <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
 800a2a2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a2a6:	4b59      	ldr	r3, [pc, #356]	@ (800a40c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800a2a8:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800a2aa:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a2ae:	ee07 3a90 	vmov	s15, r3
 800a2b2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a2b6:	ed97 6a03 	vldr	s12, [r7, #12]
 800a2ba:	eddf 5a56 	vldr	s11, [pc, #344]	@ 800a414 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 800a2be:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a2c2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a2c6:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a2ca:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a2ce:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a2d2:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800a2d6:	e043      	b.n	800a360 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800a2d8:	697b      	ldr	r3, [r7, #20]
 800a2da:	ee07 3a90 	vmov	s15, r3
 800a2de:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a2e2:	eddf 6a4f 	vldr	s13, [pc, #316]	@ 800a420 <HAL_RCCEx_GetPLL2ClockFreq+0x2a4>
 800a2e6:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a2ea:	4b48      	ldr	r3, [pc, #288]	@ (800a40c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800a2ec:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800a2ee:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a2f2:	ee07 3a90 	vmov	s15, r3
 800a2f6:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a2fa:	ed97 6a03 	vldr	s12, [r7, #12]
 800a2fe:	eddf 5a45 	vldr	s11, [pc, #276]	@ 800a414 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 800a302:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a306:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a30a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a30e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a312:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a316:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800a31a:	e021      	b.n	800a360 <HAL_RCCEx_GetPLL2ClockFreq+0x1e4>

      default:
        pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2 / (float_t)0x2000) + (float_t)1);
 800a31c:	697b      	ldr	r3, [r7, #20]
 800a31e:	ee07 3a90 	vmov	s15, r3
 800a322:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a326:	eddf 6a3d 	vldr	s13, [pc, #244]	@ 800a41c <HAL_RCCEx_GetPLL2ClockFreq+0x2a0>
 800a32a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a32e:	4b37      	ldr	r3, [pc, #220]	@ (800a40c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800a330:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800a332:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a336:	ee07 3a90 	vmov	s15, r3
 800a33a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a33e:	ed97 6a03 	vldr	s12, [r7, #12]
 800a342:	eddf 5a34 	vldr	s11, [pc, #208]	@ 800a414 <HAL_RCCEx_GetPLL2ClockFreq+0x298>
 800a346:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a34a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a34e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a352:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a356:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a35a:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800a35e:	bf00      	nop
    }
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >> 9)  + (float_t)1)) ;
 800a360:	4b2a      	ldr	r3, [pc, #168]	@ (800a40c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800a362:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800a364:	0a5b      	lsrs	r3, r3, #9
 800a366:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800a36a:	ee07 3a90 	vmov	s15, r3
 800a36e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a372:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800a376:	ee37 7a87 	vadd.f32	s14, s15, s14
 800a37a:	edd7 6a07 	vldr	s13, [r7, #28]
 800a37e:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800a382:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800a386:	ee17 2a90 	vmov	r2, s15
 800a38a:	687b      	ldr	r3, [r7, #4]
 800a38c:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >> 16) + (float_t)1)) ;
 800a38e:	4b1f      	ldr	r3, [pc, #124]	@ (800a40c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800a390:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800a392:	0c1b      	lsrs	r3, r3, #16
 800a394:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800a398:	ee07 3a90 	vmov	s15, r3
 800a39c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a3a0:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800a3a4:	ee37 7a87 	vadd.f32	s14, s15, s14
 800a3a8:	edd7 6a07 	vldr	s13, [r7, #28]
 800a3ac:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800a3b0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800a3b4:	ee17 2a90 	vmov	r2, s15
 800a3b8:	687b      	ldr	r3, [r7, #4]
 800a3ba:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco / ((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >> 24) + (float_t)1)) ;
 800a3bc:	4b13      	ldr	r3, [pc, #76]	@ (800a40c <HAL_RCCEx_GetPLL2ClockFreq+0x290>)
 800a3be:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800a3c0:	0e1b      	lsrs	r3, r3, #24
 800a3c2:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800a3c6:	ee07 3a90 	vmov	s15, r3
 800a3ca:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a3ce:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800a3d2:	ee37 7a87 	vadd.f32	s14, s15, s14
 800a3d6:	edd7 6a07 	vldr	s13, [r7, #28]
 800a3da:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800a3de:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800a3e2:	ee17 2a90 	vmov	r2, s15
 800a3e6:	687b      	ldr	r3, [r7, #4]
 800a3e8:	609a      	str	r2, [r3, #8]
  {
    PLL2_Clocks->PLL2_P_Frequency = 0U;
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
    PLL2_Clocks->PLL2_R_Frequency = 0U;
  }
}
 800a3ea:	e008      	b.n	800a3fe <HAL_RCCEx_GetPLL2ClockFreq+0x282>
    PLL2_Clocks->PLL2_P_Frequency = 0U;
 800a3ec:	687b      	ldr	r3, [r7, #4]
 800a3ee:	2200      	movs	r2, #0
 800a3f0:	601a      	str	r2, [r3, #0]
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
 800a3f2:	687b      	ldr	r3, [r7, #4]
 800a3f4:	2200      	movs	r2, #0
 800a3f6:	605a      	str	r2, [r3, #4]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
 800a3f8:	687b      	ldr	r3, [r7, #4]
 800a3fa:	2200      	movs	r2, #0
 800a3fc:	609a      	str	r2, [r3, #8]
}
 800a3fe:	bf00      	nop
 800a400:	3724      	adds	r7, #36	@ 0x24
 800a402:	46bd      	mov	sp, r7
 800a404:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a408:	4770      	bx	lr
 800a40a:	bf00      	nop
 800a40c:	58024400 	.word	0x58024400
 800a410:	03d09000 	.word	0x03d09000
 800a414:	46000000 	.word	0x46000000
 800a418:	4c742400 	.word	0x4c742400
 800a41c:	4a742400 	.word	0x4a742400
 800a420:	4af42400 	.word	0x4af42400

0800a424 <HAL_RCCEx_GetPLL3ClockFreq>:
  *         right PLL3CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL3_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL3ClockFreq(PLL3_ClocksTypeDef *PLL3_Clocks)
{
 800a424:	b480      	push	{r7}
 800a426:	b089      	sub	sp, #36	@ 0x24
 800a428:	af00      	add	r7, sp, #0
 800a42a:	6078      	str	r0, [r7, #4]
  float_t fracn3, pll3vco;

  /* PLL3_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLL3M) * PLL3N
     PLL3xCLK = PLL3_VCO / PLLxR
  */
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800a42c:	4ba1      	ldr	r3, [pc, #644]	@ (800a6b4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800a42e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800a430:	f003 0303 	and.w	r3, r3, #3
 800a434:	61bb      	str	r3, [r7, #24]
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3) >> 20)  ;
 800a436:	4b9f      	ldr	r3, [pc, #636]	@ (800a6b4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800a438:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800a43a:	0d1b      	lsrs	r3, r3, #20
 800a43c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800a440:	617b      	str	r3, [r7, #20]
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
 800a442:	4b9c      	ldr	r3, [pc, #624]	@ (800a6b4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800a444:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800a446:	0a1b      	lsrs	r3, r3, #8
 800a448:	f003 0301 	and.w	r3, r3, #1
 800a44c:	613b      	str	r3, [r7, #16]
  fracn3 = (float_t)(uint32_t)(pll3fracen * ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3) >> 3));
 800a44e:	4b99      	ldr	r3, [pc, #612]	@ (800a6b4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800a450:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800a452:	08db      	lsrs	r3, r3, #3
 800a454:	f3c3 030c 	ubfx	r3, r3, #0, #13
 800a458:	693a      	ldr	r2, [r7, #16]
 800a45a:	fb02 f303 	mul.w	r3, r2, r3
 800a45e:	ee07 3a90 	vmov	s15, r3
 800a462:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a466:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll3m != 0U)
 800a46a:	697b      	ldr	r3, [r7, #20]
 800a46c:	2b00      	cmp	r3, #0
 800a46e:	f000 8111 	beq.w	800a694 <HAL_RCCEx_GetPLL3ClockFreq+0x270>
  {
    switch (pllsource)
 800a472:	69bb      	ldr	r3, [r7, #24]
 800a474:	2b02      	cmp	r3, #2
 800a476:	f000 8083 	beq.w	800a580 <HAL_RCCEx_GetPLL3ClockFreq+0x15c>
 800a47a:	69bb      	ldr	r3, [r7, #24]
 800a47c:	2b02      	cmp	r3, #2
 800a47e:	f200 80a1 	bhi.w	800a5c4 <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
 800a482:	69bb      	ldr	r3, [r7, #24]
 800a484:	2b00      	cmp	r3, #0
 800a486:	d003      	beq.n	800a490 <HAL_RCCEx_GetPLL3ClockFreq+0x6c>
 800a488:	69bb      	ldr	r3, [r7, #24]
 800a48a:	2b01      	cmp	r3, #1
 800a48c:	d056      	beq.n	800a53c <HAL_RCCEx_GetPLL3ClockFreq+0x118>
 800a48e:	e099      	b.n	800a5c4 <HAL_RCCEx_GetPLL3ClockFreq+0x1a0>
    {
      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800a490:	4b88      	ldr	r3, [pc, #544]	@ (800a6b4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800a492:	681b      	ldr	r3, [r3, #0]
 800a494:	f003 0320 	and.w	r3, r3, #32
 800a498:	2b00      	cmp	r3, #0
 800a49a:	d02d      	beq.n	800a4f8 <HAL_RCCEx_GetPLL3ClockFreq+0xd4>
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800a49c:	4b85      	ldr	r3, [pc, #532]	@ (800a6b4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800a49e:	681b      	ldr	r3, [r3, #0]
 800a4a0:	08db      	lsrs	r3, r3, #3
 800a4a2:	f003 0303 	and.w	r3, r3, #3
 800a4a6:	4a84      	ldr	r2, [pc, #528]	@ (800a6b8 <HAL_RCCEx_GetPLL3ClockFreq+0x294>)
 800a4a8:	fa22 f303 	lsr.w	r3, r2, r3
 800a4ac:	60bb      	str	r3, [r7, #8]
          pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800a4ae:	68bb      	ldr	r3, [r7, #8]
 800a4b0:	ee07 3a90 	vmov	s15, r3
 800a4b4:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a4b8:	697b      	ldr	r3, [r7, #20]
 800a4ba:	ee07 3a90 	vmov	s15, r3
 800a4be:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a4c2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a4c6:	4b7b      	ldr	r3, [pc, #492]	@ (800a6b4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800a4c8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800a4ca:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a4ce:	ee07 3a90 	vmov	s15, r3
 800a4d2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a4d6:	ed97 6a03 	vldr	s12, [r7, #12]
 800a4da:	eddf 5a78 	vldr	s11, [pc, #480]	@ 800a6bc <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 800a4de:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a4e2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a4e6:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a4ea:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a4ee:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a4f2:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
        }
        break;
 800a4f6:	e087      	b.n	800a608 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
          pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800a4f8:	697b      	ldr	r3, [r7, #20]
 800a4fa:	ee07 3a90 	vmov	s15, r3
 800a4fe:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a502:	eddf 6a6f 	vldr	s13, [pc, #444]	@ 800a6c0 <HAL_RCCEx_GetPLL3ClockFreq+0x29c>
 800a506:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a50a:	4b6a      	ldr	r3, [pc, #424]	@ (800a6b4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800a50c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800a50e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a512:	ee07 3a90 	vmov	s15, r3
 800a516:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a51a:	ed97 6a03 	vldr	s12, [r7, #12]
 800a51e:	eddf 5a67 	vldr	s11, [pc, #412]	@ 800a6bc <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 800a522:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a526:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a52a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a52e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a532:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a536:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800a53a:	e065      	b.n	800a608 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>
      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800a53c:	697b      	ldr	r3, [r7, #20]
 800a53e:	ee07 3a90 	vmov	s15, r3
 800a542:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a546:	eddf 6a5f 	vldr	s13, [pc, #380]	@ 800a6c4 <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
 800a54a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a54e:	4b59      	ldr	r3, [pc, #356]	@ (800a6b4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800a550:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800a552:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a556:	ee07 3a90 	vmov	s15, r3
 800a55a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a55e:	ed97 6a03 	vldr	s12, [r7, #12]
 800a562:	eddf 5a56 	vldr	s11, [pc, #344]	@ 800a6bc <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 800a566:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a56a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a56e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a572:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a576:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a57a:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800a57e:	e043      	b.n	800a608 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800a580:	697b      	ldr	r3, [r7, #20]
 800a582:	ee07 3a90 	vmov	s15, r3
 800a586:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a58a:	eddf 6a4f 	vldr	s13, [pc, #316]	@ 800a6c8 <HAL_RCCEx_GetPLL3ClockFreq+0x2a4>
 800a58e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a592:	4b48      	ldr	r3, [pc, #288]	@ (800a6b4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800a594:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800a596:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a59a:	ee07 3a90 	vmov	s15, r3
 800a59e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a5a2:	ed97 6a03 	vldr	s12, [r7, #12]
 800a5a6:	eddf 5a45 	vldr	s11, [pc, #276]	@ 800a6bc <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 800a5aa:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a5ae:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a5b2:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a5b6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a5ba:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a5be:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800a5c2:	e021      	b.n	800a608 <HAL_RCCEx_GetPLL3ClockFreq+0x1e4>

      default:
        pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3 / (float_t)0x2000) + (float_t)1);
 800a5c4:	697b      	ldr	r3, [r7, #20]
 800a5c6:	ee07 3a90 	vmov	s15, r3
 800a5ca:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a5ce:	eddf 6a3d 	vldr	s13, [pc, #244]	@ 800a6c4 <HAL_RCCEx_GetPLL3ClockFreq+0x2a0>
 800a5d2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a5d6:	4b37      	ldr	r3, [pc, #220]	@ (800a6b4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800a5d8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800a5da:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a5de:	ee07 3a90 	vmov	s15, r3
 800a5e2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a5e6:	ed97 6a03 	vldr	s12, [r7, #12]
 800a5ea:	eddf 5a34 	vldr	s11, [pc, #208]	@ 800a6bc <HAL_RCCEx_GetPLL3ClockFreq+0x298>
 800a5ee:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a5f2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a5f6:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a5fa:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a5fe:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a602:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800a606:	bf00      	nop
    }
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >> 9)  + (float_t)1)) ;
 800a608:	4b2a      	ldr	r3, [pc, #168]	@ (800a6b4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800a60a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800a60c:	0a5b      	lsrs	r3, r3, #9
 800a60e:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800a612:	ee07 3a90 	vmov	s15, r3
 800a616:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a61a:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800a61e:	ee37 7a87 	vadd.f32	s14, s15, s14
 800a622:	edd7 6a07 	vldr	s13, [r7, #28]
 800a626:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800a62a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800a62e:	ee17 2a90 	vmov	r2, s15
 800a632:	687b      	ldr	r3, [r7, #4]
 800a634:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >> 16) + (float_t)1)) ;
 800a636:	4b1f      	ldr	r3, [pc, #124]	@ (800a6b4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800a638:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800a63a:	0c1b      	lsrs	r3, r3, #16
 800a63c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800a640:	ee07 3a90 	vmov	s15, r3
 800a644:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a648:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800a64c:	ee37 7a87 	vadd.f32	s14, s15, s14
 800a650:	edd7 6a07 	vldr	s13, [r7, #28]
 800a654:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800a658:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800a65c:	ee17 2a90 	vmov	r2, s15
 800a660:	687b      	ldr	r3, [r7, #4]
 800a662:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco / ((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >> 24) + (float_t)1)) ;
 800a664:	4b13      	ldr	r3, [pc, #76]	@ (800a6b4 <HAL_RCCEx_GetPLL3ClockFreq+0x290>)
 800a666:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800a668:	0e1b      	lsrs	r3, r3, #24
 800a66a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800a66e:	ee07 3a90 	vmov	s15, r3
 800a672:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a676:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800a67a:	ee37 7a87 	vadd.f32	s14, s15, s14
 800a67e:	edd7 6a07 	vldr	s13, [r7, #28]
 800a682:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800a686:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800a68a:	ee17 2a90 	vmov	r2, s15
 800a68e:	687b      	ldr	r3, [r7, #4]
 800a690:	609a      	str	r2, [r3, #8]
    PLL3_Clocks->PLL3_P_Frequency = 0U;
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
    PLL3_Clocks->PLL3_R_Frequency = 0U;
  }

}
 800a692:	e008      	b.n	800a6a6 <HAL_RCCEx_GetPLL3ClockFreq+0x282>
    PLL3_Clocks->PLL3_P_Frequency = 0U;
 800a694:	687b      	ldr	r3, [r7, #4]
 800a696:	2200      	movs	r2, #0
 800a698:	601a      	str	r2, [r3, #0]
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
 800a69a:	687b      	ldr	r3, [r7, #4]
 800a69c:	2200      	movs	r2, #0
 800a69e:	605a      	str	r2, [r3, #4]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
 800a6a0:	687b      	ldr	r3, [r7, #4]
 800a6a2:	2200      	movs	r2, #0
 800a6a4:	609a      	str	r2, [r3, #8]
}
 800a6a6:	bf00      	nop
 800a6a8:	3724      	adds	r7, #36	@ 0x24
 800a6aa:	46bd      	mov	sp, r7
 800a6ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a6b0:	4770      	bx	lr
 800a6b2:	bf00      	nop
 800a6b4:	58024400 	.word	0x58024400
 800a6b8:	03d09000 	.word	0x03d09000
 800a6bc:	46000000 	.word	0x46000000
 800a6c0:	4c742400 	.word	0x4c742400
 800a6c4:	4a742400 	.word	0x4a742400
 800a6c8:	4af42400 	.word	0x4af42400

0800a6cc <HAL_RCCEx_GetPLL1ClockFreq>:
  *         right PLL1CLK value. Otherwise, any configuration based on this function will be incorrect.
  * @param  PLL1_Clocks structure.
  * @retval None
  */
void HAL_RCCEx_GetPLL1ClockFreq(PLL1_ClocksTypeDef *PLL1_Clocks)
{
 800a6cc:	b480      	push	{r7}
 800a6ce:	b089      	sub	sp, #36	@ 0x24
 800a6d0:	af00      	add	r7, sp, #0
 800a6d2:	6078      	str	r0, [r7, #4]
  uint32_t pllsource, pll1m, pll1fracen, hsivalue;
  float_t fracn1, pll1vco;

  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800a6d4:	4ba0      	ldr	r3, [pc, #640]	@ (800a958 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800a6d6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800a6d8:	f003 0303 	and.w	r3, r3, #3
 800a6dc:	61bb      	str	r3, [r7, #24]
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4);
 800a6de:	4b9e      	ldr	r3, [pc, #632]	@ (800a958 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800a6e0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800a6e2:	091b      	lsrs	r3, r3, #4
 800a6e4:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 800a6e8:	617b      	str	r3, [r7, #20]
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
 800a6ea:	4b9b      	ldr	r3, [pc, #620]	@ (800a958 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800a6ec:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800a6ee:	f003 0301 	and.w	r3, r3, #1
 800a6f2:	613b      	str	r3, [r7, #16]
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 800a6f4:	4b98      	ldr	r3, [pc, #608]	@ (800a958 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800a6f6:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 800a6f8:	08db      	lsrs	r3, r3, #3
 800a6fa:	f3c3 030c 	ubfx	r3, r3, #0, #13
 800a6fe:	693a      	ldr	r2, [r7, #16]
 800a700:	fb02 f303 	mul.w	r3, r2, r3
 800a704:	ee07 3a90 	vmov	s15, r3
 800a708:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a70c:	edc7 7a03 	vstr	s15, [r7, #12]

  if (pll1m != 0U)
 800a710:	697b      	ldr	r3, [r7, #20]
 800a712:	2b00      	cmp	r3, #0
 800a714:	f000 8111 	beq.w	800a93a <HAL_RCCEx_GetPLL1ClockFreq+0x26e>
  {
    switch (pllsource)
 800a718:	69bb      	ldr	r3, [r7, #24]
 800a71a:	2b02      	cmp	r3, #2
 800a71c:	f000 8083 	beq.w	800a826 <HAL_RCCEx_GetPLL1ClockFreq+0x15a>
 800a720:	69bb      	ldr	r3, [r7, #24]
 800a722:	2b02      	cmp	r3, #2
 800a724:	f200 80a1 	bhi.w	800a86a <HAL_RCCEx_GetPLL1ClockFreq+0x19e>
 800a728:	69bb      	ldr	r3, [r7, #24]
 800a72a:	2b00      	cmp	r3, #0
 800a72c:	d003      	beq.n	800a736 <HAL_RCCEx_GetPLL1ClockFreq+0x6a>
 800a72e:	69bb      	ldr	r3, [r7, #24]
 800a730:	2b01      	cmp	r3, #1
 800a732:	d056      	beq.n	800a7e2 <HAL_RCCEx_GetPLL1ClockFreq+0x116>
 800a734:	e099      	b.n	800a86a <HAL_RCCEx_GetPLL1ClockFreq+0x19e>
    {

      case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800a736:	4b88      	ldr	r3, [pc, #544]	@ (800a958 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800a738:	681b      	ldr	r3, [r3, #0]
 800a73a:	f003 0320 	and.w	r3, r3, #32
 800a73e:	2b00      	cmp	r3, #0
 800a740:	d02d      	beq.n	800a79e <HAL_RCCEx_GetPLL1ClockFreq+0xd2>
        {
          hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 800a742:	4b85      	ldr	r3, [pc, #532]	@ (800a958 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800a744:	681b      	ldr	r3, [r3, #0]
 800a746:	08db      	lsrs	r3, r3, #3
 800a748:	f003 0303 	and.w	r3, r3, #3
 800a74c:	4a83      	ldr	r2, [pc, #524]	@ (800a95c <HAL_RCCEx_GetPLL1ClockFreq+0x290>)
 800a74e:	fa22 f303 	lsr.w	r3, r2, r3
 800a752:	60bb      	str	r3, [r7, #8]
          pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800a754:	68bb      	ldr	r3, [r7, #8]
 800a756:	ee07 3a90 	vmov	s15, r3
 800a75a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a75e:	697b      	ldr	r3, [r7, #20]
 800a760:	ee07 3a90 	vmov	s15, r3
 800a764:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a768:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a76c:	4b7a      	ldr	r3, [pc, #488]	@ (800a958 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800a76e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800a770:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a774:	ee07 3a90 	vmov	s15, r3
 800a778:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a77c:	ed97 6a03 	vldr	s12, [r7, #12]
 800a780:	eddf 5a77 	vldr	s11, [pc, #476]	@ 800a960 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 800a784:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a788:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a78c:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a790:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a794:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a798:	edc7 7a07 	vstr	s15, [r7, #28]
        }
        else
        {
          pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
        }
        break;
 800a79c:	e087      	b.n	800a8ae <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>
          pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800a79e:	697b      	ldr	r3, [r7, #20]
 800a7a0:	ee07 3a90 	vmov	s15, r3
 800a7a4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a7a8:	eddf 6a6e 	vldr	s13, [pc, #440]	@ 800a964 <HAL_RCCEx_GetPLL1ClockFreq+0x298>
 800a7ac:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a7b0:	4b69      	ldr	r3, [pc, #420]	@ (800a958 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800a7b2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800a7b4:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a7b8:	ee07 3a90 	vmov	s15, r3
 800a7bc:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a7c0:	ed97 6a03 	vldr	s12, [r7, #12]
 800a7c4:	eddf 5a66 	vldr	s11, [pc, #408]	@ 800a960 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 800a7c8:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a7cc:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a7d0:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a7d4:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a7d8:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a7dc:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800a7e0:	e065      	b.n	800a8ae <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>
      case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
        pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800a7e2:	697b      	ldr	r3, [r7, #20]
 800a7e4:	ee07 3a90 	vmov	s15, r3
 800a7e8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a7ec:	eddf 6a5e 	vldr	s13, [pc, #376]	@ 800a968 <HAL_RCCEx_GetPLL1ClockFreq+0x29c>
 800a7f0:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a7f4:	4b58      	ldr	r3, [pc, #352]	@ (800a958 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800a7f6:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800a7f8:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a7fc:	ee07 3a90 	vmov	s15, r3
 800a800:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a804:	ed97 6a03 	vldr	s12, [r7, #12]
 800a808:	eddf 5a55 	vldr	s11, [pc, #340]	@ 800a960 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 800a80c:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a810:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a814:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a818:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a81c:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a820:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800a824:	e043      	b.n	800a8ae <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>

      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800a826:	697b      	ldr	r3, [r7, #20]
 800a828:	ee07 3a90 	vmov	s15, r3
 800a82c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a830:	eddf 6a4e 	vldr	s13, [pc, #312]	@ 800a96c <HAL_RCCEx_GetPLL1ClockFreq+0x2a0>
 800a834:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a838:	4b47      	ldr	r3, [pc, #284]	@ (800a958 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800a83a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800a83c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a840:	ee07 3a90 	vmov	s15, r3
 800a844:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a848:	ed97 6a03 	vldr	s12, [r7, #12]
 800a84c:	eddf 5a44 	vldr	s11, [pc, #272]	@ 800a960 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 800a850:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a854:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a858:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a85c:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a860:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a864:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800a868:	e021      	b.n	800a8ae <HAL_RCCEx_GetPLL1ClockFreq+0x1e2>

      default:
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 800a86a:	697b      	ldr	r3, [r7, #20]
 800a86c:	ee07 3a90 	vmov	s15, r3
 800a870:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a874:	eddf 6a3b 	vldr	s13, [pc, #236]	@ 800a964 <HAL_RCCEx_GetPLL1ClockFreq+0x298>
 800a878:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 800a87c:	4b36      	ldr	r3, [pc, #216]	@ (800a958 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800a87e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800a880:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800a884:	ee07 3a90 	vmov	s15, r3
 800a888:	eef8 6a67 	vcvt.f32.u32	s13, s15
 800a88c:	ed97 6a03 	vldr	s12, [r7, #12]
 800a890:	eddf 5a33 	vldr	s11, [pc, #204]	@ 800a960 <HAL_RCCEx_GetPLL1ClockFreq+0x294>
 800a894:	eec6 7a25 	vdiv.f32	s15, s12, s11
 800a898:	ee76 7aa7 	vadd.f32	s15, s13, s15
 800a89c:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 800a8a0:	ee77 7aa6 	vadd.f32	s15, s15, s13
 800a8a4:	ee67 7a27 	vmul.f32	s15, s14, s15
 800a8a8:	edc7 7a07 	vstr	s15, [r7, #28]
        break;
 800a8ac:	bf00      	nop
    }

    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> 9)  + (float_t)1)) ;
 800a8ae:	4b2a      	ldr	r3, [pc, #168]	@ (800a958 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800a8b0:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800a8b2:	0a5b      	lsrs	r3, r3, #9
 800a8b4:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800a8b8:	ee07 3a90 	vmov	s15, r3
 800a8bc:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a8c0:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800a8c4:	ee37 7a87 	vadd.f32	s14, s15, s14
 800a8c8:	edd7 6a07 	vldr	s13, [r7, #28]
 800a8cc:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800a8d0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800a8d4:	ee17 2a90 	vmov	r2, s15
 800a8d8:	687b      	ldr	r3, [r7, #4]
 800a8da:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >> 16) + (float_t)1)) ;
 800a8dc:	4b1e      	ldr	r3, [pc, #120]	@ (800a958 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800a8de:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800a8e0:	0c1b      	lsrs	r3, r3, #16
 800a8e2:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800a8e6:	ee07 3a90 	vmov	s15, r3
 800a8ea:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a8ee:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800a8f2:	ee37 7a87 	vadd.f32	s14, s15, s14
 800a8f6:	edd7 6a07 	vldr	s13, [r7, #28]
 800a8fa:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800a8fe:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800a902:	ee17 2a90 	vmov	r2, s15
 800a906:	687b      	ldr	r3, [r7, #4]
 800a908:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco / ((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >> 24) + (float_t)1)) ;
 800a90a:	4b13      	ldr	r3, [pc, #76]	@ (800a958 <HAL_RCCEx_GetPLL1ClockFreq+0x28c>)
 800a90c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800a90e:	0e1b      	lsrs	r3, r3, #24
 800a910:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 800a914:	ee07 3a90 	vmov	s15, r3
 800a918:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800a91c:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800a920:	ee37 7a87 	vadd.f32	s14, s15, s14
 800a924:	edd7 6a07 	vldr	s13, [r7, #28]
 800a928:	eec6 7a87 	vdiv.f32	s15, s13, s14
 800a92c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800a930:	ee17 2a90 	vmov	r2, s15
 800a934:	687b      	ldr	r3, [r7, #4]
 800a936:	609a      	str	r2, [r3, #8]
    PLL1_Clocks->PLL1_P_Frequency = 0U;
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
    PLL1_Clocks->PLL1_R_Frequency = 0U;
  }

}
 800a938:	e008      	b.n	800a94c <HAL_RCCEx_GetPLL1ClockFreq+0x280>
    PLL1_Clocks->PLL1_P_Frequency = 0U;
 800a93a:	687b      	ldr	r3, [r7, #4]
 800a93c:	2200      	movs	r2, #0
 800a93e:	601a      	str	r2, [r3, #0]
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
 800a940:	687b      	ldr	r3, [r7, #4]
 800a942:	2200      	movs	r2, #0
 800a944:	605a      	str	r2, [r3, #4]
    PLL1_Clocks->PLL1_R_Frequency = 0U;
 800a946:	687b      	ldr	r3, [r7, #4]
 800a948:	2200      	movs	r2, #0
 800a94a:	609a      	str	r2, [r3, #8]
}
 800a94c:	bf00      	nop
 800a94e:	3724      	adds	r7, #36	@ 0x24
 800a950:	46bd      	mov	sp, r7
 800a952:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a956:	4770      	bx	lr
 800a958:	58024400 	.word	0x58024400
 800a95c:	03d09000 	.word	0x03d09000
 800a960:	46000000 	.word	0x46000000
 800a964:	4c742400 	.word	0x4c742400
 800a968:	4a742400 	.word	0x4a742400
 800a96c:	4af42400 	.word	0x4af42400

0800a970 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(const RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
 800a970:	b580      	push	{r7, lr}
 800a972:	b084      	sub	sp, #16
 800a974:	af00      	add	r7, sp, #0
 800a976:	6078      	str	r0, [r7, #4]
 800a978:	6039      	str	r1, [r7, #0]

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 800a97a:	2300      	movs	r3, #0
 800a97c:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));

  /* Check that PLL2 OSC clock source is already set */
  if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 800a97e:	4b53      	ldr	r3, [pc, #332]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800a980:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800a982:	f003 0303 	and.w	r3, r3, #3
 800a986:	2b03      	cmp	r3, #3
 800a988:	d101      	bne.n	800a98e <RCCEx_PLL2_Config+0x1e>
  {
    return HAL_ERROR;
 800a98a:	2301      	movs	r3, #1
 800a98c:	e099      	b.n	800aac2 <RCCEx_PLL2_Config+0x152>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
 800a98e:	4b4f      	ldr	r3, [pc, #316]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800a990:	681b      	ldr	r3, [r3, #0]
 800a992:	4a4e      	ldr	r2, [pc, #312]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800a994:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
 800a998:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800a99a:	f7f7 faeb 	bl	8001f74 <HAL_GetTick>
 800a99e:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL is disabled */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 800a9a0:	e008      	b.n	800a9b4 <RCCEx_PLL2_Config+0x44>
    {
      if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 800a9a2:	f7f7 fae7 	bl	8001f74 <HAL_GetTick>
 800a9a6:	4602      	mov	r2, r0
 800a9a8:	68bb      	ldr	r3, [r7, #8]
 800a9aa:	1ad3      	subs	r3, r2, r3
 800a9ac:	2b02      	cmp	r3, #2
 800a9ae:	d901      	bls.n	800a9b4 <RCCEx_PLL2_Config+0x44>
      {
        return HAL_TIMEOUT;
 800a9b0:	2303      	movs	r3, #3
 800a9b2:	e086      	b.n	800aac2 <RCCEx_PLL2_Config+0x152>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 800a9b4:	4b45      	ldr	r3, [pc, #276]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800a9b6:	681b      	ldr	r3, [r3, #0]
 800a9b8:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800a9bc:	2b00      	cmp	r3, #0
 800a9be:	d1f0      	bne.n	800a9a2 <RCCEx_PLL2_Config+0x32>
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
 800a9c0:	4b42      	ldr	r3, [pc, #264]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800a9c2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800a9c4:	f423 327c 	bic.w	r2, r3, #258048	@ 0x3f000
 800a9c8:	687b      	ldr	r3, [r7, #4]
 800a9ca:	681b      	ldr	r3, [r3, #0]
 800a9cc:	031b      	lsls	r3, r3, #12
 800a9ce:	493f      	ldr	r1, [pc, #252]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800a9d0:	4313      	orrs	r3, r2
 800a9d2:	628b      	str	r3, [r1, #40]	@ 0x28
 800a9d4:	687b      	ldr	r3, [r7, #4]
 800a9d6:	685b      	ldr	r3, [r3, #4]
 800a9d8:	3b01      	subs	r3, #1
 800a9da:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800a9de:	687b      	ldr	r3, [r7, #4]
 800a9e0:	689b      	ldr	r3, [r3, #8]
 800a9e2:	3b01      	subs	r3, #1
 800a9e4:	025b      	lsls	r3, r3, #9
 800a9e6:	b29b      	uxth	r3, r3
 800a9e8:	431a      	orrs	r2, r3
 800a9ea:	687b      	ldr	r3, [r7, #4]
 800a9ec:	68db      	ldr	r3, [r3, #12]
 800a9ee:	3b01      	subs	r3, #1
 800a9f0:	041b      	lsls	r3, r3, #16
 800a9f2:	f403 03fe 	and.w	r3, r3, #8323072	@ 0x7f0000
 800a9f6:	431a      	orrs	r2, r3
 800a9f8:	687b      	ldr	r3, [r7, #4]
 800a9fa:	691b      	ldr	r3, [r3, #16]
 800a9fc:	3b01      	subs	r3, #1
 800a9fe:	061b      	lsls	r3, r3, #24
 800aa00:	f003 43fe 	and.w	r3, r3, #2130706432	@ 0x7f000000
 800aa04:	4931      	ldr	r1, [pc, #196]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa06:	4313      	orrs	r3, r2
 800aa08:	638b      	str	r3, [r1, #56]	@ 0x38
                          pll2->PLL2P,
                          pll2->PLL2Q,
                          pll2->PLL2R);

    /* Select PLL2 input reference frequency range: VCI */
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
 800aa0a:	4b30      	ldr	r3, [pc, #192]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa0c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800aa0e:	f023 02c0 	bic.w	r2, r3, #192	@ 0xc0
 800aa12:	687b      	ldr	r3, [r7, #4]
 800aa14:	695b      	ldr	r3, [r3, #20]
 800aa16:	492d      	ldr	r1, [pc, #180]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa18:	4313      	orrs	r3, r2
 800aa1a:	62cb      	str	r3, [r1, #44]	@ 0x2c

    /* Select PLL2 output frequency range : VCO */
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
 800aa1c:	4b2b      	ldr	r3, [pc, #172]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa1e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800aa20:	f023 0220 	bic.w	r2, r3, #32
 800aa24:	687b      	ldr	r3, [r7, #4]
 800aa26:	699b      	ldr	r3, [r3, #24]
 800aa28:	4928      	ldr	r1, [pc, #160]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa2a:	4313      	orrs	r3, r2
 800aa2c:	62cb      	str	r3, [r1, #44]	@ 0x2c

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();
 800aa2e:	4b27      	ldr	r3, [pc, #156]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa30:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800aa32:	4a26      	ldr	r2, [pc, #152]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa34:	f023 0310 	bic.w	r3, r3, #16
 800aa38:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 800aa3a:	4b24      	ldr	r3, [pc, #144]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa3c:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800aa3e:	4b24      	ldr	r3, [pc, #144]	@ (800aad0 <RCCEx_PLL2_Config+0x160>)
 800aa40:	4013      	ands	r3, r2
 800aa42:	687a      	ldr	r2, [r7, #4]
 800aa44:	69d2      	ldr	r2, [r2, #28]
 800aa46:	00d2      	lsls	r2, r2, #3
 800aa48:	4920      	ldr	r1, [pc, #128]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa4a:	4313      	orrs	r3, r2
 800aa4c:	63cb      	str	r3, [r1, #60]	@ 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
 800aa4e:	4b1f      	ldr	r3, [pc, #124]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa50:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800aa52:	4a1e      	ldr	r2, [pc, #120]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa54:	f043 0310 	orr.w	r3, r3, #16
 800aa58:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* Enable the PLL2 clock output */
    if (Divider == DIVIDER_P_UPDATE)
 800aa5a:	683b      	ldr	r3, [r7, #0]
 800aa5c:	2b00      	cmp	r3, #0
 800aa5e:	d106      	bne.n	800aa6e <RCCEx_PLL2_Config+0xfe>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
 800aa60:	4b1a      	ldr	r3, [pc, #104]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa62:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800aa64:	4a19      	ldr	r2, [pc, #100]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa66:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 800aa6a:	62d3      	str	r3, [r2, #44]	@ 0x2c
 800aa6c:	e00f      	b.n	800aa8e <RCCEx_PLL2_Config+0x11e>
    }
    else if (Divider == DIVIDER_Q_UPDATE)
 800aa6e:	683b      	ldr	r3, [r7, #0]
 800aa70:	2b01      	cmp	r3, #1
 800aa72:	d106      	bne.n	800aa82 <RCCEx_PLL2_Config+0x112>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
 800aa74:	4b15      	ldr	r3, [pc, #84]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa76:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800aa78:	4a14      	ldr	r2, [pc, #80]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa7a:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 800aa7e:	62d3      	str	r3, [r2, #44]	@ 0x2c
 800aa80:	e005      	b.n	800aa8e <RCCEx_PLL2_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
 800aa82:	4b12      	ldr	r3, [pc, #72]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa84:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800aa86:	4a11      	ldr	r2, [pc, #68]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa88:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 800aa8c:	62d3      	str	r3, [r2, #44]	@ 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
 800aa8e:	4b0f      	ldr	r3, [pc, #60]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa90:	681b      	ldr	r3, [r3, #0]
 800aa92:	4a0e      	ldr	r2, [pc, #56]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aa94:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 800aa98:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800aa9a:	f7f7 fa6b 	bl	8001f74 <HAL_GetTick>
 800aa9e:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL2 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 800aaa0:	e008      	b.n	800aab4 <RCCEx_PLL2_Config+0x144>
    {
      if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 800aaa2:	f7f7 fa67 	bl	8001f74 <HAL_GetTick>
 800aaa6:	4602      	mov	r2, r0
 800aaa8:	68bb      	ldr	r3, [r7, #8]
 800aaaa:	1ad3      	subs	r3, r2, r3
 800aaac:	2b02      	cmp	r3, #2
 800aaae:	d901      	bls.n	800aab4 <RCCEx_PLL2_Config+0x144>
      {
        return HAL_TIMEOUT;
 800aab0:	2303      	movs	r3, #3
 800aab2:	e006      	b.n	800aac2 <RCCEx_PLL2_Config+0x152>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 800aab4:	4b05      	ldr	r3, [pc, #20]	@ (800aacc <RCCEx_PLL2_Config+0x15c>)
 800aab6:	681b      	ldr	r3, [r3, #0]
 800aab8:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 800aabc:	2b00      	cmp	r3, #0
 800aabe:	d0f0      	beq.n	800aaa2 <RCCEx_PLL2_Config+0x132>
    }

  }


  return status;
 800aac0:	7bfb      	ldrb	r3, [r7, #15]
}
 800aac2:	4618      	mov	r0, r3
 800aac4:	3710      	adds	r7, #16
 800aac6:	46bd      	mov	sp, r7
 800aac8:	bd80      	pop	{r7, pc}
 800aaca:	bf00      	nop
 800aacc:	58024400 	.word	0x58024400
 800aad0:	ffff0007 	.word	0xffff0007

0800aad4 <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(const RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
 800aad4:	b580      	push	{r7, lr}
 800aad6:	b084      	sub	sp, #16
 800aad8:	af00      	add	r7, sp, #0
 800aada:	6078      	str	r0, [r7, #4]
 800aadc:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 800aade:	2300      	movs	r3, #0
 800aae0:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));

  /* Check that PLL3 OSC clock source is already set */
  if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 800aae2:	4b53      	ldr	r3, [pc, #332]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800aae4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800aae6:	f003 0303 	and.w	r3, r3, #3
 800aaea:	2b03      	cmp	r3, #3
 800aaec:	d101      	bne.n	800aaf2 <RCCEx_PLL3_Config+0x1e>
  {
    return HAL_ERROR;
 800aaee:	2301      	movs	r3, #1
 800aaf0:	e099      	b.n	800ac26 <RCCEx_PLL3_Config+0x152>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
 800aaf2:	4b4f      	ldr	r3, [pc, #316]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800aaf4:	681b      	ldr	r3, [r3, #0]
 800aaf6:	4a4e      	ldr	r2, [pc, #312]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800aaf8:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 800aafc:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800aafe:	f7f7 fa39 	bl	8001f74 <HAL_GetTick>
 800ab02:	60b8      	str	r0, [r7, #8]
    /* Wait till PLL3 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 800ab04:	e008      	b.n	800ab18 <RCCEx_PLL3_Config+0x44>
    {
      if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 800ab06:	f7f7 fa35 	bl	8001f74 <HAL_GetTick>
 800ab0a:	4602      	mov	r2, r0
 800ab0c:	68bb      	ldr	r3, [r7, #8]
 800ab0e:	1ad3      	subs	r3, r2, r3
 800ab10:	2b02      	cmp	r3, #2
 800ab12:	d901      	bls.n	800ab18 <RCCEx_PLL3_Config+0x44>
      {
        return HAL_TIMEOUT;
 800ab14:	2303      	movs	r3, #3
 800ab16:	e086      	b.n	800ac26 <RCCEx_PLL3_Config+0x152>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 800ab18:	4b45      	ldr	r3, [pc, #276]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800ab1a:	681b      	ldr	r3, [r3, #0]
 800ab1c:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 800ab20:	2b00      	cmp	r3, #0
 800ab22:	d1f0      	bne.n	800ab06 <RCCEx_PLL3_Config+0x32>
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
 800ab24:	4b42      	ldr	r3, [pc, #264]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800ab26:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800ab28:	f023 727c 	bic.w	r2, r3, #66060288	@ 0x3f00000
 800ab2c:	687b      	ldr	r3, [r7, #4]
 800ab2e:	681b      	ldr	r3, [r3, #0]
 800ab30:	051b      	lsls	r3, r3, #20
 800ab32:	493f      	ldr	r1, [pc, #252]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800ab34:	4313      	orrs	r3, r2
 800ab36:	628b      	str	r3, [r1, #40]	@ 0x28
 800ab38:	687b      	ldr	r3, [r7, #4]
 800ab3a:	685b      	ldr	r3, [r3, #4]
 800ab3c:	3b01      	subs	r3, #1
 800ab3e:	f3c3 0208 	ubfx	r2, r3, #0, #9
 800ab42:	687b      	ldr	r3, [r7, #4]
 800ab44:	689b      	ldr	r3, [r3, #8]
 800ab46:	3b01      	subs	r3, #1
 800ab48:	025b      	lsls	r3, r3, #9
 800ab4a:	b29b      	uxth	r3, r3
 800ab4c:	431a      	orrs	r2, r3
 800ab4e:	687b      	ldr	r3, [r7, #4]
 800ab50:	68db      	ldr	r3, [r3, #12]
 800ab52:	3b01      	subs	r3, #1
 800ab54:	041b      	lsls	r3, r3, #16
 800ab56:	f403 03fe 	and.w	r3, r3, #8323072	@ 0x7f0000
 800ab5a:	431a      	orrs	r2, r3
 800ab5c:	687b      	ldr	r3, [r7, #4]
 800ab5e:	691b      	ldr	r3, [r3, #16]
 800ab60:	3b01      	subs	r3, #1
 800ab62:	061b      	lsls	r3, r3, #24
 800ab64:	f003 43fe 	and.w	r3, r3, #2130706432	@ 0x7f000000
 800ab68:	4931      	ldr	r1, [pc, #196]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800ab6a:	4313      	orrs	r3, r2
 800ab6c:	640b      	str	r3, [r1, #64]	@ 0x40
                          pll3->PLL3P,
                          pll3->PLL3Q,
                          pll3->PLL3R);

    /* Select PLL3 input reference frequency range: VCI */
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
 800ab6e:	4b30      	ldr	r3, [pc, #192]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800ab70:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800ab72:	f423 6240 	bic.w	r2, r3, #3072	@ 0xc00
 800ab76:	687b      	ldr	r3, [r7, #4]
 800ab78:	695b      	ldr	r3, [r3, #20]
 800ab7a:	492d      	ldr	r1, [pc, #180]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800ab7c:	4313      	orrs	r3, r2
 800ab7e:	62cb      	str	r3, [r1, #44]	@ 0x2c

    /* Select PLL3 output frequency range : VCO */
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
 800ab80:	4b2b      	ldr	r3, [pc, #172]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800ab82:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800ab84:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
 800ab88:	687b      	ldr	r3, [r7, #4]
 800ab8a:	699b      	ldr	r3, [r3, #24]
 800ab8c:	4928      	ldr	r1, [pc, #160]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800ab8e:	4313      	orrs	r3, r2
 800ab90:	62cb      	str	r3, [r1, #44]	@ 0x2c

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();
 800ab92:	4b27      	ldr	r3, [pc, #156]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800ab94:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800ab96:	4a26      	ldr	r2, [pc, #152]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800ab98:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 800ab9c:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 800ab9e:	4b24      	ldr	r3, [pc, #144]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800aba0:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 800aba2:	4b24      	ldr	r3, [pc, #144]	@ (800ac34 <RCCEx_PLL3_Config+0x160>)
 800aba4:	4013      	ands	r3, r2
 800aba6:	687a      	ldr	r2, [r7, #4]
 800aba8:	69d2      	ldr	r2, [r2, #28]
 800abaa:	00d2      	lsls	r2, r2, #3
 800abac:	4920      	ldr	r1, [pc, #128]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800abae:	4313      	orrs	r3, r2
 800abb0:	644b      	str	r3, [r1, #68]	@ 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
 800abb2:	4b1f      	ldr	r3, [pc, #124]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800abb4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800abb6:	4a1e      	ldr	r2, [pc, #120]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800abb8:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 800abbc:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* Enable the PLL3 clock output */
    if (Divider == DIVIDER_P_UPDATE)
 800abbe:	683b      	ldr	r3, [r7, #0]
 800abc0:	2b00      	cmp	r3, #0
 800abc2:	d106      	bne.n	800abd2 <RCCEx_PLL3_Config+0xfe>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
 800abc4:	4b1a      	ldr	r3, [pc, #104]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800abc6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800abc8:	4a19      	ldr	r2, [pc, #100]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800abca:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 800abce:	62d3      	str	r3, [r2, #44]	@ 0x2c
 800abd0:	e00f      	b.n	800abf2 <RCCEx_PLL3_Config+0x11e>
    }
    else if (Divider == DIVIDER_Q_UPDATE)
 800abd2:	683b      	ldr	r3, [r7, #0]
 800abd4:	2b01      	cmp	r3, #1
 800abd6:	d106      	bne.n	800abe6 <RCCEx_PLL3_Config+0x112>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
 800abd8:	4b15      	ldr	r3, [pc, #84]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800abda:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800abdc:	4a14      	ldr	r2, [pc, #80]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800abde:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 800abe2:	62d3      	str	r3, [r2, #44]	@ 0x2c
 800abe4:	e005      	b.n	800abf2 <RCCEx_PLL3_Config+0x11e>
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
 800abe6:	4b12      	ldr	r3, [pc, #72]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800abe8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800abea:	4a11      	ldr	r2, [pc, #68]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800abec:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 800abf0:	62d3      	str	r3, [r2, #44]	@ 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
 800abf2:	4b0f      	ldr	r3, [pc, #60]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800abf4:	681b      	ldr	r3, [r3, #0]
 800abf6:	4a0e      	ldr	r2, [pc, #56]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800abf8:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 800abfc:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800abfe:	f7f7 f9b9 	bl	8001f74 <HAL_GetTick>
 800ac02:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL3 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 800ac04:	e008      	b.n	800ac18 <RCCEx_PLL3_Config+0x144>
    {
      if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 800ac06:	f7f7 f9b5 	bl	8001f74 <HAL_GetTick>
 800ac0a:	4602      	mov	r2, r0
 800ac0c:	68bb      	ldr	r3, [r7, #8]
 800ac0e:	1ad3      	subs	r3, r2, r3
 800ac10:	2b02      	cmp	r3, #2
 800ac12:	d901      	bls.n	800ac18 <RCCEx_PLL3_Config+0x144>
      {
        return HAL_TIMEOUT;
 800ac14:	2303      	movs	r3, #3
 800ac16:	e006      	b.n	800ac26 <RCCEx_PLL3_Config+0x152>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 800ac18:	4b05      	ldr	r3, [pc, #20]	@ (800ac30 <RCCEx_PLL3_Config+0x15c>)
 800ac1a:	681b      	ldr	r3, [r3, #0]
 800ac1c:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 800ac20:	2b00      	cmp	r3, #0
 800ac22:	d0f0      	beq.n	800ac06 <RCCEx_PLL3_Config+0x132>
    }

  }


  return status;
 800ac24:	7bfb      	ldrb	r3, [r7, #15]
}
 800ac26:	4618      	mov	r0, r3
 800ac28:	3710      	adds	r7, #16
 800ac2a:	46bd      	mov	sp, r7
 800ac2c:	bd80      	pop	{r7, pc}
 800ac2e:	bf00      	nop
 800ac30:	58024400 	.word	0x58024400
 800ac34:	ffff0007 	.word	0xffff0007

0800ac38 <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 800ac38:	b580      	push	{r7, lr}
 800ac3a:	b082      	sub	sp, #8
 800ac3c:	af00      	add	r7, sp, #0
 800ac3e:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 800ac40:	687b      	ldr	r3, [r7, #4]
 800ac42:	2b00      	cmp	r3, #0
 800ac44:	d101      	bne.n	800ac4a <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 800ac46:	2301      	movs	r3, #1
 800ac48:	e049      	b.n	800acde <HAL_TIM_Base_Init+0xa6>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 800ac4a:	687b      	ldr	r3, [r7, #4]
 800ac4c:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800ac50:	b2db      	uxtb	r3, r3
 800ac52:	2b00      	cmp	r3, #0
 800ac54:	d106      	bne.n	800ac64 <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 800ac56:	687b      	ldr	r3, [r7, #4]
 800ac58:	2200      	movs	r2, #0
 800ac5a:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 800ac5e:	6878      	ldr	r0, [r7, #4]
 800ac60:	f7f6 fd18 	bl	8001694 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800ac64:	687b      	ldr	r3, [r7, #4]
 800ac66:	2202      	movs	r2, #2
 800ac68:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800ac6c:	687b      	ldr	r3, [r7, #4]
 800ac6e:	681a      	ldr	r2, [r3, #0]
 800ac70:	687b      	ldr	r3, [r7, #4]
 800ac72:	3304      	adds	r3, #4
 800ac74:	4619      	mov	r1, r3
 800ac76:	4610      	mov	r0, r2
 800ac78:	f000 fb46 	bl	800b308 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 800ac7c:	687b      	ldr	r3, [r7, #4]
 800ac7e:	2201      	movs	r2, #1
 800ac80:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800ac84:	687b      	ldr	r3, [r7, #4]
 800ac86:	2201      	movs	r2, #1
 800ac88:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
 800ac8c:	687b      	ldr	r3, [r7, #4]
 800ac8e:	2201      	movs	r2, #1
 800ac90:	f883 203f 	strb.w	r2, [r3, #63]	@ 0x3f
 800ac94:	687b      	ldr	r3, [r7, #4]
 800ac96:	2201      	movs	r2, #1
 800ac98:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
 800ac9c:	687b      	ldr	r3, [r7, #4]
 800ac9e:	2201      	movs	r2, #1
 800aca0:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
 800aca4:	687b      	ldr	r3, [r7, #4]
 800aca6:	2201      	movs	r2, #1
 800aca8:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
 800acac:	687b      	ldr	r3, [r7, #4]
 800acae:	2201      	movs	r2, #1
 800acb0:	f883 2043 	strb.w	r2, [r3, #67]	@ 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 800acb4:	687b      	ldr	r3, [r7, #4]
 800acb6:	2201      	movs	r2, #1
 800acb8:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
 800acbc:	687b      	ldr	r3, [r7, #4]
 800acbe:	2201      	movs	r2, #1
 800acc0:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
 800acc4:	687b      	ldr	r3, [r7, #4]
 800acc6:	2201      	movs	r2, #1
 800acc8:	f883 2046 	strb.w	r2, [r3, #70]	@ 0x46
 800accc:	687b      	ldr	r3, [r7, #4]
 800acce:	2201      	movs	r2, #1
 800acd0:	f883 2047 	strb.w	r2, [r3, #71]	@ 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 800acd4:	687b      	ldr	r3, [r7, #4]
 800acd6:	2201      	movs	r2, #1
 800acd8:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  return HAL_OK;
 800acdc:	2300      	movs	r3, #0
}
 800acde:	4618      	mov	r0, r3
 800ace0:	3708      	adds	r7, #8
 800ace2:	46bd      	mov	sp, r7
 800ace4:	bd80      	pop	{r7, pc}
	...

0800ace8 <HAL_TIM_Base_Start>:
  * @brief  Starts the TIM Base generation.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
{
 800ace8:	b480      	push	{r7}
 800acea:	b085      	sub	sp, #20
 800acec:	af00      	add	r7, sp, #0
 800acee:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 800acf0:	687b      	ldr	r3, [r7, #4]
 800acf2:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800acf6:	b2db      	uxtb	r3, r3
 800acf8:	2b01      	cmp	r3, #1
 800acfa:	d001      	beq.n	800ad00 <HAL_TIM_Base_Start+0x18>
  {
    return HAL_ERROR;
 800acfc:	2301      	movs	r3, #1
 800acfe:	e04c      	b.n	800ad9a <HAL_TIM_Base_Start+0xb2>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800ad00:	687b      	ldr	r3, [r7, #4]
 800ad02:	2202      	movs	r2, #2
 800ad04:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800ad08:	687b      	ldr	r3, [r7, #4]
 800ad0a:	681b      	ldr	r3, [r3, #0]
 800ad0c:	4a26      	ldr	r2, [pc, #152]	@ (800ada8 <HAL_TIM_Base_Start+0xc0>)
 800ad0e:	4293      	cmp	r3, r2
 800ad10:	d022      	beq.n	800ad58 <HAL_TIM_Base_Start+0x70>
 800ad12:	687b      	ldr	r3, [r7, #4]
 800ad14:	681b      	ldr	r3, [r3, #0]
 800ad16:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800ad1a:	d01d      	beq.n	800ad58 <HAL_TIM_Base_Start+0x70>
 800ad1c:	687b      	ldr	r3, [r7, #4]
 800ad1e:	681b      	ldr	r3, [r3, #0]
 800ad20:	4a22      	ldr	r2, [pc, #136]	@ (800adac <HAL_TIM_Base_Start+0xc4>)
 800ad22:	4293      	cmp	r3, r2
 800ad24:	d018      	beq.n	800ad58 <HAL_TIM_Base_Start+0x70>
 800ad26:	687b      	ldr	r3, [r7, #4]
 800ad28:	681b      	ldr	r3, [r3, #0]
 800ad2a:	4a21      	ldr	r2, [pc, #132]	@ (800adb0 <HAL_TIM_Base_Start+0xc8>)
 800ad2c:	4293      	cmp	r3, r2
 800ad2e:	d013      	beq.n	800ad58 <HAL_TIM_Base_Start+0x70>
 800ad30:	687b      	ldr	r3, [r7, #4]
 800ad32:	681b      	ldr	r3, [r3, #0]
 800ad34:	4a1f      	ldr	r2, [pc, #124]	@ (800adb4 <HAL_TIM_Base_Start+0xcc>)
 800ad36:	4293      	cmp	r3, r2
 800ad38:	d00e      	beq.n	800ad58 <HAL_TIM_Base_Start+0x70>
 800ad3a:	687b      	ldr	r3, [r7, #4]
 800ad3c:	681b      	ldr	r3, [r3, #0]
 800ad3e:	4a1e      	ldr	r2, [pc, #120]	@ (800adb8 <HAL_TIM_Base_Start+0xd0>)
 800ad40:	4293      	cmp	r3, r2
 800ad42:	d009      	beq.n	800ad58 <HAL_TIM_Base_Start+0x70>
 800ad44:	687b      	ldr	r3, [r7, #4]
 800ad46:	681b      	ldr	r3, [r3, #0]
 800ad48:	4a1c      	ldr	r2, [pc, #112]	@ (800adbc <HAL_TIM_Base_Start+0xd4>)
 800ad4a:	4293      	cmp	r3, r2
 800ad4c:	d004      	beq.n	800ad58 <HAL_TIM_Base_Start+0x70>
 800ad4e:	687b      	ldr	r3, [r7, #4]
 800ad50:	681b      	ldr	r3, [r3, #0]
 800ad52:	4a1b      	ldr	r2, [pc, #108]	@ (800adc0 <HAL_TIM_Base_Start+0xd8>)
 800ad54:	4293      	cmp	r3, r2
 800ad56:	d115      	bne.n	800ad84 <HAL_TIM_Base_Start+0x9c>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800ad58:	687b      	ldr	r3, [r7, #4]
 800ad5a:	681b      	ldr	r3, [r3, #0]
 800ad5c:	689a      	ldr	r2, [r3, #8]
 800ad5e:	4b19      	ldr	r3, [pc, #100]	@ (800adc4 <HAL_TIM_Base_Start+0xdc>)
 800ad60:	4013      	ands	r3, r2
 800ad62:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800ad64:	68fb      	ldr	r3, [r7, #12]
 800ad66:	2b06      	cmp	r3, #6
 800ad68:	d015      	beq.n	800ad96 <HAL_TIM_Base_Start+0xae>
 800ad6a:	68fb      	ldr	r3, [r7, #12]
 800ad6c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800ad70:	d011      	beq.n	800ad96 <HAL_TIM_Base_Start+0xae>
    {
      __HAL_TIM_ENABLE(htim);
 800ad72:	687b      	ldr	r3, [r7, #4]
 800ad74:	681b      	ldr	r3, [r3, #0]
 800ad76:	681a      	ldr	r2, [r3, #0]
 800ad78:	687b      	ldr	r3, [r7, #4]
 800ad7a:	681b      	ldr	r3, [r3, #0]
 800ad7c:	f042 0201 	orr.w	r2, r2, #1
 800ad80:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800ad82:	e008      	b.n	800ad96 <HAL_TIM_Base_Start+0xae>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 800ad84:	687b      	ldr	r3, [r7, #4]
 800ad86:	681b      	ldr	r3, [r3, #0]
 800ad88:	681a      	ldr	r2, [r3, #0]
 800ad8a:	687b      	ldr	r3, [r7, #4]
 800ad8c:	681b      	ldr	r3, [r3, #0]
 800ad8e:	f042 0201 	orr.w	r2, r2, #1
 800ad92:	601a      	str	r2, [r3, #0]
 800ad94:	e000      	b.n	800ad98 <HAL_TIM_Base_Start+0xb0>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800ad96:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
 800ad98:	2300      	movs	r3, #0
}
 800ad9a:	4618      	mov	r0, r3
 800ad9c:	3714      	adds	r7, #20
 800ad9e:	46bd      	mov	sp, r7
 800ada0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ada4:	4770      	bx	lr
 800ada6:	bf00      	nop
 800ada8:	40010000 	.word	0x40010000
 800adac:	40000400 	.word	0x40000400
 800adb0:	40000800 	.word	0x40000800
 800adb4:	40000c00 	.word	0x40000c00
 800adb8:	40010400 	.word	0x40010400
 800adbc:	40001800 	.word	0x40001800
 800adc0:	40014000 	.word	0x40014000
 800adc4:	00010007 	.word	0x00010007

0800adc8 <HAL_TIM_Base_Start_IT>:
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
 800adc8:	b480      	push	{r7}
 800adca:	b085      	sub	sp, #20
 800adcc:	af00      	add	r7, sp, #0
 800adce:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 800add0:	687b      	ldr	r3, [r7, #4]
 800add2:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 800add6:	b2db      	uxtb	r3, r3
 800add8:	2b01      	cmp	r3, #1
 800adda:	d001      	beq.n	800ade0 <HAL_TIM_Base_Start_IT+0x18>
  {
    return HAL_ERROR;
 800addc:	2301      	movs	r3, #1
 800adde:	e054      	b.n	800ae8a <HAL_TIM_Base_Start_IT+0xc2>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 800ade0:	687b      	ldr	r3, [r7, #4]
 800ade2:	2202      	movs	r2, #2
 800ade4:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 800ade8:	687b      	ldr	r3, [r7, #4]
 800adea:	681b      	ldr	r3, [r3, #0]
 800adec:	68da      	ldr	r2, [r3, #12]
 800adee:	687b      	ldr	r3, [r7, #4]
 800adf0:	681b      	ldr	r3, [r3, #0]
 800adf2:	f042 0201 	orr.w	r2, r2, #1
 800adf6:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800adf8:	687b      	ldr	r3, [r7, #4]
 800adfa:	681b      	ldr	r3, [r3, #0]
 800adfc:	4a26      	ldr	r2, [pc, #152]	@ (800ae98 <HAL_TIM_Base_Start_IT+0xd0>)
 800adfe:	4293      	cmp	r3, r2
 800ae00:	d022      	beq.n	800ae48 <HAL_TIM_Base_Start_IT+0x80>
 800ae02:	687b      	ldr	r3, [r7, #4]
 800ae04:	681b      	ldr	r3, [r3, #0]
 800ae06:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800ae0a:	d01d      	beq.n	800ae48 <HAL_TIM_Base_Start_IT+0x80>
 800ae0c:	687b      	ldr	r3, [r7, #4]
 800ae0e:	681b      	ldr	r3, [r3, #0]
 800ae10:	4a22      	ldr	r2, [pc, #136]	@ (800ae9c <HAL_TIM_Base_Start_IT+0xd4>)
 800ae12:	4293      	cmp	r3, r2
 800ae14:	d018      	beq.n	800ae48 <HAL_TIM_Base_Start_IT+0x80>
 800ae16:	687b      	ldr	r3, [r7, #4]
 800ae18:	681b      	ldr	r3, [r3, #0]
 800ae1a:	4a21      	ldr	r2, [pc, #132]	@ (800aea0 <HAL_TIM_Base_Start_IT+0xd8>)
 800ae1c:	4293      	cmp	r3, r2
 800ae1e:	d013      	beq.n	800ae48 <HAL_TIM_Base_Start_IT+0x80>
 800ae20:	687b      	ldr	r3, [r7, #4]
 800ae22:	681b      	ldr	r3, [r3, #0]
 800ae24:	4a1f      	ldr	r2, [pc, #124]	@ (800aea4 <HAL_TIM_Base_Start_IT+0xdc>)
 800ae26:	4293      	cmp	r3, r2
 800ae28:	d00e      	beq.n	800ae48 <HAL_TIM_Base_Start_IT+0x80>
 800ae2a:	687b      	ldr	r3, [r7, #4]
 800ae2c:	681b      	ldr	r3, [r3, #0]
 800ae2e:	4a1e      	ldr	r2, [pc, #120]	@ (800aea8 <HAL_TIM_Base_Start_IT+0xe0>)
 800ae30:	4293      	cmp	r3, r2
 800ae32:	d009      	beq.n	800ae48 <HAL_TIM_Base_Start_IT+0x80>
 800ae34:	687b      	ldr	r3, [r7, #4]
 800ae36:	681b      	ldr	r3, [r3, #0]
 800ae38:	4a1c      	ldr	r2, [pc, #112]	@ (800aeac <HAL_TIM_Base_Start_IT+0xe4>)
 800ae3a:	4293      	cmp	r3, r2
 800ae3c:	d004      	beq.n	800ae48 <HAL_TIM_Base_Start_IT+0x80>
 800ae3e:	687b      	ldr	r3, [r7, #4]
 800ae40:	681b      	ldr	r3, [r3, #0]
 800ae42:	4a1b      	ldr	r2, [pc, #108]	@ (800aeb0 <HAL_TIM_Base_Start_IT+0xe8>)
 800ae44:	4293      	cmp	r3, r2
 800ae46:	d115      	bne.n	800ae74 <HAL_TIM_Base_Start_IT+0xac>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800ae48:	687b      	ldr	r3, [r7, #4]
 800ae4a:	681b      	ldr	r3, [r3, #0]
 800ae4c:	689a      	ldr	r2, [r3, #8]
 800ae4e:	4b19      	ldr	r3, [pc, #100]	@ (800aeb4 <HAL_TIM_Base_Start_IT+0xec>)
 800ae50:	4013      	ands	r3, r2
 800ae52:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800ae54:	68fb      	ldr	r3, [r7, #12]
 800ae56:	2b06      	cmp	r3, #6
 800ae58:	d015      	beq.n	800ae86 <HAL_TIM_Base_Start_IT+0xbe>
 800ae5a:	68fb      	ldr	r3, [r7, #12]
 800ae5c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800ae60:	d011      	beq.n	800ae86 <HAL_TIM_Base_Start_IT+0xbe>
    {
      __HAL_TIM_ENABLE(htim);
 800ae62:	687b      	ldr	r3, [r7, #4]
 800ae64:	681b      	ldr	r3, [r3, #0]
 800ae66:	681a      	ldr	r2, [r3, #0]
 800ae68:	687b      	ldr	r3, [r7, #4]
 800ae6a:	681b      	ldr	r3, [r3, #0]
 800ae6c:	f042 0201 	orr.w	r2, r2, #1
 800ae70:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800ae72:	e008      	b.n	800ae86 <HAL_TIM_Base_Start_IT+0xbe>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 800ae74:	687b      	ldr	r3, [r7, #4]
 800ae76:	681b      	ldr	r3, [r3, #0]
 800ae78:	681a      	ldr	r2, [r3, #0]
 800ae7a:	687b      	ldr	r3, [r7, #4]
 800ae7c:	681b      	ldr	r3, [r3, #0]
 800ae7e:	f042 0201 	orr.w	r2, r2, #1
 800ae82:	601a      	str	r2, [r3, #0]
 800ae84:	e000      	b.n	800ae88 <HAL_TIM_Base_Start_IT+0xc0>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800ae86:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
 800ae88:	2300      	movs	r3, #0
}
 800ae8a:	4618      	mov	r0, r3
 800ae8c:	3714      	adds	r7, #20
 800ae8e:	46bd      	mov	sp, r7
 800ae90:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ae94:	4770      	bx	lr
 800ae96:	bf00      	nop
 800ae98:	40010000 	.word	0x40010000
 800ae9c:	40000400 	.word	0x40000400
 800aea0:	40000800 	.word	0x40000800
 800aea4:	40000c00 	.word	0x40000c00
 800aea8:	40010400 	.word	0x40010400
 800aeac:	40001800 	.word	0x40001800
 800aeb0:	40014000 	.word	0x40014000
 800aeb4:	00010007 	.word	0x00010007

0800aeb8 <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 800aeb8:	b580      	push	{r7, lr}
 800aeba:	b084      	sub	sp, #16
 800aebc:	af00      	add	r7, sp, #0
 800aebe:	6078      	str	r0, [r7, #4]
  uint32_t itsource = htim->Instance->DIER;
 800aec0:	687b      	ldr	r3, [r7, #4]
 800aec2:	681b      	ldr	r3, [r3, #0]
 800aec4:	68db      	ldr	r3, [r3, #12]
 800aec6:	60fb      	str	r3, [r7, #12]
  uint32_t itflag   = htim->Instance->SR;
 800aec8:	687b      	ldr	r3, [r7, #4]
 800aeca:	681b      	ldr	r3, [r3, #0]
 800aecc:	691b      	ldr	r3, [r3, #16]
 800aece:	60bb      	str	r3, [r7, #8]

  /* Capture compare 1 event */
  if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
 800aed0:	68bb      	ldr	r3, [r7, #8]
 800aed2:	f003 0302 	and.w	r3, r3, #2
 800aed6:	2b00      	cmp	r3, #0
 800aed8:	d020      	beq.n	800af1c <HAL_TIM_IRQHandler+0x64>
  {
    if ((itsource & (TIM_IT_CC1)) == (TIM_IT_CC1))
 800aeda:	68fb      	ldr	r3, [r7, #12]
 800aedc:	f003 0302 	and.w	r3, r3, #2
 800aee0:	2b00      	cmp	r3, #0
 800aee2:	d01b      	beq.n	800af1c <HAL_TIM_IRQHandler+0x64>
    {
      {
        __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
 800aee4:	687b      	ldr	r3, [r7, #4]
 800aee6:	681b      	ldr	r3, [r3, #0]
 800aee8:	f06f 0202 	mvn.w	r2, #2
 800aeec:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 800aeee:	687b      	ldr	r3, [r7, #4]
 800aef0:	2201      	movs	r2, #1
 800aef2:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 800aef4:	687b      	ldr	r3, [r7, #4]
 800aef6:	681b      	ldr	r3, [r3, #0]
 800aef8:	699b      	ldr	r3, [r3, #24]
 800aefa:	f003 0303 	and.w	r3, r3, #3
 800aefe:	2b00      	cmp	r3, #0
 800af00:	d003      	beq.n	800af0a <HAL_TIM_IRQHandler+0x52>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 800af02:	6878      	ldr	r0, [r7, #4]
 800af04:	f000 f9e2 	bl	800b2cc <HAL_TIM_IC_CaptureCallback>
 800af08:	e005      	b.n	800af16 <HAL_TIM_IRQHandler+0x5e>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800af0a:	6878      	ldr	r0, [r7, #4]
 800af0c:	f000 f9d4 	bl	800b2b8 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 800af10:	6878      	ldr	r0, [r7, #4]
 800af12:	f000 f9e5 	bl	800b2e0 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800af16:	687b      	ldr	r3, [r7, #4]
 800af18:	2200      	movs	r2, #0
 800af1a:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if ((itflag & (TIM_FLAG_CC2)) == (TIM_FLAG_CC2))
 800af1c:	68bb      	ldr	r3, [r7, #8]
 800af1e:	f003 0304 	and.w	r3, r3, #4
 800af22:	2b00      	cmp	r3, #0
 800af24:	d020      	beq.n	800af68 <HAL_TIM_IRQHandler+0xb0>
  {
    if ((itsource & (TIM_IT_CC2)) == (TIM_IT_CC2))
 800af26:	68fb      	ldr	r3, [r7, #12]
 800af28:	f003 0304 	and.w	r3, r3, #4
 800af2c:	2b00      	cmp	r3, #0
 800af2e:	d01b      	beq.n	800af68 <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
 800af30:	687b      	ldr	r3, [r7, #4]
 800af32:	681b      	ldr	r3, [r3, #0]
 800af34:	f06f 0204 	mvn.w	r2, #4
 800af38:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 800af3a:	687b      	ldr	r3, [r7, #4]
 800af3c:	2202      	movs	r2, #2
 800af3e:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 800af40:	687b      	ldr	r3, [r7, #4]
 800af42:	681b      	ldr	r3, [r3, #0]
 800af44:	699b      	ldr	r3, [r3, #24]
 800af46:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 800af4a:	2b00      	cmp	r3, #0
 800af4c:	d003      	beq.n	800af56 <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800af4e:	6878      	ldr	r0, [r7, #4]
 800af50:	f000 f9bc 	bl	800b2cc <HAL_TIM_IC_CaptureCallback>
 800af54:	e005      	b.n	800af62 <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800af56:	6878      	ldr	r0, [r7, #4]
 800af58:	f000 f9ae 	bl	800b2b8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800af5c:	6878      	ldr	r0, [r7, #4]
 800af5e:	f000 f9bf 	bl	800b2e0 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800af62:	687b      	ldr	r3, [r7, #4]
 800af64:	2200      	movs	r2, #0
 800af66:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if ((itflag & (TIM_FLAG_CC3)) == (TIM_FLAG_CC3))
 800af68:	68bb      	ldr	r3, [r7, #8]
 800af6a:	f003 0308 	and.w	r3, r3, #8
 800af6e:	2b00      	cmp	r3, #0
 800af70:	d020      	beq.n	800afb4 <HAL_TIM_IRQHandler+0xfc>
  {
    if ((itsource & (TIM_IT_CC3)) == (TIM_IT_CC3))
 800af72:	68fb      	ldr	r3, [r7, #12]
 800af74:	f003 0308 	and.w	r3, r3, #8
 800af78:	2b00      	cmp	r3, #0
 800af7a:	d01b      	beq.n	800afb4 <HAL_TIM_IRQHandler+0xfc>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
 800af7c:	687b      	ldr	r3, [r7, #4]
 800af7e:	681b      	ldr	r3, [r3, #0]
 800af80:	f06f 0208 	mvn.w	r2, #8
 800af84:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 800af86:	687b      	ldr	r3, [r7, #4]
 800af88:	2204      	movs	r2, #4
 800af8a:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 800af8c:	687b      	ldr	r3, [r7, #4]
 800af8e:	681b      	ldr	r3, [r3, #0]
 800af90:	69db      	ldr	r3, [r3, #28]
 800af92:	f003 0303 	and.w	r3, r3, #3
 800af96:	2b00      	cmp	r3, #0
 800af98:	d003      	beq.n	800afa2 <HAL_TIM_IRQHandler+0xea>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800af9a:	6878      	ldr	r0, [r7, #4]
 800af9c:	f000 f996 	bl	800b2cc <HAL_TIM_IC_CaptureCallback>
 800afa0:	e005      	b.n	800afae <HAL_TIM_IRQHandler+0xf6>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800afa2:	6878      	ldr	r0, [r7, #4]
 800afa4:	f000 f988 	bl	800b2b8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800afa8:	6878      	ldr	r0, [r7, #4]
 800afaa:	f000 f999 	bl	800b2e0 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800afae:	687b      	ldr	r3, [r7, #4]
 800afb0:	2200      	movs	r2, #0
 800afb2:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if ((itflag & (TIM_FLAG_CC4)) == (TIM_FLAG_CC4))
 800afb4:	68bb      	ldr	r3, [r7, #8]
 800afb6:	f003 0310 	and.w	r3, r3, #16
 800afba:	2b00      	cmp	r3, #0
 800afbc:	d020      	beq.n	800b000 <HAL_TIM_IRQHandler+0x148>
  {
    if ((itsource & (TIM_IT_CC4)) == (TIM_IT_CC4))
 800afbe:	68fb      	ldr	r3, [r7, #12]
 800afc0:	f003 0310 	and.w	r3, r3, #16
 800afc4:	2b00      	cmp	r3, #0
 800afc6:	d01b      	beq.n	800b000 <HAL_TIM_IRQHandler+0x148>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
 800afc8:	687b      	ldr	r3, [r7, #4]
 800afca:	681b      	ldr	r3, [r3, #0]
 800afcc:	f06f 0210 	mvn.w	r2, #16
 800afd0:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800afd2:	687b      	ldr	r3, [r7, #4]
 800afd4:	2208      	movs	r2, #8
 800afd6:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 800afd8:	687b      	ldr	r3, [r7, #4]
 800afda:	681b      	ldr	r3, [r3, #0]
 800afdc:	69db      	ldr	r3, [r3, #28]
 800afde:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 800afe2:	2b00      	cmp	r3, #0
 800afe4:	d003      	beq.n	800afee <HAL_TIM_IRQHandler+0x136>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 800afe6:	6878      	ldr	r0, [r7, #4]
 800afe8:	f000 f970 	bl	800b2cc <HAL_TIM_IC_CaptureCallback>
 800afec:	e005      	b.n	800affa <HAL_TIM_IRQHandler+0x142>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800afee:	6878      	ldr	r0, [r7, #4]
 800aff0:	f000 f962 	bl	800b2b8 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800aff4:	6878      	ldr	r0, [r7, #4]
 800aff6:	f000 f973 	bl	800b2e0 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800affa:	687b      	ldr	r3, [r7, #4]
 800affc:	2200      	movs	r2, #0
 800affe:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if ((itflag & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
 800b000:	68bb      	ldr	r3, [r7, #8]
 800b002:	f003 0301 	and.w	r3, r3, #1
 800b006:	2b00      	cmp	r3, #0
 800b008:	d00c      	beq.n	800b024 <HAL_TIM_IRQHandler+0x16c>
  {
    if ((itsource & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE))
 800b00a:	68fb      	ldr	r3, [r7, #12]
 800b00c:	f003 0301 	and.w	r3, r3, #1
 800b010:	2b00      	cmp	r3, #0
 800b012:	d007      	beq.n	800b024 <HAL_TIM_IRQHandler+0x16c>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
 800b014:	687b      	ldr	r3, [r7, #4]
 800b016:	681b      	ldr	r3, [r3, #0]
 800b018:	f06f 0201 	mvn.w	r2, #1
 800b01c:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 800b01e:	6878      	ldr	r0, [r7, #4]
 800b020:	f7f6 f9c8 	bl	80013b4 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 800b024:	68bb      	ldr	r3, [r7, #8]
 800b026:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800b02a:	2b00      	cmp	r3, #0
 800b02c:	d104      	bne.n	800b038 <HAL_TIM_IRQHandler+0x180>
      ((itflag & (TIM_FLAG_SYSTEM_BREAK)) == (TIM_FLAG_SYSTEM_BREAK)))
 800b02e:	68bb      	ldr	r3, [r7, #8]
 800b030:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 800b034:	2b00      	cmp	r3, #0
 800b036:	d00c      	beq.n	800b052 <HAL_TIM_IRQHandler+0x19a>
  {
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 800b038:	68fb      	ldr	r3, [r7, #12]
 800b03a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800b03e:	2b00      	cmp	r3, #0
 800b040:	d007      	beq.n	800b052 <HAL_TIM_IRQHandler+0x19a>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK | TIM_FLAG_SYSTEM_BREAK);
 800b042:	687b      	ldr	r3, [r7, #4]
 800b044:	681b      	ldr	r3, [r3, #0]
 800b046:	f46f 5202 	mvn.w	r2, #8320	@ 0x2080
 800b04a:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 800b04c:	6878      	ldr	r0, [r7, #4]
 800b04e:	f000 fb31 	bl	800b6b4 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
 800b052:	68bb      	ldr	r3, [r7, #8]
 800b054:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 800b058:	2b00      	cmp	r3, #0
 800b05a:	d00c      	beq.n	800b076 <HAL_TIM_IRQHandler+0x1be>
  {
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 800b05c:	68fb      	ldr	r3, [r7, #12]
 800b05e:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800b062:	2b00      	cmp	r3, #0
 800b064:	d007      	beq.n	800b076 <HAL_TIM_IRQHandler+0x1be>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 800b066:	687b      	ldr	r3, [r7, #4]
 800b068:	681b      	ldr	r3, [r3, #0]
 800b06a:	f46f 7280 	mvn.w	r2, #256	@ 0x100
 800b06e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
 800b070:	6878      	ldr	r0, [r7, #4]
 800b072:	f000 fb29 	bl	800b6c8 <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if ((itflag & (TIM_FLAG_TRIGGER)) == (TIM_FLAG_TRIGGER))
 800b076:	68bb      	ldr	r3, [r7, #8]
 800b078:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800b07c:	2b00      	cmp	r3, #0
 800b07e:	d00c      	beq.n	800b09a <HAL_TIM_IRQHandler+0x1e2>
  {
    if ((itsource & (TIM_IT_TRIGGER)) == (TIM_IT_TRIGGER))
 800b080:	68fb      	ldr	r3, [r7, #12]
 800b082:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800b086:	2b00      	cmp	r3, #0
 800b088:	d007      	beq.n	800b09a <HAL_TIM_IRQHandler+0x1e2>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
 800b08a:	687b      	ldr	r3, [r7, #4]
 800b08c:	681b      	ldr	r3, [r3, #0]
 800b08e:	f06f 0240 	mvn.w	r2, #64	@ 0x40
 800b092:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 800b094:	6878      	ldr	r0, [r7, #4]
 800b096:	f000 f92d 	bl	800b2f4 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if ((itflag & (TIM_FLAG_COM)) == (TIM_FLAG_COM))
 800b09a:	68bb      	ldr	r3, [r7, #8]
 800b09c:	f003 0320 	and.w	r3, r3, #32
 800b0a0:	2b00      	cmp	r3, #0
 800b0a2:	d00c      	beq.n	800b0be <HAL_TIM_IRQHandler+0x206>
  {
    if ((itsource & (TIM_IT_COM)) == (TIM_IT_COM))
 800b0a4:	68fb      	ldr	r3, [r7, #12]
 800b0a6:	f003 0320 	and.w	r3, r3, #32
 800b0aa:	2b00      	cmp	r3, #0
 800b0ac:	d007      	beq.n	800b0be <HAL_TIM_IRQHandler+0x206>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 800b0ae:	687b      	ldr	r3, [r7, #4]
 800b0b0:	681b      	ldr	r3, [r3, #0]
 800b0b2:	f06f 0220 	mvn.w	r2, #32
 800b0b6:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 800b0b8:	6878      	ldr	r0, [r7, #4]
 800b0ba:	f000 faf1 	bl	800b6a0 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 800b0be:	bf00      	nop
 800b0c0:	3710      	adds	r7, #16
 800b0c2:	46bd      	mov	sp, r7
 800b0c4:	bd80      	pop	{r7, pc}
	...

0800b0c8 <HAL_TIM_ConfigClockSource>:
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, const TIM_ClockConfigTypeDef *sClockSourceConfig)
{
 800b0c8:	b580      	push	{r7, lr}
 800b0ca:	b084      	sub	sp, #16
 800b0cc:	af00      	add	r7, sp, #0
 800b0ce:	6078      	str	r0, [r7, #4]
 800b0d0:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 800b0d2:	2300      	movs	r3, #0
 800b0d4:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpsmcr;

  /* Process Locked */
  __HAL_LOCK(htim);
 800b0d6:	687b      	ldr	r3, [r7, #4]
 800b0d8:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 800b0dc:	2b01      	cmp	r3, #1
 800b0de:	d101      	bne.n	800b0e4 <HAL_TIM_ConfigClockSource+0x1c>
 800b0e0:	2302      	movs	r3, #2
 800b0e2:	e0dc      	b.n	800b29e <HAL_TIM_ConfigClockSource+0x1d6>
 800b0e4:	687b      	ldr	r3, [r7, #4]
 800b0e6:	2201      	movs	r2, #1
 800b0e8:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 800b0ec:	687b      	ldr	r3, [r7, #4]
 800b0ee:	2202      	movs	r2, #2
 800b0f0:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 800b0f4:	687b      	ldr	r3, [r7, #4]
 800b0f6:	681b      	ldr	r3, [r3, #0]
 800b0f8:	689b      	ldr	r3, [r3, #8]
 800b0fa:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 800b0fc:	68ba      	ldr	r2, [r7, #8]
 800b0fe:	4b6a      	ldr	r3, [pc, #424]	@ (800b2a8 <HAL_TIM_ConfigClockSource+0x1e0>)
 800b100:	4013      	ands	r3, r2
 800b102:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800b104:	68bb      	ldr	r3, [r7, #8]
 800b106:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 800b10a:	60bb      	str	r3, [r7, #8]
  htim->Instance->SMCR = tmpsmcr;
 800b10c:	687b      	ldr	r3, [r7, #4]
 800b10e:	681b      	ldr	r3, [r3, #0]
 800b110:	68ba      	ldr	r2, [r7, #8]
 800b112:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
 800b114:	683b      	ldr	r3, [r7, #0]
 800b116:	681b      	ldr	r3, [r3, #0]
 800b118:	4a64      	ldr	r2, [pc, #400]	@ (800b2ac <HAL_TIM_ConfigClockSource+0x1e4>)
 800b11a:	4293      	cmp	r3, r2
 800b11c:	f000 80a9 	beq.w	800b272 <HAL_TIM_ConfigClockSource+0x1aa>
 800b120:	4a62      	ldr	r2, [pc, #392]	@ (800b2ac <HAL_TIM_ConfigClockSource+0x1e4>)
 800b122:	4293      	cmp	r3, r2
 800b124:	f200 80ae 	bhi.w	800b284 <HAL_TIM_ConfigClockSource+0x1bc>
 800b128:	4a61      	ldr	r2, [pc, #388]	@ (800b2b0 <HAL_TIM_ConfigClockSource+0x1e8>)
 800b12a:	4293      	cmp	r3, r2
 800b12c:	f000 80a1 	beq.w	800b272 <HAL_TIM_ConfigClockSource+0x1aa>
 800b130:	4a5f      	ldr	r2, [pc, #380]	@ (800b2b0 <HAL_TIM_ConfigClockSource+0x1e8>)
 800b132:	4293      	cmp	r3, r2
 800b134:	f200 80a6 	bhi.w	800b284 <HAL_TIM_ConfigClockSource+0x1bc>
 800b138:	4a5e      	ldr	r2, [pc, #376]	@ (800b2b4 <HAL_TIM_ConfigClockSource+0x1ec>)
 800b13a:	4293      	cmp	r3, r2
 800b13c:	f000 8099 	beq.w	800b272 <HAL_TIM_ConfigClockSource+0x1aa>
 800b140:	4a5c      	ldr	r2, [pc, #368]	@ (800b2b4 <HAL_TIM_ConfigClockSource+0x1ec>)
 800b142:	4293      	cmp	r3, r2
 800b144:	f200 809e 	bhi.w	800b284 <HAL_TIM_ConfigClockSource+0x1bc>
 800b148:	f1b3 1f10 	cmp.w	r3, #1048592	@ 0x100010
 800b14c:	f000 8091 	beq.w	800b272 <HAL_TIM_ConfigClockSource+0x1aa>
 800b150:	f1b3 1f10 	cmp.w	r3, #1048592	@ 0x100010
 800b154:	f200 8096 	bhi.w	800b284 <HAL_TIM_ConfigClockSource+0x1bc>
 800b158:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 800b15c:	f000 8089 	beq.w	800b272 <HAL_TIM_ConfigClockSource+0x1aa>
 800b160:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 800b164:	f200 808e 	bhi.w	800b284 <HAL_TIM_ConfigClockSource+0x1bc>
 800b168:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800b16c:	d03e      	beq.n	800b1ec <HAL_TIM_ConfigClockSource+0x124>
 800b16e:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 800b172:	f200 8087 	bhi.w	800b284 <HAL_TIM_ConfigClockSource+0x1bc>
 800b176:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800b17a:	f000 8086 	beq.w	800b28a <HAL_TIM_ConfigClockSource+0x1c2>
 800b17e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800b182:	d87f      	bhi.n	800b284 <HAL_TIM_ConfigClockSource+0x1bc>
 800b184:	2b70      	cmp	r3, #112	@ 0x70
 800b186:	d01a      	beq.n	800b1be <HAL_TIM_ConfigClockSource+0xf6>
 800b188:	2b70      	cmp	r3, #112	@ 0x70
 800b18a:	d87b      	bhi.n	800b284 <HAL_TIM_ConfigClockSource+0x1bc>
 800b18c:	2b60      	cmp	r3, #96	@ 0x60
 800b18e:	d050      	beq.n	800b232 <HAL_TIM_ConfigClockSource+0x16a>
 800b190:	2b60      	cmp	r3, #96	@ 0x60
 800b192:	d877      	bhi.n	800b284 <HAL_TIM_ConfigClockSource+0x1bc>
 800b194:	2b50      	cmp	r3, #80	@ 0x50
 800b196:	d03c      	beq.n	800b212 <HAL_TIM_ConfigClockSource+0x14a>
 800b198:	2b50      	cmp	r3, #80	@ 0x50
 800b19a:	d873      	bhi.n	800b284 <HAL_TIM_ConfigClockSource+0x1bc>
 800b19c:	2b40      	cmp	r3, #64	@ 0x40
 800b19e:	d058      	beq.n	800b252 <HAL_TIM_ConfigClockSource+0x18a>
 800b1a0:	2b40      	cmp	r3, #64	@ 0x40
 800b1a2:	d86f      	bhi.n	800b284 <HAL_TIM_ConfigClockSource+0x1bc>
 800b1a4:	2b30      	cmp	r3, #48	@ 0x30
 800b1a6:	d064      	beq.n	800b272 <HAL_TIM_ConfigClockSource+0x1aa>
 800b1a8:	2b30      	cmp	r3, #48	@ 0x30
 800b1aa:	d86b      	bhi.n	800b284 <HAL_TIM_ConfigClockSource+0x1bc>
 800b1ac:	2b20      	cmp	r3, #32
 800b1ae:	d060      	beq.n	800b272 <HAL_TIM_ConfigClockSource+0x1aa>
 800b1b0:	2b20      	cmp	r3, #32
 800b1b2:	d867      	bhi.n	800b284 <HAL_TIM_ConfigClockSource+0x1bc>
 800b1b4:	2b00      	cmp	r3, #0
 800b1b6:	d05c      	beq.n	800b272 <HAL_TIM_ConfigClockSource+0x1aa>
 800b1b8:	2b10      	cmp	r3, #16
 800b1ba:	d05a      	beq.n	800b272 <HAL_TIM_ConfigClockSource+0x1aa>
 800b1bc:	e062      	b.n	800b284 <HAL_TIM_ConfigClockSource+0x1bc>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 800b1be:	687b      	ldr	r3, [r7, #4]
 800b1c0:	6818      	ldr	r0, [r3, #0]
                        sClockSourceConfig->ClockPrescaler,
 800b1c2:	683b      	ldr	r3, [r7, #0]
 800b1c4:	6899      	ldr	r1, [r3, #8]
                        sClockSourceConfig->ClockPolarity,
 800b1c6:	683b      	ldr	r3, [r7, #0]
 800b1c8:	685a      	ldr	r2, [r3, #4]
                        sClockSourceConfig->ClockFilter);
 800b1ca:	683b      	ldr	r3, [r7, #0]
 800b1cc:	68db      	ldr	r3, [r3, #12]
      TIM_ETR_SetConfig(htim->Instance,
 800b1ce:	f000 f9b9 	bl	800b544 <TIM_ETR_SetConfig>

      /* Select the External clock mode1 and the ETRF trigger */
      tmpsmcr = htim->Instance->SMCR;
 800b1d2:	687b      	ldr	r3, [r7, #4]
 800b1d4:	681b      	ldr	r3, [r3, #0]
 800b1d6:	689b      	ldr	r3, [r3, #8]
 800b1d8:	60bb      	str	r3, [r7, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 800b1da:	68bb      	ldr	r3, [r7, #8]
 800b1dc:	f043 0377 	orr.w	r3, r3, #119	@ 0x77
 800b1e0:	60bb      	str	r3, [r7, #8]
      /* Write to TIMx SMCR */
      htim->Instance->SMCR = tmpsmcr;
 800b1e2:	687b      	ldr	r3, [r7, #4]
 800b1e4:	681b      	ldr	r3, [r3, #0]
 800b1e6:	68ba      	ldr	r2, [r7, #8]
 800b1e8:	609a      	str	r2, [r3, #8]
      break;
 800b1ea:	e04f      	b.n	800b28c <HAL_TIM_ConfigClockSource+0x1c4>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 800b1ec:	687b      	ldr	r3, [r7, #4]
 800b1ee:	6818      	ldr	r0, [r3, #0]
                        sClockSourceConfig->ClockPrescaler,
 800b1f0:	683b      	ldr	r3, [r7, #0]
 800b1f2:	6899      	ldr	r1, [r3, #8]
                        sClockSourceConfig->ClockPolarity,
 800b1f4:	683b      	ldr	r3, [r7, #0]
 800b1f6:	685a      	ldr	r2, [r3, #4]
                        sClockSourceConfig->ClockFilter);
 800b1f8:	683b      	ldr	r3, [r7, #0]
 800b1fa:	68db      	ldr	r3, [r3, #12]
      TIM_ETR_SetConfig(htim->Instance,
 800b1fc:	f000 f9a2 	bl	800b544 <TIM_ETR_SetConfig>
      /* Enable the External clock mode2 */
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 800b200:	687b      	ldr	r3, [r7, #4]
 800b202:	681b      	ldr	r3, [r3, #0]
 800b204:	689a      	ldr	r2, [r3, #8]
 800b206:	687b      	ldr	r3, [r7, #4]
 800b208:	681b      	ldr	r3, [r3, #0]
 800b20a:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 800b20e:	609a      	str	r2, [r3, #8]
      break;
 800b210:	e03c      	b.n	800b28c <HAL_TIM_ConfigClockSource+0x1c4>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 800b212:	687b      	ldr	r3, [r7, #4]
 800b214:	6818      	ldr	r0, [r3, #0]
                               sClockSourceConfig->ClockPolarity,
 800b216:	683b      	ldr	r3, [r7, #0]
 800b218:	6859      	ldr	r1, [r3, #4]
                               sClockSourceConfig->ClockFilter);
 800b21a:	683b      	ldr	r3, [r7, #0]
 800b21c:	68db      	ldr	r3, [r3, #12]
      TIM_TI1_ConfigInputStage(htim->Instance,
 800b21e:	461a      	mov	r2, r3
 800b220:	f000 f912 	bl	800b448 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 800b224:	687b      	ldr	r3, [r7, #4]
 800b226:	681b      	ldr	r3, [r3, #0]
 800b228:	2150      	movs	r1, #80	@ 0x50
 800b22a:	4618      	mov	r0, r3
 800b22c:	f000 f96c 	bl	800b508 <TIM_ITRx_SetConfig>
      break;
 800b230:	e02c      	b.n	800b28c <HAL_TIM_ConfigClockSource+0x1c4>

      /* Check TI2 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI2_ConfigInputStage(htim->Instance,
 800b232:	687b      	ldr	r3, [r7, #4]
 800b234:	6818      	ldr	r0, [r3, #0]
                               sClockSourceConfig->ClockPolarity,
 800b236:	683b      	ldr	r3, [r7, #0]
 800b238:	6859      	ldr	r1, [r3, #4]
                               sClockSourceConfig->ClockFilter);
 800b23a:	683b      	ldr	r3, [r7, #0]
 800b23c:	68db      	ldr	r3, [r3, #12]
      TIM_TI2_ConfigInputStage(htim->Instance,
 800b23e:	461a      	mov	r2, r3
 800b240:	f000 f931 	bl	800b4a6 <TIM_TI2_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 800b244:	687b      	ldr	r3, [r7, #4]
 800b246:	681b      	ldr	r3, [r3, #0]
 800b248:	2160      	movs	r1, #96	@ 0x60
 800b24a:	4618      	mov	r0, r3
 800b24c:	f000 f95c 	bl	800b508 <TIM_ITRx_SetConfig>
      break;
 800b250:	e01c      	b.n	800b28c <HAL_TIM_ConfigClockSource+0x1c4>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 800b252:	687b      	ldr	r3, [r7, #4]
 800b254:	6818      	ldr	r0, [r3, #0]
                               sClockSourceConfig->ClockPolarity,
 800b256:	683b      	ldr	r3, [r7, #0]
 800b258:	6859      	ldr	r1, [r3, #4]
                               sClockSourceConfig->ClockFilter);
 800b25a:	683b      	ldr	r3, [r7, #0]
 800b25c:	68db      	ldr	r3, [r3, #12]
      TIM_TI1_ConfigInputStage(htim->Instance,
 800b25e:	461a      	mov	r2, r3
 800b260:	f000 f8f2 	bl	800b448 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 800b264:	687b      	ldr	r3, [r7, #4]
 800b266:	681b      	ldr	r3, [r3, #0]
 800b268:	2140      	movs	r1, #64	@ 0x40
 800b26a:	4618      	mov	r0, r3
 800b26c:	f000 f94c 	bl	800b508 <TIM_ITRx_SetConfig>
      break;
 800b270:	e00c      	b.n	800b28c <HAL_TIM_ConfigClockSource+0x1c4>
    case TIM_CLOCKSOURCE_ITR8:
    {
      /* Check whether or not the timer instance supports internal trigger input */
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));

      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 800b272:	687b      	ldr	r3, [r7, #4]
 800b274:	681a      	ldr	r2, [r3, #0]
 800b276:	683b      	ldr	r3, [r7, #0]
 800b278:	681b      	ldr	r3, [r3, #0]
 800b27a:	4619      	mov	r1, r3
 800b27c:	4610      	mov	r0, r2
 800b27e:	f000 f943 	bl	800b508 <TIM_ITRx_SetConfig>
      break;
 800b282:	e003      	b.n	800b28c <HAL_TIM_ConfigClockSource+0x1c4>
    }

    default:
      status = HAL_ERROR;
 800b284:	2301      	movs	r3, #1
 800b286:	73fb      	strb	r3, [r7, #15]
      break;
 800b288:	e000      	b.n	800b28c <HAL_TIM_ConfigClockSource+0x1c4>
      break;
 800b28a:	bf00      	nop
  }
  htim->State = HAL_TIM_STATE_READY;
 800b28c:	687b      	ldr	r3, [r7, #4]
 800b28e:	2201      	movs	r2, #1
 800b290:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  __HAL_UNLOCK(htim);
 800b294:	687b      	ldr	r3, [r7, #4]
 800b296:	2200      	movs	r2, #0
 800b298:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  return status;
 800b29c:	7bfb      	ldrb	r3, [r7, #15]
}
 800b29e:	4618      	mov	r0, r3
 800b2a0:	3710      	adds	r7, #16
 800b2a2:	46bd      	mov	sp, r7
 800b2a4:	bd80      	pop	{r7, pc}
 800b2a6:	bf00      	nop
 800b2a8:	ffceff88 	.word	0xffceff88
 800b2ac:	00100040 	.word	0x00100040
 800b2b0:	00100030 	.word	0x00100030
 800b2b4:	00100020 	.word	0x00100020

0800b2b8 <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 800b2b8:	b480      	push	{r7}
 800b2ba:	b083      	sub	sp, #12
 800b2bc:	af00      	add	r7, sp, #0
 800b2be:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 800b2c0:	bf00      	nop
 800b2c2:	370c      	adds	r7, #12
 800b2c4:	46bd      	mov	sp, r7
 800b2c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b2ca:	4770      	bx	lr

0800b2cc <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 800b2cc:	b480      	push	{r7}
 800b2ce:	b083      	sub	sp, #12
 800b2d0:	af00      	add	r7, sp, #0
 800b2d2:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 800b2d4:	bf00      	nop
 800b2d6:	370c      	adds	r7, #12
 800b2d8:	46bd      	mov	sp, r7
 800b2da:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b2de:	4770      	bx	lr

0800b2e0 <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 800b2e0:	b480      	push	{r7}
 800b2e2:	b083      	sub	sp, #12
 800b2e4:	af00      	add	r7, sp, #0
 800b2e6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 800b2e8:	bf00      	nop
 800b2ea:	370c      	adds	r7, #12
 800b2ec:	46bd      	mov	sp, r7
 800b2ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b2f2:	4770      	bx	lr

0800b2f4 <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 800b2f4:	b480      	push	{r7}
 800b2f6:	b083      	sub	sp, #12
 800b2f8:	af00      	add	r7, sp, #0
 800b2fa:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 800b2fc:	bf00      	nop
 800b2fe:	370c      	adds	r7, #12
 800b300:	46bd      	mov	sp, r7
 800b302:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b306:	4770      	bx	lr

0800b308 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, const TIM_Base_InitTypeDef *Structure)
{
 800b308:	b480      	push	{r7}
 800b30a:	b085      	sub	sp, #20
 800b30c:	af00      	add	r7, sp, #0
 800b30e:	6078      	str	r0, [r7, #4]
 800b310:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 800b312:	687b      	ldr	r3, [r7, #4]
 800b314:	681b      	ldr	r3, [r3, #0]
 800b316:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800b318:	687b      	ldr	r3, [r7, #4]
 800b31a:	4a43      	ldr	r2, [pc, #268]	@ (800b428 <TIM_Base_SetConfig+0x120>)
 800b31c:	4293      	cmp	r3, r2
 800b31e:	d013      	beq.n	800b348 <TIM_Base_SetConfig+0x40>
 800b320:	687b      	ldr	r3, [r7, #4]
 800b322:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800b326:	d00f      	beq.n	800b348 <TIM_Base_SetConfig+0x40>
 800b328:	687b      	ldr	r3, [r7, #4]
 800b32a:	4a40      	ldr	r2, [pc, #256]	@ (800b42c <TIM_Base_SetConfig+0x124>)
 800b32c:	4293      	cmp	r3, r2
 800b32e:	d00b      	beq.n	800b348 <TIM_Base_SetConfig+0x40>
 800b330:	687b      	ldr	r3, [r7, #4]
 800b332:	4a3f      	ldr	r2, [pc, #252]	@ (800b430 <TIM_Base_SetConfig+0x128>)
 800b334:	4293      	cmp	r3, r2
 800b336:	d007      	beq.n	800b348 <TIM_Base_SetConfig+0x40>
 800b338:	687b      	ldr	r3, [r7, #4]
 800b33a:	4a3e      	ldr	r2, [pc, #248]	@ (800b434 <TIM_Base_SetConfig+0x12c>)
 800b33c:	4293      	cmp	r3, r2
 800b33e:	d003      	beq.n	800b348 <TIM_Base_SetConfig+0x40>
 800b340:	687b      	ldr	r3, [r7, #4]
 800b342:	4a3d      	ldr	r2, [pc, #244]	@ (800b438 <TIM_Base_SetConfig+0x130>)
 800b344:	4293      	cmp	r3, r2
 800b346:	d108      	bne.n	800b35a <TIM_Base_SetConfig+0x52>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800b348:	68fb      	ldr	r3, [r7, #12]
 800b34a:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 800b34e:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 800b350:	683b      	ldr	r3, [r7, #0]
 800b352:	685b      	ldr	r3, [r3, #4]
 800b354:	68fa      	ldr	r2, [r7, #12]
 800b356:	4313      	orrs	r3, r2
 800b358:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800b35a:	687b      	ldr	r3, [r7, #4]
 800b35c:	4a32      	ldr	r2, [pc, #200]	@ (800b428 <TIM_Base_SetConfig+0x120>)
 800b35e:	4293      	cmp	r3, r2
 800b360:	d01f      	beq.n	800b3a2 <TIM_Base_SetConfig+0x9a>
 800b362:	687b      	ldr	r3, [r7, #4]
 800b364:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800b368:	d01b      	beq.n	800b3a2 <TIM_Base_SetConfig+0x9a>
 800b36a:	687b      	ldr	r3, [r7, #4]
 800b36c:	4a2f      	ldr	r2, [pc, #188]	@ (800b42c <TIM_Base_SetConfig+0x124>)
 800b36e:	4293      	cmp	r3, r2
 800b370:	d017      	beq.n	800b3a2 <TIM_Base_SetConfig+0x9a>
 800b372:	687b      	ldr	r3, [r7, #4]
 800b374:	4a2e      	ldr	r2, [pc, #184]	@ (800b430 <TIM_Base_SetConfig+0x128>)
 800b376:	4293      	cmp	r3, r2
 800b378:	d013      	beq.n	800b3a2 <TIM_Base_SetConfig+0x9a>
 800b37a:	687b      	ldr	r3, [r7, #4]
 800b37c:	4a2d      	ldr	r2, [pc, #180]	@ (800b434 <TIM_Base_SetConfig+0x12c>)
 800b37e:	4293      	cmp	r3, r2
 800b380:	d00f      	beq.n	800b3a2 <TIM_Base_SetConfig+0x9a>
 800b382:	687b      	ldr	r3, [r7, #4]
 800b384:	4a2c      	ldr	r2, [pc, #176]	@ (800b438 <TIM_Base_SetConfig+0x130>)
 800b386:	4293      	cmp	r3, r2
 800b388:	d00b      	beq.n	800b3a2 <TIM_Base_SetConfig+0x9a>
 800b38a:	687b      	ldr	r3, [r7, #4]
 800b38c:	4a2b      	ldr	r2, [pc, #172]	@ (800b43c <TIM_Base_SetConfig+0x134>)
 800b38e:	4293      	cmp	r3, r2
 800b390:	d007      	beq.n	800b3a2 <TIM_Base_SetConfig+0x9a>
 800b392:	687b      	ldr	r3, [r7, #4]
 800b394:	4a2a      	ldr	r2, [pc, #168]	@ (800b440 <TIM_Base_SetConfig+0x138>)
 800b396:	4293      	cmp	r3, r2
 800b398:	d003      	beq.n	800b3a2 <TIM_Base_SetConfig+0x9a>
 800b39a:	687b      	ldr	r3, [r7, #4]
 800b39c:	4a29      	ldr	r2, [pc, #164]	@ (800b444 <TIM_Base_SetConfig+0x13c>)
 800b39e:	4293      	cmp	r3, r2
 800b3a0:	d108      	bne.n	800b3b4 <TIM_Base_SetConfig+0xac>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 800b3a2:	68fb      	ldr	r3, [r7, #12]
 800b3a4:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 800b3a8:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800b3aa:	683b      	ldr	r3, [r7, #0]
 800b3ac:	68db      	ldr	r3, [r3, #12]
 800b3ae:	68fa      	ldr	r2, [r7, #12]
 800b3b0:	4313      	orrs	r3, r2
 800b3b2:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800b3b4:	68fb      	ldr	r3, [r7, #12]
 800b3b6:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
 800b3ba:	683b      	ldr	r3, [r7, #0]
 800b3bc:	695b      	ldr	r3, [r3, #20]
 800b3be:	4313      	orrs	r3, r2
 800b3c0:	60fb      	str	r3, [r7, #12]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 800b3c2:	683b      	ldr	r3, [r7, #0]
 800b3c4:	689a      	ldr	r2, [r3, #8]
 800b3c6:	687b      	ldr	r3, [r7, #4]
 800b3c8:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 800b3ca:	683b      	ldr	r3, [r7, #0]
 800b3cc:	681a      	ldr	r2, [r3, #0]
 800b3ce:	687b      	ldr	r3, [r7, #4]
 800b3d0:	629a      	str	r2, [r3, #40]	@ 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800b3d2:	687b      	ldr	r3, [r7, #4]
 800b3d4:	4a14      	ldr	r2, [pc, #80]	@ (800b428 <TIM_Base_SetConfig+0x120>)
 800b3d6:	4293      	cmp	r3, r2
 800b3d8:	d00f      	beq.n	800b3fa <TIM_Base_SetConfig+0xf2>
 800b3da:	687b      	ldr	r3, [r7, #4]
 800b3dc:	4a16      	ldr	r2, [pc, #88]	@ (800b438 <TIM_Base_SetConfig+0x130>)
 800b3de:	4293      	cmp	r3, r2
 800b3e0:	d00b      	beq.n	800b3fa <TIM_Base_SetConfig+0xf2>
 800b3e2:	687b      	ldr	r3, [r7, #4]
 800b3e4:	4a15      	ldr	r2, [pc, #84]	@ (800b43c <TIM_Base_SetConfig+0x134>)
 800b3e6:	4293      	cmp	r3, r2
 800b3e8:	d007      	beq.n	800b3fa <TIM_Base_SetConfig+0xf2>
 800b3ea:	687b      	ldr	r3, [r7, #4]
 800b3ec:	4a14      	ldr	r2, [pc, #80]	@ (800b440 <TIM_Base_SetConfig+0x138>)
 800b3ee:	4293      	cmp	r3, r2
 800b3f0:	d003      	beq.n	800b3fa <TIM_Base_SetConfig+0xf2>
 800b3f2:	687b      	ldr	r3, [r7, #4]
 800b3f4:	4a13      	ldr	r2, [pc, #76]	@ (800b444 <TIM_Base_SetConfig+0x13c>)
 800b3f6:	4293      	cmp	r3, r2
 800b3f8:	d103      	bne.n	800b402 <TIM_Base_SetConfig+0xfa>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 800b3fa:	683b      	ldr	r3, [r7, #0]
 800b3fc:	691a      	ldr	r2, [r3, #16]
 800b3fe:	687b      	ldr	r3, [r7, #4]
 800b400:	631a      	str	r2, [r3, #48]	@ 0x30
  }

  /* Disable Update Event (UEV) with Update Generation (UG)
     by changing Update Request Source (URS) to avoid Update flag (UIF) */
  SET_BIT(TIMx->CR1, TIM_CR1_URS);
 800b402:	687b      	ldr	r3, [r7, #4]
 800b404:	681b      	ldr	r3, [r3, #0]
 800b406:	f043 0204 	orr.w	r2, r3, #4
 800b40a:	687b      	ldr	r3, [r7, #4]
 800b40c:	601a      	str	r2, [r3, #0]

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 800b40e:	687b      	ldr	r3, [r7, #4]
 800b410:	2201      	movs	r2, #1
 800b412:	615a      	str	r2, [r3, #20]

  TIMx->CR1 = tmpcr1;
 800b414:	687b      	ldr	r3, [r7, #4]
 800b416:	68fa      	ldr	r2, [r7, #12]
 800b418:	601a      	str	r2, [r3, #0]
}
 800b41a:	bf00      	nop
 800b41c:	3714      	adds	r7, #20
 800b41e:	46bd      	mov	sp, r7
 800b420:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b424:	4770      	bx	lr
 800b426:	bf00      	nop
 800b428:	40010000 	.word	0x40010000
 800b42c:	40000400 	.word	0x40000400
 800b430:	40000800 	.word	0x40000800
 800b434:	40000c00 	.word	0x40000c00
 800b438:	40010400 	.word	0x40010400
 800b43c:	40014000 	.word	0x40014000
 800b440:	40014400 	.word	0x40014400
 800b444:	40014800 	.word	0x40014800

0800b448 <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 800b448:	b480      	push	{r7}
 800b44a:	b087      	sub	sp, #28
 800b44c:	af00      	add	r7, sp, #0
 800b44e:	60f8      	str	r0, [r7, #12]
 800b450:	60b9      	str	r1, [r7, #8]
 800b452:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 800b454:	68fb      	ldr	r3, [r7, #12]
 800b456:	6a1b      	ldr	r3, [r3, #32]
 800b458:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800b45a:	68fb      	ldr	r3, [r7, #12]
 800b45c:	6a1b      	ldr	r3, [r3, #32]
 800b45e:	f023 0201 	bic.w	r2, r3, #1
 800b462:	68fb      	ldr	r3, [r7, #12]
 800b464:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800b466:	68fb      	ldr	r3, [r7, #12]
 800b468:	699b      	ldr	r3, [r3, #24]
 800b46a:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800b46c:	693b      	ldr	r3, [r7, #16]
 800b46e:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 800b472:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800b474:	687b      	ldr	r3, [r7, #4]
 800b476:	011b      	lsls	r3, r3, #4
 800b478:	693a      	ldr	r2, [r7, #16]
 800b47a:	4313      	orrs	r3, r2
 800b47c:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800b47e:	697b      	ldr	r3, [r7, #20]
 800b480:	f023 030a 	bic.w	r3, r3, #10
 800b484:	617b      	str	r3, [r7, #20]
  tmpccer |= TIM_ICPolarity;
 800b486:	697a      	ldr	r2, [r7, #20]
 800b488:	68bb      	ldr	r3, [r7, #8]
 800b48a:	4313      	orrs	r3, r2
 800b48c:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 800b48e:	68fb      	ldr	r3, [r7, #12]
 800b490:	693a      	ldr	r2, [r7, #16]
 800b492:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800b494:	68fb      	ldr	r3, [r7, #12]
 800b496:	697a      	ldr	r2, [r7, #20]
 800b498:	621a      	str	r2, [r3, #32]
}
 800b49a:	bf00      	nop
 800b49c:	371c      	adds	r7, #28
 800b49e:	46bd      	mov	sp, r7
 800b4a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b4a4:	4770      	bx	lr

0800b4a6 <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 800b4a6:	b480      	push	{r7}
 800b4a8:	b087      	sub	sp, #28
 800b4aa:	af00      	add	r7, sp, #0
 800b4ac:	60f8      	str	r0, [r7, #12]
 800b4ae:	60b9      	str	r1, [r7, #8]
 800b4b0:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  tmpccer = TIMx->CCER;
 800b4b2:	68fb      	ldr	r3, [r7, #12]
 800b4b4:	6a1b      	ldr	r3, [r3, #32]
 800b4b6:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800b4b8:	68fb      	ldr	r3, [r7, #12]
 800b4ba:	6a1b      	ldr	r3, [r3, #32]
 800b4bc:	f023 0210 	bic.w	r2, r3, #16
 800b4c0:	68fb      	ldr	r3, [r7, #12]
 800b4c2:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800b4c4:	68fb      	ldr	r3, [r7, #12]
 800b4c6:	699b      	ldr	r3, [r3, #24]
 800b4c8:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 800b4ca:	693b      	ldr	r3, [r7, #16]
 800b4cc:	f423 4370 	bic.w	r3, r3, #61440	@ 0xf000
 800b4d0:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 12U);
 800b4d2:	687b      	ldr	r3, [r7, #4]
 800b4d4:	031b      	lsls	r3, r3, #12
 800b4d6:	693a      	ldr	r2, [r7, #16]
 800b4d8:	4313      	orrs	r3, r2
 800b4da:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800b4dc:	697b      	ldr	r3, [r7, #20]
 800b4de:	f023 03a0 	bic.w	r3, r3, #160	@ 0xa0
 800b4e2:	617b      	str	r3, [r7, #20]
  tmpccer |= (TIM_ICPolarity << 4U);
 800b4e4:	68bb      	ldr	r3, [r7, #8]
 800b4e6:	011b      	lsls	r3, r3, #4
 800b4e8:	697a      	ldr	r2, [r7, #20]
 800b4ea:	4313      	orrs	r3, r2
 800b4ec:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 800b4ee:	68fb      	ldr	r3, [r7, #12]
 800b4f0:	693a      	ldr	r2, [r7, #16]
 800b4f2:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 800b4f4:	68fb      	ldr	r3, [r7, #12]
 800b4f6:	697a      	ldr	r2, [r7, #20]
 800b4f8:	621a      	str	r2, [r3, #32]
}
 800b4fa:	bf00      	nop
 800b4fc:	371c      	adds	r7, #28
 800b4fe:	46bd      	mov	sp, r7
 800b500:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b504:	4770      	bx	lr
	...

0800b508 <TIM_ITRx_SetConfig>:
  *       (*)  Value not defined in all devices.
  *
  * @retval None
  */
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
 800b508:	b480      	push	{r7}
 800b50a:	b085      	sub	sp, #20
 800b50c:	af00      	add	r7, sp, #0
 800b50e:	6078      	str	r0, [r7, #4]
 800b510:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800b512:	687b      	ldr	r3, [r7, #4]
 800b514:	689b      	ldr	r3, [r3, #8]
 800b516:	60fb      	str	r3, [r7, #12]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 800b518:	68fa      	ldr	r2, [r7, #12]
 800b51a:	4b09      	ldr	r3, [pc, #36]	@ (800b540 <TIM_ITRx_SetConfig+0x38>)
 800b51c:	4013      	ands	r3, r2
 800b51e:	60fb      	str	r3, [r7, #12]
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800b520:	683a      	ldr	r2, [r7, #0]
 800b522:	68fb      	ldr	r3, [r7, #12]
 800b524:	4313      	orrs	r3, r2
 800b526:	f043 0307 	orr.w	r3, r3, #7
 800b52a:	60fb      	str	r3, [r7, #12]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800b52c:	687b      	ldr	r3, [r7, #4]
 800b52e:	68fa      	ldr	r2, [r7, #12]
 800b530:	609a      	str	r2, [r3, #8]
}
 800b532:	bf00      	nop
 800b534:	3714      	adds	r7, #20
 800b536:	46bd      	mov	sp, r7
 800b538:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b53c:	4770      	bx	lr
 800b53e:	bf00      	nop
 800b540:	ffcfff8f 	.word	0xffcfff8f

0800b544 <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 800b544:	b480      	push	{r7}
 800b546:	b087      	sub	sp, #28
 800b548:	af00      	add	r7, sp, #0
 800b54a:	60f8      	str	r0, [r7, #12]
 800b54c:	60b9      	str	r1, [r7, #8]
 800b54e:	607a      	str	r2, [r7, #4]
 800b550:	603b      	str	r3, [r7, #0]
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 800b552:	68fb      	ldr	r3, [r7, #12]
 800b554:	689b      	ldr	r3, [r3, #8]
 800b556:	617b      	str	r3, [r7, #20]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800b558:	697b      	ldr	r3, [r7, #20]
 800b55a:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 800b55e:	617b      	str	r3, [r7, #20]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 800b560:	683b      	ldr	r3, [r7, #0]
 800b562:	021a      	lsls	r2, r3, #8
 800b564:	687b      	ldr	r3, [r7, #4]
 800b566:	431a      	orrs	r2, r3
 800b568:	68bb      	ldr	r3, [r7, #8]
 800b56a:	4313      	orrs	r3, r2
 800b56c:	697a      	ldr	r2, [r7, #20]
 800b56e:	4313      	orrs	r3, r2
 800b570:	617b      	str	r3, [r7, #20]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800b572:	68fb      	ldr	r3, [r7, #12]
 800b574:	697a      	ldr	r2, [r7, #20]
 800b576:	609a      	str	r2, [r3, #8]
}
 800b578:	bf00      	nop
 800b57a:	371c      	adds	r7, #28
 800b57c:	46bd      	mov	sp, r7
 800b57e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b582:	4770      	bx	lr

0800b584 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        const TIM_MasterConfigTypeDef *sMasterConfig)
{
 800b584:	b480      	push	{r7}
 800b586:	b085      	sub	sp, #20
 800b588:	af00      	add	r7, sp, #0
 800b58a:	6078      	str	r0, [r7, #4]
 800b58c:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 800b58e:	687b      	ldr	r3, [r7, #4]
 800b590:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 800b594:	2b01      	cmp	r3, #1
 800b596:	d101      	bne.n	800b59c <HAL_TIMEx_MasterConfigSynchronization+0x18>
 800b598:	2302      	movs	r3, #2
 800b59a:	e06d      	b.n	800b678 <HAL_TIMEx_MasterConfigSynchronization+0xf4>
 800b59c:	687b      	ldr	r3, [r7, #4]
 800b59e:	2201      	movs	r2, #1
 800b5a0:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 800b5a4:	687b      	ldr	r3, [r7, #4]
 800b5a6:	2202      	movs	r2, #2
 800b5a8:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 800b5ac:	687b      	ldr	r3, [r7, #4]
 800b5ae:	681b      	ldr	r3, [r3, #0]
 800b5b0:	685b      	ldr	r3, [r3, #4]
 800b5b2:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 800b5b4:	687b      	ldr	r3, [r7, #4]
 800b5b6:	681b      	ldr	r3, [r3, #0]
 800b5b8:	689b      	ldr	r3, [r3, #8]
 800b5ba:	60bb      	str	r3, [r7, #8]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800b5bc:	687b      	ldr	r3, [r7, #4]
 800b5be:	681b      	ldr	r3, [r3, #0]
 800b5c0:	4a30      	ldr	r2, [pc, #192]	@ (800b684 <HAL_TIMEx_MasterConfigSynchronization+0x100>)
 800b5c2:	4293      	cmp	r3, r2
 800b5c4:	d004      	beq.n	800b5d0 <HAL_TIMEx_MasterConfigSynchronization+0x4c>
 800b5c6:	687b      	ldr	r3, [r7, #4]
 800b5c8:	681b      	ldr	r3, [r3, #0]
 800b5ca:	4a2f      	ldr	r2, [pc, #188]	@ (800b688 <HAL_TIMEx_MasterConfigSynchronization+0x104>)
 800b5cc:	4293      	cmp	r3, r2
 800b5ce:	d108      	bne.n	800b5e2 <HAL_TIMEx_MasterConfigSynchronization+0x5e>
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
 800b5d0:	68fb      	ldr	r3, [r7, #12]
 800b5d2:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
 800b5d6:	60fb      	str	r3, [r7, #12]
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 800b5d8:	683b      	ldr	r3, [r7, #0]
 800b5da:	685b      	ldr	r3, [r3, #4]
 800b5dc:	68fa      	ldr	r2, [r7, #12]
 800b5de:	4313      	orrs	r3, r2
 800b5e0:	60fb      	str	r3, [r7, #12]
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 800b5e2:	68fb      	ldr	r3, [r7, #12]
 800b5e4:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 800b5e8:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800b5ea:	683b      	ldr	r3, [r7, #0]
 800b5ec:	681b      	ldr	r3, [r3, #0]
 800b5ee:	68fa      	ldr	r2, [r7, #12]
 800b5f0:	4313      	orrs	r3, r2
 800b5f2:	60fb      	str	r3, [r7, #12]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 800b5f4:	687b      	ldr	r3, [r7, #4]
 800b5f6:	681b      	ldr	r3, [r3, #0]
 800b5f8:	68fa      	ldr	r2, [r7, #12]
 800b5fa:	605a      	str	r2, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800b5fc:	687b      	ldr	r3, [r7, #4]
 800b5fe:	681b      	ldr	r3, [r3, #0]
 800b600:	4a20      	ldr	r2, [pc, #128]	@ (800b684 <HAL_TIMEx_MasterConfigSynchronization+0x100>)
 800b602:	4293      	cmp	r3, r2
 800b604:	d022      	beq.n	800b64c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 800b606:	687b      	ldr	r3, [r7, #4]
 800b608:	681b      	ldr	r3, [r3, #0]
 800b60a:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 800b60e:	d01d      	beq.n	800b64c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 800b610:	687b      	ldr	r3, [r7, #4]
 800b612:	681b      	ldr	r3, [r3, #0]
 800b614:	4a1d      	ldr	r2, [pc, #116]	@ (800b68c <HAL_TIMEx_MasterConfigSynchronization+0x108>)
 800b616:	4293      	cmp	r3, r2
 800b618:	d018      	beq.n	800b64c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 800b61a:	687b      	ldr	r3, [r7, #4]
 800b61c:	681b      	ldr	r3, [r3, #0]
 800b61e:	4a1c      	ldr	r2, [pc, #112]	@ (800b690 <HAL_TIMEx_MasterConfigSynchronization+0x10c>)
 800b620:	4293      	cmp	r3, r2
 800b622:	d013      	beq.n	800b64c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 800b624:	687b      	ldr	r3, [r7, #4]
 800b626:	681b      	ldr	r3, [r3, #0]
 800b628:	4a1a      	ldr	r2, [pc, #104]	@ (800b694 <HAL_TIMEx_MasterConfigSynchronization+0x110>)
 800b62a:	4293      	cmp	r3, r2
 800b62c:	d00e      	beq.n	800b64c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 800b62e:	687b      	ldr	r3, [r7, #4]
 800b630:	681b      	ldr	r3, [r3, #0]
 800b632:	4a15      	ldr	r2, [pc, #84]	@ (800b688 <HAL_TIMEx_MasterConfigSynchronization+0x104>)
 800b634:	4293      	cmp	r3, r2
 800b636:	d009      	beq.n	800b64c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 800b638:	687b      	ldr	r3, [r7, #4]
 800b63a:	681b      	ldr	r3, [r3, #0]
 800b63c:	4a16      	ldr	r2, [pc, #88]	@ (800b698 <HAL_TIMEx_MasterConfigSynchronization+0x114>)
 800b63e:	4293      	cmp	r3, r2
 800b640:	d004      	beq.n	800b64c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 800b642:	687b      	ldr	r3, [r7, #4]
 800b644:	681b      	ldr	r3, [r3, #0]
 800b646:	4a15      	ldr	r2, [pc, #84]	@ (800b69c <HAL_TIMEx_MasterConfigSynchronization+0x118>)
 800b648:	4293      	cmp	r3, r2
 800b64a:	d10c      	bne.n	800b666 <HAL_TIMEx_MasterConfigSynchronization+0xe2>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 800b64c:	68bb      	ldr	r3, [r7, #8]
 800b64e:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 800b652:	60bb      	str	r3, [r7, #8]
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800b654:	683b      	ldr	r3, [r7, #0]
 800b656:	689b      	ldr	r3, [r3, #8]
 800b658:	68ba      	ldr	r2, [r7, #8]
 800b65a:	4313      	orrs	r3, r2
 800b65c:	60bb      	str	r3, [r7, #8]

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 800b65e:	687b      	ldr	r3, [r7, #4]
 800b660:	681b      	ldr	r3, [r3, #0]
 800b662:	68ba      	ldr	r2, [r7, #8]
 800b664:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 800b666:	687b      	ldr	r3, [r7, #4]
 800b668:	2201      	movs	r2, #1
 800b66a:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  __HAL_UNLOCK(htim);
 800b66e:	687b      	ldr	r3, [r7, #4]
 800b670:	2200      	movs	r2, #0
 800b672:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  return HAL_OK;
 800b676:	2300      	movs	r3, #0
}
 800b678:	4618      	mov	r0, r3
 800b67a:	3714      	adds	r7, #20
 800b67c:	46bd      	mov	sp, r7
 800b67e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b682:	4770      	bx	lr
 800b684:	40010000 	.word	0x40010000
 800b688:	40010400 	.word	0x40010400
 800b68c:	40000400 	.word	0x40000400
 800b690:	40000800 	.word	0x40000800
 800b694:	40000c00 	.word	0x40000c00
 800b698:	40001800 	.word	0x40001800
 800b69c:	40014000 	.word	0x40014000

0800b6a0 <HAL_TIMEx_CommutCallback>:
  * @brief  Commutation callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 800b6a0:	b480      	push	{r7}
 800b6a2:	b083      	sub	sp, #12
 800b6a4:	af00      	add	r7, sp, #0
 800b6a6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 800b6a8:	bf00      	nop
 800b6aa:	370c      	adds	r7, #12
 800b6ac:	46bd      	mov	sp, r7
 800b6ae:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b6b2:	4770      	bx	lr

0800b6b4 <HAL_TIMEx_BreakCallback>:
  * @brief  Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 800b6b4:	b480      	push	{r7}
 800b6b6:	b083      	sub	sp, #12
 800b6b8:	af00      	add	r7, sp, #0
 800b6ba:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 800b6bc:	bf00      	nop
 800b6be:	370c      	adds	r7, #12
 800b6c0:	46bd      	mov	sp, r7
 800b6c2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b6c6:	4770      	bx	lr

0800b6c8 <HAL_TIMEx_Break2Callback>:
  * @brief  Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
 800b6c8:	b480      	push	{r7}
 800b6ca:	b083      	sub	sp, #12
 800b6cc:	af00      	add	r7, sp, #0
 800b6ce:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 800b6d0:	bf00      	nop
 800b6d2:	370c      	adds	r7, #12
 800b6d4:	46bd      	mov	sp, r7
 800b6d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b6da:	4770      	bx	lr

0800b6dc <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 800b6dc:	b580      	push	{r7, lr}
 800b6de:	b082      	sub	sp, #8
 800b6e0:	af00      	add	r7, sp, #0
 800b6e2:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 800b6e4:	687b      	ldr	r3, [r7, #4]
 800b6e6:	2b00      	cmp	r3, #0
 800b6e8:	d101      	bne.n	800b6ee <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 800b6ea:	2301      	movs	r3, #1
 800b6ec:	e042      	b.n	800b774 <HAL_UART_Init+0x98>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 800b6ee:	687b      	ldr	r3, [r7, #4]
 800b6f0:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800b6f4:	2b00      	cmp	r3, #0
 800b6f6:	d106      	bne.n	800b706 <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 800b6f8:	687b      	ldr	r3, [r7, #4]
 800b6fa:	2200      	movs	r2, #0
 800b6fc:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 800b700:	6878      	ldr	r0, [r7, #4]
 800b702:	f7f5 ffe9 	bl	80016d8 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 800b706:	687b      	ldr	r3, [r7, #4]
 800b708:	2224      	movs	r2, #36	@ 0x24
 800b70a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  __HAL_UART_DISABLE(huart);
 800b70e:	687b      	ldr	r3, [r7, #4]
 800b710:	681b      	ldr	r3, [r3, #0]
 800b712:	681a      	ldr	r2, [r3, #0]
 800b714:	687b      	ldr	r3, [r7, #4]
 800b716:	681b      	ldr	r3, [r3, #0]
 800b718:	f022 0201 	bic.w	r2, r2, #1
 800b71c:	601a      	str	r2, [r3, #0]

  /* Perform advanced settings configuration */
  /* For some items, configuration requires to be done prior TE and RE bits are set */
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800b71e:	687b      	ldr	r3, [r7, #4]
 800b720:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800b722:	2b00      	cmp	r3, #0
 800b724:	d002      	beq.n	800b72c <HAL_UART_Init+0x50>
  {
    UART_AdvFeatureConfig(huart);
 800b726:	6878      	ldr	r0, [r7, #4]
 800b728:	f000 fe1e 	bl	800c368 <UART_AdvFeatureConfig>
  }

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 800b72c:	6878      	ldr	r0, [r7, #4]
 800b72e:	f000 f8b3 	bl	800b898 <UART_SetConfig>
 800b732:	4603      	mov	r3, r0
 800b734:	2b01      	cmp	r3, #1
 800b736:	d101      	bne.n	800b73c <HAL_UART_Init+0x60>
  {
    return HAL_ERROR;
 800b738:	2301      	movs	r3, #1
 800b73a:	e01b      	b.n	800b774 <HAL_UART_Init+0x98>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800b73c:	687b      	ldr	r3, [r7, #4]
 800b73e:	681b      	ldr	r3, [r3, #0]
 800b740:	685a      	ldr	r2, [r3, #4]
 800b742:	687b      	ldr	r3, [r7, #4]
 800b744:	681b      	ldr	r3, [r3, #0]
 800b746:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
 800b74a:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 800b74c:	687b      	ldr	r3, [r7, #4]
 800b74e:	681b      	ldr	r3, [r3, #0]
 800b750:	689a      	ldr	r2, [r3, #8]
 800b752:	687b      	ldr	r3, [r7, #4]
 800b754:	681b      	ldr	r3, [r3, #0]
 800b756:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
 800b75a:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
 800b75c:	687b      	ldr	r3, [r7, #4]
 800b75e:	681b      	ldr	r3, [r3, #0]
 800b760:	681a      	ldr	r2, [r3, #0]
 800b762:	687b      	ldr	r3, [r7, #4]
 800b764:	681b      	ldr	r3, [r3, #0]
 800b766:	f042 0201 	orr.w	r2, r2, #1
 800b76a:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 800b76c:	6878      	ldr	r0, [r7, #4]
 800b76e:	f000 fe9d 	bl	800c4ac <UART_CheckIdleState>
 800b772:	4603      	mov	r3, r0
}
 800b774:	4618      	mov	r0, r3
 800b776:	3708      	adds	r7, #8
 800b778:	46bd      	mov	sp, r7
 800b77a:	bd80      	pop	{r7, pc}

0800b77c <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800b77c:	b580      	push	{r7, lr}
 800b77e:	b08a      	sub	sp, #40	@ 0x28
 800b780:	af02      	add	r7, sp, #8
 800b782:	60f8      	str	r0, [r7, #12]
 800b784:	60b9      	str	r1, [r7, #8]
 800b786:	603b      	str	r3, [r7, #0]
 800b788:	4613      	mov	r3, r2
 800b78a:	80fb      	strh	r3, [r7, #6]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
 800b78c:	68fb      	ldr	r3, [r7, #12]
 800b78e:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 800b792:	2b20      	cmp	r3, #32
 800b794:	d17b      	bne.n	800b88e <HAL_UART_Transmit+0x112>
  {
    if ((pData == NULL) || (Size == 0U))
 800b796:	68bb      	ldr	r3, [r7, #8]
 800b798:	2b00      	cmp	r3, #0
 800b79a:	d002      	beq.n	800b7a2 <HAL_UART_Transmit+0x26>
 800b79c:	88fb      	ldrh	r3, [r7, #6]
 800b79e:	2b00      	cmp	r3, #0
 800b7a0:	d101      	bne.n	800b7a6 <HAL_UART_Transmit+0x2a>
    {
      return  HAL_ERROR;
 800b7a2:	2301      	movs	r3, #1
 800b7a4:	e074      	b.n	800b890 <HAL_UART_Transmit+0x114>
    }

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800b7a6:	68fb      	ldr	r3, [r7, #12]
 800b7a8:	2200      	movs	r2, #0
 800b7aa:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
 800b7ae:	68fb      	ldr	r3, [r7, #12]
 800b7b0:	2221      	movs	r2, #33	@ 0x21
 800b7b2:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
 800b7b6:	f7f6 fbdd 	bl	8001f74 <HAL_GetTick>
 800b7ba:	6178      	str	r0, [r7, #20]

    huart->TxXferSize  = Size;
 800b7bc:	68fb      	ldr	r3, [r7, #12]
 800b7be:	88fa      	ldrh	r2, [r7, #6]
 800b7c0:	f8a3 2054 	strh.w	r2, [r3, #84]	@ 0x54
    huart->TxXferCount = Size;
 800b7c4:	68fb      	ldr	r3, [r7, #12]
 800b7c6:	88fa      	ldrh	r2, [r7, #6]
 800b7c8:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800b7cc:	68fb      	ldr	r3, [r7, #12]
 800b7ce:	689b      	ldr	r3, [r3, #8]
 800b7d0:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 800b7d4:	d108      	bne.n	800b7e8 <HAL_UART_Transmit+0x6c>
 800b7d6:	68fb      	ldr	r3, [r7, #12]
 800b7d8:	691b      	ldr	r3, [r3, #16]
 800b7da:	2b00      	cmp	r3, #0
 800b7dc:	d104      	bne.n	800b7e8 <HAL_UART_Transmit+0x6c>
    {
      pdata8bits  = NULL;
 800b7de:	2300      	movs	r3, #0
 800b7e0:	61fb      	str	r3, [r7, #28]
      pdata16bits = (const uint16_t *) pData;
 800b7e2:	68bb      	ldr	r3, [r7, #8]
 800b7e4:	61bb      	str	r3, [r7, #24]
 800b7e6:	e003      	b.n	800b7f0 <HAL_UART_Transmit+0x74>
    }
    else
    {
      pdata8bits  = pData;
 800b7e8:	68bb      	ldr	r3, [r7, #8]
 800b7ea:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
 800b7ec:	2300      	movs	r3, #0
 800b7ee:	61bb      	str	r3, [r7, #24]
    }

    while (huart->TxXferCount > 0U)
 800b7f0:	e030      	b.n	800b854 <HAL_UART_Transmit+0xd8>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 800b7f2:	683b      	ldr	r3, [r7, #0]
 800b7f4:	9300      	str	r3, [sp, #0]
 800b7f6:	697b      	ldr	r3, [r7, #20]
 800b7f8:	2200      	movs	r2, #0
 800b7fa:	2180      	movs	r1, #128	@ 0x80
 800b7fc:	68f8      	ldr	r0, [r7, #12]
 800b7fe:	f000 feff 	bl	800c600 <UART_WaitOnFlagUntilTimeout>
 800b802:	4603      	mov	r3, r0
 800b804:	2b00      	cmp	r3, #0
 800b806:	d005      	beq.n	800b814 <HAL_UART_Transmit+0x98>
      {

        huart->gState = HAL_UART_STATE_READY;
 800b808:	68fb      	ldr	r3, [r7, #12]
 800b80a:	2220      	movs	r2, #32
 800b80c:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

        return HAL_TIMEOUT;
 800b810:	2303      	movs	r3, #3
 800b812:	e03d      	b.n	800b890 <HAL_UART_Transmit+0x114>
      }
      if (pdata8bits == NULL)
 800b814:	69fb      	ldr	r3, [r7, #28]
 800b816:	2b00      	cmp	r3, #0
 800b818:	d10b      	bne.n	800b832 <HAL_UART_Transmit+0xb6>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 800b81a:	69bb      	ldr	r3, [r7, #24]
 800b81c:	881b      	ldrh	r3, [r3, #0]
 800b81e:	461a      	mov	r2, r3
 800b820:	68fb      	ldr	r3, [r7, #12]
 800b822:	681b      	ldr	r3, [r3, #0]
 800b824:	f3c2 0208 	ubfx	r2, r2, #0, #9
 800b828:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata16bits++;
 800b82a:	69bb      	ldr	r3, [r7, #24]
 800b82c:	3302      	adds	r3, #2
 800b82e:	61bb      	str	r3, [r7, #24]
 800b830:	e007      	b.n	800b842 <HAL_UART_Transmit+0xc6>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800b832:	69fb      	ldr	r3, [r7, #28]
 800b834:	781a      	ldrb	r2, [r3, #0]
 800b836:	68fb      	ldr	r3, [r7, #12]
 800b838:	681b      	ldr	r3, [r3, #0]
 800b83a:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata8bits++;
 800b83c:	69fb      	ldr	r3, [r7, #28]
 800b83e:	3301      	adds	r3, #1
 800b840:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
 800b842:	68fb      	ldr	r3, [r7, #12]
 800b844:	f8b3 3056 	ldrh.w	r3, [r3, #86]	@ 0x56
 800b848:	b29b      	uxth	r3, r3
 800b84a:	3b01      	subs	r3, #1
 800b84c:	b29a      	uxth	r2, r3
 800b84e:	68fb      	ldr	r3, [r7, #12]
 800b850:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56
    while (huart->TxXferCount > 0U)
 800b854:	68fb      	ldr	r3, [r7, #12]
 800b856:	f8b3 3056 	ldrh.w	r3, [r3, #86]	@ 0x56
 800b85a:	b29b      	uxth	r3, r3
 800b85c:	2b00      	cmp	r3, #0
 800b85e:	d1c8      	bne.n	800b7f2 <HAL_UART_Transmit+0x76>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 800b860:	683b      	ldr	r3, [r7, #0]
 800b862:	9300      	str	r3, [sp, #0]
 800b864:	697b      	ldr	r3, [r7, #20]
 800b866:	2200      	movs	r2, #0
 800b868:	2140      	movs	r1, #64	@ 0x40
 800b86a:	68f8      	ldr	r0, [r7, #12]
 800b86c:	f000 fec8 	bl	800c600 <UART_WaitOnFlagUntilTimeout>
 800b870:	4603      	mov	r3, r0
 800b872:	2b00      	cmp	r3, #0
 800b874:	d005      	beq.n	800b882 <HAL_UART_Transmit+0x106>
    {
      huart->gState = HAL_UART_STATE_READY;
 800b876:	68fb      	ldr	r3, [r7, #12]
 800b878:	2220      	movs	r2, #32
 800b87a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      return HAL_TIMEOUT;
 800b87e:	2303      	movs	r3, #3
 800b880:	e006      	b.n	800b890 <HAL_UART_Transmit+0x114>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
 800b882:	68fb      	ldr	r3, [r7, #12]
 800b884:	2220      	movs	r2, #32
 800b886:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

    return HAL_OK;
 800b88a:	2300      	movs	r3, #0
 800b88c:	e000      	b.n	800b890 <HAL_UART_Transmit+0x114>
  }
  else
  {
    return HAL_BUSY;
 800b88e:	2302      	movs	r3, #2
  }
}
 800b890:	4618      	mov	r0, r3
 800b892:	3720      	adds	r7, #32
 800b894:	46bd      	mov	sp, r7
 800b896:	bd80      	pop	{r7, pc}

0800b898 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 800b898:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 800b89c:	b092      	sub	sp, #72	@ 0x48
 800b89e:	af00      	add	r7, sp, #0
 800b8a0:	6178      	str	r0, [r7, #20]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
 800b8a2:	2300      	movs	r3, #0
 800b8a4:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800b8a8:	697b      	ldr	r3, [r7, #20]
 800b8aa:	689a      	ldr	r2, [r3, #8]
 800b8ac:	697b      	ldr	r3, [r7, #20]
 800b8ae:	691b      	ldr	r3, [r3, #16]
 800b8b0:	431a      	orrs	r2, r3
 800b8b2:	697b      	ldr	r3, [r7, #20]
 800b8b4:	695b      	ldr	r3, [r3, #20]
 800b8b6:	431a      	orrs	r2, r3
 800b8b8:	697b      	ldr	r3, [r7, #20]
 800b8ba:	69db      	ldr	r3, [r3, #28]
 800b8bc:	4313      	orrs	r3, r2
 800b8be:	647b      	str	r3, [r7, #68]	@ 0x44
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800b8c0:	697b      	ldr	r3, [r7, #20]
 800b8c2:	681b      	ldr	r3, [r3, #0]
 800b8c4:	681a      	ldr	r2, [r3, #0]
 800b8c6:	4bbe      	ldr	r3, [pc, #760]	@ (800bbc0 <UART_SetConfig+0x328>)
 800b8c8:	4013      	ands	r3, r2
 800b8ca:	697a      	ldr	r2, [r7, #20]
 800b8cc:	6812      	ldr	r2, [r2, #0]
 800b8ce:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800b8d0:	430b      	orrs	r3, r1
 800b8d2:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 800b8d4:	697b      	ldr	r3, [r7, #20]
 800b8d6:	681b      	ldr	r3, [r3, #0]
 800b8d8:	685b      	ldr	r3, [r3, #4]
 800b8da:	f423 5140 	bic.w	r1, r3, #12288	@ 0x3000
 800b8de:	697b      	ldr	r3, [r7, #20]
 800b8e0:	68da      	ldr	r2, [r3, #12]
 800b8e2:	697b      	ldr	r3, [r7, #20]
 800b8e4:	681b      	ldr	r3, [r3, #0]
 800b8e6:	430a      	orrs	r2, r1
 800b8e8:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 800b8ea:	697b      	ldr	r3, [r7, #20]
 800b8ec:	699b      	ldr	r3, [r3, #24]
 800b8ee:	647b      	str	r3, [r7, #68]	@ 0x44

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 800b8f0:	697b      	ldr	r3, [r7, #20]
 800b8f2:	681b      	ldr	r3, [r3, #0]
 800b8f4:	4ab3      	ldr	r2, [pc, #716]	@ (800bbc4 <UART_SetConfig+0x32c>)
 800b8f6:	4293      	cmp	r3, r2
 800b8f8:	d004      	beq.n	800b904 <UART_SetConfig+0x6c>
  {
    tmpreg |= huart->Init.OneBitSampling;
 800b8fa:	697b      	ldr	r3, [r7, #20]
 800b8fc:	6a1b      	ldr	r3, [r3, #32]
 800b8fe:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800b900:	4313      	orrs	r3, r2
 800b902:	647b      	str	r3, [r7, #68]	@ 0x44
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 800b904:	697b      	ldr	r3, [r7, #20]
 800b906:	681b      	ldr	r3, [r3, #0]
 800b908:	689a      	ldr	r2, [r3, #8]
 800b90a:	4baf      	ldr	r3, [pc, #700]	@ (800bbc8 <UART_SetConfig+0x330>)
 800b90c:	4013      	ands	r3, r2
 800b90e:	697a      	ldr	r2, [r7, #20]
 800b910:	6812      	ldr	r2, [r2, #0]
 800b912:	6c79      	ldr	r1, [r7, #68]	@ 0x44
 800b914:	430b      	orrs	r3, r1
 800b916:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 800b918:	697b      	ldr	r3, [r7, #20]
 800b91a:	681b      	ldr	r3, [r3, #0]
 800b91c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800b91e:	f023 010f 	bic.w	r1, r3, #15
 800b922:	697b      	ldr	r3, [r7, #20]
 800b924:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800b926:	697b      	ldr	r3, [r7, #20]
 800b928:	681b      	ldr	r3, [r3, #0]
 800b92a:	430a      	orrs	r2, r1
 800b92c:	62da      	str	r2, [r3, #44]	@ 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 800b92e:	697b      	ldr	r3, [r7, #20]
 800b930:	681b      	ldr	r3, [r3, #0]
 800b932:	4aa6      	ldr	r2, [pc, #664]	@ (800bbcc <UART_SetConfig+0x334>)
 800b934:	4293      	cmp	r3, r2
 800b936:	d177      	bne.n	800ba28 <UART_SetConfig+0x190>
 800b938:	4ba5      	ldr	r3, [pc, #660]	@ (800bbd0 <UART_SetConfig+0x338>)
 800b93a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800b93c:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 800b940:	2b28      	cmp	r3, #40	@ 0x28
 800b942:	d86d      	bhi.n	800ba20 <UART_SetConfig+0x188>
 800b944:	a201      	add	r2, pc, #4	@ (adr r2, 800b94c <UART_SetConfig+0xb4>)
 800b946:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b94a:	bf00      	nop
 800b94c:	0800b9f1 	.word	0x0800b9f1
 800b950:	0800ba21 	.word	0x0800ba21
 800b954:	0800ba21 	.word	0x0800ba21
 800b958:	0800ba21 	.word	0x0800ba21
 800b95c:	0800ba21 	.word	0x0800ba21
 800b960:	0800ba21 	.word	0x0800ba21
 800b964:	0800ba21 	.word	0x0800ba21
 800b968:	0800ba21 	.word	0x0800ba21
 800b96c:	0800b9f9 	.word	0x0800b9f9
 800b970:	0800ba21 	.word	0x0800ba21
 800b974:	0800ba21 	.word	0x0800ba21
 800b978:	0800ba21 	.word	0x0800ba21
 800b97c:	0800ba21 	.word	0x0800ba21
 800b980:	0800ba21 	.word	0x0800ba21
 800b984:	0800ba21 	.word	0x0800ba21
 800b988:	0800ba21 	.word	0x0800ba21
 800b98c:	0800ba01 	.word	0x0800ba01
 800b990:	0800ba21 	.word	0x0800ba21
 800b994:	0800ba21 	.word	0x0800ba21
 800b998:	0800ba21 	.word	0x0800ba21
 800b99c:	0800ba21 	.word	0x0800ba21
 800b9a0:	0800ba21 	.word	0x0800ba21
 800b9a4:	0800ba21 	.word	0x0800ba21
 800b9a8:	0800ba21 	.word	0x0800ba21
 800b9ac:	0800ba09 	.word	0x0800ba09
 800b9b0:	0800ba21 	.word	0x0800ba21
 800b9b4:	0800ba21 	.word	0x0800ba21
 800b9b8:	0800ba21 	.word	0x0800ba21
 800b9bc:	0800ba21 	.word	0x0800ba21
 800b9c0:	0800ba21 	.word	0x0800ba21
 800b9c4:	0800ba21 	.word	0x0800ba21
 800b9c8:	0800ba21 	.word	0x0800ba21
 800b9cc:	0800ba11 	.word	0x0800ba11
 800b9d0:	0800ba21 	.word	0x0800ba21
 800b9d4:	0800ba21 	.word	0x0800ba21
 800b9d8:	0800ba21 	.word	0x0800ba21
 800b9dc:	0800ba21 	.word	0x0800ba21
 800b9e0:	0800ba21 	.word	0x0800ba21
 800b9e4:	0800ba21 	.word	0x0800ba21
 800b9e8:	0800ba21 	.word	0x0800ba21
 800b9ec:	0800ba19 	.word	0x0800ba19
 800b9f0:	2301      	movs	r3, #1
 800b9f2:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800b9f6:	e222      	b.n	800be3e <UART_SetConfig+0x5a6>
 800b9f8:	2304      	movs	r3, #4
 800b9fa:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800b9fe:	e21e      	b.n	800be3e <UART_SetConfig+0x5a6>
 800ba00:	2308      	movs	r3, #8
 800ba02:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800ba06:	e21a      	b.n	800be3e <UART_SetConfig+0x5a6>
 800ba08:	2310      	movs	r3, #16
 800ba0a:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800ba0e:	e216      	b.n	800be3e <UART_SetConfig+0x5a6>
 800ba10:	2320      	movs	r3, #32
 800ba12:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800ba16:	e212      	b.n	800be3e <UART_SetConfig+0x5a6>
 800ba18:	2340      	movs	r3, #64	@ 0x40
 800ba1a:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800ba1e:	e20e      	b.n	800be3e <UART_SetConfig+0x5a6>
 800ba20:	2380      	movs	r3, #128	@ 0x80
 800ba22:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800ba26:	e20a      	b.n	800be3e <UART_SetConfig+0x5a6>
 800ba28:	697b      	ldr	r3, [r7, #20]
 800ba2a:	681b      	ldr	r3, [r3, #0]
 800ba2c:	4a69      	ldr	r2, [pc, #420]	@ (800bbd4 <UART_SetConfig+0x33c>)
 800ba2e:	4293      	cmp	r3, r2
 800ba30:	d130      	bne.n	800ba94 <UART_SetConfig+0x1fc>
 800ba32:	4b67      	ldr	r3, [pc, #412]	@ (800bbd0 <UART_SetConfig+0x338>)
 800ba34:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800ba36:	f003 0307 	and.w	r3, r3, #7
 800ba3a:	2b05      	cmp	r3, #5
 800ba3c:	d826      	bhi.n	800ba8c <UART_SetConfig+0x1f4>
 800ba3e:	a201      	add	r2, pc, #4	@ (adr r2, 800ba44 <UART_SetConfig+0x1ac>)
 800ba40:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800ba44:	0800ba5d 	.word	0x0800ba5d
 800ba48:	0800ba65 	.word	0x0800ba65
 800ba4c:	0800ba6d 	.word	0x0800ba6d
 800ba50:	0800ba75 	.word	0x0800ba75
 800ba54:	0800ba7d 	.word	0x0800ba7d
 800ba58:	0800ba85 	.word	0x0800ba85
 800ba5c:	2300      	movs	r3, #0
 800ba5e:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800ba62:	e1ec      	b.n	800be3e <UART_SetConfig+0x5a6>
 800ba64:	2304      	movs	r3, #4
 800ba66:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800ba6a:	e1e8      	b.n	800be3e <UART_SetConfig+0x5a6>
 800ba6c:	2308      	movs	r3, #8
 800ba6e:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800ba72:	e1e4      	b.n	800be3e <UART_SetConfig+0x5a6>
 800ba74:	2310      	movs	r3, #16
 800ba76:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800ba7a:	e1e0      	b.n	800be3e <UART_SetConfig+0x5a6>
 800ba7c:	2320      	movs	r3, #32
 800ba7e:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800ba82:	e1dc      	b.n	800be3e <UART_SetConfig+0x5a6>
 800ba84:	2340      	movs	r3, #64	@ 0x40
 800ba86:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800ba8a:	e1d8      	b.n	800be3e <UART_SetConfig+0x5a6>
 800ba8c:	2380      	movs	r3, #128	@ 0x80
 800ba8e:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800ba92:	e1d4      	b.n	800be3e <UART_SetConfig+0x5a6>
 800ba94:	697b      	ldr	r3, [r7, #20]
 800ba96:	681b      	ldr	r3, [r3, #0]
 800ba98:	4a4f      	ldr	r2, [pc, #316]	@ (800bbd8 <UART_SetConfig+0x340>)
 800ba9a:	4293      	cmp	r3, r2
 800ba9c:	d130      	bne.n	800bb00 <UART_SetConfig+0x268>
 800ba9e:	4b4c      	ldr	r3, [pc, #304]	@ (800bbd0 <UART_SetConfig+0x338>)
 800baa0:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800baa2:	f003 0307 	and.w	r3, r3, #7
 800baa6:	2b05      	cmp	r3, #5
 800baa8:	d826      	bhi.n	800baf8 <UART_SetConfig+0x260>
 800baaa:	a201      	add	r2, pc, #4	@ (adr r2, 800bab0 <UART_SetConfig+0x218>)
 800baac:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bab0:	0800bac9 	.word	0x0800bac9
 800bab4:	0800bad1 	.word	0x0800bad1
 800bab8:	0800bad9 	.word	0x0800bad9
 800babc:	0800bae1 	.word	0x0800bae1
 800bac0:	0800bae9 	.word	0x0800bae9
 800bac4:	0800baf1 	.word	0x0800baf1
 800bac8:	2300      	movs	r3, #0
 800baca:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bace:	e1b6      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bad0:	2304      	movs	r3, #4
 800bad2:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bad6:	e1b2      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bad8:	2308      	movs	r3, #8
 800bada:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bade:	e1ae      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bae0:	2310      	movs	r3, #16
 800bae2:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bae6:	e1aa      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bae8:	2320      	movs	r3, #32
 800baea:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800baee:	e1a6      	b.n	800be3e <UART_SetConfig+0x5a6>
 800baf0:	2340      	movs	r3, #64	@ 0x40
 800baf2:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800baf6:	e1a2      	b.n	800be3e <UART_SetConfig+0x5a6>
 800baf8:	2380      	movs	r3, #128	@ 0x80
 800bafa:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bafe:	e19e      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bb00:	697b      	ldr	r3, [r7, #20]
 800bb02:	681b      	ldr	r3, [r3, #0]
 800bb04:	4a35      	ldr	r2, [pc, #212]	@ (800bbdc <UART_SetConfig+0x344>)
 800bb06:	4293      	cmp	r3, r2
 800bb08:	d130      	bne.n	800bb6c <UART_SetConfig+0x2d4>
 800bb0a:	4b31      	ldr	r3, [pc, #196]	@ (800bbd0 <UART_SetConfig+0x338>)
 800bb0c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800bb0e:	f003 0307 	and.w	r3, r3, #7
 800bb12:	2b05      	cmp	r3, #5
 800bb14:	d826      	bhi.n	800bb64 <UART_SetConfig+0x2cc>
 800bb16:	a201      	add	r2, pc, #4	@ (adr r2, 800bb1c <UART_SetConfig+0x284>)
 800bb18:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bb1c:	0800bb35 	.word	0x0800bb35
 800bb20:	0800bb3d 	.word	0x0800bb3d
 800bb24:	0800bb45 	.word	0x0800bb45
 800bb28:	0800bb4d 	.word	0x0800bb4d
 800bb2c:	0800bb55 	.word	0x0800bb55
 800bb30:	0800bb5d 	.word	0x0800bb5d
 800bb34:	2300      	movs	r3, #0
 800bb36:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bb3a:	e180      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bb3c:	2304      	movs	r3, #4
 800bb3e:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bb42:	e17c      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bb44:	2308      	movs	r3, #8
 800bb46:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bb4a:	e178      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bb4c:	2310      	movs	r3, #16
 800bb4e:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bb52:	e174      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bb54:	2320      	movs	r3, #32
 800bb56:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bb5a:	e170      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bb5c:	2340      	movs	r3, #64	@ 0x40
 800bb5e:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bb62:	e16c      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bb64:	2380      	movs	r3, #128	@ 0x80
 800bb66:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bb6a:	e168      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bb6c:	697b      	ldr	r3, [r7, #20]
 800bb6e:	681b      	ldr	r3, [r3, #0]
 800bb70:	4a1b      	ldr	r2, [pc, #108]	@ (800bbe0 <UART_SetConfig+0x348>)
 800bb72:	4293      	cmp	r3, r2
 800bb74:	d142      	bne.n	800bbfc <UART_SetConfig+0x364>
 800bb76:	4b16      	ldr	r3, [pc, #88]	@ (800bbd0 <UART_SetConfig+0x338>)
 800bb78:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800bb7a:	f003 0307 	and.w	r3, r3, #7
 800bb7e:	2b05      	cmp	r3, #5
 800bb80:	d838      	bhi.n	800bbf4 <UART_SetConfig+0x35c>
 800bb82:	a201      	add	r2, pc, #4	@ (adr r2, 800bb88 <UART_SetConfig+0x2f0>)
 800bb84:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bb88:	0800bba1 	.word	0x0800bba1
 800bb8c:	0800bba9 	.word	0x0800bba9
 800bb90:	0800bbb1 	.word	0x0800bbb1
 800bb94:	0800bbb9 	.word	0x0800bbb9
 800bb98:	0800bbe5 	.word	0x0800bbe5
 800bb9c:	0800bbed 	.word	0x0800bbed
 800bba0:	2300      	movs	r3, #0
 800bba2:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bba6:	e14a      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bba8:	2304      	movs	r3, #4
 800bbaa:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bbae:	e146      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bbb0:	2308      	movs	r3, #8
 800bbb2:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bbb6:	e142      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bbb8:	2310      	movs	r3, #16
 800bbba:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bbbe:	e13e      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bbc0:	cfff69f3 	.word	0xcfff69f3
 800bbc4:	58000c00 	.word	0x58000c00
 800bbc8:	11fff4ff 	.word	0x11fff4ff
 800bbcc:	40011000 	.word	0x40011000
 800bbd0:	58024400 	.word	0x58024400
 800bbd4:	40004400 	.word	0x40004400
 800bbd8:	40004800 	.word	0x40004800
 800bbdc:	40004c00 	.word	0x40004c00
 800bbe0:	40005000 	.word	0x40005000
 800bbe4:	2320      	movs	r3, #32
 800bbe6:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bbea:	e128      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bbec:	2340      	movs	r3, #64	@ 0x40
 800bbee:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bbf2:	e124      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bbf4:	2380      	movs	r3, #128	@ 0x80
 800bbf6:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bbfa:	e120      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bbfc:	697b      	ldr	r3, [r7, #20]
 800bbfe:	681b      	ldr	r3, [r3, #0]
 800bc00:	4acb      	ldr	r2, [pc, #812]	@ (800bf30 <UART_SetConfig+0x698>)
 800bc02:	4293      	cmp	r3, r2
 800bc04:	d176      	bne.n	800bcf4 <UART_SetConfig+0x45c>
 800bc06:	4bcb      	ldr	r3, [pc, #812]	@ (800bf34 <UART_SetConfig+0x69c>)
 800bc08:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800bc0a:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 800bc0e:	2b28      	cmp	r3, #40	@ 0x28
 800bc10:	d86c      	bhi.n	800bcec <UART_SetConfig+0x454>
 800bc12:	a201      	add	r2, pc, #4	@ (adr r2, 800bc18 <UART_SetConfig+0x380>)
 800bc14:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bc18:	0800bcbd 	.word	0x0800bcbd
 800bc1c:	0800bced 	.word	0x0800bced
 800bc20:	0800bced 	.word	0x0800bced
 800bc24:	0800bced 	.word	0x0800bced
 800bc28:	0800bced 	.word	0x0800bced
 800bc2c:	0800bced 	.word	0x0800bced
 800bc30:	0800bced 	.word	0x0800bced
 800bc34:	0800bced 	.word	0x0800bced
 800bc38:	0800bcc5 	.word	0x0800bcc5
 800bc3c:	0800bced 	.word	0x0800bced
 800bc40:	0800bced 	.word	0x0800bced
 800bc44:	0800bced 	.word	0x0800bced
 800bc48:	0800bced 	.word	0x0800bced
 800bc4c:	0800bced 	.word	0x0800bced
 800bc50:	0800bced 	.word	0x0800bced
 800bc54:	0800bced 	.word	0x0800bced
 800bc58:	0800bccd 	.word	0x0800bccd
 800bc5c:	0800bced 	.word	0x0800bced
 800bc60:	0800bced 	.word	0x0800bced
 800bc64:	0800bced 	.word	0x0800bced
 800bc68:	0800bced 	.word	0x0800bced
 800bc6c:	0800bced 	.word	0x0800bced
 800bc70:	0800bced 	.word	0x0800bced
 800bc74:	0800bced 	.word	0x0800bced
 800bc78:	0800bcd5 	.word	0x0800bcd5
 800bc7c:	0800bced 	.word	0x0800bced
 800bc80:	0800bced 	.word	0x0800bced
 800bc84:	0800bced 	.word	0x0800bced
 800bc88:	0800bced 	.word	0x0800bced
 800bc8c:	0800bced 	.word	0x0800bced
 800bc90:	0800bced 	.word	0x0800bced
 800bc94:	0800bced 	.word	0x0800bced
 800bc98:	0800bcdd 	.word	0x0800bcdd
 800bc9c:	0800bced 	.word	0x0800bced
 800bca0:	0800bced 	.word	0x0800bced
 800bca4:	0800bced 	.word	0x0800bced
 800bca8:	0800bced 	.word	0x0800bced
 800bcac:	0800bced 	.word	0x0800bced
 800bcb0:	0800bced 	.word	0x0800bced
 800bcb4:	0800bced 	.word	0x0800bced
 800bcb8:	0800bce5 	.word	0x0800bce5
 800bcbc:	2301      	movs	r3, #1
 800bcbe:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bcc2:	e0bc      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bcc4:	2304      	movs	r3, #4
 800bcc6:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bcca:	e0b8      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bccc:	2308      	movs	r3, #8
 800bcce:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bcd2:	e0b4      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bcd4:	2310      	movs	r3, #16
 800bcd6:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bcda:	e0b0      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bcdc:	2320      	movs	r3, #32
 800bcde:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bce2:	e0ac      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bce4:	2340      	movs	r3, #64	@ 0x40
 800bce6:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bcea:	e0a8      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bcec:	2380      	movs	r3, #128	@ 0x80
 800bcee:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bcf2:	e0a4      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bcf4:	697b      	ldr	r3, [r7, #20]
 800bcf6:	681b      	ldr	r3, [r3, #0]
 800bcf8:	4a8f      	ldr	r2, [pc, #572]	@ (800bf38 <UART_SetConfig+0x6a0>)
 800bcfa:	4293      	cmp	r3, r2
 800bcfc:	d130      	bne.n	800bd60 <UART_SetConfig+0x4c8>
 800bcfe:	4b8d      	ldr	r3, [pc, #564]	@ (800bf34 <UART_SetConfig+0x69c>)
 800bd00:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800bd02:	f003 0307 	and.w	r3, r3, #7
 800bd06:	2b05      	cmp	r3, #5
 800bd08:	d826      	bhi.n	800bd58 <UART_SetConfig+0x4c0>
 800bd0a:	a201      	add	r2, pc, #4	@ (adr r2, 800bd10 <UART_SetConfig+0x478>)
 800bd0c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bd10:	0800bd29 	.word	0x0800bd29
 800bd14:	0800bd31 	.word	0x0800bd31
 800bd18:	0800bd39 	.word	0x0800bd39
 800bd1c:	0800bd41 	.word	0x0800bd41
 800bd20:	0800bd49 	.word	0x0800bd49
 800bd24:	0800bd51 	.word	0x0800bd51
 800bd28:	2300      	movs	r3, #0
 800bd2a:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bd2e:	e086      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bd30:	2304      	movs	r3, #4
 800bd32:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bd36:	e082      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bd38:	2308      	movs	r3, #8
 800bd3a:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bd3e:	e07e      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bd40:	2310      	movs	r3, #16
 800bd42:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bd46:	e07a      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bd48:	2320      	movs	r3, #32
 800bd4a:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bd4e:	e076      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bd50:	2340      	movs	r3, #64	@ 0x40
 800bd52:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bd56:	e072      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bd58:	2380      	movs	r3, #128	@ 0x80
 800bd5a:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bd5e:	e06e      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bd60:	697b      	ldr	r3, [r7, #20]
 800bd62:	681b      	ldr	r3, [r3, #0]
 800bd64:	4a75      	ldr	r2, [pc, #468]	@ (800bf3c <UART_SetConfig+0x6a4>)
 800bd66:	4293      	cmp	r3, r2
 800bd68:	d130      	bne.n	800bdcc <UART_SetConfig+0x534>
 800bd6a:	4b72      	ldr	r3, [pc, #456]	@ (800bf34 <UART_SetConfig+0x69c>)
 800bd6c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 800bd6e:	f003 0307 	and.w	r3, r3, #7
 800bd72:	2b05      	cmp	r3, #5
 800bd74:	d826      	bhi.n	800bdc4 <UART_SetConfig+0x52c>
 800bd76:	a201      	add	r2, pc, #4	@ (adr r2, 800bd7c <UART_SetConfig+0x4e4>)
 800bd78:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bd7c:	0800bd95 	.word	0x0800bd95
 800bd80:	0800bd9d 	.word	0x0800bd9d
 800bd84:	0800bda5 	.word	0x0800bda5
 800bd88:	0800bdad 	.word	0x0800bdad
 800bd8c:	0800bdb5 	.word	0x0800bdb5
 800bd90:	0800bdbd 	.word	0x0800bdbd
 800bd94:	2300      	movs	r3, #0
 800bd96:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bd9a:	e050      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bd9c:	2304      	movs	r3, #4
 800bd9e:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bda2:	e04c      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bda4:	2308      	movs	r3, #8
 800bda6:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bdaa:	e048      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bdac:	2310      	movs	r3, #16
 800bdae:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bdb2:	e044      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bdb4:	2320      	movs	r3, #32
 800bdb6:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bdba:	e040      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bdbc:	2340      	movs	r3, #64	@ 0x40
 800bdbe:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bdc2:	e03c      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bdc4:	2380      	movs	r3, #128	@ 0x80
 800bdc6:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800bdca:	e038      	b.n	800be3e <UART_SetConfig+0x5a6>
 800bdcc:	697b      	ldr	r3, [r7, #20]
 800bdce:	681b      	ldr	r3, [r3, #0]
 800bdd0:	4a5b      	ldr	r2, [pc, #364]	@ (800bf40 <UART_SetConfig+0x6a8>)
 800bdd2:	4293      	cmp	r3, r2
 800bdd4:	d130      	bne.n	800be38 <UART_SetConfig+0x5a0>
 800bdd6:	4b57      	ldr	r3, [pc, #348]	@ (800bf34 <UART_SetConfig+0x69c>)
 800bdd8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 800bdda:	f003 0307 	and.w	r3, r3, #7
 800bdde:	2b05      	cmp	r3, #5
 800bde0:	d826      	bhi.n	800be30 <UART_SetConfig+0x598>
 800bde2:	a201      	add	r2, pc, #4	@ (adr r2, 800bde8 <UART_SetConfig+0x550>)
 800bde4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800bde8:	0800be01 	.word	0x0800be01
 800bdec:	0800be09 	.word	0x0800be09
 800bdf0:	0800be11 	.word	0x0800be11
 800bdf4:	0800be19 	.word	0x0800be19
 800bdf8:	0800be21 	.word	0x0800be21
 800bdfc:	0800be29 	.word	0x0800be29
 800be00:	2302      	movs	r3, #2
 800be02:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800be06:	e01a      	b.n	800be3e <UART_SetConfig+0x5a6>
 800be08:	2304      	movs	r3, #4
 800be0a:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800be0e:	e016      	b.n	800be3e <UART_SetConfig+0x5a6>
 800be10:	2308      	movs	r3, #8
 800be12:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800be16:	e012      	b.n	800be3e <UART_SetConfig+0x5a6>
 800be18:	2310      	movs	r3, #16
 800be1a:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800be1e:	e00e      	b.n	800be3e <UART_SetConfig+0x5a6>
 800be20:	2320      	movs	r3, #32
 800be22:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800be26:	e00a      	b.n	800be3e <UART_SetConfig+0x5a6>
 800be28:	2340      	movs	r3, #64	@ 0x40
 800be2a:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800be2e:	e006      	b.n	800be3e <UART_SetConfig+0x5a6>
 800be30:	2380      	movs	r3, #128	@ 0x80
 800be32:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43
 800be36:	e002      	b.n	800be3e <UART_SetConfig+0x5a6>
 800be38:	2380      	movs	r3, #128	@ 0x80
 800be3a:	f887 3043 	strb.w	r3, [r7, #67]	@ 0x43

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
 800be3e:	697b      	ldr	r3, [r7, #20]
 800be40:	681b      	ldr	r3, [r3, #0]
 800be42:	4a3f      	ldr	r2, [pc, #252]	@ (800bf40 <UART_SetConfig+0x6a8>)
 800be44:	4293      	cmp	r3, r2
 800be46:	f040 80f8 	bne.w	800c03a <UART_SetConfig+0x7a2>
  {
    /* Retrieve frequency clock */
    switch (clocksource)
 800be4a:	f897 3043 	ldrb.w	r3, [r7, #67]	@ 0x43
 800be4e:	2b20      	cmp	r3, #32
 800be50:	dc46      	bgt.n	800bee0 <UART_SetConfig+0x648>
 800be52:	2b02      	cmp	r3, #2
 800be54:	f2c0 8082 	blt.w	800bf5c <UART_SetConfig+0x6c4>
 800be58:	3b02      	subs	r3, #2
 800be5a:	2b1e      	cmp	r3, #30
 800be5c:	d87e      	bhi.n	800bf5c <UART_SetConfig+0x6c4>
 800be5e:	a201      	add	r2, pc, #4	@ (adr r2, 800be64 <UART_SetConfig+0x5cc>)
 800be60:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800be64:	0800bee7 	.word	0x0800bee7
 800be68:	0800bf5d 	.word	0x0800bf5d
 800be6c:	0800beef 	.word	0x0800beef
 800be70:	0800bf5d 	.word	0x0800bf5d
 800be74:	0800bf5d 	.word	0x0800bf5d
 800be78:	0800bf5d 	.word	0x0800bf5d
 800be7c:	0800beff 	.word	0x0800beff
 800be80:	0800bf5d 	.word	0x0800bf5d
 800be84:	0800bf5d 	.word	0x0800bf5d
 800be88:	0800bf5d 	.word	0x0800bf5d
 800be8c:	0800bf5d 	.word	0x0800bf5d
 800be90:	0800bf5d 	.word	0x0800bf5d
 800be94:	0800bf5d 	.word	0x0800bf5d
 800be98:	0800bf5d 	.word	0x0800bf5d
 800be9c:	0800bf0f 	.word	0x0800bf0f
 800bea0:	0800bf5d 	.word	0x0800bf5d
 800bea4:	0800bf5d 	.word	0x0800bf5d
 800bea8:	0800bf5d 	.word	0x0800bf5d
 800beac:	0800bf5d 	.word	0x0800bf5d
 800beb0:	0800bf5d 	.word	0x0800bf5d
 800beb4:	0800bf5d 	.word	0x0800bf5d
 800beb8:	0800bf5d 	.word	0x0800bf5d
 800bebc:	0800bf5d 	.word	0x0800bf5d
 800bec0:	0800bf5d 	.word	0x0800bf5d
 800bec4:	0800bf5d 	.word	0x0800bf5d
 800bec8:	0800bf5d 	.word	0x0800bf5d
 800becc:	0800bf5d 	.word	0x0800bf5d
 800bed0:	0800bf5d 	.word	0x0800bf5d
 800bed4:	0800bf5d 	.word	0x0800bf5d
 800bed8:	0800bf5d 	.word	0x0800bf5d
 800bedc:	0800bf4f 	.word	0x0800bf4f
 800bee0:	2b40      	cmp	r3, #64	@ 0x40
 800bee2:	d037      	beq.n	800bf54 <UART_SetConfig+0x6bc>
 800bee4:	e03a      	b.n	800bf5c <UART_SetConfig+0x6c4>
    {
      case UART_CLOCKSOURCE_D3PCLK1:
        pclk = HAL_RCCEx_GetD3PCLK1Freq();
 800bee6:	f7fe f933 	bl	800a150 <HAL_RCCEx_GetD3PCLK1Freq>
 800beea:	63f8      	str	r0, [r7, #60]	@ 0x3c
        break;
 800beec:	e03c      	b.n	800bf68 <UART_SetConfig+0x6d0>
      case UART_CLOCKSOURCE_PLL2:
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800beee:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800bef2:	4618      	mov	r0, r3
 800bef4:	f7fe f942 	bl	800a17c <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 800bef8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800befa:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800befc:	e034      	b.n	800bf68 <UART_SetConfig+0x6d0>
      case UART_CLOCKSOURCE_PLL3:
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800befe:	f107 0318 	add.w	r3, r7, #24
 800bf02:	4618      	mov	r0, r3
 800bf04:	f7fe fa8e 	bl	800a424 <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 800bf08:	69fb      	ldr	r3, [r7, #28]
 800bf0a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bf0c:	e02c      	b.n	800bf68 <UART_SetConfig+0x6d0>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800bf0e:	4b09      	ldr	r3, [pc, #36]	@ (800bf34 <UART_SetConfig+0x69c>)
 800bf10:	681b      	ldr	r3, [r3, #0]
 800bf12:	f003 0320 	and.w	r3, r3, #32
 800bf16:	2b00      	cmp	r3, #0
 800bf18:	d016      	beq.n	800bf48 <UART_SetConfig+0x6b0>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 800bf1a:	4b06      	ldr	r3, [pc, #24]	@ (800bf34 <UART_SetConfig+0x69c>)
 800bf1c:	681b      	ldr	r3, [r3, #0]
 800bf1e:	08db      	lsrs	r3, r3, #3
 800bf20:	f003 0303 	and.w	r3, r3, #3
 800bf24:	4a07      	ldr	r2, [pc, #28]	@ (800bf44 <UART_SetConfig+0x6ac>)
 800bf26:	fa22 f303 	lsr.w	r3, r2, r3
 800bf2a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 800bf2c:	e01c      	b.n	800bf68 <UART_SetConfig+0x6d0>
 800bf2e:	bf00      	nop
 800bf30:	40011400 	.word	0x40011400
 800bf34:	58024400 	.word	0x58024400
 800bf38:	40007800 	.word	0x40007800
 800bf3c:	40007c00 	.word	0x40007c00
 800bf40:	58000c00 	.word	0x58000c00
 800bf44:	03d09000 	.word	0x03d09000
          pclk = (uint32_t) HSI_VALUE;
 800bf48:	4b9d      	ldr	r3, [pc, #628]	@ (800c1c0 <UART_SetConfig+0x928>)
 800bf4a:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bf4c:	e00c      	b.n	800bf68 <UART_SetConfig+0x6d0>
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
 800bf4e:	4b9d      	ldr	r3, [pc, #628]	@ (800c1c4 <UART_SetConfig+0x92c>)
 800bf50:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bf52:	e009      	b.n	800bf68 <UART_SetConfig+0x6d0>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 800bf54:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 800bf58:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800bf5a:	e005      	b.n	800bf68 <UART_SetConfig+0x6d0>
      default:
        pclk = 0U;
 800bf5c:	2300      	movs	r3, #0
 800bf5e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        ret = HAL_ERROR;
 800bf60:	2301      	movs	r3, #1
 800bf62:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42
        break;
 800bf66:	bf00      	nop
    }

    /* If proper clock source reported */
    if (pclk != 0U)
 800bf68:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800bf6a:	2b00      	cmp	r3, #0
 800bf6c:	f000 81de 	beq.w	800c32c <UART_SetConfig+0xa94>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
 800bf70:	697b      	ldr	r3, [r7, #20]
 800bf72:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bf74:	4a94      	ldr	r2, [pc, #592]	@ (800c1c8 <UART_SetConfig+0x930>)
 800bf76:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800bf7a:	461a      	mov	r2, r3
 800bf7c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800bf7e:	fbb3 f3f2 	udiv	r3, r3, r2
 800bf82:	633b      	str	r3, [r7, #48]	@ 0x30

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800bf84:	697b      	ldr	r3, [r7, #20]
 800bf86:	685a      	ldr	r2, [r3, #4]
 800bf88:	4613      	mov	r3, r2
 800bf8a:	005b      	lsls	r3, r3, #1
 800bf8c:	4413      	add	r3, r2
 800bf8e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800bf90:	429a      	cmp	r2, r3
 800bf92:	d305      	bcc.n	800bfa0 <UART_SetConfig+0x708>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
 800bf94:	697b      	ldr	r3, [r7, #20]
 800bf96:	685b      	ldr	r3, [r3, #4]
 800bf98:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 800bf9a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800bf9c:	429a      	cmp	r2, r3
 800bf9e:	d903      	bls.n	800bfa8 <UART_SetConfig+0x710>
      {
        ret = HAL_ERROR;
 800bfa0:	2301      	movs	r3, #1
 800bfa2:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42
 800bfa6:	e1c1      	b.n	800c32c <UART_SetConfig+0xa94>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800bfa8:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800bfaa:	2200      	movs	r2, #0
 800bfac:	60bb      	str	r3, [r7, #8]
 800bfae:	60fa      	str	r2, [r7, #12]
 800bfb0:	697b      	ldr	r3, [r7, #20]
 800bfb2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800bfb4:	4a84      	ldr	r2, [pc, #528]	@ (800c1c8 <UART_SetConfig+0x930>)
 800bfb6:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800bfba:	b29b      	uxth	r3, r3
 800bfbc:	2200      	movs	r2, #0
 800bfbe:	603b      	str	r3, [r7, #0]
 800bfc0:	607a      	str	r2, [r7, #4]
 800bfc2:	e9d7 2300 	ldrd	r2, r3, [r7]
 800bfc6:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 800bfca:	f7f4 faef 	bl	80005ac <__aeabi_uldivmod>
 800bfce:	4602      	mov	r2, r0
 800bfd0:	460b      	mov	r3, r1
 800bfd2:	4610      	mov	r0, r2
 800bfd4:	4619      	mov	r1, r3
 800bfd6:	f04f 0200 	mov.w	r2, #0
 800bfda:	f04f 0300 	mov.w	r3, #0
 800bfde:	020b      	lsls	r3, r1, #8
 800bfe0:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
 800bfe4:	0202      	lsls	r2, r0, #8
 800bfe6:	6979      	ldr	r1, [r7, #20]
 800bfe8:	6849      	ldr	r1, [r1, #4]
 800bfea:	0849      	lsrs	r1, r1, #1
 800bfec:	2000      	movs	r0, #0
 800bfee:	460c      	mov	r4, r1
 800bff0:	4605      	mov	r5, r0
 800bff2:	eb12 0804 	adds.w	r8, r2, r4
 800bff6:	eb43 0905 	adc.w	r9, r3, r5
 800bffa:	697b      	ldr	r3, [r7, #20]
 800bffc:	685b      	ldr	r3, [r3, #4]
 800bffe:	2200      	movs	r2, #0
 800c000:	469a      	mov	sl, r3
 800c002:	4693      	mov	fp, r2
 800c004:	4652      	mov	r2, sl
 800c006:	465b      	mov	r3, fp
 800c008:	4640      	mov	r0, r8
 800c00a:	4649      	mov	r1, r9
 800c00c:	f7f4 face 	bl	80005ac <__aeabi_uldivmod>
 800c010:	4602      	mov	r2, r0
 800c012:	460b      	mov	r3, r1
 800c014:	4613      	mov	r3, r2
 800c016:	63bb      	str	r3, [r7, #56]	@ 0x38
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 800c018:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c01a:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 800c01e:	d308      	bcc.n	800c032 <UART_SetConfig+0x79a>
 800c020:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c022:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 800c026:	d204      	bcs.n	800c032 <UART_SetConfig+0x79a>
        {
          huart->Instance->BRR = usartdiv;
 800c028:	697b      	ldr	r3, [r7, #20]
 800c02a:	681b      	ldr	r3, [r3, #0]
 800c02c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 800c02e:	60da      	str	r2, [r3, #12]
 800c030:	e17c      	b.n	800c32c <UART_SetConfig+0xa94>
        }
        else
        {
          ret = HAL_ERROR;
 800c032:	2301      	movs	r3, #1
 800c034:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42
 800c038:	e178      	b.n	800c32c <UART_SetConfig+0xa94>
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800c03a:	697b      	ldr	r3, [r7, #20]
 800c03c:	69db      	ldr	r3, [r3, #28]
 800c03e:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 800c042:	f040 80c5 	bne.w	800c1d0 <UART_SetConfig+0x938>
  {
    switch (clocksource)
 800c046:	f897 3043 	ldrb.w	r3, [r7, #67]	@ 0x43
 800c04a:	2b20      	cmp	r3, #32
 800c04c:	dc48      	bgt.n	800c0e0 <UART_SetConfig+0x848>
 800c04e:	2b00      	cmp	r3, #0
 800c050:	db7b      	blt.n	800c14a <UART_SetConfig+0x8b2>
 800c052:	2b20      	cmp	r3, #32
 800c054:	d879      	bhi.n	800c14a <UART_SetConfig+0x8b2>
 800c056:	a201      	add	r2, pc, #4	@ (adr r2, 800c05c <UART_SetConfig+0x7c4>)
 800c058:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c05c:	0800c0e7 	.word	0x0800c0e7
 800c060:	0800c0ef 	.word	0x0800c0ef
 800c064:	0800c14b 	.word	0x0800c14b
 800c068:	0800c14b 	.word	0x0800c14b
 800c06c:	0800c0f7 	.word	0x0800c0f7
 800c070:	0800c14b 	.word	0x0800c14b
 800c074:	0800c14b 	.word	0x0800c14b
 800c078:	0800c14b 	.word	0x0800c14b
 800c07c:	0800c107 	.word	0x0800c107
 800c080:	0800c14b 	.word	0x0800c14b
 800c084:	0800c14b 	.word	0x0800c14b
 800c088:	0800c14b 	.word	0x0800c14b
 800c08c:	0800c14b 	.word	0x0800c14b
 800c090:	0800c14b 	.word	0x0800c14b
 800c094:	0800c14b 	.word	0x0800c14b
 800c098:	0800c14b 	.word	0x0800c14b
 800c09c:	0800c117 	.word	0x0800c117
 800c0a0:	0800c14b 	.word	0x0800c14b
 800c0a4:	0800c14b 	.word	0x0800c14b
 800c0a8:	0800c14b 	.word	0x0800c14b
 800c0ac:	0800c14b 	.word	0x0800c14b
 800c0b0:	0800c14b 	.word	0x0800c14b
 800c0b4:	0800c14b 	.word	0x0800c14b
 800c0b8:	0800c14b 	.word	0x0800c14b
 800c0bc:	0800c14b 	.word	0x0800c14b
 800c0c0:	0800c14b 	.word	0x0800c14b
 800c0c4:	0800c14b 	.word	0x0800c14b
 800c0c8:	0800c14b 	.word	0x0800c14b
 800c0cc:	0800c14b 	.word	0x0800c14b
 800c0d0:	0800c14b 	.word	0x0800c14b
 800c0d4:	0800c14b 	.word	0x0800c14b
 800c0d8:	0800c14b 	.word	0x0800c14b
 800c0dc:	0800c13d 	.word	0x0800c13d
 800c0e0:	2b40      	cmp	r3, #64	@ 0x40
 800c0e2:	d02e      	beq.n	800c142 <UART_SetConfig+0x8aa>
 800c0e4:	e031      	b.n	800c14a <UART_SetConfig+0x8b2>
    {
      case UART_CLOCKSOURCE_D2PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 800c0e6:	f7fc f83b 	bl	8008160 <HAL_RCC_GetPCLK1Freq>
 800c0ea:	63f8      	str	r0, [r7, #60]	@ 0x3c
        break;
 800c0ec:	e033      	b.n	800c156 <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_D2PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 800c0ee:	f7fc f84d 	bl	800818c <HAL_RCC_GetPCLK2Freq>
 800c0f2:	63f8      	str	r0, [r7, #60]	@ 0x3c
        break;
 800c0f4:	e02f      	b.n	800c156 <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_PLL2:
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800c0f6:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800c0fa:	4618      	mov	r0, r3
 800c0fc:	f7fe f83e 	bl	800a17c <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 800c100:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c102:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c104:	e027      	b.n	800c156 <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_PLL3:
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800c106:	f107 0318 	add.w	r3, r7, #24
 800c10a:	4618      	mov	r0, r3
 800c10c:	f7fe f98a 	bl	800a424 <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 800c110:	69fb      	ldr	r3, [r7, #28]
 800c112:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c114:	e01f      	b.n	800c156 <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800c116:	4b2d      	ldr	r3, [pc, #180]	@ (800c1cc <UART_SetConfig+0x934>)
 800c118:	681b      	ldr	r3, [r3, #0]
 800c11a:	f003 0320 	and.w	r3, r3, #32
 800c11e:	2b00      	cmp	r3, #0
 800c120:	d009      	beq.n	800c136 <UART_SetConfig+0x89e>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 800c122:	4b2a      	ldr	r3, [pc, #168]	@ (800c1cc <UART_SetConfig+0x934>)
 800c124:	681b      	ldr	r3, [r3, #0]
 800c126:	08db      	lsrs	r3, r3, #3
 800c128:	f003 0303 	and.w	r3, r3, #3
 800c12c:	4a24      	ldr	r2, [pc, #144]	@ (800c1c0 <UART_SetConfig+0x928>)
 800c12e:	fa22 f303 	lsr.w	r3, r2, r3
 800c132:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 800c134:	e00f      	b.n	800c156 <UART_SetConfig+0x8be>
          pclk = (uint32_t) HSI_VALUE;
 800c136:	4b22      	ldr	r3, [pc, #136]	@ (800c1c0 <UART_SetConfig+0x928>)
 800c138:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c13a:	e00c      	b.n	800c156 <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
 800c13c:	4b21      	ldr	r3, [pc, #132]	@ (800c1c4 <UART_SetConfig+0x92c>)
 800c13e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c140:	e009      	b.n	800c156 <UART_SetConfig+0x8be>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 800c142:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 800c146:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c148:	e005      	b.n	800c156 <UART_SetConfig+0x8be>
      default:
        pclk = 0U;
 800c14a:	2300      	movs	r3, #0
 800c14c:	63fb      	str	r3, [r7, #60]	@ 0x3c
        ret = HAL_ERROR;
 800c14e:	2301      	movs	r3, #1
 800c150:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42
        break;
 800c154:	bf00      	nop
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
 800c156:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800c158:	2b00      	cmp	r3, #0
 800c15a:	f000 80e7 	beq.w	800c32c <UART_SetConfig+0xa94>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800c15e:	697b      	ldr	r3, [r7, #20]
 800c160:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c162:	4a19      	ldr	r2, [pc, #100]	@ (800c1c8 <UART_SetConfig+0x930>)
 800c164:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800c168:	461a      	mov	r2, r3
 800c16a:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800c16c:	fbb3 f3f2 	udiv	r3, r3, r2
 800c170:	005a      	lsls	r2, r3, #1
 800c172:	697b      	ldr	r3, [r7, #20]
 800c174:	685b      	ldr	r3, [r3, #4]
 800c176:	085b      	lsrs	r3, r3, #1
 800c178:	441a      	add	r2, r3
 800c17a:	697b      	ldr	r3, [r7, #20]
 800c17c:	685b      	ldr	r3, [r3, #4]
 800c17e:	fbb2 f3f3 	udiv	r3, r2, r3
 800c182:	63bb      	str	r3, [r7, #56]	@ 0x38
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800c184:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c186:	2b0f      	cmp	r3, #15
 800c188:	d916      	bls.n	800c1b8 <UART_SetConfig+0x920>
 800c18a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c18c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800c190:	d212      	bcs.n	800c1b8 <UART_SetConfig+0x920>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800c192:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c194:	b29b      	uxth	r3, r3
 800c196:	f023 030f 	bic.w	r3, r3, #15
 800c19a:	86fb      	strh	r3, [r7, #54]	@ 0x36
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800c19c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c19e:	085b      	lsrs	r3, r3, #1
 800c1a0:	b29b      	uxth	r3, r3
 800c1a2:	f003 0307 	and.w	r3, r3, #7
 800c1a6:	b29a      	uxth	r2, r3
 800c1a8:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
 800c1aa:	4313      	orrs	r3, r2
 800c1ac:	86fb      	strh	r3, [r7, #54]	@ 0x36
        huart->Instance->BRR = brrtemp;
 800c1ae:	697b      	ldr	r3, [r7, #20]
 800c1b0:	681b      	ldr	r3, [r3, #0]
 800c1b2:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 800c1b4:	60da      	str	r2, [r3, #12]
 800c1b6:	e0b9      	b.n	800c32c <UART_SetConfig+0xa94>
      }
      else
      {
        ret = HAL_ERROR;
 800c1b8:	2301      	movs	r3, #1
 800c1ba:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42
 800c1be:	e0b5      	b.n	800c32c <UART_SetConfig+0xa94>
 800c1c0:	03d09000 	.word	0x03d09000
 800c1c4:	003d0900 	.word	0x003d0900
 800c1c8:	0801869c 	.word	0x0801869c
 800c1cc:	58024400 	.word	0x58024400
      }
    }
  }
  else
  {
    switch (clocksource)
 800c1d0:	f897 3043 	ldrb.w	r3, [r7, #67]	@ 0x43
 800c1d4:	2b20      	cmp	r3, #32
 800c1d6:	dc49      	bgt.n	800c26c <UART_SetConfig+0x9d4>
 800c1d8:	2b00      	cmp	r3, #0
 800c1da:	db7c      	blt.n	800c2d6 <UART_SetConfig+0xa3e>
 800c1dc:	2b20      	cmp	r3, #32
 800c1de:	d87a      	bhi.n	800c2d6 <UART_SetConfig+0xa3e>
 800c1e0:	a201      	add	r2, pc, #4	@ (adr r2, 800c1e8 <UART_SetConfig+0x950>)
 800c1e2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c1e6:	bf00      	nop
 800c1e8:	0800c273 	.word	0x0800c273
 800c1ec:	0800c27b 	.word	0x0800c27b
 800c1f0:	0800c2d7 	.word	0x0800c2d7
 800c1f4:	0800c2d7 	.word	0x0800c2d7
 800c1f8:	0800c283 	.word	0x0800c283
 800c1fc:	0800c2d7 	.word	0x0800c2d7
 800c200:	0800c2d7 	.word	0x0800c2d7
 800c204:	0800c2d7 	.word	0x0800c2d7
 800c208:	0800c293 	.word	0x0800c293
 800c20c:	0800c2d7 	.word	0x0800c2d7
 800c210:	0800c2d7 	.word	0x0800c2d7
 800c214:	0800c2d7 	.word	0x0800c2d7
 800c218:	0800c2d7 	.word	0x0800c2d7
 800c21c:	0800c2d7 	.word	0x0800c2d7
 800c220:	0800c2d7 	.word	0x0800c2d7
 800c224:	0800c2d7 	.word	0x0800c2d7
 800c228:	0800c2a3 	.word	0x0800c2a3
 800c22c:	0800c2d7 	.word	0x0800c2d7
 800c230:	0800c2d7 	.word	0x0800c2d7
 800c234:	0800c2d7 	.word	0x0800c2d7
 800c238:	0800c2d7 	.word	0x0800c2d7
 800c23c:	0800c2d7 	.word	0x0800c2d7
 800c240:	0800c2d7 	.word	0x0800c2d7
 800c244:	0800c2d7 	.word	0x0800c2d7
 800c248:	0800c2d7 	.word	0x0800c2d7
 800c24c:	0800c2d7 	.word	0x0800c2d7
 800c250:	0800c2d7 	.word	0x0800c2d7
 800c254:	0800c2d7 	.word	0x0800c2d7
 800c258:	0800c2d7 	.word	0x0800c2d7
 800c25c:	0800c2d7 	.word	0x0800c2d7
 800c260:	0800c2d7 	.word	0x0800c2d7
 800c264:	0800c2d7 	.word	0x0800c2d7
 800c268:	0800c2c9 	.word	0x0800c2c9
 800c26c:	2b40      	cmp	r3, #64	@ 0x40
 800c26e:	d02e      	beq.n	800c2ce <UART_SetConfig+0xa36>
 800c270:	e031      	b.n	800c2d6 <UART_SetConfig+0xa3e>
    {
      case UART_CLOCKSOURCE_D2PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
 800c272:	f7fb ff75 	bl	8008160 <HAL_RCC_GetPCLK1Freq>
 800c276:	63f8      	str	r0, [r7, #60]	@ 0x3c
        break;
 800c278:	e033      	b.n	800c2e2 <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_D2PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
 800c27a:	f7fb ff87 	bl	800818c <HAL_RCC_GetPCLK2Freq>
 800c27e:	63f8      	str	r0, [r7, #60]	@ 0x3c
        break;
 800c280:	e02f      	b.n	800c2e2 <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_PLL2:
        HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800c282:	f107 0324 	add.w	r3, r7, #36	@ 0x24
 800c286:	4618      	mov	r0, r3
 800c288:	f7fd ff78 	bl	800a17c <HAL_RCCEx_GetPLL2ClockFreq>
        pclk = pll2_clocks.PLL2_Q_Frequency;
 800c28c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c28e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c290:	e027      	b.n	800c2e2 <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_PLL3:
        HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800c292:	f107 0318 	add.w	r3, r7, #24
 800c296:	4618      	mov	r0, r3
 800c298:	f7fe f8c4 	bl	800a424 <HAL_RCCEx_GetPLL3ClockFreq>
        pclk = pll3_clocks.PLL3_Q_Frequency;
 800c29c:	69fb      	ldr	r3, [r7, #28]
 800c29e:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c2a0:	e01f      	b.n	800c2e2 <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800c2a2:	4b2d      	ldr	r3, [pc, #180]	@ (800c358 <UART_SetConfig+0xac0>)
 800c2a4:	681b      	ldr	r3, [r3, #0]
 800c2a6:	f003 0320 	and.w	r3, r3, #32
 800c2aa:	2b00      	cmp	r3, #0
 800c2ac:	d009      	beq.n	800c2c2 <UART_SetConfig+0xa2a>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
 800c2ae:	4b2a      	ldr	r3, [pc, #168]	@ (800c358 <UART_SetConfig+0xac0>)
 800c2b0:	681b      	ldr	r3, [r3, #0]
 800c2b2:	08db      	lsrs	r3, r3, #3
 800c2b4:	f003 0303 	and.w	r3, r3, #3
 800c2b8:	4a28      	ldr	r2, [pc, #160]	@ (800c35c <UART_SetConfig+0xac4>)
 800c2ba:	fa22 f303 	lsr.w	r3, r2, r3
 800c2be:	63fb      	str	r3, [r7, #60]	@ 0x3c
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
 800c2c0:	e00f      	b.n	800c2e2 <UART_SetConfig+0xa4a>
          pclk = (uint32_t) HSI_VALUE;
 800c2c2:	4b26      	ldr	r3, [pc, #152]	@ (800c35c <UART_SetConfig+0xac4>)
 800c2c4:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c2c6:	e00c      	b.n	800c2e2 <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
 800c2c8:	4b25      	ldr	r3, [pc, #148]	@ (800c360 <UART_SetConfig+0xac8>)
 800c2ca:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c2cc:	e009      	b.n	800c2e2 <UART_SetConfig+0xa4a>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
 800c2ce:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
 800c2d2:	63fb      	str	r3, [r7, #60]	@ 0x3c
        break;
 800c2d4:	e005      	b.n	800c2e2 <UART_SetConfig+0xa4a>
      default:
        pclk = 0U;
 800c2d6:	2300      	movs	r3, #0
 800c2d8:	63fb      	str	r3, [r7, #60]	@ 0x3c
        ret = HAL_ERROR;
 800c2da:	2301      	movs	r3, #1
 800c2dc:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42
        break;
 800c2e0:	bf00      	nop
    }

    if (pclk != 0U)
 800c2e2:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800c2e4:	2b00      	cmp	r3, #0
 800c2e6:	d021      	beq.n	800c32c <UART_SetConfig+0xa94>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800c2e8:	697b      	ldr	r3, [r7, #20]
 800c2ea:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800c2ec:	4a1d      	ldr	r2, [pc, #116]	@ (800c364 <UART_SetConfig+0xacc>)
 800c2ee:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800c2f2:	461a      	mov	r2, r3
 800c2f4:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800c2f6:	fbb3 f2f2 	udiv	r2, r3, r2
 800c2fa:	697b      	ldr	r3, [r7, #20]
 800c2fc:	685b      	ldr	r3, [r3, #4]
 800c2fe:	085b      	lsrs	r3, r3, #1
 800c300:	441a      	add	r2, r3
 800c302:	697b      	ldr	r3, [r7, #20]
 800c304:	685b      	ldr	r3, [r3, #4]
 800c306:	fbb2 f3f3 	udiv	r3, r2, r3
 800c30a:	63bb      	str	r3, [r7, #56]	@ 0x38
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800c30c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c30e:	2b0f      	cmp	r3, #15
 800c310:	d909      	bls.n	800c326 <UART_SetConfig+0xa8e>
 800c312:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c314:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 800c318:	d205      	bcs.n	800c326 <UART_SetConfig+0xa8e>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
 800c31a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c31c:	b29a      	uxth	r2, r3
 800c31e:	697b      	ldr	r3, [r7, #20]
 800c320:	681b      	ldr	r3, [r3, #0]
 800c322:	60da      	str	r2, [r3, #12]
 800c324:	e002      	b.n	800c32c <UART_SetConfig+0xa94>
      }
      else
      {
        ret = HAL_ERROR;
 800c326:	2301      	movs	r3, #1
 800c328:	f887 3042 	strb.w	r3, [r7, #66]	@ 0x42
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
 800c32c:	697b      	ldr	r3, [r7, #20]
 800c32e:	2201      	movs	r2, #1
 800c330:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
  huart->NbRxDataToProcess = 1;
 800c334:	697b      	ldr	r3, [r7, #20]
 800c336:	2201      	movs	r2, #1
 800c338:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 800c33c:	697b      	ldr	r3, [r7, #20]
 800c33e:	2200      	movs	r2, #0
 800c340:	675a      	str	r2, [r3, #116]	@ 0x74
  huart->TxISR = NULL;
 800c342:	697b      	ldr	r3, [r7, #20]
 800c344:	2200      	movs	r2, #0
 800c346:	679a      	str	r2, [r3, #120]	@ 0x78

  return ret;
 800c348:	f897 3042 	ldrb.w	r3, [r7, #66]	@ 0x42
}
 800c34c:	4618      	mov	r0, r3
 800c34e:	3748      	adds	r7, #72	@ 0x48
 800c350:	46bd      	mov	sp, r7
 800c352:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 800c356:	bf00      	nop
 800c358:	58024400 	.word	0x58024400
 800c35c:	03d09000 	.word	0x03d09000
 800c360:	003d0900 	.word	0x003d0900
 800c364:	0801869c 	.word	0x0801869c

0800c368 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 800c368:	b480      	push	{r7}
 800c36a:	b083      	sub	sp, #12
 800c36c:	af00      	add	r7, sp, #0
 800c36e:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800c370:	687b      	ldr	r3, [r7, #4]
 800c372:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800c374:	f003 0308 	and.w	r3, r3, #8
 800c378:	2b00      	cmp	r3, #0
 800c37a:	d00a      	beq.n	800c392 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800c37c:	687b      	ldr	r3, [r7, #4]
 800c37e:	681b      	ldr	r3, [r3, #0]
 800c380:	685b      	ldr	r3, [r3, #4]
 800c382:	f423 4100 	bic.w	r1, r3, #32768	@ 0x8000
 800c386:	687b      	ldr	r3, [r7, #4]
 800c388:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 800c38a:	687b      	ldr	r3, [r7, #4]
 800c38c:	681b      	ldr	r3, [r3, #0]
 800c38e:	430a      	orrs	r2, r1
 800c390:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800c392:	687b      	ldr	r3, [r7, #4]
 800c394:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800c396:	f003 0301 	and.w	r3, r3, #1
 800c39a:	2b00      	cmp	r3, #0
 800c39c:	d00a      	beq.n	800c3b4 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 800c39e:	687b      	ldr	r3, [r7, #4]
 800c3a0:	681b      	ldr	r3, [r3, #0]
 800c3a2:	685b      	ldr	r3, [r3, #4]
 800c3a4:	f423 3100 	bic.w	r1, r3, #131072	@ 0x20000
 800c3a8:	687b      	ldr	r3, [r7, #4]
 800c3aa:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800c3ac:	687b      	ldr	r3, [r7, #4]
 800c3ae:	681b      	ldr	r3, [r3, #0]
 800c3b0:	430a      	orrs	r2, r1
 800c3b2:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800c3b4:	687b      	ldr	r3, [r7, #4]
 800c3b6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800c3b8:	f003 0302 	and.w	r3, r3, #2
 800c3bc:	2b00      	cmp	r3, #0
 800c3be:	d00a      	beq.n	800c3d6 <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 800c3c0:	687b      	ldr	r3, [r7, #4]
 800c3c2:	681b      	ldr	r3, [r3, #0]
 800c3c4:	685b      	ldr	r3, [r3, #4]
 800c3c6:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
 800c3ca:	687b      	ldr	r3, [r7, #4]
 800c3cc:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800c3ce:	687b      	ldr	r3, [r7, #4]
 800c3d0:	681b      	ldr	r3, [r3, #0]
 800c3d2:	430a      	orrs	r2, r1
 800c3d4:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 800c3d6:	687b      	ldr	r3, [r7, #4]
 800c3d8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800c3da:	f003 0304 	and.w	r3, r3, #4
 800c3de:	2b00      	cmp	r3, #0
 800c3e0:	d00a      	beq.n	800c3f8 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 800c3e2:	687b      	ldr	r3, [r7, #4]
 800c3e4:	681b      	ldr	r3, [r3, #0]
 800c3e6:	685b      	ldr	r3, [r3, #4]
 800c3e8:	f423 2180 	bic.w	r1, r3, #262144	@ 0x40000
 800c3ec:	687b      	ldr	r3, [r7, #4]
 800c3ee:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 800c3f0:	687b      	ldr	r3, [r7, #4]
 800c3f2:	681b      	ldr	r3, [r3, #0]
 800c3f4:	430a      	orrs	r2, r1
 800c3f6:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 800c3f8:	687b      	ldr	r3, [r7, #4]
 800c3fa:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800c3fc:	f003 0310 	and.w	r3, r3, #16
 800c400:	2b00      	cmp	r3, #0
 800c402:	d00a      	beq.n	800c41a <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800c404:	687b      	ldr	r3, [r7, #4]
 800c406:	681b      	ldr	r3, [r3, #0]
 800c408:	689b      	ldr	r3, [r3, #8]
 800c40a:	f423 5180 	bic.w	r1, r3, #4096	@ 0x1000
 800c40e:	687b      	ldr	r3, [r7, #4]
 800c410:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
 800c412:	687b      	ldr	r3, [r7, #4]
 800c414:	681b      	ldr	r3, [r3, #0]
 800c416:	430a      	orrs	r2, r1
 800c418:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800c41a:	687b      	ldr	r3, [r7, #4]
 800c41c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800c41e:	f003 0320 	and.w	r3, r3, #32
 800c422:	2b00      	cmp	r3, #0
 800c424:	d00a      	beq.n	800c43c <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800c426:	687b      	ldr	r3, [r7, #4]
 800c428:	681b      	ldr	r3, [r3, #0]
 800c42a:	689b      	ldr	r3, [r3, #8]
 800c42c:	f423 5100 	bic.w	r1, r3, #8192	@ 0x2000
 800c430:	687b      	ldr	r3, [r7, #4]
 800c432:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
 800c434:	687b      	ldr	r3, [r7, #4]
 800c436:	681b      	ldr	r3, [r3, #0]
 800c438:	430a      	orrs	r2, r1
 800c43a:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800c43c:	687b      	ldr	r3, [r7, #4]
 800c43e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800c440:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 800c444:	2b00      	cmp	r3, #0
 800c446:	d01a      	beq.n	800c47e <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800c448:	687b      	ldr	r3, [r7, #4]
 800c44a:	681b      	ldr	r3, [r3, #0]
 800c44c:	685b      	ldr	r3, [r3, #4]
 800c44e:	f423 1180 	bic.w	r1, r3, #1048576	@ 0x100000
 800c452:	687b      	ldr	r3, [r7, #4]
 800c454:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
 800c456:	687b      	ldr	r3, [r7, #4]
 800c458:	681b      	ldr	r3, [r3, #0]
 800c45a:	430a      	orrs	r2, r1
 800c45c:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800c45e:	687b      	ldr	r3, [r7, #4]
 800c460:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 800c462:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 800c466:	d10a      	bne.n	800c47e <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 800c468:	687b      	ldr	r3, [r7, #4]
 800c46a:	681b      	ldr	r3, [r3, #0]
 800c46c:	685b      	ldr	r3, [r3, #4]
 800c46e:	f423 01c0 	bic.w	r1, r3, #6291456	@ 0x600000
 800c472:	687b      	ldr	r3, [r7, #4]
 800c474:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
 800c476:	687b      	ldr	r3, [r7, #4]
 800c478:	681b      	ldr	r3, [r3, #0]
 800c47a:	430a      	orrs	r2, r1
 800c47c:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800c47e:	687b      	ldr	r3, [r7, #4]
 800c480:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800c482:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800c486:	2b00      	cmp	r3, #0
 800c488:	d00a      	beq.n	800c4a0 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 800c48a:	687b      	ldr	r3, [r7, #4]
 800c48c:	681b      	ldr	r3, [r3, #0]
 800c48e:	685b      	ldr	r3, [r3, #4]
 800c490:	f423 2100 	bic.w	r1, r3, #524288	@ 0x80000
 800c494:	687b      	ldr	r3, [r7, #4]
 800c496:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 800c498:	687b      	ldr	r3, [r7, #4]
 800c49a:	681b      	ldr	r3, [r3, #0]
 800c49c:	430a      	orrs	r2, r1
 800c49e:	605a      	str	r2, [r3, #4]
  }
}
 800c4a0:	bf00      	nop
 800c4a2:	370c      	adds	r7, #12
 800c4a4:	46bd      	mov	sp, r7
 800c4a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c4aa:	4770      	bx	lr

0800c4ac <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 800c4ac:	b580      	push	{r7, lr}
 800c4ae:	b098      	sub	sp, #96	@ 0x60
 800c4b0:	af02      	add	r7, sp, #8
 800c4b2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 800c4b4:	687b      	ldr	r3, [r7, #4]
 800c4b6:	2200      	movs	r2, #0
 800c4b8:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
 800c4bc:	f7f5 fd5a 	bl	8001f74 <HAL_GetTick>
 800c4c0:	6578      	str	r0, [r7, #84]	@ 0x54

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800c4c2:	687b      	ldr	r3, [r7, #4]
 800c4c4:	681b      	ldr	r3, [r3, #0]
 800c4c6:	681b      	ldr	r3, [r3, #0]
 800c4c8:	f003 0308 	and.w	r3, r3, #8
 800c4cc:	2b08      	cmp	r3, #8
 800c4ce:	d12f      	bne.n	800c530 <UART_CheckIdleState+0x84>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800c4d0:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 800c4d4:	9300      	str	r3, [sp, #0]
 800c4d6:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800c4d8:	2200      	movs	r2, #0
 800c4da:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
 800c4de:	6878      	ldr	r0, [r7, #4]
 800c4e0:	f000 f88e 	bl	800c600 <UART_WaitOnFlagUntilTimeout>
 800c4e4:	4603      	mov	r3, r0
 800c4e6:	2b00      	cmp	r3, #0
 800c4e8:	d022      	beq.n	800c530 <UART_CheckIdleState+0x84>
    {
      /* Disable TXE interrupt for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
 800c4ea:	687b      	ldr	r3, [r7, #4]
 800c4ec:	681b      	ldr	r3, [r3, #0]
 800c4ee:	63bb      	str	r3, [r7, #56]	@ 0x38
 */
__STATIC_FORCEINLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800c4f0:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c4f2:	e853 3f00 	ldrex	r3, [r3]
 800c4f6:	637b      	str	r3, [r7, #52]	@ 0x34
   return(result);
 800c4f8:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800c4fa:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 800c4fe:	653b      	str	r3, [r7, #80]	@ 0x50
 800c500:	687b      	ldr	r3, [r7, #4]
 800c502:	681b      	ldr	r3, [r3, #0]
 800c504:	461a      	mov	r2, r3
 800c506:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 800c508:	647b      	str	r3, [r7, #68]	@ 0x44
 800c50a:	643a      	str	r2, [r7, #64]	@ 0x40
 */
__STATIC_FORCEINLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800c50c:	6c39      	ldr	r1, [r7, #64]	@ 0x40
 800c50e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 800c510:	e841 2300 	strex	r3, r2, [r1]
 800c514:	63fb      	str	r3, [r7, #60]	@ 0x3c
   return(result);
 800c516:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 800c518:	2b00      	cmp	r3, #0
 800c51a:	d1e6      	bne.n	800c4ea <UART_CheckIdleState+0x3e>

      huart->gState = HAL_UART_STATE_READY;
 800c51c:	687b      	ldr	r3, [r7, #4]
 800c51e:	2220      	movs	r2, #32
 800c520:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      __HAL_UNLOCK(huart);
 800c524:	687b      	ldr	r3, [r7, #4]
 800c526:	2200      	movs	r2, #0
 800c528:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
 800c52c:	2303      	movs	r3, #3
 800c52e:	e063      	b.n	800c5f8 <UART_CheckIdleState+0x14c>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 800c530:	687b      	ldr	r3, [r7, #4]
 800c532:	681b      	ldr	r3, [r3, #0]
 800c534:	681b      	ldr	r3, [r3, #0]
 800c536:	f003 0304 	and.w	r3, r3, #4
 800c53a:	2b04      	cmp	r3, #4
 800c53c:	d149      	bne.n	800c5d2 <UART_CheckIdleState+0x126>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800c53e:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
 800c542:	9300      	str	r3, [sp, #0]
 800c544:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
 800c546:	2200      	movs	r2, #0
 800c548:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
 800c54c:	6878      	ldr	r0, [r7, #4]
 800c54e:	f000 f857 	bl	800c600 <UART_WaitOnFlagUntilTimeout>
 800c552:	4603      	mov	r3, r0
 800c554:	2b00      	cmp	r3, #0
 800c556:	d03c      	beq.n	800c5d2 <UART_CheckIdleState+0x126>
    {
      /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 800c558:	687b      	ldr	r3, [r7, #4]
 800c55a:	681b      	ldr	r3, [r3, #0]
 800c55c:	627b      	str	r3, [r7, #36]	@ 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800c55e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c560:	e853 3f00 	ldrex	r3, [r3]
 800c564:	623b      	str	r3, [r7, #32]
   return(result);
 800c566:	6a3b      	ldr	r3, [r7, #32]
 800c568:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 800c56c:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800c56e:	687b      	ldr	r3, [r7, #4]
 800c570:	681b      	ldr	r3, [r3, #0]
 800c572:	461a      	mov	r2, r3
 800c574:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800c576:	633b      	str	r3, [r7, #48]	@ 0x30
 800c578:	62fa      	str	r2, [r7, #44]	@ 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800c57a:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
 800c57c:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800c57e:	e841 2300 	strex	r3, r2, [r1]
 800c582:	62bb      	str	r3, [r7, #40]	@ 0x28
   return(result);
 800c584:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800c586:	2b00      	cmp	r3, #0
 800c588:	d1e6      	bne.n	800c558 <UART_CheckIdleState+0xac>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800c58a:	687b      	ldr	r3, [r7, #4]
 800c58c:	681b      	ldr	r3, [r3, #0]
 800c58e:	3308      	adds	r3, #8
 800c590:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800c592:	693b      	ldr	r3, [r7, #16]
 800c594:	e853 3f00 	ldrex	r3, [r3]
 800c598:	60fb      	str	r3, [r7, #12]
   return(result);
 800c59a:	68fb      	ldr	r3, [r7, #12]
 800c59c:	f023 0301 	bic.w	r3, r3, #1
 800c5a0:	64bb      	str	r3, [r7, #72]	@ 0x48
 800c5a2:	687b      	ldr	r3, [r7, #4]
 800c5a4:	681b      	ldr	r3, [r3, #0]
 800c5a6:	3308      	adds	r3, #8
 800c5a8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800c5aa:	61fa      	str	r2, [r7, #28]
 800c5ac:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800c5ae:	69b9      	ldr	r1, [r7, #24]
 800c5b0:	69fa      	ldr	r2, [r7, #28]
 800c5b2:	e841 2300 	strex	r3, r2, [r1]
 800c5b6:	617b      	str	r3, [r7, #20]
   return(result);
 800c5b8:	697b      	ldr	r3, [r7, #20]
 800c5ba:	2b00      	cmp	r3, #0
 800c5bc:	d1e5      	bne.n	800c58a <UART_CheckIdleState+0xde>

      huart->RxState = HAL_UART_STATE_READY;
 800c5be:	687b      	ldr	r3, [r7, #4]
 800c5c0:	2220      	movs	r2, #32
 800c5c2:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

      __HAL_UNLOCK(huart);
 800c5c6:	687b      	ldr	r3, [r7, #4]
 800c5c8:	2200      	movs	r2, #0
 800c5ca:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
 800c5ce:	2303      	movs	r3, #3
 800c5d0:	e012      	b.n	800c5f8 <UART_CheckIdleState+0x14c>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 800c5d2:	687b      	ldr	r3, [r7, #4]
 800c5d4:	2220      	movs	r2, #32
 800c5d6:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
 800c5da:	687b      	ldr	r3, [r7, #4]
 800c5dc:	2220      	movs	r2, #32
 800c5de:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800c5e2:	687b      	ldr	r3, [r7, #4]
 800c5e4:	2200      	movs	r2, #0
 800c5e6:	66da      	str	r2, [r3, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
 800c5e8:	687b      	ldr	r3, [r7, #4]
 800c5ea:	2200      	movs	r2, #0
 800c5ec:	671a      	str	r2, [r3, #112]	@ 0x70

  __HAL_UNLOCK(huart);
 800c5ee:	687b      	ldr	r3, [r7, #4]
 800c5f0:	2200      	movs	r2, #0
 800c5f2:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
 800c5f6:	2300      	movs	r3, #0
}
 800c5f8:	4618      	mov	r0, r3
 800c5fa:	3758      	adds	r7, #88	@ 0x58
 800c5fc:	46bd      	mov	sp, r7
 800c5fe:	bd80      	pop	{r7, pc}

0800c600 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 800c600:	b580      	push	{r7, lr}
 800c602:	b084      	sub	sp, #16
 800c604:	af00      	add	r7, sp, #0
 800c606:	60f8      	str	r0, [r7, #12]
 800c608:	60b9      	str	r1, [r7, #8]
 800c60a:	603b      	str	r3, [r7, #0]
 800c60c:	4613      	mov	r3, r2
 800c60e:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800c610:	e04f      	b.n	800c6b2 <UART_WaitOnFlagUntilTimeout+0xb2>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 800c612:	69bb      	ldr	r3, [r7, #24]
 800c614:	f1b3 3fff 	cmp.w	r3, #4294967295
 800c618:	d04b      	beq.n	800c6b2 <UART_WaitOnFlagUntilTimeout+0xb2>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 800c61a:	f7f5 fcab 	bl	8001f74 <HAL_GetTick>
 800c61e:	4602      	mov	r2, r0
 800c620:	683b      	ldr	r3, [r7, #0]
 800c622:	1ad3      	subs	r3, r2, r3
 800c624:	69ba      	ldr	r2, [r7, #24]
 800c626:	429a      	cmp	r2, r3
 800c628:	d302      	bcc.n	800c630 <UART_WaitOnFlagUntilTimeout+0x30>
 800c62a:	69bb      	ldr	r3, [r7, #24]
 800c62c:	2b00      	cmp	r3, #0
 800c62e:	d101      	bne.n	800c634 <UART_WaitOnFlagUntilTimeout+0x34>
      {

        return HAL_TIMEOUT;
 800c630:	2303      	movs	r3, #3
 800c632:	e04e      	b.n	800c6d2 <UART_WaitOnFlagUntilTimeout+0xd2>
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
 800c634:	68fb      	ldr	r3, [r7, #12]
 800c636:	681b      	ldr	r3, [r3, #0]
 800c638:	681b      	ldr	r3, [r3, #0]
 800c63a:	f003 0304 	and.w	r3, r3, #4
 800c63e:	2b00      	cmp	r3, #0
 800c640:	d037      	beq.n	800c6b2 <UART_WaitOnFlagUntilTimeout+0xb2>
 800c642:	68bb      	ldr	r3, [r7, #8]
 800c644:	2b80      	cmp	r3, #128	@ 0x80
 800c646:	d034      	beq.n	800c6b2 <UART_WaitOnFlagUntilTimeout+0xb2>
 800c648:	68bb      	ldr	r3, [r7, #8]
 800c64a:	2b40      	cmp	r3, #64	@ 0x40
 800c64c:	d031      	beq.n	800c6b2 <UART_WaitOnFlagUntilTimeout+0xb2>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
 800c64e:	68fb      	ldr	r3, [r7, #12]
 800c650:	681b      	ldr	r3, [r3, #0]
 800c652:	69db      	ldr	r3, [r3, #28]
 800c654:	f003 0308 	and.w	r3, r3, #8
 800c658:	2b08      	cmp	r3, #8
 800c65a:	d110      	bne.n	800c67e <UART_WaitOnFlagUntilTimeout+0x7e>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 800c65c:	68fb      	ldr	r3, [r7, #12]
 800c65e:	681b      	ldr	r3, [r3, #0]
 800c660:	2208      	movs	r2, #8
 800c662:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
 800c664:	68f8      	ldr	r0, [r7, #12]
 800c666:	f000 f839 	bl	800c6dc <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
 800c66a:	68fb      	ldr	r3, [r7, #12]
 800c66c:	2208      	movs	r2, #8
 800c66e:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 800c672:	68fb      	ldr	r3, [r7, #12]
 800c674:	2200      	movs	r2, #0
 800c676:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_ERROR;
 800c67a:	2301      	movs	r3, #1
 800c67c:	e029      	b.n	800c6d2 <UART_WaitOnFlagUntilTimeout+0xd2>
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 800c67e:	68fb      	ldr	r3, [r7, #12]
 800c680:	681b      	ldr	r3, [r3, #0]
 800c682:	69db      	ldr	r3, [r3, #28]
 800c684:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 800c688:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 800c68c:	d111      	bne.n	800c6b2 <UART_WaitOnFlagUntilTimeout+0xb2>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 800c68e:	68fb      	ldr	r3, [r7, #12]
 800c690:	681b      	ldr	r3, [r3, #0]
 800c692:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 800c696:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
 800c698:	68f8      	ldr	r0, [r7, #12]
 800c69a:	f000 f81f 	bl	800c6dc <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_RTO;
 800c69e:	68fb      	ldr	r3, [r7, #12]
 800c6a0:	2220      	movs	r2, #32
 800c6a2:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
 800c6a6:	68fb      	ldr	r3, [r7, #12]
 800c6a8:	2200      	movs	r2, #0
 800c6aa:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_TIMEOUT;
 800c6ae:	2303      	movs	r3, #3
 800c6b0:	e00f      	b.n	800c6d2 <UART_WaitOnFlagUntilTimeout+0xd2>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800c6b2:	68fb      	ldr	r3, [r7, #12]
 800c6b4:	681b      	ldr	r3, [r3, #0]
 800c6b6:	69da      	ldr	r2, [r3, #28]
 800c6b8:	68bb      	ldr	r3, [r7, #8]
 800c6ba:	4013      	ands	r3, r2
 800c6bc:	68ba      	ldr	r2, [r7, #8]
 800c6be:	429a      	cmp	r2, r3
 800c6c0:	bf0c      	ite	eq
 800c6c2:	2301      	moveq	r3, #1
 800c6c4:	2300      	movne	r3, #0
 800c6c6:	b2db      	uxtb	r3, r3
 800c6c8:	461a      	mov	r2, r3
 800c6ca:	79fb      	ldrb	r3, [r7, #7]
 800c6cc:	429a      	cmp	r2, r3
 800c6ce:	d0a0      	beq.n	800c612 <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
 800c6d0:	2300      	movs	r3, #0
}
 800c6d2:	4618      	mov	r0, r3
 800c6d4:	3710      	adds	r7, #16
 800c6d6:	46bd      	mov	sp, r7
 800c6d8:	bd80      	pop	{r7, pc}
	...

0800c6dc <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
 800c6dc:	b480      	push	{r7}
 800c6de:	b095      	sub	sp, #84	@ 0x54
 800c6e0:	af00      	add	r7, sp, #0
 800c6e2:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
 800c6e4:	687b      	ldr	r3, [r7, #4]
 800c6e6:	681b      	ldr	r3, [r3, #0]
 800c6e8:	637b      	str	r3, [r7, #52]	@ 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800c6ea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800c6ec:	e853 3f00 	ldrex	r3, [r3]
 800c6f0:	633b      	str	r3, [r7, #48]	@ 0x30
   return(result);
 800c6f2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800c6f4:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
 800c6f8:	64fb      	str	r3, [r7, #76]	@ 0x4c
 800c6fa:	687b      	ldr	r3, [r7, #4]
 800c6fc:	681b      	ldr	r3, [r3, #0]
 800c6fe:	461a      	mov	r2, r3
 800c700:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 800c702:	643b      	str	r3, [r7, #64]	@ 0x40
 800c704:	63fa      	str	r2, [r7, #60]	@ 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800c706:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 800c708:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 800c70a:	e841 2300 	strex	r3, r2, [r1]
 800c70e:	63bb      	str	r3, [r7, #56]	@ 0x38
   return(result);
 800c710:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800c712:	2b00      	cmp	r3, #0
 800c714:	d1e6      	bne.n	800c6e4 <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
 800c716:	687b      	ldr	r3, [r7, #4]
 800c718:	681b      	ldr	r3, [r3, #0]
 800c71a:	3308      	adds	r3, #8
 800c71c:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800c71e:	6a3b      	ldr	r3, [r7, #32]
 800c720:	e853 3f00 	ldrex	r3, [r3]
 800c724:	61fb      	str	r3, [r7, #28]
   return(result);
 800c726:	69fa      	ldr	r2, [r7, #28]
 800c728:	4b1e      	ldr	r3, [pc, #120]	@ (800c7a4 <UART_EndRxTransfer+0xc8>)
 800c72a:	4013      	ands	r3, r2
 800c72c:	64bb      	str	r3, [r7, #72]	@ 0x48
 800c72e:	687b      	ldr	r3, [r7, #4]
 800c730:	681b      	ldr	r3, [r3, #0]
 800c732:	3308      	adds	r3, #8
 800c734:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 800c736:	62fa      	str	r2, [r7, #44]	@ 0x2c
 800c738:	62bb      	str	r3, [r7, #40]	@ 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800c73a:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 800c73c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800c73e:	e841 2300 	strex	r3, r2, [r1]
 800c742:	627b      	str	r3, [r7, #36]	@ 0x24
   return(result);
 800c744:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800c746:	2b00      	cmp	r3, #0
 800c748:	d1e5      	bne.n	800c716 <UART_EndRxTransfer+0x3a>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
 800c74a:	687b      	ldr	r3, [r7, #4]
 800c74c:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 800c74e:	2b01      	cmp	r3, #1
 800c750:	d118      	bne.n	800c784 <UART_EndRxTransfer+0xa8>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
 800c752:	687b      	ldr	r3, [r7, #4]
 800c754:	681b      	ldr	r3, [r3, #0]
 800c756:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 800c758:	68fb      	ldr	r3, [r7, #12]
 800c75a:	e853 3f00 	ldrex	r3, [r3]
 800c75e:	60bb      	str	r3, [r7, #8]
   return(result);
 800c760:	68bb      	ldr	r3, [r7, #8]
 800c762:	f023 0310 	bic.w	r3, r3, #16
 800c766:	647b      	str	r3, [r7, #68]	@ 0x44
 800c768:	687b      	ldr	r3, [r7, #4]
 800c76a:	681b      	ldr	r3, [r3, #0]
 800c76c:	461a      	mov	r2, r3
 800c76e:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 800c770:	61bb      	str	r3, [r7, #24]
 800c772:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 800c774:	6979      	ldr	r1, [r7, #20]
 800c776:	69ba      	ldr	r2, [r7, #24]
 800c778:	e841 2300 	strex	r3, r2, [r1]
 800c77c:	613b      	str	r3, [r7, #16]
   return(result);
 800c77e:	693b      	ldr	r3, [r7, #16]
 800c780:	2b00      	cmp	r3, #0
 800c782:	d1e6      	bne.n	800c752 <UART_EndRxTransfer+0x76>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 800c784:	687b      	ldr	r3, [r7, #4]
 800c786:	2220      	movs	r2, #32
 800c788:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
 800c78c:	687b      	ldr	r3, [r7, #4]
 800c78e:	2200      	movs	r2, #0
 800c790:	66da      	str	r2, [r3, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 800c792:	687b      	ldr	r3, [r7, #4]
 800c794:	2200      	movs	r2, #0
 800c796:	675a      	str	r2, [r3, #116]	@ 0x74
}
 800c798:	bf00      	nop
 800c79a:	3754      	adds	r7, #84	@ 0x54
 800c79c:	46bd      	mov	sp, r7
 800c79e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7a2:	4770      	bx	lr
 800c7a4:	effffffe 	.word	0xeffffffe

0800c7a8 <HAL_UARTEx_DisableFifoMode>:
  * @brief  Disable the FIFO mode.
  * @param huart      UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_DisableFifoMode(UART_HandleTypeDef *huart)
{
 800c7a8:	b480      	push	{r7}
 800c7aa:	b085      	sub	sp, #20
 800c7ac:	af00      	add	r7, sp, #0
 800c7ae:	6078      	str	r0, [r7, #4]

  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));

  /* Process Locked */
  __HAL_LOCK(huart);
 800c7b0:	687b      	ldr	r3, [r7, #4]
 800c7b2:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
 800c7b6:	2b01      	cmp	r3, #1
 800c7b8:	d101      	bne.n	800c7be <HAL_UARTEx_DisableFifoMode+0x16>
 800c7ba:	2302      	movs	r3, #2
 800c7bc:	e027      	b.n	800c80e <HAL_UARTEx_DisableFifoMode+0x66>
 800c7be:	687b      	ldr	r3, [r7, #4]
 800c7c0:	2201      	movs	r2, #1
 800c7c2:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
 800c7c6:	687b      	ldr	r3, [r7, #4]
 800c7c8:	2224      	movs	r2, #36	@ 0x24
 800c7ca:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800c7ce:	687b      	ldr	r3, [r7, #4]
 800c7d0:	681b      	ldr	r3, [r3, #0]
 800c7d2:	681b      	ldr	r3, [r3, #0]
 800c7d4:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 800c7d6:	687b      	ldr	r3, [r7, #4]
 800c7d8:	681b      	ldr	r3, [r3, #0]
 800c7da:	681a      	ldr	r2, [r3, #0]
 800c7dc:	687b      	ldr	r3, [r7, #4]
 800c7de:	681b      	ldr	r3, [r3, #0]
 800c7e0:	f022 0201 	bic.w	r2, r2, #1
 800c7e4:	601a      	str	r2, [r3, #0]

  /* Disable FIFO mode */
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
 800c7e6:	68fb      	ldr	r3, [r7, #12]
 800c7e8:	f023 5300 	bic.w	r3, r3, #536870912	@ 0x20000000
 800c7ec:	60fb      	str	r3, [r7, #12]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
 800c7ee:	687b      	ldr	r3, [r7, #4]
 800c7f0:	2200      	movs	r2, #0
 800c7f2:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 800c7f4:	687b      	ldr	r3, [r7, #4]
 800c7f6:	681b      	ldr	r3, [r3, #0]
 800c7f8:	68fa      	ldr	r2, [r7, #12]
 800c7fa:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 800c7fc:	687b      	ldr	r3, [r7, #4]
 800c7fe:	2220      	movs	r2, #32
 800c800:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 800c804:	687b      	ldr	r3, [r7, #4]
 800c806:	2200      	movs	r2, #0
 800c808:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
 800c80c:	2300      	movs	r3, #0
}
 800c80e:	4618      	mov	r0, r3
 800c810:	3714      	adds	r7, #20
 800c812:	46bd      	mov	sp, r7
 800c814:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c818:	4770      	bx	lr

0800c81a <HAL_UARTEx_SetTxFifoThreshold>:
  *            @arg @ref UART_TXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_TXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetTxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
 800c81a:	b580      	push	{r7, lr}
 800c81c:	b084      	sub	sp, #16
 800c81e:	af00      	add	r7, sp, #0
 800c820:	6078      	str	r0, [r7, #4]
 800c822:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 800c824:	687b      	ldr	r3, [r7, #4]
 800c826:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
 800c82a:	2b01      	cmp	r3, #1
 800c82c:	d101      	bne.n	800c832 <HAL_UARTEx_SetTxFifoThreshold+0x18>
 800c82e:	2302      	movs	r3, #2
 800c830:	e02d      	b.n	800c88e <HAL_UARTEx_SetTxFifoThreshold+0x74>
 800c832:	687b      	ldr	r3, [r7, #4]
 800c834:	2201      	movs	r2, #1
 800c836:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
 800c83a:	687b      	ldr	r3, [r7, #4]
 800c83c:	2224      	movs	r2, #36	@ 0x24
 800c83e:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800c842:	687b      	ldr	r3, [r7, #4]
 800c844:	681b      	ldr	r3, [r3, #0]
 800c846:	681b      	ldr	r3, [r3, #0]
 800c848:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 800c84a:	687b      	ldr	r3, [r7, #4]
 800c84c:	681b      	ldr	r3, [r3, #0]
 800c84e:	681a      	ldr	r2, [r3, #0]
 800c850:	687b      	ldr	r3, [r7, #4]
 800c852:	681b      	ldr	r3, [r3, #0]
 800c854:	f022 0201 	bic.w	r2, r2, #1
 800c858:	601a      	str	r2, [r3, #0]

  /* Update TX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
 800c85a:	687b      	ldr	r3, [r7, #4]
 800c85c:	681b      	ldr	r3, [r3, #0]
 800c85e:	689b      	ldr	r3, [r3, #8]
 800c860:	f023 4160 	bic.w	r1, r3, #3758096384	@ 0xe0000000
 800c864:	687b      	ldr	r3, [r7, #4]
 800c866:	681b      	ldr	r3, [r3, #0]
 800c868:	683a      	ldr	r2, [r7, #0]
 800c86a:	430a      	orrs	r2, r1
 800c86c:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
 800c86e:	6878      	ldr	r0, [r7, #4]
 800c870:	f000 f850 	bl	800c914 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 800c874:	687b      	ldr	r3, [r7, #4]
 800c876:	681b      	ldr	r3, [r3, #0]
 800c878:	68fa      	ldr	r2, [r7, #12]
 800c87a:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 800c87c:	687b      	ldr	r3, [r7, #4]
 800c87e:	2220      	movs	r2, #32
 800c880:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 800c884:	687b      	ldr	r3, [r7, #4]
 800c886:	2200      	movs	r2, #0
 800c888:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
 800c88c:	2300      	movs	r3, #0
}
 800c88e:	4618      	mov	r0, r3
 800c890:	3710      	adds	r7, #16
 800c892:	46bd      	mov	sp, r7
 800c894:	bd80      	pop	{r7, pc}

0800c896 <HAL_UARTEx_SetRxFifoThreshold>:
  *            @arg @ref UART_RXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_RXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetRxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
 800c896:	b580      	push	{r7, lr}
 800c898:	b084      	sub	sp, #16
 800c89a:	af00      	add	r7, sp, #0
 800c89c:	6078      	str	r0, [r7, #4]
 800c89e:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_RXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
 800c8a0:	687b      	ldr	r3, [r7, #4]
 800c8a2:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
 800c8a6:	2b01      	cmp	r3, #1
 800c8a8:	d101      	bne.n	800c8ae <HAL_UARTEx_SetRxFifoThreshold+0x18>
 800c8aa:	2302      	movs	r3, #2
 800c8ac:	e02d      	b.n	800c90a <HAL_UARTEx_SetRxFifoThreshold+0x74>
 800c8ae:	687b      	ldr	r3, [r7, #4]
 800c8b0:	2201      	movs	r2, #1
 800c8b2:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
 800c8b6:	687b      	ldr	r3, [r7, #4]
 800c8b8:	2224      	movs	r2, #36	@ 0x24
 800c8ba:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
 800c8be:	687b      	ldr	r3, [r7, #4]
 800c8c0:	681b      	ldr	r3, [r3, #0]
 800c8c2:	681b      	ldr	r3, [r3, #0]
 800c8c4:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
 800c8c6:	687b      	ldr	r3, [r7, #4]
 800c8c8:	681b      	ldr	r3, [r3, #0]
 800c8ca:	681a      	ldr	r2, [r3, #0]
 800c8cc:	687b      	ldr	r3, [r7, #4]
 800c8ce:	681b      	ldr	r3, [r3, #0]
 800c8d0:	f022 0201 	bic.w	r2, r2, #1
 800c8d4:	601a      	str	r2, [r3, #0]

  /* Update RX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
 800c8d6:	687b      	ldr	r3, [r7, #4]
 800c8d8:	681b      	ldr	r3, [r3, #0]
 800c8da:	689b      	ldr	r3, [r3, #8]
 800c8dc:	f023 6160 	bic.w	r1, r3, #234881024	@ 0xe000000
 800c8e0:	687b      	ldr	r3, [r7, #4]
 800c8e2:	681b      	ldr	r3, [r3, #0]
 800c8e4:	683a      	ldr	r2, [r7, #0]
 800c8e6:	430a      	orrs	r2, r1
 800c8e8:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
 800c8ea:	6878      	ldr	r0, [r7, #4]
 800c8ec:	f000 f812 	bl	800c914 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
 800c8f0:	687b      	ldr	r3, [r7, #4]
 800c8f2:	681b      	ldr	r3, [r3, #0]
 800c8f4:	68fa      	ldr	r2, [r7, #12]
 800c8f6:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
 800c8f8:	687b      	ldr	r3, [r7, #4]
 800c8fa:	2220      	movs	r2, #32
 800c8fc:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 800c900:	687b      	ldr	r3, [r7, #4]
 800c902:	2200      	movs	r2, #0
 800c904:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
 800c908:	2300      	movs	r3, #0
}
 800c90a:	4618      	mov	r0, r3
 800c90c:	3710      	adds	r7, #16
 800c90e:	46bd      	mov	sp, r7
 800c910:	bd80      	pop	{r7, pc}
	...

0800c914 <UARTEx_SetNbDataToProcess>:
  *       the UART configuration registers.
  * @param huart UART handle.
  * @retval None
  */
static void UARTEx_SetNbDataToProcess(UART_HandleTypeDef *huart)
{
 800c914:	b480      	push	{r7}
 800c916:	b085      	sub	sp, #20
 800c918:	af00      	add	r7, sp, #0
 800c91a:	6078      	str	r0, [r7, #4]
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
 800c91c:	687b      	ldr	r3, [r7, #4]
 800c91e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 800c920:	2b00      	cmp	r3, #0
 800c922:	d108      	bne.n	800c936 <UARTEx_SetNbDataToProcess+0x22>
  {
    huart->NbTxDataToProcess = 1U;
 800c924:	687b      	ldr	r3, [r7, #4]
 800c926:	2201      	movs	r2, #1
 800c928:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
    huart->NbRxDataToProcess = 1U;
 800c92c:	687b      	ldr	r3, [r7, #4]
 800c92e:	2201      	movs	r2, #1
 800c930:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
 800c934:	e031      	b.n	800c99a <UARTEx_SetNbDataToProcess+0x86>
    rx_fifo_depth = RX_FIFO_DEPTH;
 800c936:	2310      	movs	r3, #16
 800c938:	73fb      	strb	r3, [r7, #15]
    tx_fifo_depth = TX_FIFO_DEPTH;
 800c93a:	2310      	movs	r3, #16
 800c93c:	73bb      	strb	r3, [r7, #14]
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
 800c93e:	687b      	ldr	r3, [r7, #4]
 800c940:	681b      	ldr	r3, [r3, #0]
 800c942:	689b      	ldr	r3, [r3, #8]
 800c944:	0e5b      	lsrs	r3, r3, #25
 800c946:	b2db      	uxtb	r3, r3
 800c948:	f003 0307 	and.w	r3, r3, #7
 800c94c:	737b      	strb	r3, [r7, #13]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
 800c94e:	687b      	ldr	r3, [r7, #4]
 800c950:	681b      	ldr	r3, [r3, #0]
 800c952:	689b      	ldr	r3, [r3, #8]
 800c954:	0f5b      	lsrs	r3, r3, #29
 800c956:	b2db      	uxtb	r3, r3
 800c958:	f003 0307 	and.w	r3, r3, #7
 800c95c:	733b      	strb	r3, [r7, #12]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 800c95e:	7bbb      	ldrb	r3, [r7, #14]
 800c960:	7b3a      	ldrb	r2, [r7, #12]
 800c962:	4911      	ldr	r1, [pc, #68]	@ (800c9a8 <UARTEx_SetNbDataToProcess+0x94>)
 800c964:	5c8a      	ldrb	r2, [r1, r2]
 800c966:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[tx_fifo_threshold];
 800c96a:	7b3a      	ldrb	r2, [r7, #12]
 800c96c:	490f      	ldr	r1, [pc, #60]	@ (800c9ac <UARTEx_SetNbDataToProcess+0x98>)
 800c96e:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
 800c970:	fb93 f3f2 	sdiv	r3, r3, r2
 800c974:	b29a      	uxth	r2, r3
 800c976:	687b      	ldr	r3, [r7, #4]
 800c978:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 800c97c:	7bfb      	ldrb	r3, [r7, #15]
 800c97e:	7b7a      	ldrb	r2, [r7, #13]
 800c980:	4909      	ldr	r1, [pc, #36]	@ (800c9a8 <UARTEx_SetNbDataToProcess+0x94>)
 800c982:	5c8a      	ldrb	r2, [r1, r2]
 800c984:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[rx_fifo_threshold];
 800c988:	7b7a      	ldrb	r2, [r7, #13]
 800c98a:	4908      	ldr	r1, [pc, #32]	@ (800c9ac <UARTEx_SetNbDataToProcess+0x98>)
 800c98c:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
 800c98e:	fb93 f3f2 	sdiv	r3, r3, r2
 800c992:	b29a      	uxth	r2, r3
 800c994:	687b      	ldr	r3, [r7, #4]
 800c996:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
}
 800c99a:	bf00      	nop
 800c99c:	3714      	adds	r7, #20
 800c99e:	46bd      	mov	sp, r7
 800c9a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c9a4:	4770      	bx	lr
 800c9a6:	bf00      	nop
 800c9a8:	080186b4 	.word	0x080186b4
 800c9ac:	080186bc 	.word	0x080186bc

0800c9b0 <__NVIC_SetPriority>:
{
 800c9b0:	b480      	push	{r7}
 800c9b2:	b083      	sub	sp, #12
 800c9b4:	af00      	add	r7, sp, #0
 800c9b6:	4603      	mov	r3, r0
 800c9b8:	6039      	str	r1, [r7, #0]
 800c9ba:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 800c9bc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800c9c0:	2b00      	cmp	r3, #0
 800c9c2:	db0a      	blt.n	800c9da <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800c9c4:	683b      	ldr	r3, [r7, #0]
 800c9c6:	b2da      	uxtb	r2, r3
 800c9c8:	490c      	ldr	r1, [pc, #48]	@ (800c9fc <__NVIC_SetPriority+0x4c>)
 800c9ca:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800c9ce:	0112      	lsls	r2, r2, #4
 800c9d0:	b2d2      	uxtb	r2, r2
 800c9d2:	440b      	add	r3, r1
 800c9d4:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
}
 800c9d8:	e00a      	b.n	800c9f0 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800c9da:	683b      	ldr	r3, [r7, #0]
 800c9dc:	b2da      	uxtb	r2, r3
 800c9de:	4908      	ldr	r1, [pc, #32]	@ (800ca00 <__NVIC_SetPriority+0x50>)
 800c9e0:	88fb      	ldrh	r3, [r7, #6]
 800c9e2:	f003 030f 	and.w	r3, r3, #15
 800c9e6:	3b04      	subs	r3, #4
 800c9e8:	0112      	lsls	r2, r2, #4
 800c9ea:	b2d2      	uxtb	r2, r2
 800c9ec:	440b      	add	r3, r1
 800c9ee:	761a      	strb	r2, [r3, #24]
}
 800c9f0:	bf00      	nop
 800c9f2:	370c      	adds	r7, #12
 800c9f4:	46bd      	mov	sp, r7
 800c9f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c9fa:	4770      	bx	lr
 800c9fc:	e000e100 	.word	0xe000e100
 800ca00:	e000ed00 	.word	0xe000ed00

0800ca04 <SysTick_Handler>:

/*
  SysTick handler implementation that also clears overflow flag.
*/
#if (USE_CUSTOM_SYSTICK_HANDLER_IMPLEMENTATION == 0)
void SysTick_Handler (void) {
 800ca04:	b580      	push	{r7, lr}
 800ca06:	af00      	add	r7, sp, #0
  /* Clear overflow flag */
  SysTick->CTRL;
 800ca08:	4b05      	ldr	r3, [pc, #20]	@ (800ca20 <SysTick_Handler+0x1c>)
 800ca0a:	681b      	ldr	r3, [r3, #0]

  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
 800ca0c:	f002 f95a 	bl	800ecc4 <xTaskGetSchedulerState>
 800ca10:	4603      	mov	r3, r0
 800ca12:	2b01      	cmp	r3, #1
 800ca14:	d001      	beq.n	800ca1a <SysTick_Handler+0x16>
    /* Call tick handler */
    xPortSysTickHandler();
 800ca16:	f000 fd9f 	bl	800d558 <xPortSysTickHandler>
  }
}
 800ca1a:	bf00      	nop
 800ca1c:	bd80      	pop	{r7, pc}
 800ca1e:	bf00      	nop
 800ca20:	e000e010 	.word	0xe000e010

0800ca24 <SVC_Setup>:
#endif /* SysTick */

/*
  Setup SVC to reset value.
*/
__STATIC_INLINE void SVC_Setup (void) {
 800ca24:	b580      	push	{r7, lr}
 800ca26:	af00      	add	r7, sp, #0
#if (__ARM_ARCH_7A__ == 0U)
  /* Service Call interrupt might be configured before kernel start     */
  /* and when its priority is lower or equal to BASEPRI, svc intruction */
  /* causes a Hard Fault.                                               */
  NVIC_SetPriority (SVCall_IRQ_NBR, 0U);
 800ca28:	2100      	movs	r1, #0
 800ca2a:	f06f 0004 	mvn.w	r0, #4
 800ca2e:	f7ff ffbf 	bl	800c9b0 <__NVIC_SetPriority>
#endif
}
 800ca32:	bf00      	nop
 800ca34:	bd80      	pop	{r7, pc}
	...

0800ca38 <osKernelInitialize>:
static uint32_t OS_Tick_GetOverflow (void);
/* Get OS Tick interval */
static uint32_t OS_Tick_GetInterval (void);
/*---------------------------------------------------------------------------*/

osStatus_t osKernelInitialize (void) {
 800ca38:	b480      	push	{r7}
 800ca3a:	b083      	sub	sp, #12
 800ca3c:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800ca3e:	f3ef 8305 	mrs	r3, IPSR
 800ca42:	603b      	str	r3, [r7, #0]
  return(result);
 800ca44:	683b      	ldr	r3, [r7, #0]
  osStatus_t stat;

  if (IS_IRQ()) {
 800ca46:	2b00      	cmp	r3, #0
 800ca48:	d003      	beq.n	800ca52 <osKernelInitialize+0x1a>
    stat = osErrorISR;
 800ca4a:	f06f 0305 	mvn.w	r3, #5
 800ca4e:	607b      	str	r3, [r7, #4]
 800ca50:	e00c      	b.n	800ca6c <osKernelInitialize+0x34>
  }
  else {
    if (KernelState == osKernelInactive) {
 800ca52:	4b0a      	ldr	r3, [pc, #40]	@ (800ca7c <osKernelInitialize+0x44>)
 800ca54:	681b      	ldr	r3, [r3, #0]
 800ca56:	2b00      	cmp	r3, #0
 800ca58:	d105      	bne.n	800ca66 <osKernelInitialize+0x2e>
        EvrFreeRTOSSetup(0U);
      #endif
      #if defined(USE_FreeRTOS_HEAP_5) && (HEAP_5_REGION_SETUP == 1)
        vPortDefineHeapRegions (configHEAP_5_REGIONS);
      #endif
      KernelState = osKernelReady;
 800ca5a:	4b08      	ldr	r3, [pc, #32]	@ (800ca7c <osKernelInitialize+0x44>)
 800ca5c:	2201      	movs	r2, #1
 800ca5e:	601a      	str	r2, [r3, #0]
      stat = osOK;
 800ca60:	2300      	movs	r3, #0
 800ca62:	607b      	str	r3, [r7, #4]
 800ca64:	e002      	b.n	800ca6c <osKernelInitialize+0x34>
    } else {
      stat = osError;
 800ca66:	f04f 33ff 	mov.w	r3, #4294967295
 800ca6a:	607b      	str	r3, [r7, #4]
    }
  }

  return (stat);
 800ca6c:	687b      	ldr	r3, [r7, #4]
}
 800ca6e:	4618      	mov	r0, r3
 800ca70:	370c      	adds	r7, #12
 800ca72:	46bd      	mov	sp, r7
 800ca74:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ca78:	4770      	bx	lr
 800ca7a:	bf00      	nop
 800ca7c:	24001384 	.word	0x24001384

0800ca80 <osKernelStart>:
  }

  return (state);
}

osStatus_t osKernelStart (void) {
 800ca80:	b580      	push	{r7, lr}
 800ca82:	b082      	sub	sp, #8
 800ca84:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800ca86:	f3ef 8305 	mrs	r3, IPSR
 800ca8a:	603b      	str	r3, [r7, #0]
  return(result);
 800ca8c:	683b      	ldr	r3, [r7, #0]
  osStatus_t stat;

  if (IS_IRQ()) {
 800ca8e:	2b00      	cmp	r3, #0
 800ca90:	d003      	beq.n	800ca9a <osKernelStart+0x1a>
    stat = osErrorISR;
 800ca92:	f06f 0305 	mvn.w	r3, #5
 800ca96:	607b      	str	r3, [r7, #4]
 800ca98:	e010      	b.n	800cabc <osKernelStart+0x3c>
  }
  else {
    if (KernelState == osKernelReady) {
 800ca9a:	4b0b      	ldr	r3, [pc, #44]	@ (800cac8 <osKernelStart+0x48>)
 800ca9c:	681b      	ldr	r3, [r3, #0]
 800ca9e:	2b01      	cmp	r3, #1
 800caa0:	d109      	bne.n	800cab6 <osKernelStart+0x36>
      /* Ensure SVC priority is at the reset value */
      SVC_Setup();
 800caa2:	f7ff ffbf 	bl	800ca24 <SVC_Setup>
      /* Change state to enable IRQ masking check */
      KernelState = osKernelRunning;
 800caa6:	4b08      	ldr	r3, [pc, #32]	@ (800cac8 <osKernelStart+0x48>)
 800caa8:	2202      	movs	r2, #2
 800caaa:	601a      	str	r2, [r3, #0]
      /* Start the kernel scheduler */
      vTaskStartScheduler();
 800caac:	f001 fcbc 	bl	800e428 <vTaskStartScheduler>
      stat = osOK;
 800cab0:	2300      	movs	r3, #0
 800cab2:	607b      	str	r3, [r7, #4]
 800cab4:	e002      	b.n	800cabc <osKernelStart+0x3c>
    } else {
      stat = osError;
 800cab6:	f04f 33ff 	mov.w	r3, #4294967295
 800caba:	607b      	str	r3, [r7, #4]
    }
  }

  return (stat);
 800cabc:	687b      	ldr	r3, [r7, #4]
}
 800cabe:	4618      	mov	r0, r3
 800cac0:	3708      	adds	r7, #8
 800cac2:	46bd      	mov	sp, r7
 800cac4:	bd80      	pop	{r7, pc}
 800cac6:	bf00      	nop
 800cac8:	24001384 	.word	0x24001384

0800cacc <osThreadNew>:
  return (configCPU_CLOCK_HZ);
}

/*---------------------------------------------------------------------------*/

osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
 800cacc:	b580      	push	{r7, lr}
 800cace:	b08e      	sub	sp, #56	@ 0x38
 800cad0:	af04      	add	r7, sp, #16
 800cad2:	60f8      	str	r0, [r7, #12]
 800cad4:	60b9      	str	r1, [r7, #8]
 800cad6:	607a      	str	r2, [r7, #4]
  uint32_t stack;
  TaskHandle_t hTask;
  UBaseType_t prio;
  int32_t mem;

  hTask = NULL;
 800cad8:	2300      	movs	r3, #0
 800cada:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800cadc:	f3ef 8305 	mrs	r3, IPSR
 800cae0:	617b      	str	r3, [r7, #20]
  return(result);
 800cae2:	697b      	ldr	r3, [r7, #20]

  if (!IS_IRQ() && (func != NULL)) {
 800cae4:	2b00      	cmp	r3, #0
 800cae6:	d17e      	bne.n	800cbe6 <osThreadNew+0x11a>
 800cae8:	68fb      	ldr	r3, [r7, #12]
 800caea:	2b00      	cmp	r3, #0
 800caec:	d07b      	beq.n	800cbe6 <osThreadNew+0x11a>
    stack = configMINIMAL_STACK_SIZE;
 800caee:	2380      	movs	r3, #128	@ 0x80
 800caf0:	623b      	str	r3, [r7, #32]
    prio  = (UBaseType_t)osPriorityNormal;
 800caf2:	2318      	movs	r3, #24
 800caf4:	61fb      	str	r3, [r7, #28]

    name = NULL;
 800caf6:	2300      	movs	r3, #0
 800caf8:	627b      	str	r3, [r7, #36]	@ 0x24
    mem  = -1;
 800cafa:	f04f 33ff 	mov.w	r3, #4294967295
 800cafe:	61bb      	str	r3, [r7, #24]

    if (attr != NULL) {
 800cb00:	687b      	ldr	r3, [r7, #4]
 800cb02:	2b00      	cmp	r3, #0
 800cb04:	d045      	beq.n	800cb92 <osThreadNew+0xc6>
      if (attr->name != NULL) {
 800cb06:	687b      	ldr	r3, [r7, #4]
 800cb08:	681b      	ldr	r3, [r3, #0]
 800cb0a:	2b00      	cmp	r3, #0
 800cb0c:	d002      	beq.n	800cb14 <osThreadNew+0x48>
        name = attr->name;
 800cb0e:	687b      	ldr	r3, [r7, #4]
 800cb10:	681b      	ldr	r3, [r3, #0]
 800cb12:	627b      	str	r3, [r7, #36]	@ 0x24
      }
      if (attr->priority != osPriorityNone) {
 800cb14:	687b      	ldr	r3, [r7, #4]
 800cb16:	699b      	ldr	r3, [r3, #24]
 800cb18:	2b00      	cmp	r3, #0
 800cb1a:	d002      	beq.n	800cb22 <osThreadNew+0x56>
        prio = (UBaseType_t)attr->priority;
 800cb1c:	687b      	ldr	r3, [r7, #4]
 800cb1e:	699b      	ldr	r3, [r3, #24]
 800cb20:	61fb      	str	r3, [r7, #28]
      }

      if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
 800cb22:	69fb      	ldr	r3, [r7, #28]
 800cb24:	2b00      	cmp	r3, #0
 800cb26:	d008      	beq.n	800cb3a <osThreadNew+0x6e>
 800cb28:	69fb      	ldr	r3, [r7, #28]
 800cb2a:	2b38      	cmp	r3, #56	@ 0x38
 800cb2c:	d805      	bhi.n	800cb3a <osThreadNew+0x6e>
 800cb2e:	687b      	ldr	r3, [r7, #4]
 800cb30:	685b      	ldr	r3, [r3, #4]
 800cb32:	f003 0301 	and.w	r3, r3, #1
 800cb36:	2b00      	cmp	r3, #0
 800cb38:	d001      	beq.n	800cb3e <osThreadNew+0x72>
        return (NULL);
 800cb3a:	2300      	movs	r3, #0
 800cb3c:	e054      	b.n	800cbe8 <osThreadNew+0x11c>
      }

      if (attr->stack_size > 0U) {
 800cb3e:	687b      	ldr	r3, [r7, #4]
 800cb40:	695b      	ldr	r3, [r3, #20]
 800cb42:	2b00      	cmp	r3, #0
 800cb44:	d003      	beq.n	800cb4e <osThreadNew+0x82>
        /* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */
        /* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */
        stack = attr->stack_size / sizeof(StackType_t);
 800cb46:	687b      	ldr	r3, [r7, #4]
 800cb48:	695b      	ldr	r3, [r3, #20]
 800cb4a:	089b      	lsrs	r3, r3, #2
 800cb4c:	623b      	str	r3, [r7, #32]
      }

      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 800cb4e:	687b      	ldr	r3, [r7, #4]
 800cb50:	689b      	ldr	r3, [r3, #8]
 800cb52:	2b00      	cmp	r3, #0
 800cb54:	d00e      	beq.n	800cb74 <osThreadNew+0xa8>
 800cb56:	687b      	ldr	r3, [r7, #4]
 800cb58:	68db      	ldr	r3, [r3, #12]
 800cb5a:	2b5b      	cmp	r3, #91	@ 0x5b
 800cb5c:	d90a      	bls.n	800cb74 <osThreadNew+0xa8>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 800cb5e:	687b      	ldr	r3, [r7, #4]
 800cb60:	691b      	ldr	r3, [r3, #16]
      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 800cb62:	2b00      	cmp	r3, #0
 800cb64:	d006      	beq.n	800cb74 <osThreadNew+0xa8>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 800cb66:	687b      	ldr	r3, [r7, #4]
 800cb68:	695b      	ldr	r3, [r3, #20]
 800cb6a:	2b00      	cmp	r3, #0
 800cb6c:	d002      	beq.n	800cb74 <osThreadNew+0xa8>
        mem = 1;
 800cb6e:	2301      	movs	r3, #1
 800cb70:	61bb      	str	r3, [r7, #24]
 800cb72:	e010      	b.n	800cb96 <osThreadNew+0xca>
      }
      else {
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) && (attr->stack_mem == NULL)) {
 800cb74:	687b      	ldr	r3, [r7, #4]
 800cb76:	689b      	ldr	r3, [r3, #8]
 800cb78:	2b00      	cmp	r3, #0
 800cb7a:	d10c      	bne.n	800cb96 <osThreadNew+0xca>
 800cb7c:	687b      	ldr	r3, [r7, #4]
 800cb7e:	68db      	ldr	r3, [r3, #12]
 800cb80:	2b00      	cmp	r3, #0
 800cb82:	d108      	bne.n	800cb96 <osThreadNew+0xca>
 800cb84:	687b      	ldr	r3, [r7, #4]
 800cb86:	691b      	ldr	r3, [r3, #16]
 800cb88:	2b00      	cmp	r3, #0
 800cb8a:	d104      	bne.n	800cb96 <osThreadNew+0xca>
          mem = 0;
 800cb8c:	2300      	movs	r3, #0
 800cb8e:	61bb      	str	r3, [r7, #24]
 800cb90:	e001      	b.n	800cb96 <osThreadNew+0xca>
        }
      }
    }
    else {
      mem = 0;
 800cb92:	2300      	movs	r3, #0
 800cb94:	61bb      	str	r3, [r7, #24]
    }

    if (mem == 1) {
 800cb96:	69bb      	ldr	r3, [r7, #24]
 800cb98:	2b01      	cmp	r3, #1
 800cb9a:	d110      	bne.n	800cbbe <osThreadNew+0xf2>
      #if (configSUPPORT_STATIC_ALLOCATION == 1)
        hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
 800cb9c:	687b      	ldr	r3, [r7, #4]
 800cb9e:	691b      	ldr	r3, [r3, #16]
                                                                                      (StaticTask_t *)attr->cb_mem);
 800cba0:	687a      	ldr	r2, [r7, #4]
 800cba2:	6892      	ldr	r2, [r2, #8]
        hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
 800cba4:	9202      	str	r2, [sp, #8]
 800cba6:	9301      	str	r3, [sp, #4]
 800cba8:	69fb      	ldr	r3, [r7, #28]
 800cbaa:	9300      	str	r3, [sp, #0]
 800cbac:	68bb      	ldr	r3, [r7, #8]
 800cbae:	6a3a      	ldr	r2, [r7, #32]
 800cbb0:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800cbb2:	68f8      	ldr	r0, [r7, #12]
 800cbb4:	f001 fa5c 	bl	800e070 <xTaskCreateStatic>
 800cbb8:	4603      	mov	r3, r0
 800cbba:	613b      	str	r3, [r7, #16]
 800cbbc:	e013      	b.n	800cbe6 <osThreadNew+0x11a>
      #endif
    }
    else {
      if (mem == 0) {
 800cbbe:	69bb      	ldr	r3, [r7, #24]
 800cbc0:	2b00      	cmp	r3, #0
 800cbc2:	d110      	bne.n	800cbe6 <osThreadNew+0x11a>
        #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
          if (xTaskCreate ((TaskFunction_t)func, name, (uint16_t)stack, argument, prio, &hTask) != pdPASS) {
 800cbc4:	6a3b      	ldr	r3, [r7, #32]
 800cbc6:	b29a      	uxth	r2, r3
 800cbc8:	f107 0310 	add.w	r3, r7, #16
 800cbcc:	9301      	str	r3, [sp, #4]
 800cbce:	69fb      	ldr	r3, [r7, #28]
 800cbd0:	9300      	str	r3, [sp, #0]
 800cbd2:	68bb      	ldr	r3, [r7, #8]
 800cbd4:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 800cbd6:	68f8      	ldr	r0, [r7, #12]
 800cbd8:	f001 faaa 	bl	800e130 <xTaskCreate>
 800cbdc:	4603      	mov	r3, r0
 800cbde:	2b01      	cmp	r3, #1
 800cbe0:	d001      	beq.n	800cbe6 <osThreadNew+0x11a>
            hTask = NULL;
 800cbe2:	2300      	movs	r3, #0
 800cbe4:	613b      	str	r3, [r7, #16]
        #endif
      }
    }
  }

  return ((osThreadId_t)hTask);
 800cbe6:	693b      	ldr	r3, [r7, #16]
}
 800cbe8:	4618      	mov	r0, r3
 800cbea:	3728      	adds	r7, #40	@ 0x28
 800cbec:	46bd      	mov	sp, r7
 800cbee:	bd80      	pop	{r7, pc}

0800cbf0 <osDelay>:
  /* Return flags before clearing */
  return (rflags);
}
#endif /* (configUSE_OS2_THREAD_FLAGS == 1) */

osStatus_t osDelay (uint32_t ticks) {
 800cbf0:	b580      	push	{r7, lr}
 800cbf2:	b084      	sub	sp, #16
 800cbf4:	af00      	add	r7, sp, #0
 800cbf6:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800cbf8:	f3ef 8305 	mrs	r3, IPSR
 800cbfc:	60bb      	str	r3, [r7, #8]
  return(result);
 800cbfe:	68bb      	ldr	r3, [r7, #8]
  osStatus_t stat;

  if (IS_IRQ()) {
 800cc00:	2b00      	cmp	r3, #0
 800cc02:	d003      	beq.n	800cc0c <osDelay+0x1c>
    stat = osErrorISR;
 800cc04:	f06f 0305 	mvn.w	r3, #5
 800cc08:	60fb      	str	r3, [r7, #12]
 800cc0a:	e007      	b.n	800cc1c <osDelay+0x2c>
  }
  else {
    stat = osOK;
 800cc0c:	2300      	movs	r3, #0
 800cc0e:	60fb      	str	r3, [r7, #12]

    if (ticks != 0U) {
 800cc10:	687b      	ldr	r3, [r7, #4]
 800cc12:	2b00      	cmp	r3, #0
 800cc14:	d002      	beq.n	800cc1c <osDelay+0x2c>
      vTaskDelay(ticks);
 800cc16:	6878      	ldr	r0, [r7, #4]
 800cc18:	f001 fbd0 	bl	800e3bc <vTaskDelay>
    }
  }

  return (stat);
 800cc1c:	68fb      	ldr	r3, [r7, #12]
}
 800cc1e:	4618      	mov	r0, r3
 800cc20:	3710      	adds	r7, #16
 800cc22:	46bd      	mov	sp, r7
 800cc24:	bd80      	pop	{r7, pc}
	...

0800cc28 <vApplicationGetIdleTaskMemory>:

/*
  vApplicationGetIdleTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
  equals to 1 and is required for static memory allocation support.
*/
__WEAK void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
 800cc28:	b480      	push	{r7}
 800cc2a:	b085      	sub	sp, #20
 800cc2c:	af00      	add	r7, sp, #0
 800cc2e:	60f8      	str	r0, [r7, #12]
 800cc30:	60b9      	str	r1, [r7, #8]
 800cc32:	607a      	str	r2, [r7, #4]
  /* Idle task control block and stack */
  static StaticTask_t Idle_TCB;
  static StackType_t  Idle_Stack[configMINIMAL_STACK_SIZE];

  *ppxIdleTaskTCBBuffer   = &Idle_TCB;
 800cc34:	68fb      	ldr	r3, [r7, #12]
 800cc36:	4a07      	ldr	r2, [pc, #28]	@ (800cc54 <vApplicationGetIdleTaskMemory+0x2c>)
 800cc38:	601a      	str	r2, [r3, #0]
  *ppxIdleTaskStackBuffer = &Idle_Stack[0];
 800cc3a:	68bb      	ldr	r3, [r7, #8]
 800cc3c:	4a06      	ldr	r2, [pc, #24]	@ (800cc58 <vApplicationGetIdleTaskMemory+0x30>)
 800cc3e:	601a      	str	r2, [r3, #0]
  *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
 800cc40:	687b      	ldr	r3, [r7, #4]
 800cc42:	2280      	movs	r2, #128	@ 0x80
 800cc44:	601a      	str	r2, [r3, #0]
}
 800cc46:	bf00      	nop
 800cc48:	3714      	adds	r7, #20
 800cc4a:	46bd      	mov	sp, r7
 800cc4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc50:	4770      	bx	lr
 800cc52:	bf00      	nop
 800cc54:	24001388 	.word	0x24001388
 800cc58:	240013e4 	.word	0x240013e4

0800cc5c <vApplicationGetTimerTaskMemory>:

/*
  vApplicationGetTimerTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
  equals to 1 and is required for static memory allocation support.
*/
__WEAK void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
 800cc5c:	b480      	push	{r7}
 800cc5e:	b085      	sub	sp, #20
 800cc60:	af00      	add	r7, sp, #0
 800cc62:	60f8      	str	r0, [r7, #12]
 800cc64:	60b9      	str	r1, [r7, #8]
 800cc66:	607a      	str	r2, [r7, #4]
  /* Timer task control block and stack */
  static StaticTask_t Timer_TCB;
  static StackType_t  Timer_Stack[configTIMER_TASK_STACK_DEPTH];

  *ppxTimerTaskTCBBuffer   = &Timer_TCB;
 800cc68:	68fb      	ldr	r3, [r7, #12]
 800cc6a:	4a07      	ldr	r2, [pc, #28]	@ (800cc88 <vApplicationGetTimerTaskMemory+0x2c>)
 800cc6c:	601a      	str	r2, [r3, #0]
  *ppxTimerTaskStackBuffer = &Timer_Stack[0];
 800cc6e:	68bb      	ldr	r3, [r7, #8]
 800cc70:	4a06      	ldr	r2, [pc, #24]	@ (800cc8c <vApplicationGetTimerTaskMemory+0x30>)
 800cc72:	601a      	str	r2, [r3, #0]
  *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
 800cc74:	687b      	ldr	r3, [r7, #4]
 800cc76:	f44f 7280 	mov.w	r2, #256	@ 0x100
 800cc7a:	601a      	str	r2, [r3, #0]
}
 800cc7c:	bf00      	nop
 800cc7e:	3714      	adds	r7, #20
 800cc80:	46bd      	mov	sp, r7
 800cc82:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc86:	4770      	bx	lr
 800cc88:	240015e4 	.word	0x240015e4
 800cc8c:	24001640 	.word	0x24001640

0800cc90 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 800cc90:	b580      	push	{r7, lr}
 800cc92:	b08a      	sub	sp, #40	@ 0x28
 800cc94:	af00      	add	r7, sp, #0
 800cc96:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
 800cc98:	2300      	movs	r3, #0
 800cc9a:	61fb      	str	r3, [r7, #28]

	vTaskSuspendAll();
 800cc9c:	f001 fc2c 	bl	800e4f8 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
 800cca0:	4b5c      	ldr	r3, [pc, #368]	@ (800ce14 <pvPortMalloc+0x184>)
 800cca2:	681b      	ldr	r3, [r3, #0]
 800cca4:	2b00      	cmp	r3, #0
 800cca6:	d101      	bne.n	800ccac <pvPortMalloc+0x1c>
		{
			prvHeapInit();
 800cca8:	f000 f924 	bl	800cef4 <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 800ccac:	4b5a      	ldr	r3, [pc, #360]	@ (800ce18 <pvPortMalloc+0x188>)
 800ccae:	681a      	ldr	r2, [r3, #0]
 800ccb0:	687b      	ldr	r3, [r7, #4]
 800ccb2:	4013      	ands	r3, r2
 800ccb4:	2b00      	cmp	r3, #0
 800ccb6:	f040 8095 	bne.w	800cde4 <pvPortMalloc+0x154>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 800ccba:	687b      	ldr	r3, [r7, #4]
 800ccbc:	2b00      	cmp	r3, #0
 800ccbe:	d01e      	beq.n	800ccfe <pvPortMalloc+0x6e>
			{
				xWantedSize += xHeapStructSize;
 800ccc0:	2208      	movs	r2, #8
 800ccc2:	687b      	ldr	r3, [r7, #4]
 800ccc4:	4413      	add	r3, r2
 800ccc6:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 800ccc8:	687b      	ldr	r3, [r7, #4]
 800ccca:	f003 0307 	and.w	r3, r3, #7
 800ccce:	2b00      	cmp	r3, #0
 800ccd0:	d015      	beq.n	800ccfe <pvPortMalloc+0x6e>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800ccd2:	687b      	ldr	r3, [r7, #4]
 800ccd4:	f023 0307 	bic.w	r3, r3, #7
 800ccd8:	3308      	adds	r3, #8
 800ccda:	607b      	str	r3, [r7, #4]
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
 800ccdc:	687b      	ldr	r3, [r7, #4]
 800ccde:	f003 0307 	and.w	r3, r3, #7
 800cce2:	2b00      	cmp	r3, #0
 800cce4:	d00b      	beq.n	800ccfe <pvPortMalloc+0x6e>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 800cce6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800ccea:	f383 8811 	msr	BASEPRI, r3
 800ccee:	f3bf 8f6f 	isb	sy
 800ccf2:	f3bf 8f4f 	dsb	sy
 800ccf6:	617b      	str	r3, [r7, #20]
		"	msr basepri, %0											\n" \
		"	isb														\n" \
		"	dsb														\n" \
		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);
}
 800ccf8:	bf00      	nop
 800ccfa:	bf00      	nop
 800ccfc:	e7fd      	b.n	800ccfa <pvPortMalloc+0x6a>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 800ccfe:	687b      	ldr	r3, [r7, #4]
 800cd00:	2b00      	cmp	r3, #0
 800cd02:	d06f      	beq.n	800cde4 <pvPortMalloc+0x154>
 800cd04:	4b45      	ldr	r3, [pc, #276]	@ (800ce1c <pvPortMalloc+0x18c>)
 800cd06:	681b      	ldr	r3, [r3, #0]
 800cd08:	687a      	ldr	r2, [r7, #4]
 800cd0a:	429a      	cmp	r2, r3
 800cd0c:	d86a      	bhi.n	800cde4 <pvPortMalloc+0x154>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
 800cd0e:	4b44      	ldr	r3, [pc, #272]	@ (800ce20 <pvPortMalloc+0x190>)
 800cd10:	623b      	str	r3, [r7, #32]
				pxBlock = xStart.pxNextFreeBlock;
 800cd12:	4b43      	ldr	r3, [pc, #268]	@ (800ce20 <pvPortMalloc+0x190>)
 800cd14:	681b      	ldr	r3, [r3, #0]
 800cd16:	627b      	str	r3, [r7, #36]	@ 0x24
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800cd18:	e004      	b.n	800cd24 <pvPortMalloc+0x94>
				{
					pxPreviousBlock = pxBlock;
 800cd1a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cd1c:	623b      	str	r3, [r7, #32]
					pxBlock = pxBlock->pxNextFreeBlock;
 800cd1e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cd20:	681b      	ldr	r3, [r3, #0]
 800cd22:	627b      	str	r3, [r7, #36]	@ 0x24
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 800cd24:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cd26:	685b      	ldr	r3, [r3, #4]
 800cd28:	687a      	ldr	r2, [r7, #4]
 800cd2a:	429a      	cmp	r2, r3
 800cd2c:	d903      	bls.n	800cd36 <pvPortMalloc+0xa6>
 800cd2e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cd30:	681b      	ldr	r3, [r3, #0]
 800cd32:	2b00      	cmp	r3, #0
 800cd34:	d1f1      	bne.n	800cd1a <pvPortMalloc+0x8a>
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
 800cd36:	4b37      	ldr	r3, [pc, #220]	@ (800ce14 <pvPortMalloc+0x184>)
 800cd38:	681b      	ldr	r3, [r3, #0]
 800cd3a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800cd3c:	429a      	cmp	r2, r3
 800cd3e:	d051      	beq.n	800cde4 <pvPortMalloc+0x154>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800cd40:	6a3b      	ldr	r3, [r7, #32]
 800cd42:	681b      	ldr	r3, [r3, #0]
 800cd44:	2208      	movs	r2, #8
 800cd46:	4413      	add	r3, r2
 800cd48:	61fb      	str	r3, [r7, #28]

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 800cd4a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cd4c:	681a      	ldr	r2, [r3, #0]
 800cd4e:	6a3b      	ldr	r3, [r7, #32]
 800cd50:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800cd52:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cd54:	685a      	ldr	r2, [r3, #4]
 800cd56:	687b      	ldr	r3, [r7, #4]
 800cd58:	1ad2      	subs	r2, r2, r3
 800cd5a:	2308      	movs	r3, #8
 800cd5c:	005b      	lsls	r3, r3, #1
 800cd5e:	429a      	cmp	r2, r3
 800cd60:	d920      	bls.n	800cda4 <pvPortMalloc+0x114>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 800cd62:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800cd64:	687b      	ldr	r3, [r7, #4]
 800cd66:	4413      	add	r3, r2
 800cd68:	61bb      	str	r3, [r7, #24]
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 800cd6a:	69bb      	ldr	r3, [r7, #24]
 800cd6c:	f003 0307 	and.w	r3, r3, #7
 800cd70:	2b00      	cmp	r3, #0
 800cd72:	d00b      	beq.n	800cd8c <pvPortMalloc+0xfc>
	__asm volatile
 800cd74:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800cd78:	f383 8811 	msr	BASEPRI, r3
 800cd7c:	f3bf 8f6f 	isb	sy
 800cd80:	f3bf 8f4f 	dsb	sy
 800cd84:	613b      	str	r3, [r7, #16]
}
 800cd86:	bf00      	nop
 800cd88:	bf00      	nop
 800cd8a:	e7fd      	b.n	800cd88 <pvPortMalloc+0xf8>

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 800cd8c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cd8e:	685a      	ldr	r2, [r3, #4]
 800cd90:	687b      	ldr	r3, [r7, #4]
 800cd92:	1ad2      	subs	r2, r2, r3
 800cd94:	69bb      	ldr	r3, [r7, #24]
 800cd96:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
 800cd98:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cd9a:	687a      	ldr	r2, [r7, #4]
 800cd9c:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 800cd9e:	69b8      	ldr	r0, [r7, #24]
 800cda0:	f000 f90a 	bl	800cfb8 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800cda4:	4b1d      	ldr	r3, [pc, #116]	@ (800ce1c <pvPortMalloc+0x18c>)
 800cda6:	681a      	ldr	r2, [r3, #0]
 800cda8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cdaa:	685b      	ldr	r3, [r3, #4]
 800cdac:	1ad3      	subs	r3, r2, r3
 800cdae:	4a1b      	ldr	r2, [pc, #108]	@ (800ce1c <pvPortMalloc+0x18c>)
 800cdb0:	6013      	str	r3, [r2, #0]

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800cdb2:	4b1a      	ldr	r3, [pc, #104]	@ (800ce1c <pvPortMalloc+0x18c>)
 800cdb4:	681a      	ldr	r2, [r3, #0]
 800cdb6:	4b1b      	ldr	r3, [pc, #108]	@ (800ce24 <pvPortMalloc+0x194>)
 800cdb8:	681b      	ldr	r3, [r3, #0]
 800cdba:	429a      	cmp	r2, r3
 800cdbc:	d203      	bcs.n	800cdc6 <pvPortMalloc+0x136>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 800cdbe:	4b17      	ldr	r3, [pc, #92]	@ (800ce1c <pvPortMalloc+0x18c>)
 800cdc0:	681b      	ldr	r3, [r3, #0]
 800cdc2:	4a18      	ldr	r2, [pc, #96]	@ (800ce24 <pvPortMalloc+0x194>)
 800cdc4:	6013      	str	r3, [r2, #0]
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 800cdc6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cdc8:	685a      	ldr	r2, [r3, #4]
 800cdca:	4b13      	ldr	r3, [pc, #76]	@ (800ce18 <pvPortMalloc+0x188>)
 800cdcc:	681b      	ldr	r3, [r3, #0]
 800cdce:	431a      	orrs	r2, r3
 800cdd0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cdd2:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
 800cdd4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800cdd6:	2200      	movs	r2, #0
 800cdd8:	601a      	str	r2, [r3, #0]
					xNumberOfSuccessfulAllocations++;
 800cdda:	4b13      	ldr	r3, [pc, #76]	@ (800ce28 <pvPortMalloc+0x198>)
 800cddc:	681b      	ldr	r3, [r3, #0]
 800cdde:	3301      	adds	r3, #1
 800cde0:	4a11      	ldr	r2, [pc, #68]	@ (800ce28 <pvPortMalloc+0x198>)
 800cde2:	6013      	str	r3, [r2, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 800cde4:	f001 fb96 	bl	800e514 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 800cde8:	69fb      	ldr	r3, [r7, #28]
 800cdea:	f003 0307 	and.w	r3, r3, #7
 800cdee:	2b00      	cmp	r3, #0
 800cdf0:	d00b      	beq.n	800ce0a <pvPortMalloc+0x17a>
	__asm volatile
 800cdf2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800cdf6:	f383 8811 	msr	BASEPRI, r3
 800cdfa:	f3bf 8f6f 	isb	sy
 800cdfe:	f3bf 8f4f 	dsb	sy
 800ce02:	60fb      	str	r3, [r7, #12]
}
 800ce04:	bf00      	nop
 800ce06:	bf00      	nop
 800ce08:	e7fd      	b.n	800ce06 <pvPortMalloc+0x176>
	return pvReturn;
 800ce0a:	69fb      	ldr	r3, [r7, #28]
}
 800ce0c:	4618      	mov	r0, r3
 800ce0e:	3728      	adds	r7, #40	@ 0x28
 800ce10:	46bd      	mov	sp, r7
 800ce12:	bd80      	pop	{r7, pc}
 800ce14:	24005648 	.word	0x24005648
 800ce18:	2400565c 	.word	0x2400565c
 800ce1c:	2400564c 	.word	0x2400564c
 800ce20:	24005640 	.word	0x24005640
 800ce24:	24005650 	.word	0x24005650
 800ce28:	24005654 	.word	0x24005654

0800ce2c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 800ce2c:	b580      	push	{r7, lr}
 800ce2e:	b086      	sub	sp, #24
 800ce30:	af00      	add	r7, sp, #0
 800ce32:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
 800ce34:	687b      	ldr	r3, [r7, #4]
 800ce36:	617b      	str	r3, [r7, #20]
BlockLink_t *pxLink;

	if( pv != NULL )
 800ce38:	687b      	ldr	r3, [r7, #4]
 800ce3a:	2b00      	cmp	r3, #0
 800ce3c:	d04f      	beq.n	800cede <vPortFree+0xb2>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
 800ce3e:	2308      	movs	r3, #8
 800ce40:	425b      	negs	r3, r3
 800ce42:	697a      	ldr	r2, [r7, #20]
 800ce44:	4413      	add	r3, r2
 800ce46:	617b      	str	r3, [r7, #20]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
 800ce48:	697b      	ldr	r3, [r7, #20]
 800ce4a:	613b      	str	r3, [r7, #16]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800ce4c:	693b      	ldr	r3, [r7, #16]
 800ce4e:	685a      	ldr	r2, [r3, #4]
 800ce50:	4b25      	ldr	r3, [pc, #148]	@ (800cee8 <vPortFree+0xbc>)
 800ce52:	681b      	ldr	r3, [r3, #0]
 800ce54:	4013      	ands	r3, r2
 800ce56:	2b00      	cmp	r3, #0
 800ce58:	d10b      	bne.n	800ce72 <vPortFree+0x46>
	__asm volatile
 800ce5a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800ce5e:	f383 8811 	msr	BASEPRI, r3
 800ce62:	f3bf 8f6f 	isb	sy
 800ce66:	f3bf 8f4f 	dsb	sy
 800ce6a:	60fb      	str	r3, [r7, #12]
}
 800ce6c:	bf00      	nop
 800ce6e:	bf00      	nop
 800ce70:	e7fd      	b.n	800ce6e <vPortFree+0x42>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 800ce72:	693b      	ldr	r3, [r7, #16]
 800ce74:	681b      	ldr	r3, [r3, #0]
 800ce76:	2b00      	cmp	r3, #0
 800ce78:	d00b      	beq.n	800ce92 <vPortFree+0x66>
	__asm volatile
 800ce7a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800ce7e:	f383 8811 	msr	BASEPRI, r3
 800ce82:	f3bf 8f6f 	isb	sy
 800ce86:	f3bf 8f4f 	dsb	sy
 800ce8a:	60bb      	str	r3, [r7, #8]
}
 800ce8c:	bf00      	nop
 800ce8e:	bf00      	nop
 800ce90:	e7fd      	b.n	800ce8e <vPortFree+0x62>

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 800ce92:	693b      	ldr	r3, [r7, #16]
 800ce94:	685a      	ldr	r2, [r3, #4]
 800ce96:	4b14      	ldr	r3, [pc, #80]	@ (800cee8 <vPortFree+0xbc>)
 800ce98:	681b      	ldr	r3, [r3, #0]
 800ce9a:	4013      	ands	r3, r2
 800ce9c:	2b00      	cmp	r3, #0
 800ce9e:	d01e      	beq.n	800cede <vPortFree+0xb2>
		{
			if( pxLink->pxNextFreeBlock == NULL )
 800cea0:	693b      	ldr	r3, [r7, #16]
 800cea2:	681b      	ldr	r3, [r3, #0]
 800cea4:	2b00      	cmp	r3, #0
 800cea6:	d11a      	bne.n	800cede <vPortFree+0xb2>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 800cea8:	693b      	ldr	r3, [r7, #16]
 800ceaa:	685a      	ldr	r2, [r3, #4]
 800ceac:	4b0e      	ldr	r3, [pc, #56]	@ (800cee8 <vPortFree+0xbc>)
 800ceae:	681b      	ldr	r3, [r3, #0]
 800ceb0:	43db      	mvns	r3, r3
 800ceb2:	401a      	ands	r2, r3
 800ceb4:	693b      	ldr	r3, [r7, #16]
 800ceb6:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
 800ceb8:	f001 fb1e 	bl	800e4f8 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
 800cebc:	693b      	ldr	r3, [r7, #16]
 800cebe:	685a      	ldr	r2, [r3, #4]
 800cec0:	4b0a      	ldr	r3, [pc, #40]	@ (800ceec <vPortFree+0xc0>)
 800cec2:	681b      	ldr	r3, [r3, #0]
 800cec4:	4413      	add	r3, r2
 800cec6:	4a09      	ldr	r2, [pc, #36]	@ (800ceec <vPortFree+0xc0>)
 800cec8:	6013      	str	r3, [r2, #0]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 800ceca:	6938      	ldr	r0, [r7, #16]
 800cecc:	f000 f874 	bl	800cfb8 <prvInsertBlockIntoFreeList>
					xNumberOfSuccessfulFrees++;
 800ced0:	4b07      	ldr	r3, [pc, #28]	@ (800cef0 <vPortFree+0xc4>)
 800ced2:	681b      	ldr	r3, [r3, #0]
 800ced4:	3301      	adds	r3, #1
 800ced6:	4a06      	ldr	r2, [pc, #24]	@ (800cef0 <vPortFree+0xc4>)
 800ced8:	6013      	str	r3, [r2, #0]
				}
				( void ) xTaskResumeAll();
 800ceda:	f001 fb1b 	bl	800e514 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 800cede:	bf00      	nop
 800cee0:	3718      	adds	r7, #24
 800cee2:	46bd      	mov	sp, r7
 800cee4:	bd80      	pop	{r7, pc}
 800cee6:	bf00      	nop
 800cee8:	2400565c 	.word	0x2400565c
 800ceec:	2400564c 	.word	0x2400564c
 800cef0:	24005658 	.word	0x24005658

0800cef4 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
 800cef4:	b480      	push	{r7}
 800cef6:	b085      	sub	sp, #20
 800cef8:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 800cefa:	f44f 5370 	mov.w	r3, #15360	@ 0x3c00
 800cefe:	60bb      	str	r3, [r7, #8]

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 800cf00:	4b27      	ldr	r3, [pc, #156]	@ (800cfa0 <prvHeapInit+0xac>)
 800cf02:	60fb      	str	r3, [r7, #12]

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800cf04:	68fb      	ldr	r3, [r7, #12]
 800cf06:	f003 0307 	and.w	r3, r3, #7
 800cf0a:	2b00      	cmp	r3, #0
 800cf0c:	d00c      	beq.n	800cf28 <prvHeapInit+0x34>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 800cf0e:	68fb      	ldr	r3, [r7, #12]
 800cf10:	3307      	adds	r3, #7
 800cf12:	60fb      	str	r3, [r7, #12]
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800cf14:	68fb      	ldr	r3, [r7, #12]
 800cf16:	f023 0307 	bic.w	r3, r3, #7
 800cf1a:	60fb      	str	r3, [r7, #12]
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 800cf1c:	68ba      	ldr	r2, [r7, #8]
 800cf1e:	68fb      	ldr	r3, [r7, #12]
 800cf20:	1ad3      	subs	r3, r2, r3
 800cf22:	4a1f      	ldr	r2, [pc, #124]	@ (800cfa0 <prvHeapInit+0xac>)
 800cf24:	4413      	add	r3, r2
 800cf26:	60bb      	str	r3, [r7, #8]
	}

	pucAlignedHeap = ( uint8_t * ) uxAddress;
 800cf28:	68fb      	ldr	r3, [r7, #12]
 800cf2a:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800cf2c:	4a1d      	ldr	r2, [pc, #116]	@ (800cfa4 <prvHeapInit+0xb0>)
 800cf2e:	687b      	ldr	r3, [r7, #4]
 800cf30:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
 800cf32:	4b1c      	ldr	r3, [pc, #112]	@ (800cfa4 <prvHeapInit+0xb0>)
 800cf34:	2200      	movs	r2, #0
 800cf36:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 800cf38:	687b      	ldr	r3, [r7, #4]
 800cf3a:	68ba      	ldr	r2, [r7, #8]
 800cf3c:	4413      	add	r3, r2
 800cf3e:	60fb      	str	r3, [r7, #12]
	uxAddress -= xHeapStructSize;
 800cf40:	2208      	movs	r2, #8
 800cf42:	68fb      	ldr	r3, [r7, #12]
 800cf44:	1a9b      	subs	r3, r3, r2
 800cf46:	60fb      	str	r3, [r7, #12]
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800cf48:	68fb      	ldr	r3, [r7, #12]
 800cf4a:	f023 0307 	bic.w	r3, r3, #7
 800cf4e:	60fb      	str	r3, [r7, #12]
	pxEnd = ( void * ) uxAddress;
 800cf50:	68fb      	ldr	r3, [r7, #12]
 800cf52:	4a15      	ldr	r2, [pc, #84]	@ (800cfa8 <prvHeapInit+0xb4>)
 800cf54:	6013      	str	r3, [r2, #0]
	pxEnd->xBlockSize = 0;
 800cf56:	4b14      	ldr	r3, [pc, #80]	@ (800cfa8 <prvHeapInit+0xb4>)
 800cf58:	681b      	ldr	r3, [r3, #0]
 800cf5a:	2200      	movs	r2, #0
 800cf5c:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 800cf5e:	4b12      	ldr	r3, [pc, #72]	@ (800cfa8 <prvHeapInit+0xb4>)
 800cf60:	681b      	ldr	r3, [r3, #0]
 800cf62:	2200      	movs	r2, #0
 800cf64:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
 800cf66:	687b      	ldr	r3, [r7, #4]
 800cf68:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 800cf6a:	683b      	ldr	r3, [r7, #0]
 800cf6c:	68fa      	ldr	r2, [r7, #12]
 800cf6e:	1ad2      	subs	r2, r2, r3
 800cf70:	683b      	ldr	r3, [r7, #0]
 800cf72:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 800cf74:	4b0c      	ldr	r3, [pc, #48]	@ (800cfa8 <prvHeapInit+0xb4>)
 800cf76:	681a      	ldr	r2, [r3, #0]
 800cf78:	683b      	ldr	r3, [r7, #0]
 800cf7a:	601a      	str	r2, [r3, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800cf7c:	683b      	ldr	r3, [r7, #0]
 800cf7e:	685b      	ldr	r3, [r3, #4]
 800cf80:	4a0a      	ldr	r2, [pc, #40]	@ (800cfac <prvHeapInit+0xb8>)
 800cf82:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800cf84:	683b      	ldr	r3, [r7, #0]
 800cf86:	685b      	ldr	r3, [r3, #4]
 800cf88:	4a09      	ldr	r2, [pc, #36]	@ (800cfb0 <prvHeapInit+0xbc>)
 800cf8a:	6013      	str	r3, [r2, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 800cf8c:	4b09      	ldr	r3, [pc, #36]	@ (800cfb4 <prvHeapInit+0xc0>)
 800cf8e:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
 800cf92:	601a      	str	r2, [r3, #0]
}
 800cf94:	bf00      	nop
 800cf96:	3714      	adds	r7, #20
 800cf98:	46bd      	mov	sp, r7
 800cf9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cf9e:	4770      	bx	lr
 800cfa0:	24001a40 	.word	0x24001a40
 800cfa4:	24005640 	.word	0x24005640
 800cfa8:	24005648 	.word	0x24005648
 800cfac:	24005650 	.word	0x24005650
 800cfb0:	2400564c 	.word	0x2400564c
 800cfb4:	2400565c 	.word	0x2400565c

0800cfb8 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 800cfb8:	b480      	push	{r7}
 800cfba:	b085      	sub	sp, #20
 800cfbc:	af00      	add	r7, sp, #0
 800cfbe:	6078      	str	r0, [r7, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 800cfc0:	4b28      	ldr	r3, [pc, #160]	@ (800d064 <prvInsertBlockIntoFreeList+0xac>)
 800cfc2:	60fb      	str	r3, [r7, #12]
 800cfc4:	e002      	b.n	800cfcc <prvInsertBlockIntoFreeList+0x14>
 800cfc6:	68fb      	ldr	r3, [r7, #12]
 800cfc8:	681b      	ldr	r3, [r3, #0]
 800cfca:	60fb      	str	r3, [r7, #12]
 800cfcc:	68fb      	ldr	r3, [r7, #12]
 800cfce:	681b      	ldr	r3, [r3, #0]
 800cfd0:	687a      	ldr	r2, [r7, #4]
 800cfd2:	429a      	cmp	r2, r3
 800cfd4:	d8f7      	bhi.n	800cfc6 <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
 800cfd6:	68fb      	ldr	r3, [r7, #12]
 800cfd8:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 800cfda:	68fb      	ldr	r3, [r7, #12]
 800cfdc:	685b      	ldr	r3, [r3, #4]
 800cfde:	68ba      	ldr	r2, [r7, #8]
 800cfe0:	4413      	add	r3, r2
 800cfe2:	687a      	ldr	r2, [r7, #4]
 800cfe4:	429a      	cmp	r2, r3
 800cfe6:	d108      	bne.n	800cffa <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 800cfe8:	68fb      	ldr	r3, [r7, #12]
 800cfea:	685a      	ldr	r2, [r3, #4]
 800cfec:	687b      	ldr	r3, [r7, #4]
 800cfee:	685b      	ldr	r3, [r3, #4]
 800cff0:	441a      	add	r2, r3
 800cff2:	68fb      	ldr	r3, [r7, #12]
 800cff4:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
 800cff6:	68fb      	ldr	r3, [r7, #12]
 800cff8:	607b      	str	r3, [r7, #4]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
 800cffa:	687b      	ldr	r3, [r7, #4]
 800cffc:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 800cffe:	687b      	ldr	r3, [r7, #4]
 800d000:	685b      	ldr	r3, [r3, #4]
 800d002:	68ba      	ldr	r2, [r7, #8]
 800d004:	441a      	add	r2, r3
 800d006:	68fb      	ldr	r3, [r7, #12]
 800d008:	681b      	ldr	r3, [r3, #0]
 800d00a:	429a      	cmp	r2, r3
 800d00c:	d118      	bne.n	800d040 <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 800d00e:	68fb      	ldr	r3, [r7, #12]
 800d010:	681a      	ldr	r2, [r3, #0]
 800d012:	4b15      	ldr	r3, [pc, #84]	@ (800d068 <prvInsertBlockIntoFreeList+0xb0>)
 800d014:	681b      	ldr	r3, [r3, #0]
 800d016:	429a      	cmp	r2, r3
 800d018:	d00d      	beq.n	800d036 <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 800d01a:	687b      	ldr	r3, [r7, #4]
 800d01c:	685a      	ldr	r2, [r3, #4]
 800d01e:	68fb      	ldr	r3, [r7, #12]
 800d020:	681b      	ldr	r3, [r3, #0]
 800d022:	685b      	ldr	r3, [r3, #4]
 800d024:	441a      	add	r2, r3
 800d026:	687b      	ldr	r3, [r7, #4]
 800d028:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 800d02a:	68fb      	ldr	r3, [r7, #12]
 800d02c:	681b      	ldr	r3, [r3, #0]
 800d02e:	681a      	ldr	r2, [r3, #0]
 800d030:	687b      	ldr	r3, [r7, #4]
 800d032:	601a      	str	r2, [r3, #0]
 800d034:	e008      	b.n	800d048 <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 800d036:	4b0c      	ldr	r3, [pc, #48]	@ (800d068 <prvInsertBlockIntoFreeList+0xb0>)
 800d038:	681a      	ldr	r2, [r3, #0]
 800d03a:	687b      	ldr	r3, [r7, #4]
 800d03c:	601a      	str	r2, [r3, #0]
 800d03e:	e003      	b.n	800d048 <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 800d040:	68fb      	ldr	r3, [r7, #12]
 800d042:	681a      	ldr	r2, [r3, #0]
 800d044:	687b      	ldr	r3, [r7, #4]
 800d046:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 800d048:	68fa      	ldr	r2, [r7, #12]
 800d04a:	687b      	ldr	r3, [r7, #4]
 800d04c:	429a      	cmp	r2, r3
 800d04e:	d002      	beq.n	800d056 <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 800d050:	68fb      	ldr	r3, [r7, #12]
 800d052:	687a      	ldr	r2, [r7, #4]
 800d054:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 800d056:	bf00      	nop
 800d058:	3714      	adds	r7, #20
 800d05a:	46bd      	mov	sp, r7
 800d05c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d060:	4770      	bx	lr
 800d062:	bf00      	nop
 800d064:	24005640 	.word	0x24005640
 800d068:	24005648 	.word	0x24005648

0800d06c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 800d06c:	b480      	push	{r7}
 800d06e:	b083      	sub	sp, #12
 800d070:	af00      	add	r7, sp, #0
 800d072:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800d074:	687b      	ldr	r3, [r7, #4]
 800d076:	f103 0208 	add.w	r2, r3, #8
 800d07a:	687b      	ldr	r3, [r7, #4]
 800d07c:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 800d07e:	687b      	ldr	r3, [r7, #4]
 800d080:	f04f 32ff 	mov.w	r2, #4294967295
 800d084:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800d086:	687b      	ldr	r3, [r7, #4]
 800d088:	f103 0208 	add.w	r2, r3, #8
 800d08c:	687b      	ldr	r3, [r7, #4]
 800d08e:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800d090:	687b      	ldr	r3, [r7, #4]
 800d092:	f103 0208 	add.w	r2, r3, #8
 800d096:	687b      	ldr	r3, [r7, #4]
 800d098:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 800d09a:	687b      	ldr	r3, [r7, #4]
 800d09c:	2200      	movs	r2, #0
 800d09e:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 800d0a0:	bf00      	nop
 800d0a2:	370c      	adds	r7, #12
 800d0a4:	46bd      	mov	sp, r7
 800d0a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d0aa:	4770      	bx	lr

0800d0ac <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 800d0ac:	b480      	push	{r7}
 800d0ae:	b083      	sub	sp, #12
 800d0b0:	af00      	add	r7, sp, #0
 800d0b2:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 800d0b4:	687b      	ldr	r3, [r7, #4]
 800d0b6:	2200      	movs	r2, #0
 800d0b8:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 800d0ba:	bf00      	nop
 800d0bc:	370c      	adds	r7, #12
 800d0be:	46bd      	mov	sp, r7
 800d0c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d0c4:	4770      	bx	lr

0800d0c6 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 800d0c6:	b480      	push	{r7}
 800d0c8:	b085      	sub	sp, #20
 800d0ca:	af00      	add	r7, sp, #0
 800d0cc:	6078      	str	r0, [r7, #4]
 800d0ce:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
 800d0d0:	687b      	ldr	r3, [r7, #4]
 800d0d2:	685b      	ldr	r3, [r3, #4]
 800d0d4:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 800d0d6:	683b      	ldr	r3, [r7, #0]
 800d0d8:	68fa      	ldr	r2, [r7, #12]
 800d0da:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 800d0dc:	68fb      	ldr	r3, [r7, #12]
 800d0de:	689a      	ldr	r2, [r3, #8]
 800d0e0:	683b      	ldr	r3, [r7, #0]
 800d0e2:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800d0e4:	68fb      	ldr	r3, [r7, #12]
 800d0e6:	689b      	ldr	r3, [r3, #8]
 800d0e8:	683a      	ldr	r2, [r7, #0]
 800d0ea:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800d0ec:	68fb      	ldr	r3, [r7, #12]
 800d0ee:	683a      	ldr	r2, [r7, #0]
 800d0f0:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 800d0f2:	683b      	ldr	r3, [r7, #0]
 800d0f4:	687a      	ldr	r2, [r7, #4]
 800d0f6:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 800d0f8:	687b      	ldr	r3, [r7, #4]
 800d0fa:	681b      	ldr	r3, [r3, #0]
 800d0fc:	1c5a      	adds	r2, r3, #1
 800d0fe:	687b      	ldr	r3, [r7, #4]
 800d100:	601a      	str	r2, [r3, #0]
}
 800d102:	bf00      	nop
 800d104:	3714      	adds	r7, #20
 800d106:	46bd      	mov	sp, r7
 800d108:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d10c:	4770      	bx	lr

0800d10e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 800d10e:	b480      	push	{r7}
 800d110:	b085      	sub	sp, #20
 800d112:	af00      	add	r7, sp, #0
 800d114:	6078      	str	r0, [r7, #4]
 800d116:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 800d118:	683b      	ldr	r3, [r7, #0]
 800d11a:	681b      	ldr	r3, [r3, #0]
 800d11c:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 800d11e:	68bb      	ldr	r3, [r7, #8]
 800d120:	f1b3 3fff 	cmp.w	r3, #4294967295
 800d124:	d103      	bne.n	800d12e <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 800d126:	687b      	ldr	r3, [r7, #4]
 800d128:	691b      	ldr	r3, [r3, #16]
 800d12a:	60fb      	str	r3, [r7, #12]
 800d12c:	e00c      	b.n	800d148 <vListInsert+0x3a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 800d12e:	687b      	ldr	r3, [r7, #4]
 800d130:	3308      	adds	r3, #8
 800d132:	60fb      	str	r3, [r7, #12]
 800d134:	e002      	b.n	800d13c <vListInsert+0x2e>
 800d136:	68fb      	ldr	r3, [r7, #12]
 800d138:	685b      	ldr	r3, [r3, #4]
 800d13a:	60fb      	str	r3, [r7, #12]
 800d13c:	68fb      	ldr	r3, [r7, #12]
 800d13e:	685b      	ldr	r3, [r3, #4]
 800d140:	681b      	ldr	r3, [r3, #0]
 800d142:	68ba      	ldr	r2, [r7, #8]
 800d144:	429a      	cmp	r2, r3
 800d146:	d2f6      	bcs.n	800d136 <vListInsert+0x28>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 800d148:	68fb      	ldr	r3, [r7, #12]
 800d14a:	685a      	ldr	r2, [r3, #4]
 800d14c:	683b      	ldr	r3, [r7, #0]
 800d14e:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 800d150:	683b      	ldr	r3, [r7, #0]
 800d152:	685b      	ldr	r3, [r3, #4]
 800d154:	683a      	ldr	r2, [r7, #0]
 800d156:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 800d158:	683b      	ldr	r3, [r7, #0]
 800d15a:	68fa      	ldr	r2, [r7, #12]
 800d15c:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
 800d15e:	68fb      	ldr	r3, [r7, #12]
 800d160:	683a      	ldr	r2, [r7, #0]
 800d162:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 800d164:	683b      	ldr	r3, [r7, #0]
 800d166:	687a      	ldr	r2, [r7, #4]
 800d168:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 800d16a:	687b      	ldr	r3, [r7, #4]
 800d16c:	681b      	ldr	r3, [r3, #0]
 800d16e:	1c5a      	adds	r2, r3, #1
 800d170:	687b      	ldr	r3, [r7, #4]
 800d172:	601a      	str	r2, [r3, #0]
}
 800d174:	bf00      	nop
 800d176:	3714      	adds	r7, #20
 800d178:	46bd      	mov	sp, r7
 800d17a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d17e:	4770      	bx	lr

0800d180 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 800d180:	b480      	push	{r7}
 800d182:	b085      	sub	sp, #20
 800d184:	af00      	add	r7, sp, #0
 800d186:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 800d188:	687b      	ldr	r3, [r7, #4]
 800d18a:	691b      	ldr	r3, [r3, #16]
 800d18c:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800d18e:	687b      	ldr	r3, [r7, #4]
 800d190:	685b      	ldr	r3, [r3, #4]
 800d192:	687a      	ldr	r2, [r7, #4]
 800d194:	6892      	ldr	r2, [r2, #8]
 800d196:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 800d198:	687b      	ldr	r3, [r7, #4]
 800d19a:	689b      	ldr	r3, [r3, #8]
 800d19c:	687a      	ldr	r2, [r7, #4]
 800d19e:	6852      	ldr	r2, [r2, #4]
 800d1a0:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 800d1a2:	68fb      	ldr	r3, [r7, #12]
 800d1a4:	685b      	ldr	r3, [r3, #4]
 800d1a6:	687a      	ldr	r2, [r7, #4]
 800d1a8:	429a      	cmp	r2, r3
 800d1aa:	d103      	bne.n	800d1b4 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 800d1ac:	687b      	ldr	r3, [r7, #4]
 800d1ae:	689a      	ldr	r2, [r3, #8]
 800d1b0:	68fb      	ldr	r3, [r7, #12]
 800d1b2:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 800d1b4:	687b      	ldr	r3, [r7, #4]
 800d1b6:	2200      	movs	r2, #0
 800d1b8:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 800d1ba:	68fb      	ldr	r3, [r7, #12]
 800d1bc:	681b      	ldr	r3, [r3, #0]
 800d1be:	1e5a      	subs	r2, r3, #1
 800d1c0:	68fb      	ldr	r3, [r7, #12]
 800d1c2:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 800d1c4:	68fb      	ldr	r3, [r7, #12]
 800d1c6:	681b      	ldr	r3, [r3, #0]
}
 800d1c8:	4618      	mov	r0, r3
 800d1ca:	3714      	adds	r7, #20
 800d1cc:	46bd      	mov	sp, r7
 800d1ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d1d2:	4770      	bx	lr

0800d1d4 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
 800d1d4:	b480      	push	{r7}
 800d1d6:	b085      	sub	sp, #20
 800d1d8:	af00      	add	r7, sp, #0
 800d1da:	60f8      	str	r0, [r7, #12]
 800d1dc:	60b9      	str	r1, [r7, #8]
 800d1de:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
 800d1e0:	68fb      	ldr	r3, [r7, #12]
 800d1e2:	3b04      	subs	r3, #4
 800d1e4:	60fb      	str	r3, [r7, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800d1e6:	68fb      	ldr	r3, [r7, #12]
 800d1e8:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
 800d1ec:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 800d1ee:	68fb      	ldr	r3, [r7, #12]
 800d1f0:	3b04      	subs	r3, #4
 800d1f2:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 800d1f4:	68bb      	ldr	r3, [r7, #8]
 800d1f6:	f023 0201 	bic.w	r2, r3, #1
 800d1fa:	68fb      	ldr	r3, [r7, #12]
 800d1fc:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 800d1fe:	68fb      	ldr	r3, [r7, #12]
 800d200:	3b04      	subs	r3, #4
 800d202:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 800d204:	4a0c      	ldr	r2, [pc, #48]	@ (800d238 <pxPortInitialiseStack+0x64>)
 800d206:	68fb      	ldr	r3, [r7, #12]
 800d208:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 800d20a:	68fb      	ldr	r3, [r7, #12]
 800d20c:	3b14      	subs	r3, #20
 800d20e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 800d210:	687a      	ldr	r2, [r7, #4]
 800d212:	68fb      	ldr	r3, [r7, #12]
 800d214:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
 800d216:	68fb      	ldr	r3, [r7, #12]
 800d218:	3b04      	subs	r3, #4
 800d21a:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 800d21c:	68fb      	ldr	r3, [r7, #12]
 800d21e:	f06f 0202 	mvn.w	r2, #2
 800d222:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 800d224:	68fb      	ldr	r3, [r7, #12]
 800d226:	3b20      	subs	r3, #32
 800d228:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
 800d22a:	68fb      	ldr	r3, [r7, #12]
}
 800d22c:	4618      	mov	r0, r3
 800d22e:	3714      	adds	r7, #20
 800d230:	46bd      	mov	sp, r7
 800d232:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d236:	4770      	bx	lr
 800d238:	0800d23d 	.word	0x0800d23d

0800d23c <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 800d23c:	b480      	push	{r7}
 800d23e:	b085      	sub	sp, #20
 800d240:	af00      	add	r7, sp, #0
volatile uint32_t ulDummy = 0;
 800d242:	2300      	movs	r3, #0
 800d244:	607b      	str	r3, [r7, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 800d246:	4b13      	ldr	r3, [pc, #76]	@ (800d294 <prvTaskExitError+0x58>)
 800d248:	681b      	ldr	r3, [r3, #0]
 800d24a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800d24e:	d00b      	beq.n	800d268 <prvTaskExitError+0x2c>
	__asm volatile
 800d250:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d254:	f383 8811 	msr	BASEPRI, r3
 800d258:	f3bf 8f6f 	isb	sy
 800d25c:	f3bf 8f4f 	dsb	sy
 800d260:	60fb      	str	r3, [r7, #12]
}
 800d262:	bf00      	nop
 800d264:	bf00      	nop
 800d266:	e7fd      	b.n	800d264 <prvTaskExitError+0x28>
	__asm volatile
 800d268:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d26c:	f383 8811 	msr	BASEPRI, r3
 800d270:	f3bf 8f6f 	isb	sy
 800d274:	f3bf 8f4f 	dsb	sy
 800d278:	60bb      	str	r3, [r7, #8]
}
 800d27a:	bf00      	nop
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 800d27c:	bf00      	nop
 800d27e:	687b      	ldr	r3, [r7, #4]
 800d280:	2b00      	cmp	r3, #0
 800d282:	d0fc      	beq.n	800d27e <prvTaskExitError+0x42>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 800d284:	bf00      	nop
 800d286:	bf00      	nop
 800d288:	3714      	adds	r7, #20
 800d28a:	46bd      	mov	sp, r7
 800d28c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d290:	4770      	bx	lr
 800d292:	bf00      	nop
 800d294:	24000028 	.word	0x24000028
	...

0800d2a0 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 800d2a0:	4b07      	ldr	r3, [pc, #28]	@ (800d2c0 <pxCurrentTCBConst2>)
 800d2a2:	6819      	ldr	r1, [r3, #0]
 800d2a4:	6808      	ldr	r0, [r1, #0]
 800d2a6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d2aa:	f380 8809 	msr	PSP, r0
 800d2ae:	f3bf 8f6f 	isb	sy
 800d2b2:	f04f 0000 	mov.w	r0, #0
 800d2b6:	f380 8811 	msr	BASEPRI, r0
 800d2ba:	4770      	bx	lr
 800d2bc:	f3af 8000 	nop.w

0800d2c0 <pxCurrentTCBConst2>:
 800d2c0:	240056a8 	.word	0x240056a8
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
 800d2c4:	bf00      	nop
 800d2c6:	bf00      	nop

0800d2c8 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 800d2c8:	4808      	ldr	r0, [pc, #32]	@ (800d2ec <prvPortStartFirstTask+0x24>)
 800d2ca:	6800      	ldr	r0, [r0, #0]
 800d2cc:	6800      	ldr	r0, [r0, #0]
 800d2ce:	f380 8808 	msr	MSP, r0
 800d2d2:	f04f 0000 	mov.w	r0, #0
 800d2d6:	f380 8814 	msr	CONTROL, r0
 800d2da:	b662      	cpsie	i
 800d2dc:	b661      	cpsie	f
 800d2de:	f3bf 8f4f 	dsb	sy
 800d2e2:	f3bf 8f6f 	isb	sy
 800d2e6:	df00      	svc	0
 800d2e8:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 800d2ea:	bf00      	nop
 800d2ec:	e000ed08 	.word	0xe000ed08

0800d2f0 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 800d2f0:	b580      	push	{r7, lr}
 800d2f2:	b086      	sub	sp, #24
 800d2f4:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* This port can be used on all revisions of the Cortex-M7 core other than
	the r0p1 parts.  r0p1 parts should use the port from the
	/source/portable/GCC/ARM_CM7/r0p1 directory. */
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 800d2f6:	4b47      	ldr	r3, [pc, #284]	@ (800d414 <xPortStartScheduler+0x124>)
 800d2f8:	681b      	ldr	r3, [r3, #0]
 800d2fa:	4a47      	ldr	r2, [pc, #284]	@ (800d418 <xPortStartScheduler+0x128>)
 800d2fc:	4293      	cmp	r3, r2
 800d2fe:	d10b      	bne.n	800d318 <xPortStartScheduler+0x28>
	__asm volatile
 800d300:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d304:	f383 8811 	msr	BASEPRI, r3
 800d308:	f3bf 8f6f 	isb	sy
 800d30c:	f3bf 8f4f 	dsb	sy
 800d310:	613b      	str	r3, [r7, #16]
}
 800d312:	bf00      	nop
 800d314:	bf00      	nop
 800d316:	e7fd      	b.n	800d314 <xPortStartScheduler+0x24>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 800d318:	4b3e      	ldr	r3, [pc, #248]	@ (800d414 <xPortStartScheduler+0x124>)
 800d31a:	681b      	ldr	r3, [r3, #0]
 800d31c:	4a3f      	ldr	r2, [pc, #252]	@ (800d41c <xPortStartScheduler+0x12c>)
 800d31e:	4293      	cmp	r3, r2
 800d320:	d10b      	bne.n	800d33a <xPortStartScheduler+0x4a>
	__asm volatile
 800d322:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d326:	f383 8811 	msr	BASEPRI, r3
 800d32a:	f3bf 8f6f 	isb	sy
 800d32e:	f3bf 8f4f 	dsb	sy
 800d332:	60fb      	str	r3, [r7, #12]
}
 800d334:	bf00      	nop
 800d336:	bf00      	nop
 800d338:	e7fd      	b.n	800d336 <xPortStartScheduler+0x46>

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t ulOriginalPriority;
		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
 800d33a:	4b39      	ldr	r3, [pc, #228]	@ (800d420 <xPortStartScheduler+0x130>)
 800d33c:	617b      	str	r3, [r7, #20]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 800d33e:	697b      	ldr	r3, [r7, #20]
 800d340:	781b      	ldrb	r3, [r3, #0]
 800d342:	b2db      	uxtb	r3, r3
 800d344:	607b      	str	r3, [r7, #4]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 800d346:	697b      	ldr	r3, [r7, #20]
 800d348:	22ff      	movs	r2, #255	@ 0xff
 800d34a:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 800d34c:	697b      	ldr	r3, [r7, #20]
 800d34e:	781b      	ldrb	r3, [r3, #0]
 800d350:	b2db      	uxtb	r3, r3
 800d352:	70fb      	strb	r3, [r7, #3]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 800d354:	78fb      	ldrb	r3, [r7, #3]
 800d356:	b2db      	uxtb	r3, r3
 800d358:	f003 0350 	and.w	r3, r3, #80	@ 0x50
 800d35c:	b2da      	uxtb	r2, r3
 800d35e:	4b31      	ldr	r3, [pc, #196]	@ (800d424 <xPortStartScheduler+0x134>)
 800d360:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 800d362:	4b31      	ldr	r3, [pc, #196]	@ (800d428 <xPortStartScheduler+0x138>)
 800d364:	2207      	movs	r2, #7
 800d366:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800d368:	e009      	b.n	800d37e <xPortStartScheduler+0x8e>
		{
			ulMaxPRIGROUPValue--;
 800d36a:	4b2f      	ldr	r3, [pc, #188]	@ (800d428 <xPortStartScheduler+0x138>)
 800d36c:	681b      	ldr	r3, [r3, #0]
 800d36e:	3b01      	subs	r3, #1
 800d370:	4a2d      	ldr	r2, [pc, #180]	@ (800d428 <xPortStartScheduler+0x138>)
 800d372:	6013      	str	r3, [r2, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 800d374:	78fb      	ldrb	r3, [r7, #3]
 800d376:	b2db      	uxtb	r3, r3
 800d378:	005b      	lsls	r3, r3, #1
 800d37a:	b2db      	uxtb	r3, r3
 800d37c:	70fb      	strb	r3, [r7, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 800d37e:	78fb      	ldrb	r3, [r7, #3]
 800d380:	b2db      	uxtb	r3, r3
 800d382:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 800d386:	2b80      	cmp	r3, #128	@ 0x80
 800d388:	d0ef      	beq.n	800d36a <xPortStartScheduler+0x7a>
		#ifdef configPRIO_BITS
		{
			/* Check the FreeRTOS configuration that defines the number of
			priority bits matches the number of priority bits actually queried
			from the hardware. */
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 800d38a:	4b27      	ldr	r3, [pc, #156]	@ (800d428 <xPortStartScheduler+0x138>)
 800d38c:	681b      	ldr	r3, [r3, #0]
 800d38e:	f1c3 0307 	rsb	r3, r3, #7
 800d392:	2b04      	cmp	r3, #4
 800d394:	d00b      	beq.n	800d3ae <xPortStartScheduler+0xbe>
	__asm volatile
 800d396:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d39a:	f383 8811 	msr	BASEPRI, r3
 800d39e:	f3bf 8f6f 	isb	sy
 800d3a2:	f3bf 8f4f 	dsb	sy
 800d3a6:	60bb      	str	r3, [r7, #8]
}
 800d3a8:	bf00      	nop
 800d3aa:	bf00      	nop
 800d3ac:	e7fd      	b.n	800d3aa <xPortStartScheduler+0xba>
		}
		#endif

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 800d3ae:	4b1e      	ldr	r3, [pc, #120]	@ (800d428 <xPortStartScheduler+0x138>)
 800d3b0:	681b      	ldr	r3, [r3, #0]
 800d3b2:	021b      	lsls	r3, r3, #8
 800d3b4:	4a1c      	ldr	r2, [pc, #112]	@ (800d428 <xPortStartScheduler+0x138>)
 800d3b6:	6013      	str	r3, [r2, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 800d3b8:	4b1b      	ldr	r3, [pc, #108]	@ (800d428 <xPortStartScheduler+0x138>)
 800d3ba:	681b      	ldr	r3, [r3, #0]
 800d3bc:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 800d3c0:	4a19      	ldr	r2, [pc, #100]	@ (800d428 <xPortStartScheduler+0x138>)
 800d3c2:	6013      	str	r3, [r2, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 800d3c4:	687b      	ldr	r3, [r7, #4]
 800d3c6:	b2da      	uxtb	r2, r3
 800d3c8:	697b      	ldr	r3, [r7, #20]
 800d3ca:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 800d3cc:	4b17      	ldr	r3, [pc, #92]	@ (800d42c <xPortStartScheduler+0x13c>)
 800d3ce:	681b      	ldr	r3, [r3, #0]
 800d3d0:	4a16      	ldr	r2, [pc, #88]	@ (800d42c <xPortStartScheduler+0x13c>)
 800d3d2:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 800d3d6:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 800d3d8:	4b14      	ldr	r3, [pc, #80]	@ (800d42c <xPortStartScheduler+0x13c>)
 800d3da:	681b      	ldr	r3, [r3, #0]
 800d3dc:	4a13      	ldr	r2, [pc, #76]	@ (800d42c <xPortStartScheduler+0x13c>)
 800d3de:	f043 4370 	orr.w	r3, r3, #4026531840	@ 0xf0000000
 800d3e2:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 800d3e4:	f000 f8da 	bl	800d59c <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 800d3e8:	4b11      	ldr	r3, [pc, #68]	@ (800d430 <xPortStartScheduler+0x140>)
 800d3ea:	2200      	movs	r2, #0
 800d3ec:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
 800d3ee:	f000 f8f9 	bl	800d5e4 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 800d3f2:	4b10      	ldr	r3, [pc, #64]	@ (800d434 <xPortStartScheduler+0x144>)
 800d3f4:	681b      	ldr	r3, [r3, #0]
 800d3f6:	4a0f      	ldr	r2, [pc, #60]	@ (800d434 <xPortStartScheduler+0x144>)
 800d3f8:	f043 4340 	orr.w	r3, r3, #3221225472	@ 0xc0000000
 800d3fc:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 800d3fe:	f7ff ff63 	bl	800d2c8 <prvPortStartFirstTask>
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
 800d402:	f001 f9ef 	bl	800e7e4 <vTaskSwitchContext>
	prvTaskExitError();
 800d406:	f7ff ff19 	bl	800d23c <prvTaskExitError>

	/* Should not get here! */
	return 0;
 800d40a:	2300      	movs	r3, #0
}
 800d40c:	4618      	mov	r0, r3
 800d40e:	3718      	adds	r7, #24
 800d410:	46bd      	mov	sp, r7
 800d412:	bd80      	pop	{r7, pc}
 800d414:	e000ed00 	.word	0xe000ed00
 800d418:	410fc271 	.word	0x410fc271
 800d41c:	410fc270 	.word	0x410fc270
 800d420:	e000e400 	.word	0xe000e400
 800d424:	24005660 	.word	0x24005660
 800d428:	24005664 	.word	0x24005664
 800d42c:	e000ed20 	.word	0xe000ed20
 800d430:	24000028 	.word	0x24000028
 800d434:	e000ef34 	.word	0xe000ef34

0800d438 <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 800d438:	b480      	push	{r7}
 800d43a:	b083      	sub	sp, #12
 800d43c:	af00      	add	r7, sp, #0
	__asm volatile
 800d43e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d442:	f383 8811 	msr	BASEPRI, r3
 800d446:	f3bf 8f6f 	isb	sy
 800d44a:	f3bf 8f4f 	dsb	sy
 800d44e:	607b      	str	r3, [r7, #4]
}
 800d450:	bf00      	nop
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
 800d452:	4b10      	ldr	r3, [pc, #64]	@ (800d494 <vPortEnterCritical+0x5c>)
 800d454:	681b      	ldr	r3, [r3, #0]
 800d456:	3301      	adds	r3, #1
 800d458:	4a0e      	ldr	r2, [pc, #56]	@ (800d494 <vPortEnterCritical+0x5c>)
 800d45a:	6013      	str	r3, [r2, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
 800d45c:	4b0d      	ldr	r3, [pc, #52]	@ (800d494 <vPortEnterCritical+0x5c>)
 800d45e:	681b      	ldr	r3, [r3, #0]
 800d460:	2b01      	cmp	r3, #1
 800d462:	d110      	bne.n	800d486 <vPortEnterCritical+0x4e>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 800d464:	4b0c      	ldr	r3, [pc, #48]	@ (800d498 <vPortEnterCritical+0x60>)
 800d466:	681b      	ldr	r3, [r3, #0]
 800d468:	b2db      	uxtb	r3, r3
 800d46a:	2b00      	cmp	r3, #0
 800d46c:	d00b      	beq.n	800d486 <vPortEnterCritical+0x4e>
	__asm volatile
 800d46e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d472:	f383 8811 	msr	BASEPRI, r3
 800d476:	f3bf 8f6f 	isb	sy
 800d47a:	f3bf 8f4f 	dsb	sy
 800d47e:	603b      	str	r3, [r7, #0]
}
 800d480:	bf00      	nop
 800d482:	bf00      	nop
 800d484:	e7fd      	b.n	800d482 <vPortEnterCritical+0x4a>
	}
}
 800d486:	bf00      	nop
 800d488:	370c      	adds	r7, #12
 800d48a:	46bd      	mov	sp, r7
 800d48c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d490:	4770      	bx	lr
 800d492:	bf00      	nop
 800d494:	24000028 	.word	0x24000028
 800d498:	e000ed04 	.word	0xe000ed04

0800d49c <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 800d49c:	b480      	push	{r7}
 800d49e:	b083      	sub	sp, #12
 800d4a0:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
 800d4a2:	4b12      	ldr	r3, [pc, #72]	@ (800d4ec <vPortExitCritical+0x50>)
 800d4a4:	681b      	ldr	r3, [r3, #0]
 800d4a6:	2b00      	cmp	r3, #0
 800d4a8:	d10b      	bne.n	800d4c2 <vPortExitCritical+0x26>
	__asm volatile
 800d4aa:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d4ae:	f383 8811 	msr	BASEPRI, r3
 800d4b2:	f3bf 8f6f 	isb	sy
 800d4b6:	f3bf 8f4f 	dsb	sy
 800d4ba:	607b      	str	r3, [r7, #4]
}
 800d4bc:	bf00      	nop
 800d4be:	bf00      	nop
 800d4c0:	e7fd      	b.n	800d4be <vPortExitCritical+0x22>
	uxCriticalNesting--;
 800d4c2:	4b0a      	ldr	r3, [pc, #40]	@ (800d4ec <vPortExitCritical+0x50>)
 800d4c4:	681b      	ldr	r3, [r3, #0]
 800d4c6:	3b01      	subs	r3, #1
 800d4c8:	4a08      	ldr	r2, [pc, #32]	@ (800d4ec <vPortExitCritical+0x50>)
 800d4ca:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 800d4cc:	4b07      	ldr	r3, [pc, #28]	@ (800d4ec <vPortExitCritical+0x50>)
 800d4ce:	681b      	ldr	r3, [r3, #0]
 800d4d0:	2b00      	cmp	r3, #0
 800d4d2:	d105      	bne.n	800d4e0 <vPortExitCritical+0x44>
 800d4d4:	2300      	movs	r3, #0
 800d4d6:	603b      	str	r3, [r7, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 800d4d8:	683b      	ldr	r3, [r7, #0]
 800d4da:	f383 8811 	msr	BASEPRI, r3
	(
		"	msr basepri, %0	" :: "r" ( ulNewMaskValue ) : "memory"
	);
}
 800d4de:	bf00      	nop
	{
		portENABLE_INTERRUPTS();
	}
}
 800d4e0:	bf00      	nop
 800d4e2:	370c      	adds	r7, #12
 800d4e4:	46bd      	mov	sp, r7
 800d4e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d4ea:	4770      	bx	lr
 800d4ec:	24000028 	.word	0x24000028

0800d4f0 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 800d4f0:	f3ef 8009 	mrs	r0, PSP
 800d4f4:	f3bf 8f6f 	isb	sy
 800d4f8:	4b15      	ldr	r3, [pc, #84]	@ (800d550 <pxCurrentTCBConst>)
 800d4fa:	681a      	ldr	r2, [r3, #0]
 800d4fc:	f01e 0f10 	tst.w	lr, #16
 800d500:	bf08      	it	eq
 800d502:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 800d506:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d50a:	6010      	str	r0, [r2, #0]
 800d50c:	e92d 0009 	stmdb	sp!, {r0, r3}
 800d510:	f04f 0050 	mov.w	r0, #80	@ 0x50
 800d514:	f380 8811 	msr	BASEPRI, r0
 800d518:	f3bf 8f4f 	dsb	sy
 800d51c:	f3bf 8f6f 	isb	sy
 800d520:	f001 f960 	bl	800e7e4 <vTaskSwitchContext>
 800d524:	f04f 0000 	mov.w	r0, #0
 800d528:	f380 8811 	msr	BASEPRI, r0
 800d52c:	bc09      	pop	{r0, r3}
 800d52e:	6819      	ldr	r1, [r3, #0]
 800d530:	6808      	ldr	r0, [r1, #0]
 800d532:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d536:	f01e 0f10 	tst.w	lr, #16
 800d53a:	bf08      	it	eq
 800d53c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 800d540:	f380 8809 	msr	PSP, r0
 800d544:	f3bf 8f6f 	isb	sy
 800d548:	4770      	bx	lr
 800d54a:	bf00      	nop
 800d54c:	f3af 8000 	nop.w

0800d550 <pxCurrentTCBConst>:
 800d550:	240056a8 	.word	0x240056a8
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
 800d554:	bf00      	nop
 800d556:	bf00      	nop

0800d558 <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 800d558:	b580      	push	{r7, lr}
 800d55a:	b082      	sub	sp, #8
 800d55c:	af00      	add	r7, sp, #0
	__asm volatile
 800d55e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d562:	f383 8811 	msr	BASEPRI, r3
 800d566:	f3bf 8f6f 	isb	sy
 800d56a:	f3bf 8f4f 	dsb	sy
 800d56e:	607b      	str	r3, [r7, #4]
}
 800d570:	bf00      	nop
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 800d572:	f001 f87d 	bl	800e670 <xTaskIncrementTick>
 800d576:	4603      	mov	r3, r0
 800d578:	2b00      	cmp	r3, #0
 800d57a:	d003      	beq.n	800d584 <xPortSysTickHandler+0x2c>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800d57c:	4b06      	ldr	r3, [pc, #24]	@ (800d598 <xPortSysTickHandler+0x40>)
 800d57e:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800d582:	601a      	str	r2, [r3, #0]
 800d584:	2300      	movs	r3, #0
 800d586:	603b      	str	r3, [r7, #0]
	__asm volatile
 800d588:	683b      	ldr	r3, [r7, #0]
 800d58a:	f383 8811 	msr	BASEPRI, r3
}
 800d58e:	bf00      	nop
		}
	}
	portENABLE_INTERRUPTS();
}
 800d590:	bf00      	nop
 800d592:	3708      	adds	r7, #8
 800d594:	46bd      	mov	sp, r7
 800d596:	bd80      	pop	{r7, pc}
 800d598:	e000ed04 	.word	0xe000ed04

0800d59c <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
 800d59c:	b480      	push	{r7}
 800d59e:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 800d5a0:	4b0b      	ldr	r3, [pc, #44]	@ (800d5d0 <vPortSetupTimerInterrupt+0x34>)
 800d5a2:	2200      	movs	r2, #0
 800d5a4:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 800d5a6:	4b0b      	ldr	r3, [pc, #44]	@ (800d5d4 <vPortSetupTimerInterrupt+0x38>)
 800d5a8:	2200      	movs	r2, #0
 800d5aa:	601a      	str	r2, [r3, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800d5ac:	4b0a      	ldr	r3, [pc, #40]	@ (800d5d8 <vPortSetupTimerInterrupt+0x3c>)
 800d5ae:	681b      	ldr	r3, [r3, #0]
 800d5b0:	4a0a      	ldr	r2, [pc, #40]	@ (800d5dc <vPortSetupTimerInterrupt+0x40>)
 800d5b2:	fba2 2303 	umull	r2, r3, r2, r3
 800d5b6:	099b      	lsrs	r3, r3, #6
 800d5b8:	4a09      	ldr	r2, [pc, #36]	@ (800d5e0 <vPortSetupTimerInterrupt+0x44>)
 800d5ba:	3b01      	subs	r3, #1
 800d5bc:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 800d5be:	4b04      	ldr	r3, [pc, #16]	@ (800d5d0 <vPortSetupTimerInterrupt+0x34>)
 800d5c0:	2207      	movs	r2, #7
 800d5c2:	601a      	str	r2, [r3, #0]
}
 800d5c4:	bf00      	nop
 800d5c6:	46bd      	mov	sp, r7
 800d5c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d5cc:	4770      	bx	lr
 800d5ce:	bf00      	nop
 800d5d0:	e000e010 	.word	0xe000e010
 800d5d4:	e000e018 	.word	0xe000e018
 800d5d8:	24000000 	.word	0x24000000
 800d5dc:	10624dd3 	.word	0x10624dd3
 800d5e0:	e000e014 	.word	0xe000e014

0800d5e4 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 800d5e4:	f8df 000c 	ldr.w	r0, [pc, #12]	@ 800d5f4 <vPortEnableVFP+0x10>
 800d5e8:	6801      	ldr	r1, [r0, #0]
 800d5ea:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 800d5ee:	6001      	str	r1, [r0, #0]
 800d5f0:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
 800d5f2:	bf00      	nop
 800d5f4:	e000ed88 	.word	0xe000ed88

0800d5f8 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
 800d5f8:	b480      	push	{r7}
 800d5fa:	b085      	sub	sp, #20
 800d5fc:	af00      	add	r7, sp, #0
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 800d5fe:	f3ef 8305 	mrs	r3, IPSR
 800d602:	60fb      	str	r3, [r7, #12]

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 800d604:	68fb      	ldr	r3, [r7, #12]
 800d606:	2b0f      	cmp	r3, #15
 800d608:	d915      	bls.n	800d636 <vPortValidateInterruptPriority+0x3e>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 800d60a:	4a18      	ldr	r2, [pc, #96]	@ (800d66c <vPortValidateInterruptPriority+0x74>)
 800d60c:	68fb      	ldr	r3, [r7, #12]
 800d60e:	4413      	add	r3, r2
 800d610:	781b      	ldrb	r3, [r3, #0]
 800d612:	72fb      	strb	r3, [r7, #11]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 800d614:	4b16      	ldr	r3, [pc, #88]	@ (800d670 <vPortValidateInterruptPriority+0x78>)
 800d616:	781b      	ldrb	r3, [r3, #0]
 800d618:	7afa      	ldrb	r2, [r7, #11]
 800d61a:	429a      	cmp	r2, r3
 800d61c:	d20b      	bcs.n	800d636 <vPortValidateInterruptPriority+0x3e>
	__asm volatile
 800d61e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d622:	f383 8811 	msr	BASEPRI, r3
 800d626:	f3bf 8f6f 	isb	sy
 800d62a:	f3bf 8f4f 	dsb	sy
 800d62e:	607b      	str	r3, [r7, #4]
}
 800d630:	bf00      	nop
 800d632:	bf00      	nop
 800d634:	e7fd      	b.n	800d632 <vPortValidateInterruptPriority+0x3a>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 800d636:	4b0f      	ldr	r3, [pc, #60]	@ (800d674 <vPortValidateInterruptPriority+0x7c>)
 800d638:	681b      	ldr	r3, [r3, #0]
 800d63a:	f403 62e0 	and.w	r2, r3, #1792	@ 0x700
 800d63e:	4b0e      	ldr	r3, [pc, #56]	@ (800d678 <vPortValidateInterruptPriority+0x80>)
 800d640:	681b      	ldr	r3, [r3, #0]
 800d642:	429a      	cmp	r2, r3
 800d644:	d90b      	bls.n	800d65e <vPortValidateInterruptPriority+0x66>
	__asm volatile
 800d646:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d64a:	f383 8811 	msr	BASEPRI, r3
 800d64e:	f3bf 8f6f 	isb	sy
 800d652:	f3bf 8f4f 	dsb	sy
 800d656:	603b      	str	r3, [r7, #0]
}
 800d658:	bf00      	nop
 800d65a:	bf00      	nop
 800d65c:	e7fd      	b.n	800d65a <vPortValidateInterruptPriority+0x62>
	}
 800d65e:	bf00      	nop
 800d660:	3714      	adds	r7, #20
 800d662:	46bd      	mov	sp, r7
 800d664:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d668:	4770      	bx	lr
 800d66a:	bf00      	nop
 800d66c:	e000e3f0 	.word	0xe000e3f0
 800d670:	24005660 	.word	0x24005660
 800d674:	e000ed0c 	.word	0xe000ed0c
 800d678:	24005664 	.word	0x24005664

0800d67c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 800d67c:	b580      	push	{r7, lr}
 800d67e:	b084      	sub	sp, #16
 800d680:	af00      	add	r7, sp, #0
 800d682:	6078      	str	r0, [r7, #4]
 800d684:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = xQueue;
 800d686:	687b      	ldr	r3, [r7, #4]
 800d688:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
 800d68a:	68fb      	ldr	r3, [r7, #12]
 800d68c:	2b00      	cmp	r3, #0
 800d68e:	d10b      	bne.n	800d6a8 <xQueueGenericReset+0x2c>
	__asm volatile
 800d690:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d694:	f383 8811 	msr	BASEPRI, r3
 800d698:	f3bf 8f6f 	isb	sy
 800d69c:	f3bf 8f4f 	dsb	sy
 800d6a0:	60bb      	str	r3, [r7, #8]
}
 800d6a2:	bf00      	nop
 800d6a4:	bf00      	nop
 800d6a6:	e7fd      	b.n	800d6a4 <xQueueGenericReset+0x28>

	taskENTER_CRITICAL();
 800d6a8:	f7ff fec6 	bl	800d438 <vPortEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800d6ac:	68fb      	ldr	r3, [r7, #12]
 800d6ae:	681a      	ldr	r2, [r3, #0]
 800d6b0:	68fb      	ldr	r3, [r7, #12]
 800d6b2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800d6b4:	68f9      	ldr	r1, [r7, #12]
 800d6b6:	6c09      	ldr	r1, [r1, #64]	@ 0x40
 800d6b8:	fb01 f303 	mul.w	r3, r1, r3
 800d6bc:	441a      	add	r2, r3
 800d6be:	68fb      	ldr	r3, [r7, #12]
 800d6c0:	609a      	str	r2, [r3, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800d6c2:	68fb      	ldr	r3, [r7, #12]
 800d6c4:	2200      	movs	r2, #0
 800d6c6:	639a      	str	r2, [r3, #56]	@ 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 800d6c8:	68fb      	ldr	r3, [r7, #12]
 800d6ca:	681a      	ldr	r2, [r3, #0]
 800d6cc:	68fb      	ldr	r3, [r7, #12]
 800d6ce:	605a      	str	r2, [r3, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 800d6d0:	68fb      	ldr	r3, [r7, #12]
 800d6d2:	681a      	ldr	r2, [r3, #0]
 800d6d4:	68fb      	ldr	r3, [r7, #12]
 800d6d6:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800d6d8:	3b01      	subs	r3, #1
 800d6da:	68f9      	ldr	r1, [r7, #12]
 800d6dc:	6c09      	ldr	r1, [r1, #64]	@ 0x40
 800d6de:	fb01 f303 	mul.w	r3, r1, r3
 800d6e2:	441a      	add	r2, r3
 800d6e4:	68fb      	ldr	r3, [r7, #12]
 800d6e6:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 800d6e8:	68fb      	ldr	r3, [r7, #12]
 800d6ea:	22ff      	movs	r2, #255	@ 0xff
 800d6ec:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 800d6f0:	68fb      	ldr	r3, [r7, #12]
 800d6f2:	22ff      	movs	r2, #255	@ 0xff
 800d6f4:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45

		if( xNewQueue == pdFALSE )
 800d6f8:	683b      	ldr	r3, [r7, #0]
 800d6fa:	2b00      	cmp	r3, #0
 800d6fc:	d114      	bne.n	800d728 <xQueueGenericReset+0xac>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800d6fe:	68fb      	ldr	r3, [r7, #12]
 800d700:	691b      	ldr	r3, [r3, #16]
 800d702:	2b00      	cmp	r3, #0
 800d704:	d01a      	beq.n	800d73c <xQueueGenericReset+0xc0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800d706:	68fb      	ldr	r3, [r7, #12]
 800d708:	3310      	adds	r3, #16
 800d70a:	4618      	mov	r0, r3
 800d70c:	f001 f91a 	bl	800e944 <xTaskRemoveFromEventList>
 800d710:	4603      	mov	r3, r0
 800d712:	2b00      	cmp	r3, #0
 800d714:	d012      	beq.n	800d73c <xQueueGenericReset+0xc0>
				{
					queueYIELD_IF_USING_PREEMPTION();
 800d716:	4b0d      	ldr	r3, [pc, #52]	@ (800d74c <xQueueGenericReset+0xd0>)
 800d718:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800d71c:	601a      	str	r2, [r3, #0]
 800d71e:	f3bf 8f4f 	dsb	sy
 800d722:	f3bf 8f6f 	isb	sy
 800d726:	e009      	b.n	800d73c <xQueueGenericReset+0xc0>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800d728:	68fb      	ldr	r3, [r7, #12]
 800d72a:	3310      	adds	r3, #16
 800d72c:	4618      	mov	r0, r3
 800d72e:	f7ff fc9d 	bl	800d06c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 800d732:	68fb      	ldr	r3, [r7, #12]
 800d734:	3324      	adds	r3, #36	@ 0x24
 800d736:	4618      	mov	r0, r3
 800d738:	f7ff fc98 	bl	800d06c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 800d73c:	f7ff feae 	bl	800d49c <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
 800d740:	2301      	movs	r3, #1
}
 800d742:	4618      	mov	r0, r3
 800d744:	3710      	adds	r7, #16
 800d746:	46bd      	mov	sp, r7
 800d748:	bd80      	pop	{r7, pc}
 800d74a:	bf00      	nop
 800d74c:	e000ed04 	.word	0xe000ed04

0800d750 <xQueueGenericCreateStatic>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_STATIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )
	{
 800d750:	b580      	push	{r7, lr}
 800d752:	b08e      	sub	sp, #56	@ 0x38
 800d754:	af02      	add	r7, sp, #8
 800d756:	60f8      	str	r0, [r7, #12]
 800d758:	60b9      	str	r1, [r7, #8]
 800d75a:	607a      	str	r2, [r7, #4]
 800d75c:	603b      	str	r3, [r7, #0]
	Queue_t *pxNewQueue;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 800d75e:	68fb      	ldr	r3, [r7, #12]
 800d760:	2b00      	cmp	r3, #0
 800d762:	d10b      	bne.n	800d77c <xQueueGenericCreateStatic+0x2c>
	__asm volatile
 800d764:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d768:	f383 8811 	msr	BASEPRI, r3
 800d76c:	f3bf 8f6f 	isb	sy
 800d770:	f3bf 8f4f 	dsb	sy
 800d774:	62bb      	str	r3, [r7, #40]	@ 0x28
}
 800d776:	bf00      	nop
 800d778:	bf00      	nop
 800d77a:	e7fd      	b.n	800d778 <xQueueGenericCreateStatic+0x28>

		/* The StaticQueue_t structure and the queue storage area must be
		supplied. */
		configASSERT( pxStaticQueue != NULL );
 800d77c:	683b      	ldr	r3, [r7, #0]
 800d77e:	2b00      	cmp	r3, #0
 800d780:	d10b      	bne.n	800d79a <xQueueGenericCreateStatic+0x4a>
	__asm volatile
 800d782:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d786:	f383 8811 	msr	BASEPRI, r3
 800d78a:	f3bf 8f6f 	isb	sy
 800d78e:	f3bf 8f4f 	dsb	sy
 800d792:	627b      	str	r3, [r7, #36]	@ 0x24
}
 800d794:	bf00      	nop
 800d796:	bf00      	nop
 800d798:	e7fd      	b.n	800d796 <xQueueGenericCreateStatic+0x46>

		/* A queue storage area should be provided if the item size is not 0, and
		should not be provided if the item size is 0. */
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 800d79a:	687b      	ldr	r3, [r7, #4]
 800d79c:	2b00      	cmp	r3, #0
 800d79e:	d002      	beq.n	800d7a6 <xQueueGenericCreateStatic+0x56>
 800d7a0:	68bb      	ldr	r3, [r7, #8]
 800d7a2:	2b00      	cmp	r3, #0
 800d7a4:	d001      	beq.n	800d7aa <xQueueGenericCreateStatic+0x5a>
 800d7a6:	2301      	movs	r3, #1
 800d7a8:	e000      	b.n	800d7ac <xQueueGenericCreateStatic+0x5c>
 800d7aa:	2300      	movs	r3, #0
 800d7ac:	2b00      	cmp	r3, #0
 800d7ae:	d10b      	bne.n	800d7c8 <xQueueGenericCreateStatic+0x78>
	__asm volatile
 800d7b0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d7b4:	f383 8811 	msr	BASEPRI, r3
 800d7b8:	f3bf 8f6f 	isb	sy
 800d7bc:	f3bf 8f4f 	dsb	sy
 800d7c0:	623b      	str	r3, [r7, #32]
}
 800d7c2:	bf00      	nop
 800d7c4:	bf00      	nop
 800d7c6:	e7fd      	b.n	800d7c4 <xQueueGenericCreateStatic+0x74>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 800d7c8:	687b      	ldr	r3, [r7, #4]
 800d7ca:	2b00      	cmp	r3, #0
 800d7cc:	d102      	bne.n	800d7d4 <xQueueGenericCreateStatic+0x84>
 800d7ce:	68bb      	ldr	r3, [r7, #8]
 800d7d0:	2b00      	cmp	r3, #0
 800d7d2:	d101      	bne.n	800d7d8 <xQueueGenericCreateStatic+0x88>
 800d7d4:	2301      	movs	r3, #1
 800d7d6:	e000      	b.n	800d7da <xQueueGenericCreateStatic+0x8a>
 800d7d8:	2300      	movs	r3, #0
 800d7da:	2b00      	cmp	r3, #0
 800d7dc:	d10b      	bne.n	800d7f6 <xQueueGenericCreateStatic+0xa6>
	__asm volatile
 800d7de:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d7e2:	f383 8811 	msr	BASEPRI, r3
 800d7e6:	f3bf 8f6f 	isb	sy
 800d7ea:	f3bf 8f4f 	dsb	sy
 800d7ee:	61fb      	str	r3, [r7, #28]
}
 800d7f0:	bf00      	nop
 800d7f2:	bf00      	nop
 800d7f4:	e7fd      	b.n	800d7f2 <xQueueGenericCreateStatic+0xa2>
		#if( configASSERT_DEFINED == 1 )
		{
			/* Sanity check that the size of the structure used to declare a
			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
			the real queue and semaphore structures. */
			volatile size_t xSize = sizeof( StaticQueue_t );
 800d7f6:	2350      	movs	r3, #80	@ 0x50
 800d7f8:	617b      	str	r3, [r7, #20]
			configASSERT( xSize == sizeof( Queue_t ) );
 800d7fa:	697b      	ldr	r3, [r7, #20]
 800d7fc:	2b50      	cmp	r3, #80	@ 0x50
 800d7fe:	d00b      	beq.n	800d818 <xQueueGenericCreateStatic+0xc8>
	__asm volatile
 800d800:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d804:	f383 8811 	msr	BASEPRI, r3
 800d808:	f3bf 8f6f 	isb	sy
 800d80c:	f3bf 8f4f 	dsb	sy
 800d810:	61bb      	str	r3, [r7, #24]
}
 800d812:	bf00      	nop
 800d814:	bf00      	nop
 800d816:	e7fd      	b.n	800d814 <xQueueGenericCreateStatic+0xc4>
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 800d818:	697b      	ldr	r3, [r7, #20]
		#endif /* configASSERT_DEFINED */

		/* The address of a statically allocated queue was passed in, use it.
		The address of a statically allocated storage area was also passed in
		but is already set. */
		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
 800d81a:	683b      	ldr	r3, [r7, #0]
 800d81c:	62fb      	str	r3, [r7, #44]	@ 0x2c

		if( pxNewQueue != NULL )
 800d81e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d820:	2b00      	cmp	r3, #0
 800d822:	d00d      	beq.n	800d840 <xQueueGenericCreateStatic+0xf0>
			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
			{
				/* Queues can be allocated wither statically or dynamically, so
				note this queue was allocated statically in case the queue is
				later deleted. */
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 800d824:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d826:	2201      	movs	r2, #1
 800d828:	f883 2046 	strb.w	r2, [r3, #70]	@ 0x46
			}
			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 800d82c:	f897 2038 	ldrb.w	r2, [r7, #56]	@ 0x38
 800d830:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d832:	9300      	str	r3, [sp, #0]
 800d834:	4613      	mov	r3, r2
 800d836:	687a      	ldr	r2, [r7, #4]
 800d838:	68b9      	ldr	r1, [r7, #8]
 800d83a:	68f8      	ldr	r0, [r7, #12]
 800d83c:	f000 f805 	bl	800d84a <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
 800d840:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
	}
 800d842:	4618      	mov	r0, r3
 800d844:	3730      	adds	r7, #48	@ 0x30
 800d846:	46bd      	mov	sp, r7
 800d848:	bd80      	pop	{r7, pc}

0800d84a <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
 800d84a:	b580      	push	{r7, lr}
 800d84c:	b084      	sub	sp, #16
 800d84e:	af00      	add	r7, sp, #0
 800d850:	60f8      	str	r0, [r7, #12]
 800d852:	60b9      	str	r1, [r7, #8]
 800d854:	607a      	str	r2, [r7, #4]
 800d856:	70fb      	strb	r3, [r7, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
 800d858:	68bb      	ldr	r3, [r7, #8]
 800d85a:	2b00      	cmp	r3, #0
 800d85c:	d103      	bne.n	800d866 <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 800d85e:	69bb      	ldr	r3, [r7, #24]
 800d860:	69ba      	ldr	r2, [r7, #24]
 800d862:	601a      	str	r2, [r3, #0]
 800d864:	e002      	b.n	800d86c <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 800d866:	69bb      	ldr	r3, [r7, #24]
 800d868:	687a      	ldr	r2, [r7, #4]
 800d86a:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
 800d86c:	69bb      	ldr	r3, [r7, #24]
 800d86e:	68fa      	ldr	r2, [r7, #12]
 800d870:	63da      	str	r2, [r3, #60]	@ 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 800d872:	69bb      	ldr	r3, [r7, #24]
 800d874:	68ba      	ldr	r2, [r7, #8]
 800d876:	641a      	str	r2, [r3, #64]	@ 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800d878:	2101      	movs	r1, #1
 800d87a:	69b8      	ldr	r0, [r7, #24]
 800d87c:	f7ff fefe 	bl	800d67c <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
 800d880:	69bb      	ldr	r3, [r7, #24]
 800d882:	78fa      	ldrb	r2, [r7, #3]
 800d884:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
 800d888:	bf00      	nop
 800d88a:	3710      	adds	r7, #16
 800d88c:	46bd      	mov	sp, r7
 800d88e:	bd80      	pop	{r7, pc}

0800d890 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 800d890:	b580      	push	{r7, lr}
 800d892:	b08e      	sub	sp, #56	@ 0x38
 800d894:	af00      	add	r7, sp, #0
 800d896:	60f8      	str	r0, [r7, #12]
 800d898:	60b9      	str	r1, [r7, #8]
 800d89a:	607a      	str	r2, [r7, #4]
 800d89c:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 800d89e:	2300      	movs	r3, #0
 800d8a0:	637b      	str	r3, [r7, #52]	@ 0x34
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 800d8a2:	68fb      	ldr	r3, [r7, #12]
 800d8a4:	633b      	str	r3, [r7, #48]	@ 0x30

	configASSERT( pxQueue );
 800d8a6:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d8a8:	2b00      	cmp	r3, #0
 800d8aa:	d10b      	bne.n	800d8c4 <xQueueGenericSend+0x34>
	__asm volatile
 800d8ac:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d8b0:	f383 8811 	msr	BASEPRI, r3
 800d8b4:	f3bf 8f6f 	isb	sy
 800d8b8:	f3bf 8f4f 	dsb	sy
 800d8bc:	62bb      	str	r3, [r7, #40]	@ 0x28
}
 800d8be:	bf00      	nop
 800d8c0:	bf00      	nop
 800d8c2:	e7fd      	b.n	800d8c0 <xQueueGenericSend+0x30>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800d8c4:	68bb      	ldr	r3, [r7, #8]
 800d8c6:	2b00      	cmp	r3, #0
 800d8c8:	d103      	bne.n	800d8d2 <xQueueGenericSend+0x42>
 800d8ca:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d8cc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800d8ce:	2b00      	cmp	r3, #0
 800d8d0:	d101      	bne.n	800d8d6 <xQueueGenericSend+0x46>
 800d8d2:	2301      	movs	r3, #1
 800d8d4:	e000      	b.n	800d8d8 <xQueueGenericSend+0x48>
 800d8d6:	2300      	movs	r3, #0
 800d8d8:	2b00      	cmp	r3, #0
 800d8da:	d10b      	bne.n	800d8f4 <xQueueGenericSend+0x64>
	__asm volatile
 800d8dc:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d8e0:	f383 8811 	msr	BASEPRI, r3
 800d8e4:	f3bf 8f6f 	isb	sy
 800d8e8:	f3bf 8f4f 	dsb	sy
 800d8ec:	627b      	str	r3, [r7, #36]	@ 0x24
}
 800d8ee:	bf00      	nop
 800d8f0:	bf00      	nop
 800d8f2:	e7fd      	b.n	800d8f0 <xQueueGenericSend+0x60>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800d8f4:	683b      	ldr	r3, [r7, #0]
 800d8f6:	2b02      	cmp	r3, #2
 800d8f8:	d103      	bne.n	800d902 <xQueueGenericSend+0x72>
 800d8fa:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d8fc:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800d8fe:	2b01      	cmp	r3, #1
 800d900:	d101      	bne.n	800d906 <xQueueGenericSend+0x76>
 800d902:	2301      	movs	r3, #1
 800d904:	e000      	b.n	800d908 <xQueueGenericSend+0x78>
 800d906:	2300      	movs	r3, #0
 800d908:	2b00      	cmp	r3, #0
 800d90a:	d10b      	bne.n	800d924 <xQueueGenericSend+0x94>
	__asm volatile
 800d90c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d910:	f383 8811 	msr	BASEPRI, r3
 800d914:	f3bf 8f6f 	isb	sy
 800d918:	f3bf 8f4f 	dsb	sy
 800d91c:	623b      	str	r3, [r7, #32]
}
 800d91e:	bf00      	nop
 800d920:	bf00      	nop
 800d922:	e7fd      	b.n	800d920 <xQueueGenericSend+0x90>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800d924:	f001 f9ce 	bl	800ecc4 <xTaskGetSchedulerState>
 800d928:	4603      	mov	r3, r0
 800d92a:	2b00      	cmp	r3, #0
 800d92c:	d102      	bne.n	800d934 <xQueueGenericSend+0xa4>
 800d92e:	687b      	ldr	r3, [r7, #4]
 800d930:	2b00      	cmp	r3, #0
 800d932:	d101      	bne.n	800d938 <xQueueGenericSend+0xa8>
 800d934:	2301      	movs	r3, #1
 800d936:	e000      	b.n	800d93a <xQueueGenericSend+0xaa>
 800d938:	2300      	movs	r3, #0
 800d93a:	2b00      	cmp	r3, #0
 800d93c:	d10b      	bne.n	800d956 <xQueueGenericSend+0xc6>
	__asm volatile
 800d93e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800d942:	f383 8811 	msr	BASEPRI, r3
 800d946:	f3bf 8f6f 	isb	sy
 800d94a:	f3bf 8f4f 	dsb	sy
 800d94e:	61fb      	str	r3, [r7, #28]
}
 800d950:	bf00      	nop
 800d952:	bf00      	nop
 800d954:	e7fd      	b.n	800d952 <xQueueGenericSend+0xc2>
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 800d956:	f7ff fd6f 	bl	800d438 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800d95a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d95c:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 800d95e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d960:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800d962:	429a      	cmp	r2, r3
 800d964:	d302      	bcc.n	800d96c <xQueueGenericSend+0xdc>
 800d966:	683b      	ldr	r3, [r7, #0]
 800d968:	2b02      	cmp	r3, #2
 800d96a:	d129      	bne.n	800d9c0 <xQueueGenericSend+0x130>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800d96c:	683a      	ldr	r2, [r7, #0]
 800d96e:	68b9      	ldr	r1, [r7, #8]
 800d970:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 800d972:	f000 fa0f 	bl	800dd94 <prvCopyDataToQueue>
 800d976:	62f8      	str	r0, [r7, #44]	@ 0x2c

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800d978:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d97a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800d97c:	2b00      	cmp	r3, #0
 800d97e:	d010      	beq.n	800d9a2 <xQueueGenericSend+0x112>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800d980:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d982:	3324      	adds	r3, #36	@ 0x24
 800d984:	4618      	mov	r0, r3
 800d986:	f000 ffdd 	bl	800e944 <xTaskRemoveFromEventList>
 800d98a:	4603      	mov	r3, r0
 800d98c:	2b00      	cmp	r3, #0
 800d98e:	d013      	beq.n	800d9b8 <xQueueGenericSend+0x128>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 800d990:	4b3f      	ldr	r3, [pc, #252]	@ (800da90 <xQueueGenericSend+0x200>)
 800d992:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800d996:	601a      	str	r2, [r3, #0]
 800d998:	f3bf 8f4f 	dsb	sy
 800d99c:	f3bf 8f6f 	isb	sy
 800d9a0:	e00a      	b.n	800d9b8 <xQueueGenericSend+0x128>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 800d9a2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800d9a4:	2b00      	cmp	r3, #0
 800d9a6:	d007      	beq.n	800d9b8 <xQueueGenericSend+0x128>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
 800d9a8:	4b39      	ldr	r3, [pc, #228]	@ (800da90 <xQueueGenericSend+0x200>)
 800d9aa:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800d9ae:	601a      	str	r2, [r3, #0]
 800d9b0:	f3bf 8f4f 	dsb	sy
 800d9b4:	f3bf 8f6f 	isb	sy
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 800d9b8:	f7ff fd70 	bl	800d49c <vPortExitCritical>
				return pdPASS;
 800d9bc:	2301      	movs	r3, #1
 800d9be:	e063      	b.n	800da88 <xQueueGenericSend+0x1f8>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 800d9c0:	687b      	ldr	r3, [r7, #4]
 800d9c2:	2b00      	cmp	r3, #0
 800d9c4:	d103      	bne.n	800d9ce <xQueueGenericSend+0x13e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 800d9c6:	f7ff fd69 	bl	800d49c <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 800d9ca:	2300      	movs	r3, #0
 800d9cc:	e05c      	b.n	800da88 <xQueueGenericSend+0x1f8>
				}
				else if( xEntryTimeSet == pdFALSE )
 800d9ce:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800d9d0:	2b00      	cmp	r3, #0
 800d9d2:	d106      	bne.n	800d9e2 <xQueueGenericSend+0x152>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 800d9d4:	f107 0314 	add.w	r3, r7, #20
 800d9d8:	4618      	mov	r0, r3
 800d9da:	f001 f817 	bl	800ea0c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800d9de:	2301      	movs	r3, #1
 800d9e0:	637b      	str	r3, [r7, #52]	@ 0x34
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 800d9e2:	f7ff fd5b 	bl	800d49c <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 800d9e6:	f000 fd87 	bl	800e4f8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800d9ea:	f7ff fd25 	bl	800d438 <vPortEnterCritical>
 800d9ee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d9f0:	f893 3044 	ldrb.w	r3, [r3, #68]	@ 0x44
 800d9f4:	b25b      	sxtb	r3, r3
 800d9f6:	f1b3 3fff 	cmp.w	r3, #4294967295
 800d9fa:	d103      	bne.n	800da04 <xQueueGenericSend+0x174>
 800d9fc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800d9fe:	2200      	movs	r2, #0
 800da00:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
 800da04:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800da06:	f893 3045 	ldrb.w	r3, [r3, #69]	@ 0x45
 800da0a:	b25b      	sxtb	r3, r3
 800da0c:	f1b3 3fff 	cmp.w	r3, #4294967295
 800da10:	d103      	bne.n	800da1a <xQueueGenericSend+0x18a>
 800da12:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800da14:	2200      	movs	r2, #0
 800da16:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
 800da1a:	f7ff fd3f 	bl	800d49c <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800da1e:	1d3a      	adds	r2, r7, #4
 800da20:	f107 0314 	add.w	r3, r7, #20
 800da24:	4611      	mov	r1, r2
 800da26:	4618      	mov	r0, r3
 800da28:	f001 f806 	bl	800ea38 <xTaskCheckForTimeOut>
 800da2c:	4603      	mov	r3, r0
 800da2e:	2b00      	cmp	r3, #0
 800da30:	d124      	bne.n	800da7c <xQueueGenericSend+0x1ec>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 800da32:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 800da34:	f000 faa6 	bl	800df84 <prvIsQueueFull>
 800da38:	4603      	mov	r3, r0
 800da3a:	2b00      	cmp	r3, #0
 800da3c:	d018      	beq.n	800da70 <xQueueGenericSend+0x1e0>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 800da3e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800da40:	3310      	adds	r3, #16
 800da42:	687a      	ldr	r2, [r7, #4]
 800da44:	4611      	mov	r1, r2
 800da46:	4618      	mov	r0, r3
 800da48:	f000 ff2a 	bl	800e8a0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 800da4c:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 800da4e:	f000 fa31 	bl	800deb4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 800da52:	f000 fd5f 	bl	800e514 <xTaskResumeAll>
 800da56:	4603      	mov	r3, r0
 800da58:	2b00      	cmp	r3, #0
 800da5a:	f47f af7c 	bne.w	800d956 <xQueueGenericSend+0xc6>
				{
					portYIELD_WITHIN_API();
 800da5e:	4b0c      	ldr	r3, [pc, #48]	@ (800da90 <xQueueGenericSend+0x200>)
 800da60:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800da64:	601a      	str	r2, [r3, #0]
 800da66:	f3bf 8f4f 	dsb	sy
 800da6a:	f3bf 8f6f 	isb	sy
 800da6e:	e772      	b.n	800d956 <xQueueGenericSend+0xc6>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 800da70:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 800da72:	f000 fa1f 	bl	800deb4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800da76:	f000 fd4d 	bl	800e514 <xTaskResumeAll>
 800da7a:	e76c      	b.n	800d956 <xQueueGenericSend+0xc6>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 800da7c:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 800da7e:	f000 fa19 	bl	800deb4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800da82:	f000 fd47 	bl	800e514 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 800da86:	2300      	movs	r3, #0
		}
	} /*lint -restore */
}
 800da88:	4618      	mov	r0, r3
 800da8a:	3738      	adds	r7, #56	@ 0x38
 800da8c:	46bd      	mov	sp, r7
 800da8e:	bd80      	pop	{r7, pc}
 800da90:	e000ed04 	.word	0xe000ed04

0800da94 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
 800da94:	b580      	push	{r7, lr}
 800da96:	b090      	sub	sp, #64	@ 0x40
 800da98:	af00      	add	r7, sp, #0
 800da9a:	60f8      	str	r0, [r7, #12]
 800da9c:	60b9      	str	r1, [r7, #8]
 800da9e:	607a      	str	r2, [r7, #4]
 800daa0:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 800daa2:	68fb      	ldr	r3, [r7, #12]
 800daa4:	63bb      	str	r3, [r7, #56]	@ 0x38

	configASSERT( pxQueue );
 800daa6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800daa8:	2b00      	cmp	r3, #0
 800daaa:	d10b      	bne.n	800dac4 <xQueueGenericSendFromISR+0x30>
	__asm volatile
 800daac:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800dab0:	f383 8811 	msr	BASEPRI, r3
 800dab4:	f3bf 8f6f 	isb	sy
 800dab8:	f3bf 8f4f 	dsb	sy
 800dabc:	62bb      	str	r3, [r7, #40]	@ 0x28
}
 800dabe:	bf00      	nop
 800dac0:	bf00      	nop
 800dac2:	e7fd      	b.n	800dac0 <xQueueGenericSendFromISR+0x2c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800dac4:	68bb      	ldr	r3, [r7, #8]
 800dac6:	2b00      	cmp	r3, #0
 800dac8:	d103      	bne.n	800dad2 <xQueueGenericSendFromISR+0x3e>
 800daca:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800dacc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800dace:	2b00      	cmp	r3, #0
 800dad0:	d101      	bne.n	800dad6 <xQueueGenericSendFromISR+0x42>
 800dad2:	2301      	movs	r3, #1
 800dad4:	e000      	b.n	800dad8 <xQueueGenericSendFromISR+0x44>
 800dad6:	2300      	movs	r3, #0
 800dad8:	2b00      	cmp	r3, #0
 800dada:	d10b      	bne.n	800daf4 <xQueueGenericSendFromISR+0x60>
	__asm volatile
 800dadc:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800dae0:	f383 8811 	msr	BASEPRI, r3
 800dae4:	f3bf 8f6f 	isb	sy
 800dae8:	f3bf 8f4f 	dsb	sy
 800daec:	627b      	str	r3, [r7, #36]	@ 0x24
}
 800daee:	bf00      	nop
 800daf0:	bf00      	nop
 800daf2:	e7fd      	b.n	800daf0 <xQueueGenericSendFromISR+0x5c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800daf4:	683b      	ldr	r3, [r7, #0]
 800daf6:	2b02      	cmp	r3, #2
 800daf8:	d103      	bne.n	800db02 <xQueueGenericSendFromISR+0x6e>
 800dafa:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800dafc:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800dafe:	2b01      	cmp	r3, #1
 800db00:	d101      	bne.n	800db06 <xQueueGenericSendFromISR+0x72>
 800db02:	2301      	movs	r3, #1
 800db04:	e000      	b.n	800db08 <xQueueGenericSendFromISR+0x74>
 800db06:	2300      	movs	r3, #0
 800db08:	2b00      	cmp	r3, #0
 800db0a:	d10b      	bne.n	800db24 <xQueueGenericSendFromISR+0x90>
	__asm volatile
 800db0c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800db10:	f383 8811 	msr	BASEPRI, r3
 800db14:	f3bf 8f6f 	isb	sy
 800db18:	f3bf 8f4f 	dsb	sy
 800db1c:	623b      	str	r3, [r7, #32]
}
 800db1e:	bf00      	nop
 800db20:	bf00      	nop
 800db22:	e7fd      	b.n	800db20 <xQueueGenericSendFromISR+0x8c>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800db24:	f7ff fd68 	bl	800d5f8 <vPortValidateInterruptPriority>
	__asm volatile
 800db28:	f3ef 8211 	mrs	r2, BASEPRI
 800db2c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800db30:	f383 8811 	msr	BASEPRI, r3
 800db34:	f3bf 8f6f 	isb	sy
 800db38:	f3bf 8f4f 	dsb	sy
 800db3c:	61fa      	str	r2, [r7, #28]
 800db3e:	61bb      	str	r3, [r7, #24]
	return ulOriginalBASEPRI;
 800db40:	69fb      	ldr	r3, [r7, #28]
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800db42:	637b      	str	r3, [r7, #52]	@ 0x34
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800db44:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800db46:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 800db48:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800db4a:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800db4c:	429a      	cmp	r2, r3
 800db4e:	d302      	bcc.n	800db56 <xQueueGenericSendFromISR+0xc2>
 800db50:	683b      	ldr	r3, [r7, #0]
 800db52:	2b02      	cmp	r3, #2
 800db54:	d12f      	bne.n	800dbb6 <xQueueGenericSendFromISR+0x122>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 800db56:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800db58:	f893 3045 	ldrb.w	r3, [r3, #69]	@ 0x45
 800db5c:	f887 3033 	strb.w	r3, [r7, #51]	@ 0x33
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 800db60:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800db62:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800db64:	62fb      	str	r3, [r7, #44]	@ 0x2c
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 800db66:	683a      	ldr	r2, [r7, #0]
 800db68:	68b9      	ldr	r1, [r7, #8]
 800db6a:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 800db6c:	f000 f912 	bl	800dd94 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 800db70:	f997 3033 	ldrsb.w	r3, [r7, #51]	@ 0x33
 800db74:	f1b3 3fff 	cmp.w	r3, #4294967295
 800db78:	d112      	bne.n	800dba0 <xQueueGenericSendFromISR+0x10c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800db7a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800db7c:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800db7e:	2b00      	cmp	r3, #0
 800db80:	d016      	beq.n	800dbb0 <xQueueGenericSendFromISR+0x11c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800db82:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800db84:	3324      	adds	r3, #36	@ 0x24
 800db86:	4618      	mov	r0, r3
 800db88:	f000 fedc 	bl	800e944 <xTaskRemoveFromEventList>
 800db8c:	4603      	mov	r3, r0
 800db8e:	2b00      	cmp	r3, #0
 800db90:	d00e      	beq.n	800dbb0 <xQueueGenericSendFromISR+0x11c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 800db92:	687b      	ldr	r3, [r7, #4]
 800db94:	2b00      	cmp	r3, #0
 800db96:	d00b      	beq.n	800dbb0 <xQueueGenericSendFromISR+0x11c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 800db98:	687b      	ldr	r3, [r7, #4]
 800db9a:	2201      	movs	r2, #1
 800db9c:	601a      	str	r2, [r3, #0]
 800db9e:	e007      	b.n	800dbb0 <xQueueGenericSendFromISR+0x11c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800dba0:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 800dba4:	3301      	adds	r3, #1
 800dba6:	b2db      	uxtb	r3, r3
 800dba8:	b25a      	sxtb	r2, r3
 800dbaa:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800dbac:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
			}

			xReturn = pdPASS;
 800dbb0:	2301      	movs	r3, #1
 800dbb2:	63fb      	str	r3, [r7, #60]	@ 0x3c
		{
 800dbb4:	e001      	b.n	800dbba <xQueueGenericSendFromISR+0x126>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 800dbb6:	2300      	movs	r3, #0
 800dbb8:	63fb      	str	r3, [r7, #60]	@ 0x3c
 800dbba:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800dbbc:	617b      	str	r3, [r7, #20]
	__asm volatile
 800dbbe:	697b      	ldr	r3, [r7, #20]
 800dbc0:	f383 8811 	msr	BASEPRI, r3
}
 800dbc4:	bf00      	nop
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 800dbc6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
}
 800dbc8:	4618      	mov	r0, r3
 800dbca:	3740      	adds	r7, #64	@ 0x40
 800dbcc:	46bd      	mov	sp, r7
 800dbce:	bd80      	pop	{r7, pc}

0800dbd0 <xQueueReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
 800dbd0:	b580      	push	{r7, lr}
 800dbd2:	b08c      	sub	sp, #48	@ 0x30
 800dbd4:	af00      	add	r7, sp, #0
 800dbd6:	60f8      	str	r0, [r7, #12]
 800dbd8:	60b9      	str	r1, [r7, #8]
 800dbda:	607a      	str	r2, [r7, #4]
BaseType_t xEntryTimeSet = pdFALSE;
 800dbdc:	2300      	movs	r3, #0
 800dbde:	62fb      	str	r3, [r7, #44]	@ 0x2c
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 800dbe0:	68fb      	ldr	r3, [r7, #12]
 800dbe2:	62bb      	str	r3, [r7, #40]	@ 0x28

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
 800dbe4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800dbe6:	2b00      	cmp	r3, #0
 800dbe8:	d10b      	bne.n	800dc02 <xQueueReceive+0x32>
	__asm volatile
 800dbea:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800dbee:	f383 8811 	msr	BASEPRI, r3
 800dbf2:	f3bf 8f6f 	isb	sy
 800dbf6:	f3bf 8f4f 	dsb	sy
 800dbfa:	623b      	str	r3, [r7, #32]
}
 800dbfc:	bf00      	nop
 800dbfe:	bf00      	nop
 800dc00:	e7fd      	b.n	800dbfe <xQueueReceive+0x2e>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 800dc02:	68bb      	ldr	r3, [r7, #8]
 800dc04:	2b00      	cmp	r3, #0
 800dc06:	d103      	bne.n	800dc10 <xQueueReceive+0x40>
 800dc08:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800dc0a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800dc0c:	2b00      	cmp	r3, #0
 800dc0e:	d101      	bne.n	800dc14 <xQueueReceive+0x44>
 800dc10:	2301      	movs	r3, #1
 800dc12:	e000      	b.n	800dc16 <xQueueReceive+0x46>
 800dc14:	2300      	movs	r3, #0
 800dc16:	2b00      	cmp	r3, #0
 800dc18:	d10b      	bne.n	800dc32 <xQueueReceive+0x62>
	__asm volatile
 800dc1a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800dc1e:	f383 8811 	msr	BASEPRI, r3
 800dc22:	f3bf 8f6f 	isb	sy
 800dc26:	f3bf 8f4f 	dsb	sy
 800dc2a:	61fb      	str	r3, [r7, #28]
}
 800dc2c:	bf00      	nop
 800dc2e:	bf00      	nop
 800dc30:	e7fd      	b.n	800dc2e <xQueueReceive+0x5e>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800dc32:	f001 f847 	bl	800ecc4 <xTaskGetSchedulerState>
 800dc36:	4603      	mov	r3, r0
 800dc38:	2b00      	cmp	r3, #0
 800dc3a:	d102      	bne.n	800dc42 <xQueueReceive+0x72>
 800dc3c:	687b      	ldr	r3, [r7, #4]
 800dc3e:	2b00      	cmp	r3, #0
 800dc40:	d101      	bne.n	800dc46 <xQueueReceive+0x76>
 800dc42:	2301      	movs	r3, #1
 800dc44:	e000      	b.n	800dc48 <xQueueReceive+0x78>
 800dc46:	2300      	movs	r3, #0
 800dc48:	2b00      	cmp	r3, #0
 800dc4a:	d10b      	bne.n	800dc64 <xQueueReceive+0x94>
	__asm volatile
 800dc4c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800dc50:	f383 8811 	msr	BASEPRI, r3
 800dc54:	f3bf 8f6f 	isb	sy
 800dc58:	f3bf 8f4f 	dsb	sy
 800dc5c:	61bb      	str	r3, [r7, #24]
}
 800dc5e:	bf00      	nop
 800dc60:	bf00      	nop
 800dc62:	e7fd      	b.n	800dc60 <xQueueReceive+0x90>
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 800dc64:	f7ff fbe8 	bl	800d438 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800dc68:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800dc6a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800dc6c:	627b      	str	r3, [r7, #36]	@ 0x24

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800dc6e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800dc70:	2b00      	cmp	r3, #0
 800dc72:	d01f      	beq.n	800dcb4 <xQueueReceive+0xe4>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800dc74:	68b9      	ldr	r1, [r7, #8]
 800dc76:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800dc78:	f000 f8f6 	bl	800de68 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 800dc7c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800dc7e:	1e5a      	subs	r2, r3, #1
 800dc80:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800dc82:	639a      	str	r2, [r3, #56]	@ 0x38

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800dc84:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800dc86:	691b      	ldr	r3, [r3, #16]
 800dc88:	2b00      	cmp	r3, #0
 800dc8a:	d00f      	beq.n	800dcac <xQueueReceive+0xdc>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800dc8c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800dc8e:	3310      	adds	r3, #16
 800dc90:	4618      	mov	r0, r3
 800dc92:	f000 fe57 	bl	800e944 <xTaskRemoveFromEventList>
 800dc96:	4603      	mov	r3, r0
 800dc98:	2b00      	cmp	r3, #0
 800dc9a:	d007      	beq.n	800dcac <xQueueReceive+0xdc>
					{
						queueYIELD_IF_USING_PREEMPTION();
 800dc9c:	4b3c      	ldr	r3, [pc, #240]	@ (800dd90 <xQueueReceive+0x1c0>)
 800dc9e:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800dca2:	601a      	str	r2, [r3, #0]
 800dca4:	f3bf 8f4f 	dsb	sy
 800dca8:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 800dcac:	f7ff fbf6 	bl	800d49c <vPortExitCritical>
				return pdPASS;
 800dcb0:	2301      	movs	r3, #1
 800dcb2:	e069      	b.n	800dd88 <xQueueReceive+0x1b8>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 800dcb4:	687b      	ldr	r3, [r7, #4]
 800dcb6:	2b00      	cmp	r3, #0
 800dcb8:	d103      	bne.n	800dcc2 <xQueueReceive+0xf2>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 800dcba:	f7ff fbef 	bl	800d49c <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 800dcbe:	2300      	movs	r3, #0
 800dcc0:	e062      	b.n	800dd88 <xQueueReceive+0x1b8>
				}
				else if( xEntryTimeSet == pdFALSE )
 800dcc2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800dcc4:	2b00      	cmp	r3, #0
 800dcc6:	d106      	bne.n	800dcd6 <xQueueReceive+0x106>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 800dcc8:	f107 0310 	add.w	r3, r7, #16
 800dccc:	4618      	mov	r0, r3
 800dcce:	f000 fe9d 	bl	800ea0c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 800dcd2:	2301      	movs	r3, #1
 800dcd4:	62fb      	str	r3, [r7, #44]	@ 0x2c
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 800dcd6:	f7ff fbe1 	bl	800d49c <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 800dcda:	f000 fc0d 	bl	800e4f8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 800dcde:	f7ff fbab 	bl	800d438 <vPortEnterCritical>
 800dce2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800dce4:	f893 3044 	ldrb.w	r3, [r3, #68]	@ 0x44
 800dce8:	b25b      	sxtb	r3, r3
 800dcea:	f1b3 3fff 	cmp.w	r3, #4294967295
 800dcee:	d103      	bne.n	800dcf8 <xQueueReceive+0x128>
 800dcf0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800dcf2:	2200      	movs	r2, #0
 800dcf4:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
 800dcf8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800dcfa:	f893 3045 	ldrb.w	r3, [r3, #69]	@ 0x45
 800dcfe:	b25b      	sxtb	r3, r3
 800dd00:	f1b3 3fff 	cmp.w	r3, #4294967295
 800dd04:	d103      	bne.n	800dd0e <xQueueReceive+0x13e>
 800dd06:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800dd08:	2200      	movs	r2, #0
 800dd0a:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
 800dd0e:	f7ff fbc5 	bl	800d49c <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800dd12:	1d3a      	adds	r2, r7, #4
 800dd14:	f107 0310 	add.w	r3, r7, #16
 800dd18:	4611      	mov	r1, r2
 800dd1a:	4618      	mov	r0, r3
 800dd1c:	f000 fe8c 	bl	800ea38 <xTaskCheckForTimeOut>
 800dd20:	4603      	mov	r3, r0
 800dd22:	2b00      	cmp	r3, #0
 800dd24:	d123      	bne.n	800dd6e <xQueueReceive+0x19e>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 800dd26:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800dd28:	f000 f916 	bl	800df58 <prvIsQueueEmpty>
 800dd2c:	4603      	mov	r3, r0
 800dd2e:	2b00      	cmp	r3, #0
 800dd30:	d017      	beq.n	800dd62 <xQueueReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 800dd32:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800dd34:	3324      	adds	r3, #36	@ 0x24
 800dd36:	687a      	ldr	r2, [r7, #4]
 800dd38:	4611      	mov	r1, r2
 800dd3a:	4618      	mov	r0, r3
 800dd3c:	f000 fdb0 	bl	800e8a0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800dd40:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800dd42:	f000 f8b7 	bl	800deb4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 800dd46:	f000 fbe5 	bl	800e514 <xTaskResumeAll>
 800dd4a:	4603      	mov	r3, r0
 800dd4c:	2b00      	cmp	r3, #0
 800dd4e:	d189      	bne.n	800dc64 <xQueueReceive+0x94>
				{
					portYIELD_WITHIN_API();
 800dd50:	4b0f      	ldr	r3, [pc, #60]	@ (800dd90 <xQueueReceive+0x1c0>)
 800dd52:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800dd56:	601a      	str	r2, [r3, #0]
 800dd58:	f3bf 8f4f 	dsb	sy
 800dd5c:	f3bf 8f6f 	isb	sy
 800dd60:	e780      	b.n	800dc64 <xQueueReceive+0x94>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
 800dd62:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800dd64:	f000 f8a6 	bl	800deb4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 800dd68:	f000 fbd4 	bl	800e514 <xTaskResumeAll>
 800dd6c:	e77a      	b.n	800dc64 <xQueueReceive+0x94>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
 800dd6e:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800dd70:	f000 f8a0 	bl	800deb4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 800dd74:	f000 fbce 	bl	800e514 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 800dd78:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800dd7a:	f000 f8ed 	bl	800df58 <prvIsQueueEmpty>
 800dd7e:	4603      	mov	r3, r0
 800dd80:	2b00      	cmp	r3, #0
 800dd82:	f43f af6f 	beq.w	800dc64 <xQueueReceive+0x94>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 800dd86:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 800dd88:	4618      	mov	r0, r3
 800dd8a:	3730      	adds	r7, #48	@ 0x30
 800dd8c:	46bd      	mov	sp, r7
 800dd8e:	bd80      	pop	{r7, pc}
 800dd90:	e000ed04 	.word	0xe000ed04

0800dd94 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 800dd94:	b580      	push	{r7, lr}
 800dd96:	b086      	sub	sp, #24
 800dd98:	af00      	add	r7, sp, #0
 800dd9a:	60f8      	str	r0, [r7, #12]
 800dd9c:	60b9      	str	r1, [r7, #8]
 800dd9e:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
 800dda0:	2300      	movs	r3, #0
 800dda2:	617b      	str	r3, [r7, #20]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800dda4:	68fb      	ldr	r3, [r7, #12]
 800dda6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800dda8:	613b      	str	r3, [r7, #16]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 800ddaa:	68fb      	ldr	r3, [r7, #12]
 800ddac:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800ddae:	2b00      	cmp	r3, #0
 800ddb0:	d10d      	bne.n	800ddce <prvCopyDataToQueue+0x3a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800ddb2:	68fb      	ldr	r3, [r7, #12]
 800ddb4:	681b      	ldr	r3, [r3, #0]
 800ddb6:	2b00      	cmp	r3, #0
 800ddb8:	d14d      	bne.n	800de56 <prvCopyDataToQueue+0xc2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 800ddba:	68fb      	ldr	r3, [r7, #12]
 800ddbc:	689b      	ldr	r3, [r3, #8]
 800ddbe:	4618      	mov	r0, r3
 800ddc0:	f000 ff9e 	bl	800ed00 <xTaskPriorityDisinherit>
 800ddc4:	6178      	str	r0, [r7, #20]
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 800ddc6:	68fb      	ldr	r3, [r7, #12]
 800ddc8:	2200      	movs	r2, #0
 800ddca:	609a      	str	r2, [r3, #8]
 800ddcc:	e043      	b.n	800de56 <prvCopyDataToQueue+0xc2>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 800ddce:	687b      	ldr	r3, [r7, #4]
 800ddd0:	2b00      	cmp	r3, #0
 800ddd2:	d119      	bne.n	800de08 <prvCopyDataToQueue+0x74>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 800ddd4:	68fb      	ldr	r3, [r7, #12]
 800ddd6:	6858      	ldr	r0, [r3, #4]
 800ddd8:	68fb      	ldr	r3, [r7, #12]
 800ddda:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800dddc:	461a      	mov	r2, r3
 800ddde:	68b9      	ldr	r1, [r7, #8]
 800dde0:	f009 fc13 	bl	801760a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 800dde4:	68fb      	ldr	r3, [r7, #12]
 800dde6:	685a      	ldr	r2, [r3, #4]
 800dde8:	68fb      	ldr	r3, [r7, #12]
 800ddea:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800ddec:	441a      	add	r2, r3
 800ddee:	68fb      	ldr	r3, [r7, #12]
 800ddf0:	605a      	str	r2, [r3, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800ddf2:	68fb      	ldr	r3, [r7, #12]
 800ddf4:	685a      	ldr	r2, [r3, #4]
 800ddf6:	68fb      	ldr	r3, [r7, #12]
 800ddf8:	689b      	ldr	r3, [r3, #8]
 800ddfa:	429a      	cmp	r2, r3
 800ddfc:	d32b      	bcc.n	800de56 <prvCopyDataToQueue+0xc2>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 800ddfe:	68fb      	ldr	r3, [r7, #12]
 800de00:	681a      	ldr	r2, [r3, #0]
 800de02:	68fb      	ldr	r3, [r7, #12]
 800de04:	605a      	str	r2, [r3, #4]
 800de06:	e026      	b.n	800de56 <prvCopyDataToQueue+0xc2>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 800de08:	68fb      	ldr	r3, [r7, #12]
 800de0a:	68d8      	ldr	r0, [r3, #12]
 800de0c:	68fb      	ldr	r3, [r7, #12]
 800de0e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800de10:	461a      	mov	r2, r3
 800de12:	68b9      	ldr	r1, [r7, #8]
 800de14:	f009 fbf9 	bl	801760a <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 800de18:	68fb      	ldr	r3, [r7, #12]
 800de1a:	68da      	ldr	r2, [r3, #12]
 800de1c:	68fb      	ldr	r3, [r7, #12]
 800de1e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800de20:	425b      	negs	r3, r3
 800de22:	441a      	add	r2, r3
 800de24:	68fb      	ldr	r3, [r7, #12]
 800de26:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800de28:	68fb      	ldr	r3, [r7, #12]
 800de2a:	68da      	ldr	r2, [r3, #12]
 800de2c:	68fb      	ldr	r3, [r7, #12]
 800de2e:	681b      	ldr	r3, [r3, #0]
 800de30:	429a      	cmp	r2, r3
 800de32:	d207      	bcs.n	800de44 <prvCopyDataToQueue+0xb0>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 800de34:	68fb      	ldr	r3, [r7, #12]
 800de36:	689a      	ldr	r2, [r3, #8]
 800de38:	68fb      	ldr	r3, [r7, #12]
 800de3a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800de3c:	425b      	negs	r3, r3
 800de3e:	441a      	add	r2, r3
 800de40:	68fb      	ldr	r3, [r7, #12]
 800de42:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 800de44:	687b      	ldr	r3, [r7, #4]
 800de46:	2b02      	cmp	r3, #2
 800de48:	d105      	bne.n	800de56 <prvCopyDataToQueue+0xc2>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800de4a:	693b      	ldr	r3, [r7, #16]
 800de4c:	2b00      	cmp	r3, #0
 800de4e:	d002      	beq.n	800de56 <prvCopyDataToQueue+0xc2>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
 800de50:	693b      	ldr	r3, [r7, #16]
 800de52:	3b01      	subs	r3, #1
 800de54:	613b      	str	r3, [r7, #16]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 800de56:	693b      	ldr	r3, [r7, #16]
 800de58:	1c5a      	adds	r2, r3, #1
 800de5a:	68fb      	ldr	r3, [r7, #12]
 800de5c:	639a      	str	r2, [r3, #56]	@ 0x38

	return xReturn;
 800de5e:	697b      	ldr	r3, [r7, #20]
}
 800de60:	4618      	mov	r0, r3
 800de62:	3718      	adds	r7, #24
 800de64:	46bd      	mov	sp, r7
 800de66:	bd80      	pop	{r7, pc}

0800de68 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 800de68:	b580      	push	{r7, lr}
 800de6a:	b082      	sub	sp, #8
 800de6c:	af00      	add	r7, sp, #0
 800de6e:	6078      	str	r0, [r7, #4]
 800de70:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 800de72:	687b      	ldr	r3, [r7, #4]
 800de74:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800de76:	2b00      	cmp	r3, #0
 800de78:	d018      	beq.n	800deac <prvCopyDataFromQueue+0x44>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 800de7a:	687b      	ldr	r3, [r7, #4]
 800de7c:	68da      	ldr	r2, [r3, #12]
 800de7e:	687b      	ldr	r3, [r7, #4]
 800de80:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800de82:	441a      	add	r2, r3
 800de84:	687b      	ldr	r3, [r7, #4]
 800de86:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 800de88:	687b      	ldr	r3, [r7, #4]
 800de8a:	68da      	ldr	r2, [r3, #12]
 800de8c:	687b      	ldr	r3, [r7, #4]
 800de8e:	689b      	ldr	r3, [r3, #8]
 800de90:	429a      	cmp	r2, r3
 800de92:	d303      	bcc.n	800de9c <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 800de94:	687b      	ldr	r3, [r7, #4]
 800de96:	681a      	ldr	r2, [r3, #0]
 800de98:	687b      	ldr	r3, [r7, #4]
 800de9a:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 800de9c:	687b      	ldr	r3, [r7, #4]
 800de9e:	68d9      	ldr	r1, [r3, #12]
 800dea0:	687b      	ldr	r3, [r7, #4]
 800dea2:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 800dea4:	461a      	mov	r2, r3
 800dea6:	6838      	ldr	r0, [r7, #0]
 800dea8:	f009 fbaf 	bl	801760a <memcpy>
	}
}
 800deac:	bf00      	nop
 800deae:	3708      	adds	r7, #8
 800deb0:	46bd      	mov	sp, r7
 800deb2:	bd80      	pop	{r7, pc}

0800deb4 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 800deb4:	b580      	push	{r7, lr}
 800deb6:	b084      	sub	sp, #16
 800deb8:	af00      	add	r7, sp, #0
 800deba:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 800debc:	f7ff fabc 	bl	800d438 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 800dec0:	687b      	ldr	r3, [r7, #4]
 800dec2:	f893 3045 	ldrb.w	r3, [r3, #69]	@ 0x45
 800dec6:	73fb      	strb	r3, [r7, #15]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800dec8:	e011      	b.n	800deee <prvUnlockQueue+0x3a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800deca:	687b      	ldr	r3, [r7, #4]
 800decc:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800dece:	2b00      	cmp	r3, #0
 800ded0:	d012      	beq.n	800def8 <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800ded2:	687b      	ldr	r3, [r7, #4]
 800ded4:	3324      	adds	r3, #36	@ 0x24
 800ded6:	4618      	mov	r0, r3
 800ded8:	f000 fd34 	bl	800e944 <xTaskRemoveFromEventList>
 800dedc:	4603      	mov	r3, r0
 800dede:	2b00      	cmp	r3, #0
 800dee0:	d001      	beq.n	800dee6 <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
 800dee2:	f000 fe0d 	bl	800eb00 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
 800dee6:	7bfb      	ldrb	r3, [r7, #15]
 800dee8:	3b01      	subs	r3, #1
 800deea:	b2db      	uxtb	r3, r3
 800deec:	73fb      	strb	r3, [r7, #15]
		while( cTxLock > queueLOCKED_UNMODIFIED )
 800deee:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800def2:	2b00      	cmp	r3, #0
 800def4:	dce9      	bgt.n	800deca <prvUnlockQueue+0x16>
 800def6:	e000      	b.n	800defa <prvUnlockQueue+0x46>
					break;
 800def8:	bf00      	nop
		}

		pxQueue->cTxLock = queueUNLOCKED;
 800defa:	687b      	ldr	r3, [r7, #4]
 800defc:	22ff      	movs	r2, #255	@ 0xff
 800defe:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
	}
	taskEXIT_CRITICAL();
 800df02:	f7ff facb 	bl	800d49c <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 800df06:	f7ff fa97 	bl	800d438 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 800df0a:	687b      	ldr	r3, [r7, #4]
 800df0c:	f893 3044 	ldrb.w	r3, [r3, #68]	@ 0x44
 800df10:	73bb      	strb	r3, [r7, #14]

		while( cRxLock > queueLOCKED_UNMODIFIED )
 800df12:	e011      	b.n	800df38 <prvUnlockQueue+0x84>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800df14:	687b      	ldr	r3, [r7, #4]
 800df16:	691b      	ldr	r3, [r3, #16]
 800df18:	2b00      	cmp	r3, #0
 800df1a:	d012      	beq.n	800df42 <prvUnlockQueue+0x8e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800df1c:	687b      	ldr	r3, [r7, #4]
 800df1e:	3310      	adds	r3, #16
 800df20:	4618      	mov	r0, r3
 800df22:	f000 fd0f 	bl	800e944 <xTaskRemoveFromEventList>
 800df26:	4603      	mov	r3, r0
 800df28:	2b00      	cmp	r3, #0
 800df2a:	d001      	beq.n	800df30 <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
 800df2c:	f000 fde8 	bl	800eb00 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
 800df30:	7bbb      	ldrb	r3, [r7, #14]
 800df32:	3b01      	subs	r3, #1
 800df34:	b2db      	uxtb	r3, r3
 800df36:	73bb      	strb	r3, [r7, #14]
		while( cRxLock > queueLOCKED_UNMODIFIED )
 800df38:	f997 300e 	ldrsb.w	r3, [r7, #14]
 800df3c:	2b00      	cmp	r3, #0
 800df3e:	dce9      	bgt.n	800df14 <prvUnlockQueue+0x60>
 800df40:	e000      	b.n	800df44 <prvUnlockQueue+0x90>
			}
			else
			{
				break;
 800df42:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 800df44:	687b      	ldr	r3, [r7, #4]
 800df46:	22ff      	movs	r2, #255	@ 0xff
 800df48:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
	}
	taskEXIT_CRITICAL();
 800df4c:	f7ff faa6 	bl	800d49c <vPortExitCritical>
}
 800df50:	bf00      	nop
 800df52:	3710      	adds	r7, #16
 800df54:	46bd      	mov	sp, r7
 800df56:	bd80      	pop	{r7, pc}

0800df58 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
 800df58:	b580      	push	{r7, lr}
 800df5a:	b084      	sub	sp, #16
 800df5c:	af00      	add	r7, sp, #0
 800df5e:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
 800df60:	f7ff fa6a 	bl	800d438 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 800df64:	687b      	ldr	r3, [r7, #4]
 800df66:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800df68:	2b00      	cmp	r3, #0
 800df6a:	d102      	bne.n	800df72 <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
 800df6c:	2301      	movs	r3, #1
 800df6e:	60fb      	str	r3, [r7, #12]
 800df70:	e001      	b.n	800df76 <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
 800df72:	2300      	movs	r3, #0
 800df74:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 800df76:	f7ff fa91 	bl	800d49c <vPortExitCritical>

	return xReturn;
 800df7a:	68fb      	ldr	r3, [r7, #12]
}
 800df7c:	4618      	mov	r0, r3
 800df7e:	3710      	adds	r7, #16
 800df80:	46bd      	mov	sp, r7
 800df82:	bd80      	pop	{r7, pc}

0800df84 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 800df84:	b580      	push	{r7, lr}
 800df86:	b084      	sub	sp, #16
 800df88:	af00      	add	r7, sp, #0
 800df8a:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
 800df8c:	f7ff fa54 	bl	800d438 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 800df90:	687b      	ldr	r3, [r7, #4]
 800df92:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 800df94:	687b      	ldr	r3, [r7, #4]
 800df96:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 800df98:	429a      	cmp	r2, r3
 800df9a:	d102      	bne.n	800dfa2 <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
 800df9c:	2301      	movs	r3, #1
 800df9e:	60fb      	str	r3, [r7, #12]
 800dfa0:	e001      	b.n	800dfa6 <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
 800dfa2:	2300      	movs	r3, #0
 800dfa4:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 800dfa6:	f7ff fa79 	bl	800d49c <vPortExitCritical>

	return xReturn;
 800dfaa:	68fb      	ldr	r3, [r7, #12]
}
 800dfac:	4618      	mov	r0, r3
 800dfae:	3710      	adds	r7, #16
 800dfb0:	46bd      	mov	sp, r7
 800dfb2:	bd80      	pop	{r7, pc}

0800dfb4 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 800dfb4:	b480      	push	{r7}
 800dfb6:	b085      	sub	sp, #20
 800dfb8:	af00      	add	r7, sp, #0
 800dfba:	6078      	str	r0, [r7, #4]
 800dfbc:	6039      	str	r1, [r7, #0]
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 800dfbe:	2300      	movs	r3, #0
 800dfc0:	60fb      	str	r3, [r7, #12]
 800dfc2:	e014      	b.n	800dfee <vQueueAddToRegistry+0x3a>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 800dfc4:	4a0f      	ldr	r2, [pc, #60]	@ (800e004 <vQueueAddToRegistry+0x50>)
 800dfc6:	68fb      	ldr	r3, [r7, #12]
 800dfc8:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 800dfcc:	2b00      	cmp	r3, #0
 800dfce:	d10b      	bne.n	800dfe8 <vQueueAddToRegistry+0x34>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 800dfd0:	490c      	ldr	r1, [pc, #48]	@ (800e004 <vQueueAddToRegistry+0x50>)
 800dfd2:	68fb      	ldr	r3, [r7, #12]
 800dfd4:	683a      	ldr	r2, [r7, #0]
 800dfd6:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 800dfda:	4a0a      	ldr	r2, [pc, #40]	@ (800e004 <vQueueAddToRegistry+0x50>)
 800dfdc:	68fb      	ldr	r3, [r7, #12]
 800dfde:	00db      	lsls	r3, r3, #3
 800dfe0:	4413      	add	r3, r2
 800dfe2:	687a      	ldr	r2, [r7, #4]
 800dfe4:	605a      	str	r2, [r3, #4]

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
 800dfe6:	e006      	b.n	800dff6 <vQueueAddToRegistry+0x42>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 800dfe8:	68fb      	ldr	r3, [r7, #12]
 800dfea:	3301      	adds	r3, #1
 800dfec:	60fb      	str	r3, [r7, #12]
 800dfee:	68fb      	ldr	r3, [r7, #12]
 800dff0:	2b07      	cmp	r3, #7
 800dff2:	d9e7      	bls.n	800dfc4 <vQueueAddToRegistry+0x10>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 800dff4:	bf00      	nop
 800dff6:	bf00      	nop
 800dff8:	3714      	adds	r7, #20
 800dffa:	46bd      	mov	sp, r7
 800dffc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e000:	4770      	bx	lr
 800e002:	bf00      	nop
 800e004:	24005668 	.word	0x24005668

0800e008 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 800e008:	b580      	push	{r7, lr}
 800e00a:	b086      	sub	sp, #24
 800e00c:	af00      	add	r7, sp, #0
 800e00e:	60f8      	str	r0, [r7, #12]
 800e010:	60b9      	str	r1, [r7, #8]
 800e012:	607a      	str	r2, [r7, #4]
	Queue_t * const pxQueue = xQueue;
 800e014:	68fb      	ldr	r3, [r7, #12]
 800e016:	617b      	str	r3, [r7, #20]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 800e018:	f7ff fa0e 	bl	800d438 <vPortEnterCritical>
 800e01c:	697b      	ldr	r3, [r7, #20]
 800e01e:	f893 3044 	ldrb.w	r3, [r3, #68]	@ 0x44
 800e022:	b25b      	sxtb	r3, r3
 800e024:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e028:	d103      	bne.n	800e032 <vQueueWaitForMessageRestricted+0x2a>
 800e02a:	697b      	ldr	r3, [r7, #20]
 800e02c:	2200      	movs	r2, #0
 800e02e:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
 800e032:	697b      	ldr	r3, [r7, #20]
 800e034:	f893 3045 	ldrb.w	r3, [r3, #69]	@ 0x45
 800e038:	b25b      	sxtb	r3, r3
 800e03a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e03e:	d103      	bne.n	800e048 <vQueueWaitForMessageRestricted+0x40>
 800e040:	697b      	ldr	r3, [r7, #20]
 800e042:	2200      	movs	r2, #0
 800e044:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
 800e048:	f7ff fa28 	bl	800d49c <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 800e04c:	697b      	ldr	r3, [r7, #20]
 800e04e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 800e050:	2b00      	cmp	r3, #0
 800e052:	d106      	bne.n	800e062 <vQueueWaitForMessageRestricted+0x5a>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 800e054:	697b      	ldr	r3, [r7, #20]
 800e056:	3324      	adds	r3, #36	@ 0x24
 800e058:	687a      	ldr	r2, [r7, #4]
 800e05a:	68b9      	ldr	r1, [r7, #8]
 800e05c:	4618      	mov	r0, r3
 800e05e:	f000 fc45 	bl	800e8ec <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 800e062:	6978      	ldr	r0, [r7, #20]
 800e064:	f7ff ff26 	bl	800deb4 <prvUnlockQueue>
	}
 800e068:	bf00      	nop
 800e06a:	3718      	adds	r7, #24
 800e06c:	46bd      	mov	sp, r7
 800e06e:	bd80      	pop	{r7, pc}

0800e070 <xTaskCreateStatic>:
									const uint32_t ulStackDepth,
									void * const pvParameters,
									UBaseType_t uxPriority,
									StackType_t * const puxStackBuffer,
									StaticTask_t * const pxTaskBuffer )
	{
 800e070:	b580      	push	{r7, lr}
 800e072:	b08e      	sub	sp, #56	@ 0x38
 800e074:	af04      	add	r7, sp, #16
 800e076:	60f8      	str	r0, [r7, #12]
 800e078:	60b9      	str	r1, [r7, #8]
 800e07a:	607a      	str	r2, [r7, #4]
 800e07c:	603b      	str	r3, [r7, #0]
	TCB_t *pxNewTCB;
	TaskHandle_t xReturn;

		configASSERT( puxStackBuffer != NULL );
 800e07e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e080:	2b00      	cmp	r3, #0
 800e082:	d10b      	bne.n	800e09c <xTaskCreateStatic+0x2c>
	__asm volatile
 800e084:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e088:	f383 8811 	msr	BASEPRI, r3
 800e08c:	f3bf 8f6f 	isb	sy
 800e090:	f3bf 8f4f 	dsb	sy
 800e094:	623b      	str	r3, [r7, #32]
}
 800e096:	bf00      	nop
 800e098:	bf00      	nop
 800e09a:	e7fd      	b.n	800e098 <xTaskCreateStatic+0x28>
		configASSERT( pxTaskBuffer != NULL );
 800e09c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800e09e:	2b00      	cmp	r3, #0
 800e0a0:	d10b      	bne.n	800e0ba <xTaskCreateStatic+0x4a>
	__asm volatile
 800e0a2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e0a6:	f383 8811 	msr	BASEPRI, r3
 800e0aa:	f3bf 8f6f 	isb	sy
 800e0ae:	f3bf 8f4f 	dsb	sy
 800e0b2:	61fb      	str	r3, [r7, #28]
}
 800e0b4:	bf00      	nop
 800e0b6:	bf00      	nop
 800e0b8:	e7fd      	b.n	800e0b6 <xTaskCreateStatic+0x46>
		#if( configASSERT_DEFINED == 1 )
		{
			/* Sanity check that the size of the structure used to declare a
			variable of type StaticTask_t equals the size of the real task
			structure. */
			volatile size_t xSize = sizeof( StaticTask_t );
 800e0ba:	235c      	movs	r3, #92	@ 0x5c
 800e0bc:	613b      	str	r3, [r7, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
 800e0be:	693b      	ldr	r3, [r7, #16]
 800e0c0:	2b5c      	cmp	r3, #92	@ 0x5c
 800e0c2:	d00b      	beq.n	800e0dc <xTaskCreateStatic+0x6c>
	__asm volatile
 800e0c4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e0c8:	f383 8811 	msr	BASEPRI, r3
 800e0cc:	f3bf 8f6f 	isb	sy
 800e0d0:	f3bf 8f4f 	dsb	sy
 800e0d4:	61bb      	str	r3, [r7, #24]
}
 800e0d6:	bf00      	nop
 800e0d8:	bf00      	nop
 800e0da:	e7fd      	b.n	800e0d8 <xTaskCreateStatic+0x68>
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 800e0dc:	693b      	ldr	r3, [r7, #16]
		}
		#endif /* configASSERT_DEFINED */


		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 800e0de:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800e0e0:	2b00      	cmp	r3, #0
 800e0e2:	d01e      	beq.n	800e122 <xTaskCreateStatic+0xb2>
 800e0e4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 800e0e6:	2b00      	cmp	r3, #0
 800e0e8:	d01b      	beq.n	800e122 <xTaskCreateStatic+0xb2>
		{
			/* The memory used for the task's TCB and stack are passed into this
			function - use them. */
			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
 800e0ea:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 800e0ec:	627b      	str	r3, [r7, #36]	@ 0x24
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 800e0ee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e0f0:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 800e0f2:	631a      	str	r2, [r3, #48]	@ 0x30

			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created statically in case the task is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 800e0f4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e0f6:	2202      	movs	r2, #2
 800e0f8:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 800e0fc:	2300      	movs	r3, #0
 800e0fe:	9303      	str	r3, [sp, #12]
 800e100:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800e102:	9302      	str	r3, [sp, #8]
 800e104:	f107 0314 	add.w	r3, r7, #20
 800e108:	9301      	str	r3, [sp, #4]
 800e10a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e10c:	9300      	str	r3, [sp, #0]
 800e10e:	683b      	ldr	r3, [r7, #0]
 800e110:	687a      	ldr	r2, [r7, #4]
 800e112:	68b9      	ldr	r1, [r7, #8]
 800e114:	68f8      	ldr	r0, [r7, #12]
 800e116:	f000 f850 	bl	800e1ba <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 800e11a:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 800e11c:	f000 f8de 	bl	800e2dc <prvAddNewTaskToReadyList>
 800e120:	e001      	b.n	800e126 <xTaskCreateStatic+0xb6>
		}
		else
		{
			xReturn = NULL;
 800e122:	2300      	movs	r3, #0
 800e124:	617b      	str	r3, [r7, #20]
		}

		return xReturn;
 800e126:	697b      	ldr	r3, [r7, #20]
	}
 800e128:	4618      	mov	r0, r3
 800e12a:	3728      	adds	r7, #40	@ 0x28
 800e12c:	46bd      	mov	sp, r7
 800e12e:	bd80      	pop	{r7, pc}

0800e130 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
 800e130:	b580      	push	{r7, lr}
 800e132:	b08c      	sub	sp, #48	@ 0x30
 800e134:	af04      	add	r7, sp, #16
 800e136:	60f8      	str	r0, [r7, #12]
 800e138:	60b9      	str	r1, [r7, #8]
 800e13a:	603b      	str	r3, [r7, #0]
 800e13c:	4613      	mov	r3, r2
 800e13e:	80fb      	strh	r3, [r7, #6]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 800e140:	88fb      	ldrh	r3, [r7, #6]
 800e142:	009b      	lsls	r3, r3, #2
 800e144:	4618      	mov	r0, r3
 800e146:	f7fe fda3 	bl	800cc90 <pvPortMalloc>
 800e14a:	6178      	str	r0, [r7, #20]

			if( pxStack != NULL )
 800e14c:	697b      	ldr	r3, [r7, #20]
 800e14e:	2b00      	cmp	r3, #0
 800e150:	d00e      	beq.n	800e170 <xTaskCreate+0x40>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 800e152:	205c      	movs	r0, #92	@ 0x5c
 800e154:	f7fe fd9c 	bl	800cc90 <pvPortMalloc>
 800e158:	61f8      	str	r0, [r7, #28]

				if( pxNewTCB != NULL )
 800e15a:	69fb      	ldr	r3, [r7, #28]
 800e15c:	2b00      	cmp	r3, #0
 800e15e:	d003      	beq.n	800e168 <xTaskCreate+0x38>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 800e160:	69fb      	ldr	r3, [r7, #28]
 800e162:	697a      	ldr	r2, [r7, #20]
 800e164:	631a      	str	r2, [r3, #48]	@ 0x30
 800e166:	e005      	b.n	800e174 <xTaskCreate+0x44>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 800e168:	6978      	ldr	r0, [r7, #20]
 800e16a:	f7fe fe5f 	bl	800ce2c <vPortFree>
 800e16e:	e001      	b.n	800e174 <xTaskCreate+0x44>
				}
			}
			else
			{
				pxNewTCB = NULL;
 800e170:	2300      	movs	r3, #0
 800e172:	61fb      	str	r3, [r7, #28]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
 800e174:	69fb      	ldr	r3, [r7, #28]
 800e176:	2b00      	cmp	r3, #0
 800e178:	d017      	beq.n	800e1aa <xTaskCreate+0x7a>
		{
			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 800e17a:	69fb      	ldr	r3, [r7, #28]
 800e17c:	2200      	movs	r2, #0
 800e17e:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 800e182:	88fa      	ldrh	r2, [r7, #6]
 800e184:	2300      	movs	r3, #0
 800e186:	9303      	str	r3, [sp, #12]
 800e188:	69fb      	ldr	r3, [r7, #28]
 800e18a:	9302      	str	r3, [sp, #8]
 800e18c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800e18e:	9301      	str	r3, [sp, #4]
 800e190:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e192:	9300      	str	r3, [sp, #0]
 800e194:	683b      	ldr	r3, [r7, #0]
 800e196:	68b9      	ldr	r1, [r7, #8]
 800e198:	68f8      	ldr	r0, [r7, #12]
 800e19a:	f000 f80e 	bl	800e1ba <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 800e19e:	69f8      	ldr	r0, [r7, #28]
 800e1a0:	f000 f89c 	bl	800e2dc <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 800e1a4:	2301      	movs	r3, #1
 800e1a6:	61bb      	str	r3, [r7, #24]
 800e1a8:	e002      	b.n	800e1b0 <xTaskCreate+0x80>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 800e1aa:	f04f 33ff 	mov.w	r3, #4294967295
 800e1ae:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
 800e1b0:	69bb      	ldr	r3, [r7, #24]
	}
 800e1b2:	4618      	mov	r0, r3
 800e1b4:	3720      	adds	r7, #32
 800e1b6:	46bd      	mov	sp, r7
 800e1b8:	bd80      	pop	{r7, pc}

0800e1ba <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
 800e1ba:	b580      	push	{r7, lr}
 800e1bc:	b088      	sub	sp, #32
 800e1be:	af00      	add	r7, sp, #0
 800e1c0:	60f8      	str	r0, [r7, #12]
 800e1c2:	60b9      	str	r1, [r7, #8]
 800e1c4:	607a      	str	r2, [r7, #4]
 800e1c6:	603b      	str	r3, [r7, #0]

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 800e1c8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e1ca:	6b18      	ldr	r0, [r3, #48]	@ 0x30
 800e1cc:	687b      	ldr	r3, [r7, #4]
 800e1ce:	009b      	lsls	r3, r3, #2
 800e1d0:	461a      	mov	r2, r3
 800e1d2:	21a5      	movs	r1, #165	@ 0xa5
 800e1d4:	f009 f98e 	bl	80174f4 <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 800e1d8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e1da:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 800e1dc:	6879      	ldr	r1, [r7, #4]
 800e1de:	f06f 4340 	mvn.w	r3, #3221225472	@ 0xc0000000
 800e1e2:	440b      	add	r3, r1
 800e1e4:	009b      	lsls	r3, r3, #2
 800e1e6:	4413      	add	r3, r2
 800e1e8:	61bb      	str	r3, [r7, #24]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 800e1ea:	69bb      	ldr	r3, [r7, #24]
 800e1ec:	f023 0307 	bic.w	r3, r3, #7
 800e1f0:	61bb      	str	r3, [r7, #24]

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
 800e1f2:	69bb      	ldr	r3, [r7, #24]
 800e1f4:	f003 0307 	and.w	r3, r3, #7
 800e1f8:	2b00      	cmp	r3, #0
 800e1fa:	d00b      	beq.n	800e214 <prvInitialiseNewTask+0x5a>
	__asm volatile
 800e1fc:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e200:	f383 8811 	msr	BASEPRI, r3
 800e204:	f3bf 8f6f 	isb	sy
 800e208:	f3bf 8f4f 	dsb	sy
 800e20c:	617b      	str	r3, [r7, #20]
}
 800e20e:	bf00      	nop
 800e210:	bf00      	nop
 800e212:	e7fd      	b.n	800e210 <prvInitialiseNewTask+0x56>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
 800e214:	68bb      	ldr	r3, [r7, #8]
 800e216:	2b00      	cmp	r3, #0
 800e218:	d01f      	beq.n	800e25a <prvInitialiseNewTask+0xa0>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800e21a:	2300      	movs	r3, #0
 800e21c:	61fb      	str	r3, [r7, #28]
 800e21e:	e012      	b.n	800e246 <prvInitialiseNewTask+0x8c>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800e220:	68ba      	ldr	r2, [r7, #8]
 800e222:	69fb      	ldr	r3, [r7, #28]
 800e224:	4413      	add	r3, r2
 800e226:	7819      	ldrb	r1, [r3, #0]
 800e228:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800e22a:	69fb      	ldr	r3, [r7, #28]
 800e22c:	4413      	add	r3, r2
 800e22e:	3334      	adds	r3, #52	@ 0x34
 800e230:	460a      	mov	r2, r1
 800e232:	701a      	strb	r2, [r3, #0]

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
 800e234:	68ba      	ldr	r2, [r7, #8]
 800e236:	69fb      	ldr	r3, [r7, #28]
 800e238:	4413      	add	r3, r2
 800e23a:	781b      	ldrb	r3, [r3, #0]
 800e23c:	2b00      	cmp	r3, #0
 800e23e:	d006      	beq.n	800e24e <prvInitialiseNewTask+0x94>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800e240:	69fb      	ldr	r3, [r7, #28]
 800e242:	3301      	adds	r3, #1
 800e244:	61fb      	str	r3, [r7, #28]
 800e246:	69fb      	ldr	r3, [r7, #28]
 800e248:	2b0f      	cmp	r3, #15
 800e24a:	d9e9      	bls.n	800e220 <prvInitialiseNewTask+0x66>
 800e24c:	e000      	b.n	800e250 <prvInitialiseNewTask+0x96>
			{
				break;
 800e24e:	bf00      	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800e250:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e252:	2200      	movs	r2, #0
 800e254:	f883 2043 	strb.w	r2, [r3, #67]	@ 0x43
 800e258:	e003      	b.n	800e262 <prvInitialiseNewTask+0xa8>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 800e25a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e25c:	2200      	movs	r2, #0
 800e25e:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 800e262:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e264:	2b37      	cmp	r3, #55	@ 0x37
 800e266:	d901      	bls.n	800e26c <prvInitialiseNewTask+0xb2>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 800e268:	2337      	movs	r3, #55	@ 0x37
 800e26a:	62bb      	str	r3, [r7, #40]	@ 0x28
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 800e26c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e26e:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800e270:	62da      	str	r2, [r3, #44]	@ 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
 800e272:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e274:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 800e276:	64da      	str	r2, [r3, #76]	@ 0x4c
		pxNewTCB->uxMutexesHeld = 0;
 800e278:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e27a:	2200      	movs	r2, #0
 800e27c:	651a      	str	r2, [r3, #80]	@ 0x50
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800e27e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e280:	3304      	adds	r3, #4
 800e282:	4618      	mov	r0, r3
 800e284:	f7fe ff12 	bl	800d0ac <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 800e288:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e28a:	3318      	adds	r3, #24
 800e28c:	4618      	mov	r0, r3
 800e28e:	f7fe ff0d 	bl	800d0ac <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 800e292:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e294:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800e296:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800e298:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800e29a:	f1c3 0238 	rsb	r2, r3, #56	@ 0x38
 800e29e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e2a0:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 800e2a2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e2a4:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800e2a6:	625a      	str	r2, [r3, #36]	@ 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 800e2a8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e2aa:	2200      	movs	r2, #0
 800e2ac:	655a      	str	r2, [r3, #84]	@ 0x54
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 800e2ae:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e2b0:	2200      	movs	r2, #0
 800e2b2:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800e2b6:	683a      	ldr	r2, [r7, #0]
 800e2b8:	68f9      	ldr	r1, [r7, #12]
 800e2ba:	69b8      	ldr	r0, [r7, #24]
 800e2bc:	f7fe ff8a 	bl	800d1d4 <pxPortInitialiseStack>
 800e2c0:	4602      	mov	r2, r0
 800e2c2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 800e2c4:	601a      	str	r2, [r3, #0]
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
 800e2c6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800e2c8:	2b00      	cmp	r3, #0
 800e2ca:	d002      	beq.n	800e2d2 <prvInitialiseNewTask+0x118>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 800e2cc:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800e2ce:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800e2d0:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 800e2d2:	bf00      	nop
 800e2d4:	3720      	adds	r7, #32
 800e2d6:	46bd      	mov	sp, r7
 800e2d8:	bd80      	pop	{r7, pc}
	...

0800e2dc <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 800e2dc:	b580      	push	{r7, lr}
 800e2de:	b082      	sub	sp, #8
 800e2e0:	af00      	add	r7, sp, #0
 800e2e2:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 800e2e4:	f7ff f8a8 	bl	800d438 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 800e2e8:	4b2d      	ldr	r3, [pc, #180]	@ (800e3a0 <prvAddNewTaskToReadyList+0xc4>)
 800e2ea:	681b      	ldr	r3, [r3, #0]
 800e2ec:	3301      	adds	r3, #1
 800e2ee:	4a2c      	ldr	r2, [pc, #176]	@ (800e3a0 <prvAddNewTaskToReadyList+0xc4>)
 800e2f0:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 800e2f2:	4b2c      	ldr	r3, [pc, #176]	@ (800e3a4 <prvAddNewTaskToReadyList+0xc8>)
 800e2f4:	681b      	ldr	r3, [r3, #0]
 800e2f6:	2b00      	cmp	r3, #0
 800e2f8:	d109      	bne.n	800e30e <prvAddNewTaskToReadyList+0x32>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 800e2fa:	4a2a      	ldr	r2, [pc, #168]	@ (800e3a4 <prvAddNewTaskToReadyList+0xc8>)
 800e2fc:	687b      	ldr	r3, [r7, #4]
 800e2fe:	6013      	str	r3, [r2, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 800e300:	4b27      	ldr	r3, [pc, #156]	@ (800e3a0 <prvAddNewTaskToReadyList+0xc4>)
 800e302:	681b      	ldr	r3, [r3, #0]
 800e304:	2b01      	cmp	r3, #1
 800e306:	d110      	bne.n	800e32a <prvAddNewTaskToReadyList+0x4e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 800e308:	f000 fc1e 	bl	800eb48 <prvInitialiseTaskLists>
 800e30c:	e00d      	b.n	800e32a <prvAddNewTaskToReadyList+0x4e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 800e30e:	4b26      	ldr	r3, [pc, #152]	@ (800e3a8 <prvAddNewTaskToReadyList+0xcc>)
 800e310:	681b      	ldr	r3, [r3, #0]
 800e312:	2b00      	cmp	r3, #0
 800e314:	d109      	bne.n	800e32a <prvAddNewTaskToReadyList+0x4e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 800e316:	4b23      	ldr	r3, [pc, #140]	@ (800e3a4 <prvAddNewTaskToReadyList+0xc8>)
 800e318:	681b      	ldr	r3, [r3, #0]
 800e31a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e31c:	687b      	ldr	r3, [r7, #4]
 800e31e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800e320:	429a      	cmp	r2, r3
 800e322:	d802      	bhi.n	800e32a <prvAddNewTaskToReadyList+0x4e>
				{
					pxCurrentTCB = pxNewTCB;
 800e324:	4a1f      	ldr	r2, [pc, #124]	@ (800e3a4 <prvAddNewTaskToReadyList+0xc8>)
 800e326:	687b      	ldr	r3, [r7, #4]
 800e328:	6013      	str	r3, [r2, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 800e32a:	4b20      	ldr	r3, [pc, #128]	@ (800e3ac <prvAddNewTaskToReadyList+0xd0>)
 800e32c:	681b      	ldr	r3, [r3, #0]
 800e32e:	3301      	adds	r3, #1
 800e330:	4a1e      	ldr	r2, [pc, #120]	@ (800e3ac <prvAddNewTaskToReadyList+0xd0>)
 800e332:	6013      	str	r3, [r2, #0]

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 800e334:	4b1d      	ldr	r3, [pc, #116]	@ (800e3ac <prvAddNewTaskToReadyList+0xd0>)
 800e336:	681a      	ldr	r2, [r3, #0]
 800e338:	687b      	ldr	r3, [r7, #4]
 800e33a:	645a      	str	r2, [r3, #68]	@ 0x44
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 800e33c:	687b      	ldr	r3, [r7, #4]
 800e33e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e340:	4b1b      	ldr	r3, [pc, #108]	@ (800e3b0 <prvAddNewTaskToReadyList+0xd4>)
 800e342:	681b      	ldr	r3, [r3, #0]
 800e344:	429a      	cmp	r2, r3
 800e346:	d903      	bls.n	800e350 <prvAddNewTaskToReadyList+0x74>
 800e348:	687b      	ldr	r3, [r7, #4]
 800e34a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800e34c:	4a18      	ldr	r2, [pc, #96]	@ (800e3b0 <prvAddNewTaskToReadyList+0xd4>)
 800e34e:	6013      	str	r3, [r2, #0]
 800e350:	687b      	ldr	r3, [r7, #4]
 800e352:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e354:	4613      	mov	r3, r2
 800e356:	009b      	lsls	r3, r3, #2
 800e358:	4413      	add	r3, r2
 800e35a:	009b      	lsls	r3, r3, #2
 800e35c:	4a15      	ldr	r2, [pc, #84]	@ (800e3b4 <prvAddNewTaskToReadyList+0xd8>)
 800e35e:	441a      	add	r2, r3
 800e360:	687b      	ldr	r3, [r7, #4]
 800e362:	3304      	adds	r3, #4
 800e364:	4619      	mov	r1, r3
 800e366:	4610      	mov	r0, r2
 800e368:	f7fe fead 	bl	800d0c6 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 800e36c:	f7ff f896 	bl	800d49c <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
 800e370:	4b0d      	ldr	r3, [pc, #52]	@ (800e3a8 <prvAddNewTaskToReadyList+0xcc>)
 800e372:	681b      	ldr	r3, [r3, #0]
 800e374:	2b00      	cmp	r3, #0
 800e376:	d00e      	beq.n	800e396 <prvAddNewTaskToReadyList+0xba>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 800e378:	4b0a      	ldr	r3, [pc, #40]	@ (800e3a4 <prvAddNewTaskToReadyList+0xc8>)
 800e37a:	681b      	ldr	r3, [r3, #0]
 800e37c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e37e:	687b      	ldr	r3, [r7, #4]
 800e380:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800e382:	429a      	cmp	r2, r3
 800e384:	d207      	bcs.n	800e396 <prvAddNewTaskToReadyList+0xba>
		{
			taskYIELD_IF_USING_PREEMPTION();
 800e386:	4b0c      	ldr	r3, [pc, #48]	@ (800e3b8 <prvAddNewTaskToReadyList+0xdc>)
 800e388:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800e38c:	601a      	str	r2, [r3, #0]
 800e38e:	f3bf 8f4f 	dsb	sy
 800e392:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 800e396:	bf00      	nop
 800e398:	3708      	adds	r7, #8
 800e39a:	46bd      	mov	sp, r7
 800e39c:	bd80      	pop	{r7, pc}
 800e39e:	bf00      	nop
 800e3a0:	24005b7c 	.word	0x24005b7c
 800e3a4:	240056a8 	.word	0x240056a8
 800e3a8:	24005b88 	.word	0x24005b88
 800e3ac:	24005b98 	.word	0x24005b98
 800e3b0:	24005b84 	.word	0x24005b84
 800e3b4:	240056ac 	.word	0x240056ac
 800e3b8:	e000ed04 	.word	0xe000ed04

0800e3bc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 800e3bc:	b580      	push	{r7, lr}
 800e3be:	b084      	sub	sp, #16
 800e3c0:	af00      	add	r7, sp, #0
 800e3c2:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
 800e3c4:	2300      	movs	r3, #0
 800e3c6:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 800e3c8:	687b      	ldr	r3, [r7, #4]
 800e3ca:	2b00      	cmp	r3, #0
 800e3cc:	d018      	beq.n	800e400 <vTaskDelay+0x44>
		{
			configASSERT( uxSchedulerSuspended == 0 );
 800e3ce:	4b14      	ldr	r3, [pc, #80]	@ (800e420 <vTaskDelay+0x64>)
 800e3d0:	681b      	ldr	r3, [r3, #0]
 800e3d2:	2b00      	cmp	r3, #0
 800e3d4:	d00b      	beq.n	800e3ee <vTaskDelay+0x32>
	__asm volatile
 800e3d6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e3da:	f383 8811 	msr	BASEPRI, r3
 800e3de:	f3bf 8f6f 	isb	sy
 800e3e2:	f3bf 8f4f 	dsb	sy
 800e3e6:	60bb      	str	r3, [r7, #8]
}
 800e3e8:	bf00      	nop
 800e3ea:	bf00      	nop
 800e3ec:	e7fd      	b.n	800e3ea <vTaskDelay+0x2e>
			vTaskSuspendAll();
 800e3ee:	f000 f883 	bl	800e4f8 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 800e3f2:	2100      	movs	r1, #0
 800e3f4:	6878      	ldr	r0, [r7, #4]
 800e3f6:	f000 fcf3 	bl	800ede0 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 800e3fa:	f000 f88b 	bl	800e514 <xTaskResumeAll>
 800e3fe:	60f8      	str	r0, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 800e400:	68fb      	ldr	r3, [r7, #12]
 800e402:	2b00      	cmp	r3, #0
 800e404:	d107      	bne.n	800e416 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
 800e406:	4b07      	ldr	r3, [pc, #28]	@ (800e424 <vTaskDelay+0x68>)
 800e408:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800e40c:	601a      	str	r2, [r3, #0]
 800e40e:	f3bf 8f4f 	dsb	sy
 800e412:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 800e416:	bf00      	nop
 800e418:	3710      	adds	r7, #16
 800e41a:	46bd      	mov	sp, r7
 800e41c:	bd80      	pop	{r7, pc}
 800e41e:	bf00      	nop
 800e420:	24005ba4 	.word	0x24005ba4
 800e424:	e000ed04 	.word	0xe000ed04

0800e428 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 800e428:	b580      	push	{r7, lr}
 800e42a:	b08a      	sub	sp, #40	@ 0x28
 800e42c:	af04      	add	r7, sp, #16
BaseType_t xReturn;

	/* Add the idle task at the lowest priority. */
	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
	{
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 800e42e:	2300      	movs	r3, #0
 800e430:	60bb      	str	r3, [r7, #8]
		StackType_t *pxIdleTaskStackBuffer = NULL;
 800e432:	2300      	movs	r3, #0
 800e434:	607b      	str	r3, [r7, #4]
		uint32_t ulIdleTaskStackSize;

		/* The Idle task is created using user provided RAM - obtain the
		address of the RAM then create the idle task. */
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 800e436:	463a      	mov	r2, r7
 800e438:	1d39      	adds	r1, r7, #4
 800e43a:	f107 0308 	add.w	r3, r7, #8
 800e43e:	4618      	mov	r0, r3
 800e440:	f7fe fbf2 	bl	800cc28 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 800e444:	6839      	ldr	r1, [r7, #0]
 800e446:	687b      	ldr	r3, [r7, #4]
 800e448:	68ba      	ldr	r2, [r7, #8]
 800e44a:	9202      	str	r2, [sp, #8]
 800e44c:	9301      	str	r3, [sp, #4]
 800e44e:	2300      	movs	r3, #0
 800e450:	9300      	str	r3, [sp, #0]
 800e452:	2300      	movs	r3, #0
 800e454:	460a      	mov	r2, r1
 800e456:	4922      	ldr	r1, [pc, #136]	@ (800e4e0 <vTaskStartScheduler+0xb8>)
 800e458:	4822      	ldr	r0, [pc, #136]	@ (800e4e4 <vTaskStartScheduler+0xbc>)
 800e45a:	f7ff fe09 	bl	800e070 <xTaskCreateStatic>
 800e45e:	4603      	mov	r3, r0
 800e460:	4a21      	ldr	r2, [pc, #132]	@ (800e4e8 <vTaskStartScheduler+0xc0>)
 800e462:	6013      	str	r3, [r2, #0]
												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
												pxIdleTaskStackBuffer,
												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */

		if( xIdleTaskHandle != NULL )
 800e464:	4b20      	ldr	r3, [pc, #128]	@ (800e4e8 <vTaskStartScheduler+0xc0>)
 800e466:	681b      	ldr	r3, [r3, #0]
 800e468:	2b00      	cmp	r3, #0
 800e46a:	d002      	beq.n	800e472 <vTaskStartScheduler+0x4a>
		{
			xReturn = pdPASS;
 800e46c:	2301      	movs	r3, #1
 800e46e:	617b      	str	r3, [r7, #20]
 800e470:	e001      	b.n	800e476 <vTaskStartScheduler+0x4e>
		}
		else
		{
			xReturn = pdFAIL;
 800e472:	2300      	movs	r3, #0
 800e474:	617b      	str	r3, [r7, #20]
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 800e476:	697b      	ldr	r3, [r7, #20]
 800e478:	2b01      	cmp	r3, #1
 800e47a:	d102      	bne.n	800e482 <vTaskStartScheduler+0x5a>
		{
			xReturn = xTimerCreateTimerTask();
 800e47c:	f000 fd04 	bl	800ee88 <xTimerCreateTimerTask>
 800e480:	6178      	str	r0, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 800e482:	697b      	ldr	r3, [r7, #20]
 800e484:	2b01      	cmp	r3, #1
 800e486:	d116      	bne.n	800e4b6 <vTaskStartScheduler+0x8e>
	__asm volatile
 800e488:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e48c:	f383 8811 	msr	BASEPRI, r3
 800e490:	f3bf 8f6f 	isb	sy
 800e494:	f3bf 8f4f 	dsb	sy
 800e498:	613b      	str	r3, [r7, #16]
}
 800e49a:	bf00      	nop
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 800e49c:	4b13      	ldr	r3, [pc, #76]	@ (800e4ec <vTaskStartScheduler+0xc4>)
 800e49e:	f04f 32ff 	mov.w	r2, #4294967295
 800e4a2:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 800e4a4:	4b12      	ldr	r3, [pc, #72]	@ (800e4f0 <vTaskStartScheduler+0xc8>)
 800e4a6:	2201      	movs	r2, #1
 800e4a8:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 800e4aa:	4b12      	ldr	r3, [pc, #72]	@ (800e4f4 <vTaskStartScheduler+0xcc>)
 800e4ac:	2200      	movs	r2, #0
 800e4ae:	601a      	str	r2, [r3, #0]

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 800e4b0:	f7fe ff1e 	bl	800d2f0 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 800e4b4:	e00f      	b.n	800e4d6 <vTaskStartScheduler+0xae>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 800e4b6:	697b      	ldr	r3, [r7, #20]
 800e4b8:	f1b3 3fff 	cmp.w	r3, #4294967295
 800e4bc:	d10b      	bne.n	800e4d6 <vTaskStartScheduler+0xae>
	__asm volatile
 800e4be:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e4c2:	f383 8811 	msr	BASEPRI, r3
 800e4c6:	f3bf 8f6f 	isb	sy
 800e4ca:	f3bf 8f4f 	dsb	sy
 800e4ce:	60fb      	str	r3, [r7, #12]
}
 800e4d0:	bf00      	nop
 800e4d2:	bf00      	nop
 800e4d4:	e7fd      	b.n	800e4d2 <vTaskStartScheduler+0xaa>
}
 800e4d6:	bf00      	nop
 800e4d8:	3718      	adds	r7, #24
 800e4da:	46bd      	mov	sp, r7
 800e4dc:	bd80      	pop	{r7, pc}
 800e4de:	bf00      	nop
 800e4e0:	080183c4 	.word	0x080183c4
 800e4e4:	0800eb19 	.word	0x0800eb19
 800e4e8:	24005ba0 	.word	0x24005ba0
 800e4ec:	24005b9c 	.word	0x24005b9c
 800e4f0:	24005b88 	.word	0x24005b88
 800e4f4:	24005b80 	.word	0x24005b80

0800e4f8 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 800e4f8:	b480      	push	{r7}
 800e4fa:	af00      	add	r7, sp, #0
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
 800e4fc:	4b04      	ldr	r3, [pc, #16]	@ (800e510 <vTaskSuspendAll+0x18>)
 800e4fe:	681b      	ldr	r3, [r3, #0]
 800e500:	3301      	adds	r3, #1
 800e502:	4a03      	ldr	r2, [pc, #12]	@ (800e510 <vTaskSuspendAll+0x18>)
 800e504:	6013      	str	r3, [r2, #0]

	/* Enforces ordering for ports and optimised compilers that may otherwise place
	the above increment elsewhere. */
	portMEMORY_BARRIER();
}
 800e506:	bf00      	nop
 800e508:	46bd      	mov	sp, r7
 800e50a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e50e:	4770      	bx	lr
 800e510:	24005ba4 	.word	0x24005ba4

0800e514 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 800e514:	b580      	push	{r7, lr}
 800e516:	b084      	sub	sp, #16
 800e518:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
 800e51a:	2300      	movs	r3, #0
 800e51c:	60fb      	str	r3, [r7, #12]
BaseType_t xAlreadyYielded = pdFALSE;
 800e51e:	2300      	movs	r3, #0
 800e520:	60bb      	str	r3, [r7, #8]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 800e522:	4b42      	ldr	r3, [pc, #264]	@ (800e62c <xTaskResumeAll+0x118>)
 800e524:	681b      	ldr	r3, [r3, #0]
 800e526:	2b00      	cmp	r3, #0
 800e528:	d10b      	bne.n	800e542 <xTaskResumeAll+0x2e>
	__asm volatile
 800e52a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e52e:	f383 8811 	msr	BASEPRI, r3
 800e532:	f3bf 8f6f 	isb	sy
 800e536:	f3bf 8f4f 	dsb	sy
 800e53a:	603b      	str	r3, [r7, #0]
}
 800e53c:	bf00      	nop
 800e53e:	bf00      	nop
 800e540:	e7fd      	b.n	800e53e <xTaskResumeAll+0x2a>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 800e542:	f7fe ff79 	bl	800d438 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 800e546:	4b39      	ldr	r3, [pc, #228]	@ (800e62c <xTaskResumeAll+0x118>)
 800e548:	681b      	ldr	r3, [r3, #0]
 800e54a:	3b01      	subs	r3, #1
 800e54c:	4a37      	ldr	r2, [pc, #220]	@ (800e62c <xTaskResumeAll+0x118>)
 800e54e:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800e550:	4b36      	ldr	r3, [pc, #216]	@ (800e62c <xTaskResumeAll+0x118>)
 800e552:	681b      	ldr	r3, [r3, #0]
 800e554:	2b00      	cmp	r3, #0
 800e556:	d162      	bne.n	800e61e <xTaskResumeAll+0x10a>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800e558:	4b35      	ldr	r3, [pc, #212]	@ (800e630 <xTaskResumeAll+0x11c>)
 800e55a:	681b      	ldr	r3, [r3, #0]
 800e55c:	2b00      	cmp	r3, #0
 800e55e:	d05e      	beq.n	800e61e <xTaskResumeAll+0x10a>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800e560:	e02f      	b.n	800e5c2 <xTaskResumeAll+0xae>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800e562:	4b34      	ldr	r3, [pc, #208]	@ (800e634 <xTaskResumeAll+0x120>)
 800e564:	68db      	ldr	r3, [r3, #12]
 800e566:	68db      	ldr	r3, [r3, #12]
 800e568:	60fb      	str	r3, [r7, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800e56a:	68fb      	ldr	r3, [r7, #12]
 800e56c:	3318      	adds	r3, #24
 800e56e:	4618      	mov	r0, r3
 800e570:	f7fe fe06 	bl	800d180 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800e574:	68fb      	ldr	r3, [r7, #12]
 800e576:	3304      	adds	r3, #4
 800e578:	4618      	mov	r0, r3
 800e57a:	f7fe fe01 	bl	800d180 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800e57e:	68fb      	ldr	r3, [r7, #12]
 800e580:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e582:	4b2d      	ldr	r3, [pc, #180]	@ (800e638 <xTaskResumeAll+0x124>)
 800e584:	681b      	ldr	r3, [r3, #0]
 800e586:	429a      	cmp	r2, r3
 800e588:	d903      	bls.n	800e592 <xTaskResumeAll+0x7e>
 800e58a:	68fb      	ldr	r3, [r7, #12]
 800e58c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800e58e:	4a2a      	ldr	r2, [pc, #168]	@ (800e638 <xTaskResumeAll+0x124>)
 800e590:	6013      	str	r3, [r2, #0]
 800e592:	68fb      	ldr	r3, [r7, #12]
 800e594:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e596:	4613      	mov	r3, r2
 800e598:	009b      	lsls	r3, r3, #2
 800e59a:	4413      	add	r3, r2
 800e59c:	009b      	lsls	r3, r3, #2
 800e59e:	4a27      	ldr	r2, [pc, #156]	@ (800e63c <xTaskResumeAll+0x128>)
 800e5a0:	441a      	add	r2, r3
 800e5a2:	68fb      	ldr	r3, [r7, #12]
 800e5a4:	3304      	adds	r3, #4
 800e5a6:	4619      	mov	r1, r3
 800e5a8:	4610      	mov	r0, r2
 800e5aa:	f7fe fd8c 	bl	800d0c6 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800e5ae:	68fb      	ldr	r3, [r7, #12]
 800e5b0:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e5b2:	4b23      	ldr	r3, [pc, #140]	@ (800e640 <xTaskResumeAll+0x12c>)
 800e5b4:	681b      	ldr	r3, [r3, #0]
 800e5b6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800e5b8:	429a      	cmp	r2, r3
 800e5ba:	d302      	bcc.n	800e5c2 <xTaskResumeAll+0xae>
					{
						xYieldPending = pdTRUE;
 800e5bc:	4b21      	ldr	r3, [pc, #132]	@ (800e644 <xTaskResumeAll+0x130>)
 800e5be:	2201      	movs	r2, #1
 800e5c0:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800e5c2:	4b1c      	ldr	r3, [pc, #112]	@ (800e634 <xTaskResumeAll+0x120>)
 800e5c4:	681b      	ldr	r3, [r3, #0]
 800e5c6:	2b00      	cmp	r3, #0
 800e5c8:	d1cb      	bne.n	800e562 <xTaskResumeAll+0x4e>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 800e5ca:	68fb      	ldr	r3, [r7, #12]
 800e5cc:	2b00      	cmp	r3, #0
 800e5ce:	d001      	beq.n	800e5d4 <xTaskResumeAll+0xc0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 800e5d0:	f000 fb58 	bl	800ec84 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 800e5d4:	4b1c      	ldr	r3, [pc, #112]	@ (800e648 <xTaskResumeAll+0x134>)
 800e5d6:	681b      	ldr	r3, [r3, #0]
 800e5d8:	607b      	str	r3, [r7, #4]

					if( xPendedCounts > ( TickType_t ) 0U )
 800e5da:	687b      	ldr	r3, [r7, #4]
 800e5dc:	2b00      	cmp	r3, #0
 800e5de:	d010      	beq.n	800e602 <xTaskResumeAll+0xee>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 800e5e0:	f000 f846 	bl	800e670 <xTaskIncrementTick>
 800e5e4:	4603      	mov	r3, r0
 800e5e6:	2b00      	cmp	r3, #0
 800e5e8:	d002      	beq.n	800e5f0 <xTaskResumeAll+0xdc>
							{
								xYieldPending = pdTRUE;
 800e5ea:	4b16      	ldr	r3, [pc, #88]	@ (800e644 <xTaskResumeAll+0x130>)
 800e5ec:	2201      	movs	r2, #1
 800e5ee:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
 800e5f0:	687b      	ldr	r3, [r7, #4]
 800e5f2:	3b01      	subs	r3, #1
 800e5f4:	607b      	str	r3, [r7, #4]
						} while( xPendedCounts > ( TickType_t ) 0U );
 800e5f6:	687b      	ldr	r3, [r7, #4]
 800e5f8:	2b00      	cmp	r3, #0
 800e5fa:	d1f1      	bne.n	800e5e0 <xTaskResumeAll+0xcc>

						xPendedTicks = 0;
 800e5fc:	4b12      	ldr	r3, [pc, #72]	@ (800e648 <xTaskResumeAll+0x134>)
 800e5fe:	2200      	movs	r2, #0
 800e600:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 800e602:	4b10      	ldr	r3, [pc, #64]	@ (800e644 <xTaskResumeAll+0x130>)
 800e604:	681b      	ldr	r3, [r3, #0]
 800e606:	2b00      	cmp	r3, #0
 800e608:	d009      	beq.n	800e61e <xTaskResumeAll+0x10a>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 800e60a:	2301      	movs	r3, #1
 800e60c:	60bb      	str	r3, [r7, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 800e60e:	4b0f      	ldr	r3, [pc, #60]	@ (800e64c <xTaskResumeAll+0x138>)
 800e610:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800e614:	601a      	str	r2, [r3, #0]
 800e616:	f3bf 8f4f 	dsb	sy
 800e61a:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 800e61e:	f7fe ff3d 	bl	800d49c <vPortExitCritical>

	return xAlreadyYielded;
 800e622:	68bb      	ldr	r3, [r7, #8]
}
 800e624:	4618      	mov	r0, r3
 800e626:	3710      	adds	r7, #16
 800e628:	46bd      	mov	sp, r7
 800e62a:	bd80      	pop	{r7, pc}
 800e62c:	24005ba4 	.word	0x24005ba4
 800e630:	24005b7c 	.word	0x24005b7c
 800e634:	24005b3c 	.word	0x24005b3c
 800e638:	24005b84 	.word	0x24005b84
 800e63c:	240056ac 	.word	0x240056ac
 800e640:	240056a8 	.word	0x240056a8
 800e644:	24005b90 	.word	0x24005b90
 800e648:	24005b8c 	.word	0x24005b8c
 800e64c:	e000ed04 	.word	0xe000ed04

0800e650 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 800e650:	b480      	push	{r7}
 800e652:	b083      	sub	sp, #12
 800e654:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
 800e656:	4b05      	ldr	r3, [pc, #20]	@ (800e66c <xTaskGetTickCount+0x1c>)
 800e658:	681b      	ldr	r3, [r3, #0]
 800e65a:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
 800e65c:	687b      	ldr	r3, [r7, #4]
}
 800e65e:	4618      	mov	r0, r3
 800e660:	370c      	adds	r7, #12
 800e662:	46bd      	mov	sp, r7
 800e664:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e668:	4770      	bx	lr
 800e66a:	bf00      	nop
 800e66c:	24005b80 	.word	0x24005b80

0800e670 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 800e670:	b580      	push	{r7, lr}
 800e672:	b086      	sub	sp, #24
 800e674:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 800e676:	2300      	movs	r3, #0
 800e678:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800e67a:	4b4f      	ldr	r3, [pc, #316]	@ (800e7b8 <xTaskIncrementTick+0x148>)
 800e67c:	681b      	ldr	r3, [r3, #0]
 800e67e:	2b00      	cmp	r3, #0
 800e680:	f040 8090 	bne.w	800e7a4 <xTaskIncrementTick+0x134>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 800e684:	4b4d      	ldr	r3, [pc, #308]	@ (800e7bc <xTaskIncrementTick+0x14c>)
 800e686:	681b      	ldr	r3, [r3, #0]
 800e688:	3301      	adds	r3, #1
 800e68a:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 800e68c:	4a4b      	ldr	r2, [pc, #300]	@ (800e7bc <xTaskIncrementTick+0x14c>)
 800e68e:	693b      	ldr	r3, [r7, #16]
 800e690:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 800e692:	693b      	ldr	r3, [r7, #16]
 800e694:	2b00      	cmp	r3, #0
 800e696:	d121      	bne.n	800e6dc <xTaskIncrementTick+0x6c>
		{
			taskSWITCH_DELAYED_LISTS();
 800e698:	4b49      	ldr	r3, [pc, #292]	@ (800e7c0 <xTaskIncrementTick+0x150>)
 800e69a:	681b      	ldr	r3, [r3, #0]
 800e69c:	681b      	ldr	r3, [r3, #0]
 800e69e:	2b00      	cmp	r3, #0
 800e6a0:	d00b      	beq.n	800e6ba <xTaskIncrementTick+0x4a>
	__asm volatile
 800e6a2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e6a6:	f383 8811 	msr	BASEPRI, r3
 800e6aa:	f3bf 8f6f 	isb	sy
 800e6ae:	f3bf 8f4f 	dsb	sy
 800e6b2:	603b      	str	r3, [r7, #0]
}
 800e6b4:	bf00      	nop
 800e6b6:	bf00      	nop
 800e6b8:	e7fd      	b.n	800e6b6 <xTaskIncrementTick+0x46>
 800e6ba:	4b41      	ldr	r3, [pc, #260]	@ (800e7c0 <xTaskIncrementTick+0x150>)
 800e6bc:	681b      	ldr	r3, [r3, #0]
 800e6be:	60fb      	str	r3, [r7, #12]
 800e6c0:	4b40      	ldr	r3, [pc, #256]	@ (800e7c4 <xTaskIncrementTick+0x154>)
 800e6c2:	681b      	ldr	r3, [r3, #0]
 800e6c4:	4a3e      	ldr	r2, [pc, #248]	@ (800e7c0 <xTaskIncrementTick+0x150>)
 800e6c6:	6013      	str	r3, [r2, #0]
 800e6c8:	4a3e      	ldr	r2, [pc, #248]	@ (800e7c4 <xTaskIncrementTick+0x154>)
 800e6ca:	68fb      	ldr	r3, [r7, #12]
 800e6cc:	6013      	str	r3, [r2, #0]
 800e6ce:	4b3e      	ldr	r3, [pc, #248]	@ (800e7c8 <xTaskIncrementTick+0x158>)
 800e6d0:	681b      	ldr	r3, [r3, #0]
 800e6d2:	3301      	adds	r3, #1
 800e6d4:	4a3c      	ldr	r2, [pc, #240]	@ (800e7c8 <xTaskIncrementTick+0x158>)
 800e6d6:	6013      	str	r3, [r2, #0]
 800e6d8:	f000 fad4 	bl	800ec84 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 800e6dc:	4b3b      	ldr	r3, [pc, #236]	@ (800e7cc <xTaskIncrementTick+0x15c>)
 800e6de:	681b      	ldr	r3, [r3, #0]
 800e6e0:	693a      	ldr	r2, [r7, #16]
 800e6e2:	429a      	cmp	r2, r3
 800e6e4:	d349      	bcc.n	800e77a <xTaskIncrementTick+0x10a>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800e6e6:	4b36      	ldr	r3, [pc, #216]	@ (800e7c0 <xTaskIncrementTick+0x150>)
 800e6e8:	681b      	ldr	r3, [r3, #0]
 800e6ea:	681b      	ldr	r3, [r3, #0]
 800e6ec:	2b00      	cmp	r3, #0
 800e6ee:	d104      	bne.n	800e6fa <xTaskIncrementTick+0x8a>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800e6f0:	4b36      	ldr	r3, [pc, #216]	@ (800e7cc <xTaskIncrementTick+0x15c>)
 800e6f2:	f04f 32ff 	mov.w	r2, #4294967295
 800e6f6:	601a      	str	r2, [r3, #0]
					break;
 800e6f8:	e03f      	b.n	800e77a <xTaskIncrementTick+0x10a>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800e6fa:	4b31      	ldr	r3, [pc, #196]	@ (800e7c0 <xTaskIncrementTick+0x150>)
 800e6fc:	681b      	ldr	r3, [r3, #0]
 800e6fe:	68db      	ldr	r3, [r3, #12]
 800e700:	68db      	ldr	r3, [r3, #12]
 800e702:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 800e704:	68bb      	ldr	r3, [r7, #8]
 800e706:	685b      	ldr	r3, [r3, #4]
 800e708:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
 800e70a:	693a      	ldr	r2, [r7, #16]
 800e70c:	687b      	ldr	r3, [r7, #4]
 800e70e:	429a      	cmp	r2, r3
 800e710:	d203      	bcs.n	800e71a <xTaskIncrementTick+0xaa>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 800e712:	4a2e      	ldr	r2, [pc, #184]	@ (800e7cc <xTaskIncrementTick+0x15c>)
 800e714:	687b      	ldr	r3, [r7, #4]
 800e716:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 800e718:	e02f      	b.n	800e77a <xTaskIncrementTick+0x10a>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800e71a:	68bb      	ldr	r3, [r7, #8]
 800e71c:	3304      	adds	r3, #4
 800e71e:	4618      	mov	r0, r3
 800e720:	f7fe fd2e 	bl	800d180 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 800e724:	68bb      	ldr	r3, [r7, #8]
 800e726:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 800e728:	2b00      	cmp	r3, #0
 800e72a:	d004      	beq.n	800e736 <xTaskIncrementTick+0xc6>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800e72c:	68bb      	ldr	r3, [r7, #8]
 800e72e:	3318      	adds	r3, #24
 800e730:	4618      	mov	r0, r3
 800e732:	f7fe fd25 	bl	800d180 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 800e736:	68bb      	ldr	r3, [r7, #8]
 800e738:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e73a:	4b25      	ldr	r3, [pc, #148]	@ (800e7d0 <xTaskIncrementTick+0x160>)
 800e73c:	681b      	ldr	r3, [r3, #0]
 800e73e:	429a      	cmp	r2, r3
 800e740:	d903      	bls.n	800e74a <xTaskIncrementTick+0xda>
 800e742:	68bb      	ldr	r3, [r7, #8]
 800e744:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800e746:	4a22      	ldr	r2, [pc, #136]	@ (800e7d0 <xTaskIncrementTick+0x160>)
 800e748:	6013      	str	r3, [r2, #0]
 800e74a:	68bb      	ldr	r3, [r7, #8]
 800e74c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e74e:	4613      	mov	r3, r2
 800e750:	009b      	lsls	r3, r3, #2
 800e752:	4413      	add	r3, r2
 800e754:	009b      	lsls	r3, r3, #2
 800e756:	4a1f      	ldr	r2, [pc, #124]	@ (800e7d4 <xTaskIncrementTick+0x164>)
 800e758:	441a      	add	r2, r3
 800e75a:	68bb      	ldr	r3, [r7, #8]
 800e75c:	3304      	adds	r3, #4
 800e75e:	4619      	mov	r1, r3
 800e760:	4610      	mov	r0, r2
 800e762:	f7fe fcb0 	bl	800d0c6 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800e766:	68bb      	ldr	r3, [r7, #8]
 800e768:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e76a:	4b1b      	ldr	r3, [pc, #108]	@ (800e7d8 <xTaskIncrementTick+0x168>)
 800e76c:	681b      	ldr	r3, [r3, #0]
 800e76e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800e770:	429a      	cmp	r2, r3
 800e772:	d3b8      	bcc.n	800e6e6 <xTaskIncrementTick+0x76>
						{
							xSwitchRequired = pdTRUE;
 800e774:	2301      	movs	r3, #1
 800e776:	617b      	str	r3, [r7, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800e778:	e7b5      	b.n	800e6e6 <xTaskIncrementTick+0x76>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 800e77a:	4b17      	ldr	r3, [pc, #92]	@ (800e7d8 <xTaskIncrementTick+0x168>)
 800e77c:	681b      	ldr	r3, [r3, #0]
 800e77e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e780:	4914      	ldr	r1, [pc, #80]	@ (800e7d4 <xTaskIncrementTick+0x164>)
 800e782:	4613      	mov	r3, r2
 800e784:	009b      	lsls	r3, r3, #2
 800e786:	4413      	add	r3, r2
 800e788:	009b      	lsls	r3, r3, #2
 800e78a:	440b      	add	r3, r1
 800e78c:	681b      	ldr	r3, [r3, #0]
 800e78e:	2b01      	cmp	r3, #1
 800e790:	d901      	bls.n	800e796 <xTaskIncrementTick+0x126>
			{
				xSwitchRequired = pdTRUE;
 800e792:	2301      	movs	r3, #1
 800e794:	617b      	str	r3, [r7, #20]
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
 800e796:	4b11      	ldr	r3, [pc, #68]	@ (800e7dc <xTaskIncrementTick+0x16c>)
 800e798:	681b      	ldr	r3, [r3, #0]
 800e79a:	2b00      	cmp	r3, #0
 800e79c:	d007      	beq.n	800e7ae <xTaskIncrementTick+0x13e>
			{
				xSwitchRequired = pdTRUE;
 800e79e:	2301      	movs	r3, #1
 800e7a0:	617b      	str	r3, [r7, #20]
 800e7a2:	e004      	b.n	800e7ae <xTaskIncrementTick+0x13e>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
 800e7a4:	4b0e      	ldr	r3, [pc, #56]	@ (800e7e0 <xTaskIncrementTick+0x170>)
 800e7a6:	681b      	ldr	r3, [r3, #0]
 800e7a8:	3301      	adds	r3, #1
 800e7aa:	4a0d      	ldr	r2, [pc, #52]	@ (800e7e0 <xTaskIncrementTick+0x170>)
 800e7ac:	6013      	str	r3, [r2, #0]
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
 800e7ae:	697b      	ldr	r3, [r7, #20]
}
 800e7b0:	4618      	mov	r0, r3
 800e7b2:	3718      	adds	r7, #24
 800e7b4:	46bd      	mov	sp, r7
 800e7b6:	bd80      	pop	{r7, pc}
 800e7b8:	24005ba4 	.word	0x24005ba4
 800e7bc:	24005b80 	.word	0x24005b80
 800e7c0:	24005b34 	.word	0x24005b34
 800e7c4:	24005b38 	.word	0x24005b38
 800e7c8:	24005b94 	.word	0x24005b94
 800e7cc:	24005b9c 	.word	0x24005b9c
 800e7d0:	24005b84 	.word	0x24005b84
 800e7d4:	240056ac 	.word	0x240056ac
 800e7d8:	240056a8 	.word	0x240056a8
 800e7dc:	24005b90 	.word	0x24005b90
 800e7e0:	24005b8c 	.word	0x24005b8c

0800e7e4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 800e7e4:	b480      	push	{r7}
 800e7e6:	b085      	sub	sp, #20
 800e7e8:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 800e7ea:	4b28      	ldr	r3, [pc, #160]	@ (800e88c <vTaskSwitchContext+0xa8>)
 800e7ec:	681b      	ldr	r3, [r3, #0]
 800e7ee:	2b00      	cmp	r3, #0
 800e7f0:	d003      	beq.n	800e7fa <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 800e7f2:	4b27      	ldr	r3, [pc, #156]	@ (800e890 <vTaskSwitchContext+0xac>)
 800e7f4:	2201      	movs	r2, #1
 800e7f6:	601a      	str	r2, [r3, #0]
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 800e7f8:	e042      	b.n	800e880 <vTaskSwitchContext+0x9c>
		xYieldPending = pdFALSE;
 800e7fa:	4b25      	ldr	r3, [pc, #148]	@ (800e890 <vTaskSwitchContext+0xac>)
 800e7fc:	2200      	movs	r2, #0
 800e7fe:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800e800:	4b24      	ldr	r3, [pc, #144]	@ (800e894 <vTaskSwitchContext+0xb0>)
 800e802:	681b      	ldr	r3, [r3, #0]
 800e804:	60fb      	str	r3, [r7, #12]
 800e806:	e011      	b.n	800e82c <vTaskSwitchContext+0x48>
 800e808:	68fb      	ldr	r3, [r7, #12]
 800e80a:	2b00      	cmp	r3, #0
 800e80c:	d10b      	bne.n	800e826 <vTaskSwitchContext+0x42>
	__asm volatile
 800e80e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e812:	f383 8811 	msr	BASEPRI, r3
 800e816:	f3bf 8f6f 	isb	sy
 800e81a:	f3bf 8f4f 	dsb	sy
 800e81e:	607b      	str	r3, [r7, #4]
}
 800e820:	bf00      	nop
 800e822:	bf00      	nop
 800e824:	e7fd      	b.n	800e822 <vTaskSwitchContext+0x3e>
 800e826:	68fb      	ldr	r3, [r7, #12]
 800e828:	3b01      	subs	r3, #1
 800e82a:	60fb      	str	r3, [r7, #12]
 800e82c:	491a      	ldr	r1, [pc, #104]	@ (800e898 <vTaskSwitchContext+0xb4>)
 800e82e:	68fa      	ldr	r2, [r7, #12]
 800e830:	4613      	mov	r3, r2
 800e832:	009b      	lsls	r3, r3, #2
 800e834:	4413      	add	r3, r2
 800e836:	009b      	lsls	r3, r3, #2
 800e838:	440b      	add	r3, r1
 800e83a:	681b      	ldr	r3, [r3, #0]
 800e83c:	2b00      	cmp	r3, #0
 800e83e:	d0e3      	beq.n	800e808 <vTaskSwitchContext+0x24>
 800e840:	68fa      	ldr	r2, [r7, #12]
 800e842:	4613      	mov	r3, r2
 800e844:	009b      	lsls	r3, r3, #2
 800e846:	4413      	add	r3, r2
 800e848:	009b      	lsls	r3, r3, #2
 800e84a:	4a13      	ldr	r2, [pc, #76]	@ (800e898 <vTaskSwitchContext+0xb4>)
 800e84c:	4413      	add	r3, r2
 800e84e:	60bb      	str	r3, [r7, #8]
 800e850:	68bb      	ldr	r3, [r7, #8]
 800e852:	685b      	ldr	r3, [r3, #4]
 800e854:	685a      	ldr	r2, [r3, #4]
 800e856:	68bb      	ldr	r3, [r7, #8]
 800e858:	605a      	str	r2, [r3, #4]
 800e85a:	68bb      	ldr	r3, [r7, #8]
 800e85c:	685a      	ldr	r2, [r3, #4]
 800e85e:	68bb      	ldr	r3, [r7, #8]
 800e860:	3308      	adds	r3, #8
 800e862:	429a      	cmp	r2, r3
 800e864:	d104      	bne.n	800e870 <vTaskSwitchContext+0x8c>
 800e866:	68bb      	ldr	r3, [r7, #8]
 800e868:	685b      	ldr	r3, [r3, #4]
 800e86a:	685a      	ldr	r2, [r3, #4]
 800e86c:	68bb      	ldr	r3, [r7, #8]
 800e86e:	605a      	str	r2, [r3, #4]
 800e870:	68bb      	ldr	r3, [r7, #8]
 800e872:	685b      	ldr	r3, [r3, #4]
 800e874:	68db      	ldr	r3, [r3, #12]
 800e876:	4a09      	ldr	r2, [pc, #36]	@ (800e89c <vTaskSwitchContext+0xb8>)
 800e878:	6013      	str	r3, [r2, #0]
 800e87a:	4a06      	ldr	r2, [pc, #24]	@ (800e894 <vTaskSwitchContext+0xb0>)
 800e87c:	68fb      	ldr	r3, [r7, #12]
 800e87e:	6013      	str	r3, [r2, #0]
}
 800e880:	bf00      	nop
 800e882:	3714      	adds	r7, #20
 800e884:	46bd      	mov	sp, r7
 800e886:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e88a:	4770      	bx	lr
 800e88c:	24005ba4 	.word	0x24005ba4
 800e890:	24005b90 	.word	0x24005b90
 800e894:	24005b84 	.word	0x24005b84
 800e898:	240056ac 	.word	0x240056ac
 800e89c:	240056a8 	.word	0x240056a8

0800e8a0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 800e8a0:	b580      	push	{r7, lr}
 800e8a2:	b084      	sub	sp, #16
 800e8a4:	af00      	add	r7, sp, #0
 800e8a6:	6078      	str	r0, [r7, #4]
 800e8a8:	6039      	str	r1, [r7, #0]
	configASSERT( pxEventList );
 800e8aa:	687b      	ldr	r3, [r7, #4]
 800e8ac:	2b00      	cmp	r3, #0
 800e8ae:	d10b      	bne.n	800e8c8 <vTaskPlaceOnEventList+0x28>
	__asm volatile
 800e8b0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e8b4:	f383 8811 	msr	BASEPRI, r3
 800e8b8:	f3bf 8f6f 	isb	sy
 800e8bc:	f3bf 8f4f 	dsb	sy
 800e8c0:	60fb      	str	r3, [r7, #12]
}
 800e8c2:	bf00      	nop
 800e8c4:	bf00      	nop
 800e8c6:	e7fd      	b.n	800e8c4 <vTaskPlaceOnEventList+0x24>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800e8c8:	4b07      	ldr	r3, [pc, #28]	@ (800e8e8 <vTaskPlaceOnEventList+0x48>)
 800e8ca:	681b      	ldr	r3, [r3, #0]
 800e8cc:	3318      	adds	r3, #24
 800e8ce:	4619      	mov	r1, r3
 800e8d0:	6878      	ldr	r0, [r7, #4]
 800e8d2:	f7fe fc1c 	bl	800d10e <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 800e8d6:	2101      	movs	r1, #1
 800e8d8:	6838      	ldr	r0, [r7, #0]
 800e8da:	f000 fa81 	bl	800ede0 <prvAddCurrentTaskToDelayedList>
}
 800e8de:	bf00      	nop
 800e8e0:	3710      	adds	r7, #16
 800e8e2:	46bd      	mov	sp, r7
 800e8e4:	bd80      	pop	{r7, pc}
 800e8e6:	bf00      	nop
 800e8e8:	240056a8 	.word	0x240056a8

0800e8ec <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 800e8ec:	b580      	push	{r7, lr}
 800e8ee:	b086      	sub	sp, #24
 800e8f0:	af00      	add	r7, sp, #0
 800e8f2:	60f8      	str	r0, [r7, #12]
 800e8f4:	60b9      	str	r1, [r7, #8]
 800e8f6:	607a      	str	r2, [r7, #4]
		configASSERT( pxEventList );
 800e8f8:	68fb      	ldr	r3, [r7, #12]
 800e8fa:	2b00      	cmp	r3, #0
 800e8fc:	d10b      	bne.n	800e916 <vTaskPlaceOnEventListRestricted+0x2a>
	__asm volatile
 800e8fe:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e902:	f383 8811 	msr	BASEPRI, r3
 800e906:	f3bf 8f6f 	isb	sy
 800e90a:	f3bf 8f4f 	dsb	sy
 800e90e:	617b      	str	r3, [r7, #20]
}
 800e910:	bf00      	nop
 800e912:	bf00      	nop
 800e914:	e7fd      	b.n	800e912 <vTaskPlaceOnEventListRestricted+0x26>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 800e916:	4b0a      	ldr	r3, [pc, #40]	@ (800e940 <vTaskPlaceOnEventListRestricted+0x54>)
 800e918:	681b      	ldr	r3, [r3, #0]
 800e91a:	3318      	adds	r3, #24
 800e91c:	4619      	mov	r1, r3
 800e91e:	68f8      	ldr	r0, [r7, #12]
 800e920:	f7fe fbd1 	bl	800d0c6 <vListInsertEnd>

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
 800e924:	687b      	ldr	r3, [r7, #4]
 800e926:	2b00      	cmp	r3, #0
 800e928:	d002      	beq.n	800e930 <vTaskPlaceOnEventListRestricted+0x44>
		{
			xTicksToWait = portMAX_DELAY;
 800e92a:	f04f 33ff 	mov.w	r3, #4294967295
 800e92e:	60bb      	str	r3, [r7, #8]
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 800e930:	6879      	ldr	r1, [r7, #4]
 800e932:	68b8      	ldr	r0, [r7, #8]
 800e934:	f000 fa54 	bl	800ede0 <prvAddCurrentTaskToDelayedList>
	}
 800e938:	bf00      	nop
 800e93a:	3718      	adds	r7, #24
 800e93c:	46bd      	mov	sp, r7
 800e93e:	bd80      	pop	{r7, pc}
 800e940:	240056a8 	.word	0x240056a8

0800e944 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 800e944:	b580      	push	{r7, lr}
 800e946:	b086      	sub	sp, #24
 800e948:	af00      	add	r7, sp, #0
 800e94a:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800e94c:	687b      	ldr	r3, [r7, #4]
 800e94e:	68db      	ldr	r3, [r3, #12]
 800e950:	68db      	ldr	r3, [r3, #12]
 800e952:	613b      	str	r3, [r7, #16]
	configASSERT( pxUnblockedTCB );
 800e954:	693b      	ldr	r3, [r7, #16]
 800e956:	2b00      	cmp	r3, #0
 800e958:	d10b      	bne.n	800e972 <xTaskRemoveFromEventList+0x2e>
	__asm volatile
 800e95a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800e95e:	f383 8811 	msr	BASEPRI, r3
 800e962:	f3bf 8f6f 	isb	sy
 800e966:	f3bf 8f4f 	dsb	sy
 800e96a:	60fb      	str	r3, [r7, #12]
}
 800e96c:	bf00      	nop
 800e96e:	bf00      	nop
 800e970:	e7fd      	b.n	800e96e <xTaskRemoveFromEventList+0x2a>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 800e972:	693b      	ldr	r3, [r7, #16]
 800e974:	3318      	adds	r3, #24
 800e976:	4618      	mov	r0, r3
 800e978:	f7fe fc02 	bl	800d180 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800e97c:	4b1d      	ldr	r3, [pc, #116]	@ (800e9f4 <xTaskRemoveFromEventList+0xb0>)
 800e97e:	681b      	ldr	r3, [r3, #0]
 800e980:	2b00      	cmp	r3, #0
 800e982:	d11d      	bne.n	800e9c0 <xTaskRemoveFromEventList+0x7c>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 800e984:	693b      	ldr	r3, [r7, #16]
 800e986:	3304      	adds	r3, #4
 800e988:	4618      	mov	r0, r3
 800e98a:	f7fe fbf9 	bl	800d180 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 800e98e:	693b      	ldr	r3, [r7, #16]
 800e990:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e992:	4b19      	ldr	r3, [pc, #100]	@ (800e9f8 <xTaskRemoveFromEventList+0xb4>)
 800e994:	681b      	ldr	r3, [r3, #0]
 800e996:	429a      	cmp	r2, r3
 800e998:	d903      	bls.n	800e9a2 <xTaskRemoveFromEventList+0x5e>
 800e99a:	693b      	ldr	r3, [r7, #16]
 800e99c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800e99e:	4a16      	ldr	r2, [pc, #88]	@ (800e9f8 <xTaskRemoveFromEventList+0xb4>)
 800e9a0:	6013      	str	r3, [r2, #0]
 800e9a2:	693b      	ldr	r3, [r7, #16]
 800e9a4:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e9a6:	4613      	mov	r3, r2
 800e9a8:	009b      	lsls	r3, r3, #2
 800e9aa:	4413      	add	r3, r2
 800e9ac:	009b      	lsls	r3, r3, #2
 800e9ae:	4a13      	ldr	r2, [pc, #76]	@ (800e9fc <xTaskRemoveFromEventList+0xb8>)
 800e9b0:	441a      	add	r2, r3
 800e9b2:	693b      	ldr	r3, [r7, #16]
 800e9b4:	3304      	adds	r3, #4
 800e9b6:	4619      	mov	r1, r3
 800e9b8:	4610      	mov	r0, r2
 800e9ba:	f7fe fb84 	bl	800d0c6 <vListInsertEnd>
 800e9be:	e005      	b.n	800e9cc <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 800e9c0:	693b      	ldr	r3, [r7, #16]
 800e9c2:	3318      	adds	r3, #24
 800e9c4:	4619      	mov	r1, r3
 800e9c6:	480e      	ldr	r0, [pc, #56]	@ (800ea00 <xTaskRemoveFromEventList+0xbc>)
 800e9c8:	f7fe fb7d 	bl	800d0c6 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800e9cc:	693b      	ldr	r3, [r7, #16]
 800e9ce:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800e9d0:	4b0c      	ldr	r3, [pc, #48]	@ (800ea04 <xTaskRemoveFromEventList+0xc0>)
 800e9d2:	681b      	ldr	r3, [r3, #0]
 800e9d4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800e9d6:	429a      	cmp	r2, r3
 800e9d8:	d905      	bls.n	800e9e6 <xTaskRemoveFromEventList+0xa2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
 800e9da:	2301      	movs	r3, #1
 800e9dc:	617b      	str	r3, [r7, #20]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 800e9de:	4b0a      	ldr	r3, [pc, #40]	@ (800ea08 <xTaskRemoveFromEventList+0xc4>)
 800e9e0:	2201      	movs	r2, #1
 800e9e2:	601a      	str	r2, [r3, #0]
 800e9e4:	e001      	b.n	800e9ea <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
 800e9e6:	2300      	movs	r3, #0
 800e9e8:	617b      	str	r3, [r7, #20]
	}

	return xReturn;
 800e9ea:	697b      	ldr	r3, [r7, #20]
}
 800e9ec:	4618      	mov	r0, r3
 800e9ee:	3718      	adds	r7, #24
 800e9f0:	46bd      	mov	sp, r7
 800e9f2:	bd80      	pop	{r7, pc}
 800e9f4:	24005ba4 	.word	0x24005ba4
 800e9f8:	24005b84 	.word	0x24005b84
 800e9fc:	240056ac 	.word	0x240056ac
 800ea00:	24005b3c 	.word	0x24005b3c
 800ea04:	240056a8 	.word	0x240056a8
 800ea08:	24005b90 	.word	0x24005b90

0800ea0c <vTaskInternalSetTimeOutState>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 800ea0c:	b480      	push	{r7}
 800ea0e:	b083      	sub	sp, #12
 800ea10:	af00      	add	r7, sp, #0
 800ea12:	6078      	str	r0, [r7, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 800ea14:	4b06      	ldr	r3, [pc, #24]	@ (800ea30 <vTaskInternalSetTimeOutState+0x24>)
 800ea16:	681a      	ldr	r2, [r3, #0]
 800ea18:	687b      	ldr	r3, [r7, #4]
 800ea1a:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 800ea1c:	4b05      	ldr	r3, [pc, #20]	@ (800ea34 <vTaskInternalSetTimeOutState+0x28>)
 800ea1e:	681a      	ldr	r2, [r3, #0]
 800ea20:	687b      	ldr	r3, [r7, #4]
 800ea22:	605a      	str	r2, [r3, #4]
}
 800ea24:	bf00      	nop
 800ea26:	370c      	adds	r7, #12
 800ea28:	46bd      	mov	sp, r7
 800ea2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ea2e:	4770      	bx	lr
 800ea30:	24005b94 	.word	0x24005b94
 800ea34:	24005b80 	.word	0x24005b80

0800ea38 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 800ea38:	b580      	push	{r7, lr}
 800ea3a:	b088      	sub	sp, #32
 800ea3c:	af00      	add	r7, sp, #0
 800ea3e:	6078      	str	r0, [r7, #4]
 800ea40:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
 800ea42:	687b      	ldr	r3, [r7, #4]
 800ea44:	2b00      	cmp	r3, #0
 800ea46:	d10b      	bne.n	800ea60 <xTaskCheckForTimeOut+0x28>
	__asm volatile
 800ea48:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800ea4c:	f383 8811 	msr	BASEPRI, r3
 800ea50:	f3bf 8f6f 	isb	sy
 800ea54:	f3bf 8f4f 	dsb	sy
 800ea58:	613b      	str	r3, [r7, #16]
}
 800ea5a:	bf00      	nop
 800ea5c:	bf00      	nop
 800ea5e:	e7fd      	b.n	800ea5c <xTaskCheckForTimeOut+0x24>
	configASSERT( pxTicksToWait );
 800ea60:	683b      	ldr	r3, [r7, #0]
 800ea62:	2b00      	cmp	r3, #0
 800ea64:	d10b      	bne.n	800ea7e <xTaskCheckForTimeOut+0x46>
	__asm volatile
 800ea66:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800ea6a:	f383 8811 	msr	BASEPRI, r3
 800ea6e:	f3bf 8f6f 	isb	sy
 800ea72:	f3bf 8f4f 	dsb	sy
 800ea76:	60fb      	str	r3, [r7, #12]
}
 800ea78:	bf00      	nop
 800ea7a:	bf00      	nop
 800ea7c:	e7fd      	b.n	800ea7a <xTaskCheckForTimeOut+0x42>

	taskENTER_CRITICAL();
 800ea7e:	f7fe fcdb 	bl	800d438 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 800ea82:	4b1d      	ldr	r3, [pc, #116]	@ (800eaf8 <xTaskCheckForTimeOut+0xc0>)
 800ea84:	681b      	ldr	r3, [r3, #0]
 800ea86:	61bb      	str	r3, [r7, #24]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 800ea88:	687b      	ldr	r3, [r7, #4]
 800ea8a:	685b      	ldr	r3, [r3, #4]
 800ea8c:	69ba      	ldr	r2, [r7, #24]
 800ea8e:	1ad3      	subs	r3, r2, r3
 800ea90:	617b      	str	r3, [r7, #20]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
 800ea92:	683b      	ldr	r3, [r7, #0]
 800ea94:	681b      	ldr	r3, [r3, #0]
 800ea96:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ea9a:	d102      	bne.n	800eaa2 <xTaskCheckForTimeOut+0x6a>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
 800ea9c:	2300      	movs	r3, #0
 800ea9e:	61fb      	str	r3, [r7, #28]
 800eaa0:	e023      	b.n	800eaea <xTaskCheckForTimeOut+0xb2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 800eaa2:	687b      	ldr	r3, [r7, #4]
 800eaa4:	681a      	ldr	r2, [r3, #0]
 800eaa6:	4b15      	ldr	r3, [pc, #84]	@ (800eafc <xTaskCheckForTimeOut+0xc4>)
 800eaa8:	681b      	ldr	r3, [r3, #0]
 800eaaa:	429a      	cmp	r2, r3
 800eaac:	d007      	beq.n	800eabe <xTaskCheckForTimeOut+0x86>
 800eaae:	687b      	ldr	r3, [r7, #4]
 800eab0:	685b      	ldr	r3, [r3, #4]
 800eab2:	69ba      	ldr	r2, [r7, #24]
 800eab4:	429a      	cmp	r2, r3
 800eab6:	d302      	bcc.n	800eabe <xTaskCheckForTimeOut+0x86>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
 800eab8:	2301      	movs	r3, #1
 800eaba:	61fb      	str	r3, [r7, #28]
 800eabc:	e015      	b.n	800eaea <xTaskCheckForTimeOut+0xb2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 800eabe:	683b      	ldr	r3, [r7, #0]
 800eac0:	681b      	ldr	r3, [r3, #0]
 800eac2:	697a      	ldr	r2, [r7, #20]
 800eac4:	429a      	cmp	r2, r3
 800eac6:	d20b      	bcs.n	800eae0 <xTaskCheckForTimeOut+0xa8>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
 800eac8:	683b      	ldr	r3, [r7, #0]
 800eaca:	681a      	ldr	r2, [r3, #0]
 800eacc:	697b      	ldr	r3, [r7, #20]
 800eace:	1ad2      	subs	r2, r2, r3
 800ead0:	683b      	ldr	r3, [r7, #0]
 800ead2:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
 800ead4:	6878      	ldr	r0, [r7, #4]
 800ead6:	f7ff ff99 	bl	800ea0c <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
 800eada:	2300      	movs	r3, #0
 800eadc:	61fb      	str	r3, [r7, #28]
 800eade:	e004      	b.n	800eaea <xTaskCheckForTimeOut+0xb2>
		}
		else
		{
			*pxTicksToWait = 0;
 800eae0:	683b      	ldr	r3, [r7, #0]
 800eae2:	2200      	movs	r2, #0
 800eae4:	601a      	str	r2, [r3, #0]
			xReturn = pdTRUE;
 800eae6:	2301      	movs	r3, #1
 800eae8:	61fb      	str	r3, [r7, #28]
		}
	}
	taskEXIT_CRITICAL();
 800eaea:	f7fe fcd7 	bl	800d49c <vPortExitCritical>

	return xReturn;
 800eaee:	69fb      	ldr	r3, [r7, #28]
}
 800eaf0:	4618      	mov	r0, r3
 800eaf2:	3720      	adds	r7, #32
 800eaf4:	46bd      	mov	sp, r7
 800eaf6:	bd80      	pop	{r7, pc}
 800eaf8:	24005b80 	.word	0x24005b80
 800eafc:	24005b94 	.word	0x24005b94

0800eb00 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 800eb00:	b480      	push	{r7}
 800eb02:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
 800eb04:	4b03      	ldr	r3, [pc, #12]	@ (800eb14 <vTaskMissedYield+0x14>)
 800eb06:	2201      	movs	r2, #1
 800eb08:	601a      	str	r2, [r3, #0]
}
 800eb0a:	bf00      	nop
 800eb0c:	46bd      	mov	sp, r7
 800eb0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eb12:	4770      	bx	lr
 800eb14:	24005b90 	.word	0x24005b90

0800eb18 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 800eb18:	b580      	push	{r7, lr}
 800eb1a:	b082      	sub	sp, #8
 800eb1c:	af00      	add	r7, sp, #0
 800eb1e:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
 800eb20:	f000 f852 	bl	800ebc8 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 800eb24:	4b06      	ldr	r3, [pc, #24]	@ (800eb40 <prvIdleTask+0x28>)
 800eb26:	681b      	ldr	r3, [r3, #0]
 800eb28:	2b01      	cmp	r3, #1
 800eb2a:	d9f9      	bls.n	800eb20 <prvIdleTask+0x8>
			{
				taskYIELD();
 800eb2c:	4b05      	ldr	r3, [pc, #20]	@ (800eb44 <prvIdleTask+0x2c>)
 800eb2e:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800eb32:	601a      	str	r2, [r3, #0]
 800eb34:	f3bf 8f4f 	dsb	sy
 800eb38:	f3bf 8f6f 	isb	sy
		prvCheckTasksWaitingTermination();
 800eb3c:	e7f0      	b.n	800eb20 <prvIdleTask+0x8>
 800eb3e:	bf00      	nop
 800eb40:	240056ac 	.word	0x240056ac
 800eb44:	e000ed04 	.word	0xe000ed04

0800eb48 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 800eb48:	b580      	push	{r7, lr}
 800eb4a:	b082      	sub	sp, #8
 800eb4c:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800eb4e:	2300      	movs	r3, #0
 800eb50:	607b      	str	r3, [r7, #4]
 800eb52:	e00c      	b.n	800eb6e <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800eb54:	687a      	ldr	r2, [r7, #4]
 800eb56:	4613      	mov	r3, r2
 800eb58:	009b      	lsls	r3, r3, #2
 800eb5a:	4413      	add	r3, r2
 800eb5c:	009b      	lsls	r3, r3, #2
 800eb5e:	4a12      	ldr	r2, [pc, #72]	@ (800eba8 <prvInitialiseTaskLists+0x60>)
 800eb60:	4413      	add	r3, r2
 800eb62:	4618      	mov	r0, r3
 800eb64:	f7fe fa82 	bl	800d06c <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 800eb68:	687b      	ldr	r3, [r7, #4]
 800eb6a:	3301      	adds	r3, #1
 800eb6c:	607b      	str	r3, [r7, #4]
 800eb6e:	687b      	ldr	r3, [r7, #4]
 800eb70:	2b37      	cmp	r3, #55	@ 0x37
 800eb72:	d9ef      	bls.n	800eb54 <prvInitialiseTaskLists+0xc>
	}

	vListInitialise( &xDelayedTaskList1 );
 800eb74:	480d      	ldr	r0, [pc, #52]	@ (800ebac <prvInitialiseTaskLists+0x64>)
 800eb76:	f7fe fa79 	bl	800d06c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 800eb7a:	480d      	ldr	r0, [pc, #52]	@ (800ebb0 <prvInitialiseTaskLists+0x68>)
 800eb7c:	f7fe fa76 	bl	800d06c <vListInitialise>
	vListInitialise( &xPendingReadyList );
 800eb80:	480c      	ldr	r0, [pc, #48]	@ (800ebb4 <prvInitialiseTaskLists+0x6c>)
 800eb82:	f7fe fa73 	bl	800d06c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 800eb86:	480c      	ldr	r0, [pc, #48]	@ (800ebb8 <prvInitialiseTaskLists+0x70>)
 800eb88:	f7fe fa70 	bl	800d06c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 800eb8c:	480b      	ldr	r0, [pc, #44]	@ (800ebbc <prvInitialiseTaskLists+0x74>)
 800eb8e:	f7fe fa6d 	bl	800d06c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 800eb92:	4b0b      	ldr	r3, [pc, #44]	@ (800ebc0 <prvInitialiseTaskLists+0x78>)
 800eb94:	4a05      	ldr	r2, [pc, #20]	@ (800ebac <prvInitialiseTaskLists+0x64>)
 800eb96:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 800eb98:	4b0a      	ldr	r3, [pc, #40]	@ (800ebc4 <prvInitialiseTaskLists+0x7c>)
 800eb9a:	4a05      	ldr	r2, [pc, #20]	@ (800ebb0 <prvInitialiseTaskLists+0x68>)
 800eb9c:	601a      	str	r2, [r3, #0]
}
 800eb9e:	bf00      	nop
 800eba0:	3708      	adds	r7, #8
 800eba2:	46bd      	mov	sp, r7
 800eba4:	bd80      	pop	{r7, pc}
 800eba6:	bf00      	nop
 800eba8:	240056ac 	.word	0x240056ac
 800ebac:	24005b0c 	.word	0x24005b0c
 800ebb0:	24005b20 	.word	0x24005b20
 800ebb4:	24005b3c 	.word	0x24005b3c
 800ebb8:	24005b50 	.word	0x24005b50
 800ebbc:	24005b68 	.word	0x24005b68
 800ebc0:	24005b34 	.word	0x24005b34
 800ebc4:	24005b38 	.word	0x24005b38

0800ebc8 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 800ebc8:	b580      	push	{r7, lr}
 800ebca:	b082      	sub	sp, #8
 800ebcc:	af00      	add	r7, sp, #0
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800ebce:	e019      	b.n	800ec04 <prvCheckTasksWaitingTermination+0x3c>
		{
			taskENTER_CRITICAL();
 800ebd0:	f7fe fc32 	bl	800d438 <vPortEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800ebd4:	4b10      	ldr	r3, [pc, #64]	@ (800ec18 <prvCheckTasksWaitingTermination+0x50>)
 800ebd6:	68db      	ldr	r3, [r3, #12]
 800ebd8:	68db      	ldr	r3, [r3, #12]
 800ebda:	607b      	str	r3, [r7, #4]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800ebdc:	687b      	ldr	r3, [r7, #4]
 800ebde:	3304      	adds	r3, #4
 800ebe0:	4618      	mov	r0, r3
 800ebe2:	f7fe facd 	bl	800d180 <uxListRemove>
				--uxCurrentNumberOfTasks;
 800ebe6:	4b0d      	ldr	r3, [pc, #52]	@ (800ec1c <prvCheckTasksWaitingTermination+0x54>)
 800ebe8:	681b      	ldr	r3, [r3, #0]
 800ebea:	3b01      	subs	r3, #1
 800ebec:	4a0b      	ldr	r2, [pc, #44]	@ (800ec1c <prvCheckTasksWaitingTermination+0x54>)
 800ebee:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
 800ebf0:	4b0b      	ldr	r3, [pc, #44]	@ (800ec20 <prvCheckTasksWaitingTermination+0x58>)
 800ebf2:	681b      	ldr	r3, [r3, #0]
 800ebf4:	3b01      	subs	r3, #1
 800ebf6:	4a0a      	ldr	r2, [pc, #40]	@ (800ec20 <prvCheckTasksWaitingTermination+0x58>)
 800ebf8:	6013      	str	r3, [r2, #0]
			}
			taskEXIT_CRITICAL();
 800ebfa:	f7fe fc4f 	bl	800d49c <vPortExitCritical>

			prvDeleteTCB( pxTCB );
 800ebfe:	6878      	ldr	r0, [r7, #4]
 800ec00:	f000 f810 	bl	800ec24 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 800ec04:	4b06      	ldr	r3, [pc, #24]	@ (800ec20 <prvCheckTasksWaitingTermination+0x58>)
 800ec06:	681b      	ldr	r3, [r3, #0]
 800ec08:	2b00      	cmp	r3, #0
 800ec0a:	d1e1      	bne.n	800ebd0 <prvCheckTasksWaitingTermination+0x8>
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
 800ec0c:	bf00      	nop
 800ec0e:	bf00      	nop
 800ec10:	3708      	adds	r7, #8
 800ec12:	46bd      	mov	sp, r7
 800ec14:	bd80      	pop	{r7, pc}
 800ec16:	bf00      	nop
 800ec18:	24005b50 	.word	0x24005b50
 800ec1c:	24005b7c 	.word	0x24005b7c
 800ec20:	24005b64 	.word	0x24005b64

0800ec24 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
 800ec24:	b580      	push	{r7, lr}
 800ec26:	b084      	sub	sp, #16
 800ec28:	af00      	add	r7, sp, #0
 800ec2a:	6078      	str	r0, [r7, #4]
		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
		{
			/* The task could have been allocated statically or dynamically, so
			check what was statically allocated before trying to free the
			memory. */
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 800ec2c:	687b      	ldr	r3, [r7, #4]
 800ec2e:	f893 3059 	ldrb.w	r3, [r3, #89]	@ 0x59
 800ec32:	2b00      	cmp	r3, #0
 800ec34:	d108      	bne.n	800ec48 <prvDeleteTCB+0x24>
			{
				/* Both the stack and TCB were allocated dynamically, so both
				must be freed. */
				vPortFree( pxTCB->pxStack );
 800ec36:	687b      	ldr	r3, [r7, #4]
 800ec38:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 800ec3a:	4618      	mov	r0, r3
 800ec3c:	f7fe f8f6 	bl	800ce2c <vPortFree>
				vPortFree( pxTCB );
 800ec40:	6878      	ldr	r0, [r7, #4]
 800ec42:	f7fe f8f3 	bl	800ce2c <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
 800ec46:	e019      	b.n	800ec7c <prvDeleteTCB+0x58>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 800ec48:	687b      	ldr	r3, [r7, #4]
 800ec4a:	f893 3059 	ldrb.w	r3, [r3, #89]	@ 0x59
 800ec4e:	2b01      	cmp	r3, #1
 800ec50:	d103      	bne.n	800ec5a <prvDeleteTCB+0x36>
				vPortFree( pxTCB );
 800ec52:	6878      	ldr	r0, [r7, #4]
 800ec54:	f7fe f8ea 	bl	800ce2c <vPortFree>
	}
 800ec58:	e010      	b.n	800ec7c <prvDeleteTCB+0x58>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 800ec5a:	687b      	ldr	r3, [r7, #4]
 800ec5c:	f893 3059 	ldrb.w	r3, [r3, #89]	@ 0x59
 800ec60:	2b02      	cmp	r3, #2
 800ec62:	d00b      	beq.n	800ec7c <prvDeleteTCB+0x58>
	__asm volatile
 800ec64:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800ec68:	f383 8811 	msr	BASEPRI, r3
 800ec6c:	f3bf 8f6f 	isb	sy
 800ec70:	f3bf 8f4f 	dsb	sy
 800ec74:	60fb      	str	r3, [r7, #12]
}
 800ec76:	bf00      	nop
 800ec78:	bf00      	nop
 800ec7a:	e7fd      	b.n	800ec78 <prvDeleteTCB+0x54>
	}
 800ec7c:	bf00      	nop
 800ec7e:	3710      	adds	r7, #16
 800ec80:	46bd      	mov	sp, r7
 800ec82:	bd80      	pop	{r7, pc}

0800ec84 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 800ec84:	b480      	push	{r7}
 800ec86:	b083      	sub	sp, #12
 800ec88:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800ec8a:	4b0c      	ldr	r3, [pc, #48]	@ (800ecbc <prvResetNextTaskUnblockTime+0x38>)
 800ec8c:	681b      	ldr	r3, [r3, #0]
 800ec8e:	681b      	ldr	r3, [r3, #0]
 800ec90:	2b00      	cmp	r3, #0
 800ec92:	d104      	bne.n	800ec9e <prvResetNextTaskUnblockTime+0x1a>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 800ec94:	4b0a      	ldr	r3, [pc, #40]	@ (800ecc0 <prvResetNextTaskUnblockTime+0x3c>)
 800ec96:	f04f 32ff 	mov.w	r2, #4294967295
 800ec9a:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
 800ec9c:	e008      	b.n	800ecb0 <prvResetNextTaskUnblockTime+0x2c>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800ec9e:	4b07      	ldr	r3, [pc, #28]	@ (800ecbc <prvResetNextTaskUnblockTime+0x38>)
 800eca0:	681b      	ldr	r3, [r3, #0]
 800eca2:	68db      	ldr	r3, [r3, #12]
 800eca4:	68db      	ldr	r3, [r3, #12]
 800eca6:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 800eca8:	687b      	ldr	r3, [r7, #4]
 800ecaa:	685b      	ldr	r3, [r3, #4]
 800ecac:	4a04      	ldr	r2, [pc, #16]	@ (800ecc0 <prvResetNextTaskUnblockTime+0x3c>)
 800ecae:	6013      	str	r3, [r2, #0]
}
 800ecb0:	bf00      	nop
 800ecb2:	370c      	adds	r7, #12
 800ecb4:	46bd      	mov	sp, r7
 800ecb6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ecba:	4770      	bx	lr
 800ecbc:	24005b34 	.word	0x24005b34
 800ecc0:	24005b9c 	.word	0x24005b9c

0800ecc4 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
 800ecc4:	b480      	push	{r7}
 800ecc6:	b083      	sub	sp, #12
 800ecc8:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 800ecca:	4b0b      	ldr	r3, [pc, #44]	@ (800ecf8 <xTaskGetSchedulerState+0x34>)
 800eccc:	681b      	ldr	r3, [r3, #0]
 800ecce:	2b00      	cmp	r3, #0
 800ecd0:	d102      	bne.n	800ecd8 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 800ecd2:	2301      	movs	r3, #1
 800ecd4:	607b      	str	r3, [r7, #4]
 800ecd6:	e008      	b.n	800ecea <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800ecd8:	4b08      	ldr	r3, [pc, #32]	@ (800ecfc <xTaskGetSchedulerState+0x38>)
 800ecda:	681b      	ldr	r3, [r3, #0]
 800ecdc:	2b00      	cmp	r3, #0
 800ecde:	d102      	bne.n	800ece6 <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
 800ece0:	2302      	movs	r3, #2
 800ece2:	607b      	str	r3, [r7, #4]
 800ece4:	e001      	b.n	800ecea <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 800ece6:	2300      	movs	r3, #0
 800ece8:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
 800ecea:	687b      	ldr	r3, [r7, #4]
	}
 800ecec:	4618      	mov	r0, r3
 800ecee:	370c      	adds	r7, #12
 800ecf0:	46bd      	mov	sp, r7
 800ecf2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ecf6:	4770      	bx	lr
 800ecf8:	24005b88 	.word	0x24005b88
 800ecfc:	24005ba4 	.word	0x24005ba4

0800ed00 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 800ed00:	b580      	push	{r7, lr}
 800ed02:	b086      	sub	sp, #24
 800ed04:	af00      	add	r7, sp, #0
 800ed06:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = pxMutexHolder;
 800ed08:	687b      	ldr	r3, [r7, #4]
 800ed0a:	613b      	str	r3, [r7, #16]
	BaseType_t xReturn = pdFALSE;
 800ed0c:	2300      	movs	r3, #0
 800ed0e:	617b      	str	r3, [r7, #20]

		if( pxMutexHolder != NULL )
 800ed10:	687b      	ldr	r3, [r7, #4]
 800ed12:	2b00      	cmp	r3, #0
 800ed14:	d058      	beq.n	800edc8 <xTaskPriorityDisinherit+0xc8>
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
 800ed16:	4b2f      	ldr	r3, [pc, #188]	@ (800edd4 <xTaskPriorityDisinherit+0xd4>)
 800ed18:	681b      	ldr	r3, [r3, #0]
 800ed1a:	693a      	ldr	r2, [r7, #16]
 800ed1c:	429a      	cmp	r2, r3
 800ed1e:	d00b      	beq.n	800ed38 <xTaskPriorityDisinherit+0x38>
	__asm volatile
 800ed20:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800ed24:	f383 8811 	msr	BASEPRI, r3
 800ed28:	f3bf 8f6f 	isb	sy
 800ed2c:	f3bf 8f4f 	dsb	sy
 800ed30:	60fb      	str	r3, [r7, #12]
}
 800ed32:	bf00      	nop
 800ed34:	bf00      	nop
 800ed36:	e7fd      	b.n	800ed34 <xTaskPriorityDisinherit+0x34>
			configASSERT( pxTCB->uxMutexesHeld );
 800ed38:	693b      	ldr	r3, [r7, #16]
 800ed3a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800ed3c:	2b00      	cmp	r3, #0
 800ed3e:	d10b      	bne.n	800ed58 <xTaskPriorityDisinherit+0x58>
	__asm volatile
 800ed40:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800ed44:	f383 8811 	msr	BASEPRI, r3
 800ed48:	f3bf 8f6f 	isb	sy
 800ed4c:	f3bf 8f4f 	dsb	sy
 800ed50:	60bb      	str	r3, [r7, #8]
}
 800ed52:	bf00      	nop
 800ed54:	bf00      	nop
 800ed56:	e7fd      	b.n	800ed54 <xTaskPriorityDisinherit+0x54>
			( pxTCB->uxMutexesHeld )--;
 800ed58:	693b      	ldr	r3, [r7, #16]
 800ed5a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800ed5c:	1e5a      	subs	r2, r3, #1
 800ed5e:	693b      	ldr	r3, [r7, #16]
 800ed60:	651a      	str	r2, [r3, #80]	@ 0x50

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 800ed62:	693b      	ldr	r3, [r7, #16]
 800ed64:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800ed66:	693b      	ldr	r3, [r7, #16]
 800ed68:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800ed6a:	429a      	cmp	r2, r3
 800ed6c:	d02c      	beq.n	800edc8 <xTaskPriorityDisinherit+0xc8>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 800ed6e:	693b      	ldr	r3, [r7, #16]
 800ed70:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 800ed72:	2b00      	cmp	r3, #0
 800ed74:	d128      	bne.n	800edc8 <xTaskPriorityDisinherit+0xc8>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready/delayed list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800ed76:	693b      	ldr	r3, [r7, #16]
 800ed78:	3304      	adds	r3, #4
 800ed7a:	4618      	mov	r0, r3
 800ed7c:	f7fe fa00 	bl	800d180 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 800ed80:	693b      	ldr	r3, [r7, #16]
 800ed82:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 800ed84:	693b      	ldr	r3, [r7, #16]
 800ed86:	62da      	str	r2, [r3, #44]	@ 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800ed88:	693b      	ldr	r3, [r7, #16]
 800ed8a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800ed8c:	f1c3 0238 	rsb	r2, r3, #56	@ 0x38
 800ed90:	693b      	ldr	r3, [r7, #16]
 800ed92:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
 800ed94:	693b      	ldr	r3, [r7, #16]
 800ed96:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800ed98:	4b0f      	ldr	r3, [pc, #60]	@ (800edd8 <xTaskPriorityDisinherit+0xd8>)
 800ed9a:	681b      	ldr	r3, [r3, #0]
 800ed9c:	429a      	cmp	r2, r3
 800ed9e:	d903      	bls.n	800eda8 <xTaskPriorityDisinherit+0xa8>
 800eda0:	693b      	ldr	r3, [r7, #16]
 800eda2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800eda4:	4a0c      	ldr	r2, [pc, #48]	@ (800edd8 <xTaskPriorityDisinherit+0xd8>)
 800eda6:	6013      	str	r3, [r2, #0]
 800eda8:	693b      	ldr	r3, [r7, #16]
 800edaa:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 800edac:	4613      	mov	r3, r2
 800edae:	009b      	lsls	r3, r3, #2
 800edb0:	4413      	add	r3, r2
 800edb2:	009b      	lsls	r3, r3, #2
 800edb4:	4a09      	ldr	r2, [pc, #36]	@ (800eddc <xTaskPriorityDisinherit+0xdc>)
 800edb6:	441a      	add	r2, r3
 800edb8:	693b      	ldr	r3, [r7, #16]
 800edba:	3304      	adds	r3, #4
 800edbc:	4619      	mov	r1, r3
 800edbe:	4610      	mov	r0, r2
 800edc0:	f7fe f981 	bl	800d0c6 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
 800edc4:	2301      	movs	r3, #1
 800edc6:	617b      	str	r3, [r7, #20]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 800edc8:	697b      	ldr	r3, [r7, #20]
	}
 800edca:	4618      	mov	r0, r3
 800edcc:	3718      	adds	r7, #24
 800edce:	46bd      	mov	sp, r7
 800edd0:	bd80      	pop	{r7, pc}
 800edd2:	bf00      	nop
 800edd4:	240056a8 	.word	0x240056a8
 800edd8:	24005b84 	.word	0x24005b84
 800eddc:	240056ac 	.word	0x240056ac

0800ede0 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 800ede0:	b580      	push	{r7, lr}
 800ede2:	b084      	sub	sp, #16
 800ede4:	af00      	add	r7, sp, #0
 800ede6:	6078      	str	r0, [r7, #4]
 800ede8:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 800edea:	4b21      	ldr	r3, [pc, #132]	@ (800ee70 <prvAddCurrentTaskToDelayedList+0x90>)
 800edec:	681b      	ldr	r3, [r3, #0]
 800edee:	60fb      	str	r3, [r7, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800edf0:	4b20      	ldr	r3, [pc, #128]	@ (800ee74 <prvAddCurrentTaskToDelayedList+0x94>)
 800edf2:	681b      	ldr	r3, [r3, #0]
 800edf4:	3304      	adds	r3, #4
 800edf6:	4618      	mov	r0, r3
 800edf8:	f7fe f9c2 	bl	800d180 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800edfc:	687b      	ldr	r3, [r7, #4]
 800edfe:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ee02:	d10a      	bne.n	800ee1a <prvAddCurrentTaskToDelayedList+0x3a>
 800ee04:	683b      	ldr	r3, [r7, #0]
 800ee06:	2b00      	cmp	r3, #0
 800ee08:	d007      	beq.n	800ee1a <prvAddCurrentTaskToDelayedList+0x3a>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800ee0a:	4b1a      	ldr	r3, [pc, #104]	@ (800ee74 <prvAddCurrentTaskToDelayedList+0x94>)
 800ee0c:	681b      	ldr	r3, [r3, #0]
 800ee0e:	3304      	adds	r3, #4
 800ee10:	4619      	mov	r1, r3
 800ee12:	4819      	ldr	r0, [pc, #100]	@ (800ee78 <prvAddCurrentTaskToDelayedList+0x98>)
 800ee14:	f7fe f957 	bl	800d0c6 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 800ee18:	e026      	b.n	800ee68 <prvAddCurrentTaskToDelayedList+0x88>
			xTimeToWake = xConstTickCount + xTicksToWait;
 800ee1a:	68fa      	ldr	r2, [r7, #12]
 800ee1c:	687b      	ldr	r3, [r7, #4]
 800ee1e:	4413      	add	r3, r2
 800ee20:	60bb      	str	r3, [r7, #8]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 800ee22:	4b14      	ldr	r3, [pc, #80]	@ (800ee74 <prvAddCurrentTaskToDelayedList+0x94>)
 800ee24:	681b      	ldr	r3, [r3, #0]
 800ee26:	68ba      	ldr	r2, [r7, #8]
 800ee28:	605a      	str	r2, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 800ee2a:	68ba      	ldr	r2, [r7, #8]
 800ee2c:	68fb      	ldr	r3, [r7, #12]
 800ee2e:	429a      	cmp	r2, r3
 800ee30:	d209      	bcs.n	800ee46 <prvAddCurrentTaskToDelayedList+0x66>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800ee32:	4b12      	ldr	r3, [pc, #72]	@ (800ee7c <prvAddCurrentTaskToDelayedList+0x9c>)
 800ee34:	681a      	ldr	r2, [r3, #0]
 800ee36:	4b0f      	ldr	r3, [pc, #60]	@ (800ee74 <prvAddCurrentTaskToDelayedList+0x94>)
 800ee38:	681b      	ldr	r3, [r3, #0]
 800ee3a:	3304      	adds	r3, #4
 800ee3c:	4619      	mov	r1, r3
 800ee3e:	4610      	mov	r0, r2
 800ee40:	f7fe f965 	bl	800d10e <vListInsert>
}
 800ee44:	e010      	b.n	800ee68 <prvAddCurrentTaskToDelayedList+0x88>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 800ee46:	4b0e      	ldr	r3, [pc, #56]	@ (800ee80 <prvAddCurrentTaskToDelayedList+0xa0>)
 800ee48:	681a      	ldr	r2, [r3, #0]
 800ee4a:	4b0a      	ldr	r3, [pc, #40]	@ (800ee74 <prvAddCurrentTaskToDelayedList+0x94>)
 800ee4c:	681b      	ldr	r3, [r3, #0]
 800ee4e:	3304      	adds	r3, #4
 800ee50:	4619      	mov	r1, r3
 800ee52:	4610      	mov	r0, r2
 800ee54:	f7fe f95b 	bl	800d10e <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 800ee58:	4b0a      	ldr	r3, [pc, #40]	@ (800ee84 <prvAddCurrentTaskToDelayedList+0xa4>)
 800ee5a:	681b      	ldr	r3, [r3, #0]
 800ee5c:	68ba      	ldr	r2, [r7, #8]
 800ee5e:	429a      	cmp	r2, r3
 800ee60:	d202      	bcs.n	800ee68 <prvAddCurrentTaskToDelayedList+0x88>
					xNextTaskUnblockTime = xTimeToWake;
 800ee62:	4a08      	ldr	r2, [pc, #32]	@ (800ee84 <prvAddCurrentTaskToDelayedList+0xa4>)
 800ee64:	68bb      	ldr	r3, [r7, #8]
 800ee66:	6013      	str	r3, [r2, #0]
}
 800ee68:	bf00      	nop
 800ee6a:	3710      	adds	r7, #16
 800ee6c:	46bd      	mov	sp, r7
 800ee6e:	bd80      	pop	{r7, pc}
 800ee70:	24005b80 	.word	0x24005b80
 800ee74:	240056a8 	.word	0x240056a8
 800ee78:	24005b68 	.word	0x24005b68
 800ee7c:	24005b38 	.word	0x24005b38
 800ee80:	24005b34 	.word	0x24005b34
 800ee84:	24005b9c 	.word	0x24005b9c

0800ee88 <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
 800ee88:	b580      	push	{r7, lr}
 800ee8a:	b08a      	sub	sp, #40	@ 0x28
 800ee8c:	af04      	add	r7, sp, #16
BaseType_t xReturn = pdFAIL;
 800ee8e:	2300      	movs	r3, #0
 800ee90:	617b      	str	r3, [r7, #20]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
 800ee92:	f000 fb13 	bl	800f4bc <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
 800ee96:	4b1d      	ldr	r3, [pc, #116]	@ (800ef0c <xTimerCreateTimerTask+0x84>)
 800ee98:	681b      	ldr	r3, [r3, #0]
 800ee9a:	2b00      	cmp	r3, #0
 800ee9c:	d021      	beq.n	800eee2 <xTimerCreateTimerTask+0x5a>
	{
		#if( configSUPPORT_STATIC_ALLOCATION == 1 )
		{
			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
 800ee9e:	2300      	movs	r3, #0
 800eea0:	60fb      	str	r3, [r7, #12]
			StackType_t *pxTimerTaskStackBuffer = NULL;
 800eea2:	2300      	movs	r3, #0
 800eea4:	60bb      	str	r3, [r7, #8]
			uint32_t ulTimerTaskStackSize;

			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 800eea6:	1d3a      	adds	r2, r7, #4
 800eea8:	f107 0108 	add.w	r1, r7, #8
 800eeac:	f107 030c 	add.w	r3, r7, #12
 800eeb0:	4618      	mov	r0, r3
 800eeb2:	f7fd fed3 	bl	800cc5c <vApplicationGetTimerTaskMemory>
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
 800eeb6:	6879      	ldr	r1, [r7, #4]
 800eeb8:	68bb      	ldr	r3, [r7, #8]
 800eeba:	68fa      	ldr	r2, [r7, #12]
 800eebc:	9202      	str	r2, [sp, #8]
 800eebe:	9301      	str	r3, [sp, #4]
 800eec0:	2302      	movs	r3, #2
 800eec2:	9300      	str	r3, [sp, #0]
 800eec4:	2300      	movs	r3, #0
 800eec6:	460a      	mov	r2, r1
 800eec8:	4911      	ldr	r1, [pc, #68]	@ (800ef10 <xTimerCreateTimerTask+0x88>)
 800eeca:	4812      	ldr	r0, [pc, #72]	@ (800ef14 <xTimerCreateTimerTask+0x8c>)
 800eecc:	f7ff f8d0 	bl	800e070 <xTaskCreateStatic>
 800eed0:	4603      	mov	r3, r0
 800eed2:	4a11      	ldr	r2, [pc, #68]	@ (800ef18 <xTimerCreateTimerTask+0x90>)
 800eed4:	6013      	str	r3, [r2, #0]
													NULL,
													( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
													pxTimerTaskStackBuffer,
													pxTimerTaskTCBBuffer );

			if( xTimerTaskHandle != NULL )
 800eed6:	4b10      	ldr	r3, [pc, #64]	@ (800ef18 <xTimerCreateTimerTask+0x90>)
 800eed8:	681b      	ldr	r3, [r3, #0]
 800eeda:	2b00      	cmp	r3, #0
 800eedc:	d001      	beq.n	800eee2 <xTimerCreateTimerTask+0x5a>
			{
				xReturn = pdPASS;
 800eede:	2301      	movs	r3, #1
 800eee0:	617b      	str	r3, [r7, #20]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
 800eee2:	697b      	ldr	r3, [r7, #20]
 800eee4:	2b00      	cmp	r3, #0
 800eee6:	d10b      	bne.n	800ef00 <xTimerCreateTimerTask+0x78>
	__asm volatile
 800eee8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800eeec:	f383 8811 	msr	BASEPRI, r3
 800eef0:	f3bf 8f6f 	isb	sy
 800eef4:	f3bf 8f4f 	dsb	sy
 800eef8:	613b      	str	r3, [r7, #16]
}
 800eefa:	bf00      	nop
 800eefc:	bf00      	nop
 800eefe:	e7fd      	b.n	800eefc <xTimerCreateTimerTask+0x74>
	return xReturn;
 800ef00:	697b      	ldr	r3, [r7, #20]
}
 800ef02:	4618      	mov	r0, r3
 800ef04:	3718      	adds	r7, #24
 800ef06:	46bd      	mov	sp, r7
 800ef08:	bd80      	pop	{r7, pc}
 800ef0a:	bf00      	nop
 800ef0c:	24005bd8 	.word	0x24005bd8
 800ef10:	080183cc 	.word	0x080183cc
 800ef14:	0800f055 	.word	0x0800f055
 800ef18:	24005bdc 	.word	0x24005bdc

0800ef1c <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
 800ef1c:	b580      	push	{r7, lr}
 800ef1e:	b08a      	sub	sp, #40	@ 0x28
 800ef20:	af00      	add	r7, sp, #0
 800ef22:	60f8      	str	r0, [r7, #12]
 800ef24:	60b9      	str	r1, [r7, #8]
 800ef26:	607a      	str	r2, [r7, #4]
 800ef28:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdFAIL;
 800ef2a:	2300      	movs	r3, #0
 800ef2c:	627b      	str	r3, [r7, #36]	@ 0x24
DaemonTaskMessage_t xMessage;

	configASSERT( xTimer );
 800ef2e:	68fb      	ldr	r3, [r7, #12]
 800ef30:	2b00      	cmp	r3, #0
 800ef32:	d10b      	bne.n	800ef4c <xTimerGenericCommand+0x30>
	__asm volatile
 800ef34:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800ef38:	f383 8811 	msr	BASEPRI, r3
 800ef3c:	f3bf 8f6f 	isb	sy
 800ef40:	f3bf 8f4f 	dsb	sy
 800ef44:	623b      	str	r3, [r7, #32]
}
 800ef46:	bf00      	nop
 800ef48:	bf00      	nop
 800ef4a:	e7fd      	b.n	800ef48 <xTimerGenericCommand+0x2c>

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 800ef4c:	4b19      	ldr	r3, [pc, #100]	@ (800efb4 <xTimerGenericCommand+0x98>)
 800ef4e:	681b      	ldr	r3, [r3, #0]
 800ef50:	2b00      	cmp	r3, #0
 800ef52:	d02a      	beq.n	800efaa <xTimerGenericCommand+0x8e>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 800ef54:	68bb      	ldr	r3, [r7, #8]
 800ef56:	613b      	str	r3, [r7, #16]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 800ef58:	687b      	ldr	r3, [r7, #4]
 800ef5a:	617b      	str	r3, [r7, #20]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 800ef5c:	68fb      	ldr	r3, [r7, #12]
 800ef5e:	61bb      	str	r3, [r7, #24]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 800ef60:	68bb      	ldr	r3, [r7, #8]
 800ef62:	2b05      	cmp	r3, #5
 800ef64:	dc18      	bgt.n	800ef98 <xTimerGenericCommand+0x7c>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 800ef66:	f7ff fead 	bl	800ecc4 <xTaskGetSchedulerState>
 800ef6a:	4603      	mov	r3, r0
 800ef6c:	2b02      	cmp	r3, #2
 800ef6e:	d109      	bne.n	800ef84 <xTimerGenericCommand+0x68>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 800ef70:	4b10      	ldr	r3, [pc, #64]	@ (800efb4 <xTimerGenericCommand+0x98>)
 800ef72:	6818      	ldr	r0, [r3, #0]
 800ef74:	f107 0110 	add.w	r1, r7, #16
 800ef78:	2300      	movs	r3, #0
 800ef7a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 800ef7c:	f7fe fc88 	bl	800d890 <xQueueGenericSend>
 800ef80:	6278      	str	r0, [r7, #36]	@ 0x24
 800ef82:	e012      	b.n	800efaa <xTimerGenericCommand+0x8e>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 800ef84:	4b0b      	ldr	r3, [pc, #44]	@ (800efb4 <xTimerGenericCommand+0x98>)
 800ef86:	6818      	ldr	r0, [r3, #0]
 800ef88:	f107 0110 	add.w	r1, r7, #16
 800ef8c:	2300      	movs	r3, #0
 800ef8e:	2200      	movs	r2, #0
 800ef90:	f7fe fc7e 	bl	800d890 <xQueueGenericSend>
 800ef94:	6278      	str	r0, [r7, #36]	@ 0x24
 800ef96:	e008      	b.n	800efaa <xTimerGenericCommand+0x8e>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 800ef98:	4b06      	ldr	r3, [pc, #24]	@ (800efb4 <xTimerGenericCommand+0x98>)
 800ef9a:	6818      	ldr	r0, [r3, #0]
 800ef9c:	f107 0110 	add.w	r1, r7, #16
 800efa0:	2300      	movs	r3, #0
 800efa2:	683a      	ldr	r2, [r7, #0]
 800efa4:	f7fe fd76 	bl	800da94 <xQueueGenericSendFromISR>
 800efa8:	6278      	str	r0, [r7, #36]	@ 0x24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
 800efaa:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 800efac:	4618      	mov	r0, r3
 800efae:	3728      	adds	r7, #40	@ 0x28
 800efb0:	46bd      	mov	sp, r7
 800efb2:	bd80      	pop	{r7, pc}
 800efb4:	24005bd8 	.word	0x24005bd8

0800efb8 <prvProcessExpiredTimer>:
	return pxTimer->pcTimerName;
}
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
 800efb8:	b580      	push	{r7, lr}
 800efba:	b088      	sub	sp, #32
 800efbc:	af02      	add	r7, sp, #8
 800efbe:	6078      	str	r0, [r7, #4]
 800efc0:	6039      	str	r1, [r7, #0]
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800efc2:	4b23      	ldr	r3, [pc, #140]	@ (800f050 <prvProcessExpiredTimer+0x98>)
 800efc4:	681b      	ldr	r3, [r3, #0]
 800efc6:	68db      	ldr	r3, [r3, #12]
 800efc8:	68db      	ldr	r3, [r3, #12]
 800efca:	617b      	str	r3, [r7, #20]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800efcc:	697b      	ldr	r3, [r7, #20]
 800efce:	3304      	adds	r3, #4
 800efd0:	4618      	mov	r0, r3
 800efd2:	f7fe f8d5 	bl	800d180 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto-reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 800efd6:	697b      	ldr	r3, [r7, #20]
 800efd8:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 800efdc:	f003 0304 	and.w	r3, r3, #4
 800efe0:	2b00      	cmp	r3, #0
 800efe2:	d023      	beq.n	800f02c <prvProcessExpiredTimer+0x74>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 800efe4:	697b      	ldr	r3, [r7, #20]
 800efe6:	699a      	ldr	r2, [r3, #24]
 800efe8:	687b      	ldr	r3, [r7, #4]
 800efea:	18d1      	adds	r1, r2, r3
 800efec:	687b      	ldr	r3, [r7, #4]
 800efee:	683a      	ldr	r2, [r7, #0]
 800eff0:	6978      	ldr	r0, [r7, #20]
 800eff2:	f000 f8d5 	bl	800f1a0 <prvInsertTimerInActiveList>
 800eff6:	4603      	mov	r3, r0
 800eff8:	2b00      	cmp	r3, #0
 800effa:	d020      	beq.n	800f03e <prvProcessExpiredTimer+0x86>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 800effc:	2300      	movs	r3, #0
 800effe:	9300      	str	r3, [sp, #0]
 800f000:	2300      	movs	r3, #0
 800f002:	687a      	ldr	r2, [r7, #4]
 800f004:	2100      	movs	r1, #0
 800f006:	6978      	ldr	r0, [r7, #20]
 800f008:	f7ff ff88 	bl	800ef1c <xTimerGenericCommand>
 800f00c:	6138      	str	r0, [r7, #16]
			configASSERT( xResult );
 800f00e:	693b      	ldr	r3, [r7, #16]
 800f010:	2b00      	cmp	r3, #0
 800f012:	d114      	bne.n	800f03e <prvProcessExpiredTimer+0x86>
	__asm volatile
 800f014:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800f018:	f383 8811 	msr	BASEPRI, r3
 800f01c:	f3bf 8f6f 	isb	sy
 800f020:	f3bf 8f4f 	dsb	sy
 800f024:	60fb      	str	r3, [r7, #12]
}
 800f026:	bf00      	nop
 800f028:	bf00      	nop
 800f02a:	e7fd      	b.n	800f028 <prvProcessExpiredTimer+0x70>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 800f02c:	697b      	ldr	r3, [r7, #20]
 800f02e:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 800f032:	f023 0301 	bic.w	r3, r3, #1
 800f036:	b2da      	uxtb	r2, r3
 800f038:	697b      	ldr	r3, [r7, #20]
 800f03a:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 800f03e:	697b      	ldr	r3, [r7, #20]
 800f040:	6a1b      	ldr	r3, [r3, #32]
 800f042:	6978      	ldr	r0, [r7, #20]
 800f044:	4798      	blx	r3
}
 800f046:	bf00      	nop
 800f048:	3718      	adds	r7, #24
 800f04a:	46bd      	mov	sp, r7
 800f04c:	bd80      	pop	{r7, pc}
 800f04e:	bf00      	nop
 800f050:	24005bd0 	.word	0x24005bd0

0800f054 <prvTimerTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
 800f054:	b580      	push	{r7, lr}
 800f056:	b084      	sub	sp, #16
 800f058:	af00      	add	r7, sp, #0
 800f05a:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 800f05c:	f107 0308 	add.w	r3, r7, #8
 800f060:	4618      	mov	r0, r3
 800f062:	f000 f859 	bl	800f118 <prvGetNextExpireTime>
 800f066:	60f8      	str	r0, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 800f068:	68bb      	ldr	r3, [r7, #8]
 800f06a:	4619      	mov	r1, r3
 800f06c:	68f8      	ldr	r0, [r7, #12]
 800f06e:	f000 f805 	bl	800f07c <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
 800f072:	f000 f8d7 	bl	800f224 <prvProcessReceivedCommands>
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 800f076:	bf00      	nop
 800f078:	e7f0      	b.n	800f05c <prvTimerTask+0x8>
	...

0800f07c <prvProcessTimerOrBlockTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
 800f07c:	b580      	push	{r7, lr}
 800f07e:	b084      	sub	sp, #16
 800f080:	af00      	add	r7, sp, #0
 800f082:	6078      	str	r0, [r7, #4]
 800f084:	6039      	str	r1, [r7, #0]
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
 800f086:	f7ff fa37 	bl	800e4f8 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 800f08a:	f107 0308 	add.w	r3, r7, #8
 800f08e:	4618      	mov	r0, r3
 800f090:	f000 f866 	bl	800f160 <prvSampleTimeNow>
 800f094:	60f8      	str	r0, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
 800f096:	68bb      	ldr	r3, [r7, #8]
 800f098:	2b00      	cmp	r3, #0
 800f09a:	d130      	bne.n	800f0fe <prvProcessTimerOrBlockTask+0x82>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 800f09c:	683b      	ldr	r3, [r7, #0]
 800f09e:	2b00      	cmp	r3, #0
 800f0a0:	d10a      	bne.n	800f0b8 <prvProcessTimerOrBlockTask+0x3c>
 800f0a2:	687a      	ldr	r2, [r7, #4]
 800f0a4:	68fb      	ldr	r3, [r7, #12]
 800f0a6:	429a      	cmp	r2, r3
 800f0a8:	d806      	bhi.n	800f0b8 <prvProcessTimerOrBlockTask+0x3c>
			{
				( void ) xTaskResumeAll();
 800f0aa:	f7ff fa33 	bl	800e514 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 800f0ae:	68f9      	ldr	r1, [r7, #12]
 800f0b0:	6878      	ldr	r0, [r7, #4]
 800f0b2:	f7ff ff81 	bl	800efb8 <prvProcessExpiredTimer>
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
 800f0b6:	e024      	b.n	800f102 <prvProcessTimerOrBlockTask+0x86>
				if( xListWasEmpty != pdFALSE )
 800f0b8:	683b      	ldr	r3, [r7, #0]
 800f0ba:	2b00      	cmp	r3, #0
 800f0bc:	d008      	beq.n	800f0d0 <prvProcessTimerOrBlockTask+0x54>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 800f0be:	4b13      	ldr	r3, [pc, #76]	@ (800f10c <prvProcessTimerOrBlockTask+0x90>)
 800f0c0:	681b      	ldr	r3, [r3, #0]
 800f0c2:	681b      	ldr	r3, [r3, #0]
 800f0c4:	2b00      	cmp	r3, #0
 800f0c6:	d101      	bne.n	800f0cc <prvProcessTimerOrBlockTask+0x50>
 800f0c8:	2301      	movs	r3, #1
 800f0ca:	e000      	b.n	800f0ce <prvProcessTimerOrBlockTask+0x52>
 800f0cc:	2300      	movs	r3, #0
 800f0ce:	603b      	str	r3, [r7, #0]
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 800f0d0:	4b0f      	ldr	r3, [pc, #60]	@ (800f110 <prvProcessTimerOrBlockTask+0x94>)
 800f0d2:	6818      	ldr	r0, [r3, #0]
 800f0d4:	687a      	ldr	r2, [r7, #4]
 800f0d6:	68fb      	ldr	r3, [r7, #12]
 800f0d8:	1ad3      	subs	r3, r2, r3
 800f0da:	683a      	ldr	r2, [r7, #0]
 800f0dc:	4619      	mov	r1, r3
 800f0de:	f7fe ff93 	bl	800e008 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 800f0e2:	f7ff fa17 	bl	800e514 <xTaskResumeAll>
 800f0e6:	4603      	mov	r3, r0
 800f0e8:	2b00      	cmp	r3, #0
 800f0ea:	d10a      	bne.n	800f102 <prvProcessTimerOrBlockTask+0x86>
					portYIELD_WITHIN_API();
 800f0ec:	4b09      	ldr	r3, [pc, #36]	@ (800f114 <prvProcessTimerOrBlockTask+0x98>)
 800f0ee:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 800f0f2:	601a      	str	r2, [r3, #0]
 800f0f4:	f3bf 8f4f 	dsb	sy
 800f0f8:	f3bf 8f6f 	isb	sy
}
 800f0fc:	e001      	b.n	800f102 <prvProcessTimerOrBlockTask+0x86>
			( void ) xTaskResumeAll();
 800f0fe:	f7ff fa09 	bl	800e514 <xTaskResumeAll>
}
 800f102:	bf00      	nop
 800f104:	3710      	adds	r7, #16
 800f106:	46bd      	mov	sp, r7
 800f108:	bd80      	pop	{r7, pc}
 800f10a:	bf00      	nop
 800f10c:	24005bd4 	.word	0x24005bd4
 800f110:	24005bd8 	.word	0x24005bd8
 800f114:	e000ed04 	.word	0xe000ed04

0800f118 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
 800f118:	b480      	push	{r7}
 800f11a:	b085      	sub	sp, #20
 800f11c:	af00      	add	r7, sp, #0
 800f11e:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 800f120:	4b0e      	ldr	r3, [pc, #56]	@ (800f15c <prvGetNextExpireTime+0x44>)
 800f122:	681b      	ldr	r3, [r3, #0]
 800f124:	681b      	ldr	r3, [r3, #0]
 800f126:	2b00      	cmp	r3, #0
 800f128:	d101      	bne.n	800f12e <prvGetNextExpireTime+0x16>
 800f12a:	2201      	movs	r2, #1
 800f12c:	e000      	b.n	800f130 <prvGetNextExpireTime+0x18>
 800f12e:	2200      	movs	r2, #0
 800f130:	687b      	ldr	r3, [r7, #4]
 800f132:	601a      	str	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
 800f134:	687b      	ldr	r3, [r7, #4]
 800f136:	681b      	ldr	r3, [r3, #0]
 800f138:	2b00      	cmp	r3, #0
 800f13a:	d105      	bne.n	800f148 <prvGetNextExpireTime+0x30>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800f13c:	4b07      	ldr	r3, [pc, #28]	@ (800f15c <prvGetNextExpireTime+0x44>)
 800f13e:	681b      	ldr	r3, [r3, #0]
 800f140:	68db      	ldr	r3, [r3, #12]
 800f142:	681b      	ldr	r3, [r3, #0]
 800f144:	60fb      	str	r3, [r7, #12]
 800f146:	e001      	b.n	800f14c <prvGetNextExpireTime+0x34>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
 800f148:	2300      	movs	r3, #0
 800f14a:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
 800f14c:	68fb      	ldr	r3, [r7, #12]
}
 800f14e:	4618      	mov	r0, r3
 800f150:	3714      	adds	r7, #20
 800f152:	46bd      	mov	sp, r7
 800f154:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f158:	4770      	bx	lr
 800f15a:	bf00      	nop
 800f15c:	24005bd0 	.word	0x24005bd0

0800f160 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
 800f160:	b580      	push	{r7, lr}
 800f162:	b084      	sub	sp, #16
 800f164:	af00      	add	r7, sp, #0
 800f166:	6078      	str	r0, [r7, #4]
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 800f168:	f7ff fa72 	bl	800e650 <xTaskGetTickCount>
 800f16c:	60f8      	str	r0, [r7, #12]

	if( xTimeNow < xLastTime )
 800f16e:	4b0b      	ldr	r3, [pc, #44]	@ (800f19c <prvSampleTimeNow+0x3c>)
 800f170:	681b      	ldr	r3, [r3, #0]
 800f172:	68fa      	ldr	r2, [r7, #12]
 800f174:	429a      	cmp	r2, r3
 800f176:	d205      	bcs.n	800f184 <prvSampleTimeNow+0x24>
	{
		prvSwitchTimerLists();
 800f178:	f000 f93a 	bl	800f3f0 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 800f17c:	687b      	ldr	r3, [r7, #4]
 800f17e:	2201      	movs	r2, #1
 800f180:	601a      	str	r2, [r3, #0]
 800f182:	e002      	b.n	800f18a <prvSampleTimeNow+0x2a>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
 800f184:	687b      	ldr	r3, [r7, #4]
 800f186:	2200      	movs	r2, #0
 800f188:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
 800f18a:	4a04      	ldr	r2, [pc, #16]	@ (800f19c <prvSampleTimeNow+0x3c>)
 800f18c:	68fb      	ldr	r3, [r7, #12]
 800f18e:	6013      	str	r3, [r2, #0]

	return xTimeNow;
 800f190:	68fb      	ldr	r3, [r7, #12]
}
 800f192:	4618      	mov	r0, r3
 800f194:	3710      	adds	r7, #16
 800f196:	46bd      	mov	sp, r7
 800f198:	bd80      	pop	{r7, pc}
 800f19a:	bf00      	nop
 800f19c:	24005be0 	.word	0x24005be0

0800f1a0 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
 800f1a0:	b580      	push	{r7, lr}
 800f1a2:	b086      	sub	sp, #24
 800f1a4:	af00      	add	r7, sp, #0
 800f1a6:	60f8      	str	r0, [r7, #12]
 800f1a8:	60b9      	str	r1, [r7, #8]
 800f1aa:	607a      	str	r2, [r7, #4]
 800f1ac:	603b      	str	r3, [r7, #0]
BaseType_t xProcessTimerNow = pdFALSE;
 800f1ae:	2300      	movs	r3, #0
 800f1b0:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 800f1b2:	68fb      	ldr	r3, [r7, #12]
 800f1b4:	68ba      	ldr	r2, [r7, #8]
 800f1b6:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 800f1b8:	68fb      	ldr	r3, [r7, #12]
 800f1ba:	68fa      	ldr	r2, [r7, #12]
 800f1bc:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
 800f1be:	68ba      	ldr	r2, [r7, #8]
 800f1c0:	687b      	ldr	r3, [r7, #4]
 800f1c2:	429a      	cmp	r2, r3
 800f1c4:	d812      	bhi.n	800f1ec <prvInsertTimerInActiveList+0x4c>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800f1c6:	687a      	ldr	r2, [r7, #4]
 800f1c8:	683b      	ldr	r3, [r7, #0]
 800f1ca:	1ad2      	subs	r2, r2, r3
 800f1cc:	68fb      	ldr	r3, [r7, #12]
 800f1ce:	699b      	ldr	r3, [r3, #24]
 800f1d0:	429a      	cmp	r2, r3
 800f1d2:	d302      	bcc.n	800f1da <prvInsertTimerInActiveList+0x3a>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 800f1d4:	2301      	movs	r3, #1
 800f1d6:	617b      	str	r3, [r7, #20]
 800f1d8:	e01b      	b.n	800f212 <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 800f1da:	4b10      	ldr	r3, [pc, #64]	@ (800f21c <prvInsertTimerInActiveList+0x7c>)
 800f1dc:	681a      	ldr	r2, [r3, #0]
 800f1de:	68fb      	ldr	r3, [r7, #12]
 800f1e0:	3304      	adds	r3, #4
 800f1e2:	4619      	mov	r1, r3
 800f1e4:	4610      	mov	r0, r2
 800f1e6:	f7fd ff92 	bl	800d10e <vListInsert>
 800f1ea:	e012      	b.n	800f212 <prvInsertTimerInActiveList+0x72>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 800f1ec:	687a      	ldr	r2, [r7, #4]
 800f1ee:	683b      	ldr	r3, [r7, #0]
 800f1f0:	429a      	cmp	r2, r3
 800f1f2:	d206      	bcs.n	800f202 <prvInsertTimerInActiveList+0x62>
 800f1f4:	68ba      	ldr	r2, [r7, #8]
 800f1f6:	683b      	ldr	r3, [r7, #0]
 800f1f8:	429a      	cmp	r2, r3
 800f1fa:	d302      	bcc.n	800f202 <prvInsertTimerInActiveList+0x62>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
 800f1fc:	2301      	movs	r3, #1
 800f1fe:	617b      	str	r3, [r7, #20]
 800f200:	e007      	b.n	800f212 <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800f202:	4b07      	ldr	r3, [pc, #28]	@ (800f220 <prvInsertTimerInActiveList+0x80>)
 800f204:	681a      	ldr	r2, [r3, #0]
 800f206:	68fb      	ldr	r3, [r7, #12]
 800f208:	3304      	adds	r3, #4
 800f20a:	4619      	mov	r1, r3
 800f20c:	4610      	mov	r0, r2
 800f20e:	f7fd ff7e 	bl	800d10e <vListInsert>
		}
	}

	return xProcessTimerNow;
 800f212:	697b      	ldr	r3, [r7, #20]
}
 800f214:	4618      	mov	r0, r3
 800f216:	3718      	adds	r7, #24
 800f218:	46bd      	mov	sp, r7
 800f21a:	bd80      	pop	{r7, pc}
 800f21c:	24005bd4 	.word	0x24005bd4
 800f220:	24005bd0 	.word	0x24005bd0

0800f224 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
 800f224:	b580      	push	{r7, lr}
 800f226:	b08e      	sub	sp, #56	@ 0x38
 800f228:	af02      	add	r7, sp, #8
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 800f22a:	e0ce      	b.n	800f3ca <prvProcessReceivedCommands+0x1a6>
	{
		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
		{
			/* Negative commands are pended function calls rather than timer
			commands. */
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
 800f22c:	687b      	ldr	r3, [r7, #4]
 800f22e:	2b00      	cmp	r3, #0
 800f230:	da19      	bge.n	800f266 <prvProcessReceivedCommands+0x42>
			{
				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
 800f232:	1d3b      	adds	r3, r7, #4
 800f234:	3304      	adds	r3, #4
 800f236:	62fb      	str	r3, [r7, #44]	@ 0x2c

				/* The timer uses the xCallbackParameters member to request a
				callback be executed.  Check the callback is not NULL. */
				configASSERT( pxCallback );
 800f238:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f23a:	2b00      	cmp	r3, #0
 800f23c:	d10b      	bne.n	800f256 <prvProcessReceivedCommands+0x32>
	__asm volatile
 800f23e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800f242:	f383 8811 	msr	BASEPRI, r3
 800f246:	f3bf 8f6f 	isb	sy
 800f24a:	f3bf 8f4f 	dsb	sy
 800f24e:	61fb      	str	r3, [r7, #28]
}
 800f250:	bf00      	nop
 800f252:	bf00      	nop
 800f254:	e7fd      	b.n	800f252 <prvProcessReceivedCommands+0x2e>

				/* Call the function. */
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
 800f256:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 800f258:	681b      	ldr	r3, [r3, #0]
 800f25a:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800f25c:	6850      	ldr	r0, [r2, #4]
 800f25e:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 800f260:	6892      	ldr	r2, [r2, #8]
 800f262:	4611      	mov	r1, r2
 800f264:	4798      	blx	r3
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 800f266:	687b      	ldr	r3, [r7, #4]
 800f268:	2b00      	cmp	r3, #0
 800f26a:	f2c0 80ae 	blt.w	800f3ca <prvProcessReceivedCommands+0x1a6>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 800f26e:	68fb      	ldr	r3, [r7, #12]
 800f270:	62bb      	str	r3, [r7, #40]	@ 0x28

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 800f272:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f274:	695b      	ldr	r3, [r3, #20]
 800f276:	2b00      	cmp	r3, #0
 800f278:	d004      	beq.n	800f284 <prvProcessReceivedCommands+0x60>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800f27a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f27c:	3304      	adds	r3, #4
 800f27e:	4618      	mov	r0, r3
 800f280:	f7fd ff7e 	bl	800d180 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 800f284:	463b      	mov	r3, r7
 800f286:	4618      	mov	r0, r3
 800f288:	f7ff ff6a 	bl	800f160 <prvSampleTimeNow>
 800f28c:	6278      	str	r0, [r7, #36]	@ 0x24

			switch( xMessage.xMessageID )
 800f28e:	687b      	ldr	r3, [r7, #4]
 800f290:	2b09      	cmp	r3, #9
 800f292:	f200 8097 	bhi.w	800f3c4 <prvProcessReceivedCommands+0x1a0>
 800f296:	a201      	add	r2, pc, #4	@ (adr r2, 800f29c <prvProcessReceivedCommands+0x78>)
 800f298:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800f29c:	0800f2c5 	.word	0x0800f2c5
 800f2a0:	0800f2c5 	.word	0x0800f2c5
 800f2a4:	0800f2c5 	.word	0x0800f2c5
 800f2a8:	0800f33b 	.word	0x0800f33b
 800f2ac:	0800f34f 	.word	0x0800f34f
 800f2b0:	0800f39b 	.word	0x0800f39b
 800f2b4:	0800f2c5 	.word	0x0800f2c5
 800f2b8:	0800f2c5 	.word	0x0800f2c5
 800f2bc:	0800f33b 	.word	0x0800f33b
 800f2c0:	0800f34f 	.word	0x0800f34f
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 800f2c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f2c6:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 800f2ca:	f043 0301 	orr.w	r3, r3, #1
 800f2ce:	b2da      	uxtb	r2, r3
 800f2d0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f2d2:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 800f2d6:	68ba      	ldr	r2, [r7, #8]
 800f2d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f2da:	699b      	ldr	r3, [r3, #24]
 800f2dc:	18d1      	adds	r1, r2, r3
 800f2de:	68bb      	ldr	r3, [r7, #8]
 800f2e0:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800f2e2:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800f2e4:	f7ff ff5c 	bl	800f1a0 <prvInsertTimerInActiveList>
 800f2e8:	4603      	mov	r3, r0
 800f2ea:	2b00      	cmp	r3, #0
 800f2ec:	d06c      	beq.n	800f3c8 <prvProcessReceivedCommands+0x1a4>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 800f2ee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f2f0:	6a1b      	ldr	r3, [r3, #32]
 800f2f2:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800f2f4:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 800f2f6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f2f8:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 800f2fc:	f003 0304 	and.w	r3, r3, #4
 800f300:	2b00      	cmp	r3, #0
 800f302:	d061      	beq.n	800f3c8 <prvProcessReceivedCommands+0x1a4>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 800f304:	68ba      	ldr	r2, [r7, #8]
 800f306:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f308:	699b      	ldr	r3, [r3, #24]
 800f30a:	441a      	add	r2, r3
 800f30c:	2300      	movs	r3, #0
 800f30e:	9300      	str	r3, [sp, #0]
 800f310:	2300      	movs	r3, #0
 800f312:	2100      	movs	r1, #0
 800f314:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800f316:	f7ff fe01 	bl	800ef1c <xTimerGenericCommand>
 800f31a:	6238      	str	r0, [r7, #32]
							configASSERT( xResult );
 800f31c:	6a3b      	ldr	r3, [r7, #32]
 800f31e:	2b00      	cmp	r3, #0
 800f320:	d152      	bne.n	800f3c8 <prvProcessReceivedCommands+0x1a4>
	__asm volatile
 800f322:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800f326:	f383 8811 	msr	BASEPRI, r3
 800f32a:	f3bf 8f6f 	isb	sy
 800f32e:	f3bf 8f4f 	dsb	sy
 800f332:	61bb      	str	r3, [r7, #24]
}
 800f334:	bf00      	nop
 800f336:	bf00      	nop
 800f338:	e7fd      	b.n	800f336 <prvProcessReceivedCommands+0x112>
					break;

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 800f33a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f33c:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 800f340:	f023 0301 	bic.w	r3, r3, #1
 800f344:	b2da      	uxtb	r2, r3
 800f346:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f348:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
					break;
 800f34c:	e03d      	b.n	800f3ca <prvProcessReceivedCommands+0x1a6>

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 800f34e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f350:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 800f354:	f043 0301 	orr.w	r3, r3, #1
 800f358:	b2da      	uxtb	r2, r3
 800f35a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f35c:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 800f360:	68ba      	ldr	r2, [r7, #8]
 800f362:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f364:	619a      	str	r2, [r3, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 800f366:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f368:	699b      	ldr	r3, [r3, #24]
 800f36a:	2b00      	cmp	r3, #0
 800f36c:	d10b      	bne.n	800f386 <prvProcessReceivedCommands+0x162>
	__asm volatile
 800f36e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800f372:	f383 8811 	msr	BASEPRI, r3
 800f376:	f3bf 8f6f 	isb	sy
 800f37a:	f3bf 8f4f 	dsb	sy
 800f37e:	617b      	str	r3, [r7, #20]
}
 800f380:	bf00      	nop
 800f382:	bf00      	nop
 800f384:	e7fd      	b.n	800f382 <prvProcessReceivedCommands+0x15e>
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 800f386:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f388:	699a      	ldr	r2, [r3, #24]
 800f38a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f38c:	18d1      	adds	r1, r2, r3
 800f38e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 800f390:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 800f392:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800f394:	f7ff ff04 	bl	800f1a0 <prvInsertTimerInActiveList>
					break;
 800f398:	e017      	b.n	800f3ca <prvProcessReceivedCommands+0x1a6>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 800f39a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f39c:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 800f3a0:	f003 0302 	and.w	r3, r3, #2
 800f3a4:	2b00      	cmp	r3, #0
 800f3a6:	d103      	bne.n	800f3b0 <prvProcessReceivedCommands+0x18c>
						{
							vPortFree( pxTimer );
 800f3a8:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 800f3aa:	f7fd fd3f 	bl	800ce2c <vPortFree>
						no need to free the memory - just mark the timer as
						"not active". */
						pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
					}
					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
					break;
 800f3ae:	e00c      	b.n	800f3ca <prvProcessReceivedCommands+0x1a6>
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 800f3b0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f3b2:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 800f3b6:	f023 0301 	bic.w	r3, r3, #1
 800f3ba:	b2da      	uxtb	r2, r3
 800f3bc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800f3be:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
					break;
 800f3c2:	e002      	b.n	800f3ca <prvProcessReceivedCommands+0x1a6>

				default	:
					/* Don't expect to get here. */
					break;
 800f3c4:	bf00      	nop
 800f3c6:	e000      	b.n	800f3ca <prvProcessReceivedCommands+0x1a6>
					break;
 800f3c8:	bf00      	nop
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 800f3ca:	4b08      	ldr	r3, [pc, #32]	@ (800f3ec <prvProcessReceivedCommands+0x1c8>)
 800f3cc:	681b      	ldr	r3, [r3, #0]
 800f3ce:	1d39      	adds	r1, r7, #4
 800f3d0:	2200      	movs	r2, #0
 800f3d2:	4618      	mov	r0, r3
 800f3d4:	f7fe fbfc 	bl	800dbd0 <xQueueReceive>
 800f3d8:	4603      	mov	r3, r0
 800f3da:	2b00      	cmp	r3, #0
 800f3dc:	f47f af26 	bne.w	800f22c <prvProcessReceivedCommands+0x8>
			}
		}
	}
}
 800f3e0:	bf00      	nop
 800f3e2:	bf00      	nop
 800f3e4:	3730      	adds	r7, #48	@ 0x30
 800f3e6:	46bd      	mov	sp, r7
 800f3e8:	bd80      	pop	{r7, pc}
 800f3ea:	bf00      	nop
 800f3ec:	24005bd8 	.word	0x24005bd8

0800f3f0 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
 800f3f0:	b580      	push	{r7, lr}
 800f3f2:	b088      	sub	sp, #32
 800f3f4:	af02      	add	r7, sp, #8

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 800f3f6:	e049      	b.n	800f48c <prvSwitchTimerLists+0x9c>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800f3f8:	4b2e      	ldr	r3, [pc, #184]	@ (800f4b4 <prvSwitchTimerLists+0xc4>)
 800f3fa:	681b      	ldr	r3, [r3, #0]
 800f3fc:	68db      	ldr	r3, [r3, #12]
 800f3fe:	681b      	ldr	r3, [r3, #0]
 800f400:	613b      	str	r3, [r7, #16]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800f402:	4b2c      	ldr	r3, [pc, #176]	@ (800f4b4 <prvSwitchTimerLists+0xc4>)
 800f404:	681b      	ldr	r3, [r3, #0]
 800f406:	68db      	ldr	r3, [r3, #12]
 800f408:	68db      	ldr	r3, [r3, #12]
 800f40a:	60fb      	str	r3, [r7, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 800f40c:	68fb      	ldr	r3, [r7, #12]
 800f40e:	3304      	adds	r3, #4
 800f410:	4618      	mov	r0, r3
 800f412:	f7fd feb5 	bl	800d180 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 800f416:	68fb      	ldr	r3, [r7, #12]
 800f418:	6a1b      	ldr	r3, [r3, #32]
 800f41a:	68f8      	ldr	r0, [r7, #12]
 800f41c:	4798      	blx	r3

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 800f41e:	68fb      	ldr	r3, [r7, #12]
 800f420:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 800f424:	f003 0304 	and.w	r3, r3, #4
 800f428:	2b00      	cmp	r3, #0
 800f42a:	d02f      	beq.n	800f48c <prvSwitchTimerLists+0x9c>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 800f42c:	68fb      	ldr	r3, [r7, #12]
 800f42e:	699b      	ldr	r3, [r3, #24]
 800f430:	693a      	ldr	r2, [r7, #16]
 800f432:	4413      	add	r3, r2
 800f434:	60bb      	str	r3, [r7, #8]
			if( xReloadTime > xNextExpireTime )
 800f436:	68ba      	ldr	r2, [r7, #8]
 800f438:	693b      	ldr	r3, [r7, #16]
 800f43a:	429a      	cmp	r2, r3
 800f43c:	d90e      	bls.n	800f45c <prvSwitchTimerLists+0x6c>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 800f43e:	68fb      	ldr	r3, [r7, #12]
 800f440:	68ba      	ldr	r2, [r7, #8]
 800f442:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 800f444:	68fb      	ldr	r3, [r7, #12]
 800f446:	68fa      	ldr	r2, [r7, #12]
 800f448:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 800f44a:	4b1a      	ldr	r3, [pc, #104]	@ (800f4b4 <prvSwitchTimerLists+0xc4>)
 800f44c:	681a      	ldr	r2, [r3, #0]
 800f44e:	68fb      	ldr	r3, [r7, #12]
 800f450:	3304      	adds	r3, #4
 800f452:	4619      	mov	r1, r3
 800f454:	4610      	mov	r0, r2
 800f456:	f7fd fe5a 	bl	800d10e <vListInsert>
 800f45a:	e017      	b.n	800f48c <prvSwitchTimerLists+0x9c>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 800f45c:	2300      	movs	r3, #0
 800f45e:	9300      	str	r3, [sp, #0]
 800f460:	2300      	movs	r3, #0
 800f462:	693a      	ldr	r2, [r7, #16]
 800f464:	2100      	movs	r1, #0
 800f466:	68f8      	ldr	r0, [r7, #12]
 800f468:	f7ff fd58 	bl	800ef1c <xTimerGenericCommand>
 800f46c:	6078      	str	r0, [r7, #4]
				configASSERT( xResult );
 800f46e:	687b      	ldr	r3, [r7, #4]
 800f470:	2b00      	cmp	r3, #0
 800f472:	d10b      	bne.n	800f48c <prvSwitchTimerLists+0x9c>
	__asm volatile
 800f474:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800f478:	f383 8811 	msr	BASEPRI, r3
 800f47c:	f3bf 8f6f 	isb	sy
 800f480:	f3bf 8f4f 	dsb	sy
 800f484:	603b      	str	r3, [r7, #0]
}
 800f486:	bf00      	nop
 800f488:	bf00      	nop
 800f48a:	e7fd      	b.n	800f488 <prvSwitchTimerLists+0x98>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 800f48c:	4b09      	ldr	r3, [pc, #36]	@ (800f4b4 <prvSwitchTimerLists+0xc4>)
 800f48e:	681b      	ldr	r3, [r3, #0]
 800f490:	681b      	ldr	r3, [r3, #0]
 800f492:	2b00      	cmp	r3, #0
 800f494:	d1b0      	bne.n	800f3f8 <prvSwitchTimerLists+0x8>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
 800f496:	4b07      	ldr	r3, [pc, #28]	@ (800f4b4 <prvSwitchTimerLists+0xc4>)
 800f498:	681b      	ldr	r3, [r3, #0]
 800f49a:	617b      	str	r3, [r7, #20]
	pxCurrentTimerList = pxOverflowTimerList;
 800f49c:	4b06      	ldr	r3, [pc, #24]	@ (800f4b8 <prvSwitchTimerLists+0xc8>)
 800f49e:	681b      	ldr	r3, [r3, #0]
 800f4a0:	4a04      	ldr	r2, [pc, #16]	@ (800f4b4 <prvSwitchTimerLists+0xc4>)
 800f4a2:	6013      	str	r3, [r2, #0]
	pxOverflowTimerList = pxTemp;
 800f4a4:	4a04      	ldr	r2, [pc, #16]	@ (800f4b8 <prvSwitchTimerLists+0xc8>)
 800f4a6:	697b      	ldr	r3, [r7, #20]
 800f4a8:	6013      	str	r3, [r2, #0]
}
 800f4aa:	bf00      	nop
 800f4ac:	3718      	adds	r7, #24
 800f4ae:	46bd      	mov	sp, r7
 800f4b0:	bd80      	pop	{r7, pc}
 800f4b2:	bf00      	nop
 800f4b4:	24005bd0 	.word	0x24005bd0
 800f4b8:	24005bd4 	.word	0x24005bd4

0800f4bc <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 800f4bc:	b580      	push	{r7, lr}
 800f4be:	b082      	sub	sp, #8
 800f4c0:	af02      	add	r7, sp, #8
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 800f4c2:	f7fd ffb9 	bl	800d438 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 800f4c6:	4b15      	ldr	r3, [pc, #84]	@ (800f51c <prvCheckForValidListAndQueue+0x60>)
 800f4c8:	681b      	ldr	r3, [r3, #0]
 800f4ca:	2b00      	cmp	r3, #0
 800f4cc:	d120      	bne.n	800f510 <prvCheckForValidListAndQueue+0x54>
		{
			vListInitialise( &xActiveTimerList1 );
 800f4ce:	4814      	ldr	r0, [pc, #80]	@ (800f520 <prvCheckForValidListAndQueue+0x64>)
 800f4d0:	f7fd fdcc 	bl	800d06c <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 800f4d4:	4813      	ldr	r0, [pc, #76]	@ (800f524 <prvCheckForValidListAndQueue+0x68>)
 800f4d6:	f7fd fdc9 	bl	800d06c <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 800f4da:	4b13      	ldr	r3, [pc, #76]	@ (800f528 <prvCheckForValidListAndQueue+0x6c>)
 800f4dc:	4a10      	ldr	r2, [pc, #64]	@ (800f520 <prvCheckForValidListAndQueue+0x64>)
 800f4de:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 800f4e0:	4b12      	ldr	r3, [pc, #72]	@ (800f52c <prvCheckForValidListAndQueue+0x70>)
 800f4e2:	4a10      	ldr	r2, [pc, #64]	@ (800f524 <prvCheckForValidListAndQueue+0x68>)
 800f4e4:	601a      	str	r2, [r3, #0]
				/* The timer queue is allocated statically in case
				configSUPPORT_DYNAMIC_ALLOCATION is 0. */
				static StaticQueue_t xStaticTimerQueue; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
				static uint8_t ucStaticTimerQueueStorage[ ( size_t ) configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ]; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 800f4e6:	2300      	movs	r3, #0
 800f4e8:	9300      	str	r3, [sp, #0]
 800f4ea:	4b11      	ldr	r3, [pc, #68]	@ (800f530 <prvCheckForValidListAndQueue+0x74>)
 800f4ec:	4a11      	ldr	r2, [pc, #68]	@ (800f534 <prvCheckForValidListAndQueue+0x78>)
 800f4ee:	2110      	movs	r1, #16
 800f4f0:	200a      	movs	r0, #10
 800f4f2:	f7fe f92d 	bl	800d750 <xQueueGenericCreateStatic>
 800f4f6:	4603      	mov	r3, r0
 800f4f8:	4a08      	ldr	r2, [pc, #32]	@ (800f51c <prvCheckForValidListAndQueue+0x60>)
 800f4fa:	6013      	str	r3, [r2, #0]
			}
			#endif

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
 800f4fc:	4b07      	ldr	r3, [pc, #28]	@ (800f51c <prvCheckForValidListAndQueue+0x60>)
 800f4fe:	681b      	ldr	r3, [r3, #0]
 800f500:	2b00      	cmp	r3, #0
 800f502:	d005      	beq.n	800f510 <prvCheckForValidListAndQueue+0x54>
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 800f504:	4b05      	ldr	r3, [pc, #20]	@ (800f51c <prvCheckForValidListAndQueue+0x60>)
 800f506:	681b      	ldr	r3, [r3, #0]
 800f508:	490b      	ldr	r1, [pc, #44]	@ (800f538 <prvCheckForValidListAndQueue+0x7c>)
 800f50a:	4618      	mov	r0, r3
 800f50c:	f7fe fd52 	bl	800dfb4 <vQueueAddToRegistry>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 800f510:	f7fd ffc4 	bl	800d49c <vPortExitCritical>
}
 800f514:	bf00      	nop
 800f516:	46bd      	mov	sp, r7
 800f518:	bd80      	pop	{r7, pc}
 800f51a:	bf00      	nop
 800f51c:	24005bd8 	.word	0x24005bd8
 800f520:	24005ba8 	.word	0x24005ba8
 800f524:	24005bbc 	.word	0x24005bbc
 800f528:	24005bd0 	.word	0x24005bd0
 800f52c:	24005bd4 	.word	0x24005bd4
 800f530:	24005c84 	.word	0x24005c84
 800f534:	24005be4 	.word	0x24005be4
 800f538:	080183d4 	.word	0x080183d4

0800f53c <ai_log_err>:

static ai_buffer* ai_input;
static ai_buffer* ai_output;

static void ai_log_err(const ai_error err, const char *fct)
{
 800f53c:	b580      	push	{r7, lr}
 800f53e:	b082      	sub	sp, #8
 800f540:	af00      	add	r7, sp, #0
 800f542:	6078      	str	r0, [r7, #4]
 800f544:	6039      	str	r1, [r7, #0]
  /* USER CODE BEGIN log */
  if (fct)
 800f546:	683b      	ldr	r3, [r7, #0]
 800f548:	2b00      	cmp	r3, #0
 800f54a:	d009      	beq.n	800f560 <ai_log_err+0x24>
    printf("TEMPLATE - Error (%s) - type=0x%02x code=0x%02x\r\n", fct,
        err.type, err.code);
 800f54c:	793b      	ldrb	r3, [r7, #4]
    printf("TEMPLATE - Error (%s) - type=0x%02x code=0x%02x\r\n", fct,
 800f54e:	461a      	mov	r2, r3
        err.type, err.code);
 800f550:	687b      	ldr	r3, [r7, #4]
 800f552:	f3c3 2317 	ubfx	r3, r3, #8, #24
    printf("TEMPLATE - Error (%s) - type=0x%02x code=0x%02x\r\n", fct,
 800f556:	6839      	ldr	r1, [r7, #0]
 800f558:	4807      	ldr	r0, [pc, #28]	@ (800f578 <ai_log_err+0x3c>)
 800f55a:	f007 fe49 	bl	80171f0 <iprintf>
 800f55e:	e009      	b.n	800f574 <ai_log_err+0x38>
  else
    printf("TEMPLATE - Error - type=0x%02x code=0x%02x\r\n", err.type, err.code);
 800f560:	793b      	ldrb	r3, [r7, #4]
 800f562:	4619      	mov	r1, r3
 800f564:	687b      	ldr	r3, [r7, #4]
 800f566:	f3c3 2317 	ubfx	r3, r3, #8, #24
 800f56a:	461a      	mov	r2, r3
 800f56c:	4803      	ldr	r0, [pc, #12]	@ (800f57c <ai_log_err+0x40>)
 800f56e:	f007 fe3f 	bl	80171f0 <iprintf>

  do {} while (1);
 800f572:	bf00      	nop
 800f574:	bf00      	nop
 800f576:	e7fd      	b.n	800f574 <ai_log_err+0x38>
 800f578:	080183e0 	.word	0x080183e0
 800f57c:	08018414 	.word	0x08018414

0800f580 <ai_boostrap>:
  /* USER CODE END log */
}

static int ai_boostrap(ai_handle *act_addr)
{
 800f580:	b580      	push	{r7, lr}
 800f582:	b086      	sub	sp, #24
 800f584:	af00      	add	r7, sp, #0
 800f586:	6078      	str	r0, [r7, #4]
  ai_error err;

  /* Create and initialize an instance of the model */
  err = ai_network_create_and_init(&network, act_addr, NULL);
 800f588:	2200      	movs	r2, #0
 800f58a:	6879      	ldr	r1, [r7, #4]
 800f58c:	4828      	ldr	r0, [pc, #160]	@ (800f630 <ai_boostrap+0xb0>)
 800f58e:	f000 fdeb 	bl	8010168 <ai_network_create_and_init>
 800f592:	4603      	mov	r3, r0
 800f594:	60fb      	str	r3, [r7, #12]
  if (err.type != AI_ERROR_NONE) {
 800f596:	7b3b      	ldrb	r3, [r7, #12]
 800f598:	2b00      	cmp	r3, #0
 800f59a:	d006      	beq.n	800f5aa <ai_boostrap+0x2a>
    ai_log_err(err, "ai_network_create_and_init");
 800f59c:	4925      	ldr	r1, [pc, #148]	@ (800f634 <ai_boostrap+0xb4>)
 800f59e:	68f8      	ldr	r0, [r7, #12]
 800f5a0:	f7ff ffcc 	bl	800f53c <ai_log_err>
    return -1;
 800f5a4:	f04f 33ff 	mov.w	r3, #4294967295
 800f5a8:	e03e      	b.n	800f628 <ai_boostrap+0xa8>
  }

  ai_input = ai_network_inputs_get(network, NULL);
 800f5aa:	4b21      	ldr	r3, [pc, #132]	@ (800f630 <ai_boostrap+0xb0>)
 800f5ac:	681b      	ldr	r3, [r3, #0]
 800f5ae:	2100      	movs	r1, #0
 800f5b0:	4618      	mov	r0, r3
 800f5b2:	f000 fe57 	bl	8010264 <ai_network_inputs_get>
 800f5b6:	4603      	mov	r3, r0
 800f5b8:	4a1f      	ldr	r2, [pc, #124]	@ (800f638 <ai_boostrap+0xb8>)
 800f5ba:	6013      	str	r3, [r2, #0]
  ai_output = ai_network_outputs_get(network, NULL);
 800f5bc:	4b1c      	ldr	r3, [pc, #112]	@ (800f630 <ai_boostrap+0xb0>)
 800f5be:	681b      	ldr	r3, [r3, #0]
 800f5c0:	2100      	movs	r1, #0
 800f5c2:	4618      	mov	r0, r3
 800f5c4:	f000 fe68 	bl	8010298 <ai_network_outputs_get>
 800f5c8:	4603      	mov	r3, r0
 800f5ca:	4a1c      	ldr	r2, [pc, #112]	@ (800f63c <ai_boostrap+0xbc>)
 800f5cc:	6013      	str	r3, [r2, #0]

#if defined(AI_NETWORK_INPUTS_IN_ACTIVATIONS)
  /*  In the case where "--allocate-inputs" option is used, memory buffer can be
   *  used from the activations buffer. This is not mandatory.
   */
  for (int idx=0; idx < AI_NETWORK_IN_NUM; idx++) {
 800f5ce:	2300      	movs	r3, #0
 800f5d0:	617b      	str	r3, [r7, #20]
 800f5d2:	e00f      	b.n	800f5f4 <ai_boostrap+0x74>
	data_ins[idx] = ai_input[idx].data;
 800f5d4:	4b18      	ldr	r3, [pc, #96]	@ (800f638 <ai_boostrap+0xb8>)
 800f5d6:	6819      	ldr	r1, [r3, #0]
 800f5d8:	697a      	ldr	r2, [r7, #20]
 800f5da:	4613      	mov	r3, r2
 800f5dc:	00db      	lsls	r3, r3, #3
 800f5de:	1a9b      	subs	r3, r3, r2
 800f5e0:	009b      	lsls	r3, r3, #2
 800f5e2:	440b      	add	r3, r1
 800f5e4:	685a      	ldr	r2, [r3, #4]
 800f5e6:	4916      	ldr	r1, [pc, #88]	@ (800f640 <ai_boostrap+0xc0>)
 800f5e8:	697b      	ldr	r3, [r7, #20]
 800f5ea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  for (int idx=0; idx < AI_NETWORK_IN_NUM; idx++) {
 800f5ee:	697b      	ldr	r3, [r7, #20]
 800f5f0:	3301      	adds	r3, #1
 800f5f2:	617b      	str	r3, [r7, #20]
 800f5f4:	697b      	ldr	r3, [r7, #20]
 800f5f6:	2b00      	cmp	r3, #0
 800f5f8:	ddec      	ble.n	800f5d4 <ai_boostrap+0x54>

#if defined(AI_NETWORK_OUTPUTS_IN_ACTIVATIONS)
  /*  In the case where "--allocate-outputs" option is used, memory buffer can be
   *  used from the activations buffer. This is no mandatory.
   */
  for (int idx=0; idx < AI_NETWORK_OUT_NUM; idx++) {
 800f5fa:	2300      	movs	r3, #0
 800f5fc:	613b      	str	r3, [r7, #16]
 800f5fe:	e00f      	b.n	800f620 <ai_boostrap+0xa0>
	data_outs[idx] = ai_output[idx].data;
 800f600:	4b0e      	ldr	r3, [pc, #56]	@ (800f63c <ai_boostrap+0xbc>)
 800f602:	6819      	ldr	r1, [r3, #0]
 800f604:	693a      	ldr	r2, [r7, #16]
 800f606:	4613      	mov	r3, r2
 800f608:	00db      	lsls	r3, r3, #3
 800f60a:	1a9b      	subs	r3, r3, r2
 800f60c:	009b      	lsls	r3, r3, #2
 800f60e:	440b      	add	r3, r1
 800f610:	685a      	ldr	r2, [r3, #4]
 800f612:	490c      	ldr	r1, [pc, #48]	@ (800f644 <ai_boostrap+0xc4>)
 800f614:	693b      	ldr	r3, [r7, #16]
 800f616:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  for (int idx=0; idx < AI_NETWORK_OUT_NUM; idx++) {
 800f61a:	693b      	ldr	r3, [r7, #16]
 800f61c:	3301      	adds	r3, #1
 800f61e:	613b      	str	r3, [r7, #16]
 800f620:	693b      	ldr	r3, [r7, #16]
 800f622:	2b01      	cmp	r3, #1
 800f624:	ddec      	ble.n	800f600 <ai_boostrap+0x80>
  for (int idx=0; idx < AI_NETWORK_OUT_NUM; idx++) {
	ai_output[idx].data = data_outs[idx];
  }
#endif

  return 0;
 800f626:	2300      	movs	r3, #0
}
 800f628:	4618      	mov	r0, r3
 800f62a:	3718      	adds	r7, #24
 800f62c:	46bd      	mov	sp, r7
 800f62e:	bd80      	pop	{r7, pc}
 800f630:	24005fe0 	.word	0x24005fe0
 800f634:	08018444 	.word	0x08018444
 800f638:	24005fe4 	.word	0x24005fe4
 800f63c:	24005fe8 	.word	0x24005fe8
 800f640:	24005cd4 	.word	0x24005cd4
 800f644:	24005cd8 	.word	0x24005cd8

0800f648 <ai_run>:

static int ai_run(void)
{
 800f648:	b580      	push	{r7, lr}
 800f64a:	b082      	sub	sp, #8
 800f64c:	af00      	add	r7, sp, #0
  ai_i32 batch;

  batch = ai_network_run(network, ai_input, ai_output);
 800f64e:	4b0f      	ldr	r3, [pc, #60]	@ (800f68c <ai_run+0x44>)
 800f650:	681b      	ldr	r3, [r3, #0]
 800f652:	4a0f      	ldr	r2, [pc, #60]	@ (800f690 <ai_run+0x48>)
 800f654:	6811      	ldr	r1, [r2, #0]
 800f656:	4a0f      	ldr	r2, [pc, #60]	@ (800f694 <ai_run+0x4c>)
 800f658:	6812      	ldr	r2, [r2, #0]
 800f65a:	4618      	mov	r0, r3
 800f65c:	f000 fe72 	bl	8010344 <ai_network_run>
 800f660:	6078      	str	r0, [r7, #4]
  if (batch != 1) {
 800f662:	687b      	ldr	r3, [r7, #4]
 800f664:	2b01      	cmp	r3, #1
 800f666:	d00c      	beq.n	800f682 <ai_run+0x3a>
    ai_log_err(ai_network_get_error(network),
 800f668:	4b08      	ldr	r3, [pc, #32]	@ (800f68c <ai_run+0x44>)
 800f66a:	681b      	ldr	r3, [r3, #0]
 800f66c:	4618      	mov	r0, r3
 800f66e:	f000 fd59 	bl	8010124 <ai_network_get_error>
 800f672:	4603      	mov	r3, r0
 800f674:	4908      	ldr	r1, [pc, #32]	@ (800f698 <ai_run+0x50>)
 800f676:	4618      	mov	r0, r3
 800f678:	f7ff ff60 	bl	800f53c <ai_log_err>
        "ai_network_run");
    return -1;
 800f67c:	f04f 33ff 	mov.w	r3, #4294967295
 800f680:	e000      	b.n	800f684 <ai_run+0x3c>
  }

  return 0;
 800f682:	2300      	movs	r3, #0
}
 800f684:	4618      	mov	r0, r3
 800f686:	3708      	adds	r7, #8
 800f688:	46bd      	mov	sp, r7
 800f68a:	bd80      	pop	{r7, pc}
 800f68c:	24005fe0 	.word	0x24005fe0
 800f690:	24005fe4 	.word	0x24005fe4
 800f694:	24005fe8 	.word	0x24005fe8
 800f698:	08018460 	.word	0x08018460

0800f69c <compute_mean>:

/* USER CODE BEGIN 2 */
/* --- Feature Extraction Helper Functions --- */
static double compute_mean(uint32_t *data, int n) {
 800f69c:	b480      	push	{r7}
 800f69e:	b087      	sub	sp, #28
 800f6a0:	af00      	add	r7, sp, #0
 800f6a2:	6078      	str	r0, [r7, #4]
 800f6a4:	6039      	str	r1, [r7, #0]
  double sum = 0.0;
 800f6a6:	f04f 0200 	mov.w	r2, #0
 800f6aa:	f04f 0300 	mov.w	r3, #0
 800f6ae:	e9c7 2304 	strd	r2, r3, [r7, #16]
  for (int i = 0; i < n; i++) {
 800f6b2:	2300      	movs	r3, #0
 800f6b4:	60fb      	str	r3, [r7, #12]
 800f6b6:	e011      	b.n	800f6dc <compute_mean+0x40>
    sum += data[i];
 800f6b8:	68fb      	ldr	r3, [r7, #12]
 800f6ba:	009b      	lsls	r3, r3, #2
 800f6bc:	687a      	ldr	r2, [r7, #4]
 800f6be:	4413      	add	r3, r2
 800f6c0:	681b      	ldr	r3, [r3, #0]
 800f6c2:	ee07 3a90 	vmov	s15, r3
 800f6c6:	eeb8 7b67 	vcvt.f64.u32	d7, s15
 800f6ca:	ed97 6b04 	vldr	d6, [r7, #16]
 800f6ce:	ee36 7b07 	vadd.f64	d7, d6, d7
 800f6d2:	ed87 7b04 	vstr	d7, [r7, #16]
  for (int i = 0; i < n; i++) {
 800f6d6:	68fb      	ldr	r3, [r7, #12]
 800f6d8:	3301      	adds	r3, #1
 800f6da:	60fb      	str	r3, [r7, #12]
 800f6dc:	68fa      	ldr	r2, [r7, #12]
 800f6de:	683b      	ldr	r3, [r7, #0]
 800f6e0:	429a      	cmp	r2, r3
 800f6e2:	dbe9      	blt.n	800f6b8 <compute_mean+0x1c>
  }
  return sum / n;
 800f6e4:	683b      	ldr	r3, [r7, #0]
 800f6e6:	ee07 3a90 	vmov	s15, r3
 800f6ea:	eeb8 7be7 	vcvt.f64.s32	d7, s15
 800f6ee:	ed97 6b04 	vldr	d6, [r7, #16]
 800f6f2:	ee86 5b07 	vdiv.f64	d5, d6, d7
 800f6f6:	eeb0 7b45 	vmov.f64	d7, d5
}
 800f6fa:	eeb0 0b47 	vmov.f64	d0, d7
 800f6fe:	371c      	adds	r7, #28
 800f700:	46bd      	mov	sp, r7
 800f702:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f706:	4770      	bx	lr

0800f708 <compute_variance>:

static double compute_variance(uint32_t *data, int n, double mean) {
 800f708:	b480      	push	{r7}
 800f70a:	b08b      	sub	sp, #44	@ 0x2c
 800f70c:	af00      	add	r7, sp, #0
 800f70e:	60f8      	str	r0, [r7, #12]
 800f710:	60b9      	str	r1, [r7, #8]
 800f712:	ed87 0b00 	vstr	d0, [r7]
  double sum_sq = 0.0;
 800f716:	f04f 0200 	mov.w	r2, #0
 800f71a:	f04f 0300 	mov.w	r3, #0
 800f71e:	e9c7 2308 	strd	r2, r3, [r7, #32]
  for (int i = 0; i < n; i++) {
 800f722:	2300      	movs	r3, #0
 800f724:	61fb      	str	r3, [r7, #28]
 800f726:	e01b      	b.n	800f760 <compute_variance+0x58>
    double diff = data[i] - mean;
 800f728:	69fb      	ldr	r3, [r7, #28]
 800f72a:	009b      	lsls	r3, r3, #2
 800f72c:	68fa      	ldr	r2, [r7, #12]
 800f72e:	4413      	add	r3, r2
 800f730:	681b      	ldr	r3, [r3, #0]
 800f732:	ee07 3a90 	vmov	s15, r3
 800f736:	eeb8 6b67 	vcvt.f64.u32	d6, s15
 800f73a:	ed97 7b00 	vldr	d7, [r7]
 800f73e:	ee36 7b47 	vsub.f64	d7, d6, d7
 800f742:	ed87 7b04 	vstr	d7, [r7, #16]
    sum_sq += diff * diff;
 800f746:	ed97 7b04 	vldr	d7, [r7, #16]
 800f74a:	ee27 7b07 	vmul.f64	d7, d7, d7
 800f74e:	ed97 6b08 	vldr	d6, [r7, #32]
 800f752:	ee36 7b07 	vadd.f64	d7, d6, d7
 800f756:	ed87 7b08 	vstr	d7, [r7, #32]
  for (int i = 0; i < n; i++) {
 800f75a:	69fb      	ldr	r3, [r7, #28]
 800f75c:	3301      	adds	r3, #1
 800f75e:	61fb      	str	r3, [r7, #28]
 800f760:	69fa      	ldr	r2, [r7, #28]
 800f762:	68bb      	ldr	r3, [r7, #8]
 800f764:	429a      	cmp	r2, r3
 800f766:	dbdf      	blt.n	800f728 <compute_variance+0x20>
  }
  return sum_sq / n;
 800f768:	68bb      	ldr	r3, [r7, #8]
 800f76a:	ee07 3a90 	vmov	s15, r3
 800f76e:	eeb8 7be7 	vcvt.f64.s32	d7, s15
 800f772:	ed97 6b08 	vldr	d6, [r7, #32]
 800f776:	ee86 5b07 	vdiv.f64	d5, d6, d7
 800f77a:	eeb0 7b45 	vmov.f64	d7, d5
}
 800f77e:	eeb0 0b47 	vmov.f64	d0, d7
 800f782:	372c      	adds	r7, #44	@ 0x2c
 800f784:	46bd      	mov	sp, r7
 800f786:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f78a:	4770      	bx	lr

0800f78c <compute_rms>:

static double compute_rms(uint32_t *data, int n) {
 800f78c:	b580      	push	{r7, lr}
 800f78e:	b086      	sub	sp, #24
 800f790:	af00      	add	r7, sp, #0
 800f792:	6078      	str	r0, [r7, #4]
 800f794:	6039      	str	r1, [r7, #0]
  double sum_sq = 0.0;
 800f796:	f04f 0200 	mov.w	r2, #0
 800f79a:	f04f 0300 	mov.w	r3, #0
 800f79e:	e9c7 2304 	strd	r2, r3, [r7, #16]
  for (int i = 0; i < n; i++) {
 800f7a2:	2300      	movs	r3, #0
 800f7a4:	60fb      	str	r3, [r7, #12]
 800f7a6:	e018      	b.n	800f7da <compute_rms+0x4e>
    sum_sq += data[i] * data[i];
 800f7a8:	68fb      	ldr	r3, [r7, #12]
 800f7aa:	009b      	lsls	r3, r3, #2
 800f7ac:	687a      	ldr	r2, [r7, #4]
 800f7ae:	4413      	add	r3, r2
 800f7b0:	681b      	ldr	r3, [r3, #0]
 800f7b2:	68fa      	ldr	r2, [r7, #12]
 800f7b4:	0092      	lsls	r2, r2, #2
 800f7b6:	6879      	ldr	r1, [r7, #4]
 800f7b8:	440a      	add	r2, r1
 800f7ba:	6812      	ldr	r2, [r2, #0]
 800f7bc:	fb02 f303 	mul.w	r3, r2, r3
 800f7c0:	ee07 3a90 	vmov	s15, r3
 800f7c4:	eeb8 7b67 	vcvt.f64.u32	d7, s15
 800f7c8:	ed97 6b04 	vldr	d6, [r7, #16]
 800f7cc:	ee36 7b07 	vadd.f64	d7, d6, d7
 800f7d0:	ed87 7b04 	vstr	d7, [r7, #16]
  for (int i = 0; i < n; i++) {
 800f7d4:	68fb      	ldr	r3, [r7, #12]
 800f7d6:	3301      	adds	r3, #1
 800f7d8:	60fb      	str	r3, [r7, #12]
 800f7da:	68fa      	ldr	r2, [r7, #12]
 800f7dc:	683b      	ldr	r3, [r7, #0]
 800f7de:	429a      	cmp	r2, r3
 800f7e0:	dbe2      	blt.n	800f7a8 <compute_rms+0x1c>
  }
  return sqrt(sum_sq / n);
 800f7e2:	683b      	ldr	r3, [r7, #0]
 800f7e4:	ee07 3a90 	vmov	s15, r3
 800f7e8:	eeb8 7be7 	vcvt.f64.s32	d7, s15
 800f7ec:	ed97 6b04 	vldr	d6, [r7, #16]
 800f7f0:	ee86 5b07 	vdiv.f64	d5, d6, d7
 800f7f4:	eeb0 0b45 	vmov.f64	d0, d5
 800f7f8:	f008 fcc2 	bl	8018180 <sqrt>
 800f7fc:	eeb0 7b40 	vmov.f64	d7, d0
}
 800f800:	eeb0 0b47 	vmov.f64	d0, d7
 800f804:	3718      	adds	r7, #24
 800f806:	46bd      	mov	sp, r7
 800f808:	bd80      	pop	{r7, pc}

0800f80a <compute_waveform_length>:

static double compute_waveform_length(uint32_t *data, int n) {
 800f80a:	b480      	push	{r7}
 800f80c:	b087      	sub	sp, #28
 800f80e:	af00      	add	r7, sp, #0
 800f810:	6078      	str	r0, [r7, #4]
 800f812:	6039      	str	r1, [r7, #0]
  double wl = 0.0;
 800f814:	f04f 0200 	mov.w	r2, #0
 800f818:	f04f 0300 	mov.w	r3, #0
 800f81c:	e9c7 2304 	strd	r2, r3, [r7, #16]
  for (int i = 1; i < n; i++) {
 800f820:	2301      	movs	r3, #1
 800f822:	60fb      	str	r3, [r7, #12]
 800f824:	e021      	b.n	800f86a <compute_waveform_length+0x60>
    wl += fabs((double)data[i] - (double)data[i-1]);
 800f826:	68fb      	ldr	r3, [r7, #12]
 800f828:	009b      	lsls	r3, r3, #2
 800f82a:	687a      	ldr	r2, [r7, #4]
 800f82c:	4413      	add	r3, r2
 800f82e:	681b      	ldr	r3, [r3, #0]
 800f830:	ee07 3a90 	vmov	s15, r3
 800f834:	eeb8 6b67 	vcvt.f64.u32	d6, s15
 800f838:	68fa      	ldr	r2, [r7, #12]
 800f83a:	f06f 4340 	mvn.w	r3, #3221225472	@ 0xc0000000
 800f83e:	4413      	add	r3, r2
 800f840:	009b      	lsls	r3, r3, #2
 800f842:	687a      	ldr	r2, [r7, #4]
 800f844:	4413      	add	r3, r2
 800f846:	681b      	ldr	r3, [r3, #0]
 800f848:	ee07 3a90 	vmov	s15, r3
 800f84c:	eeb8 7b67 	vcvt.f64.u32	d7, s15
 800f850:	ee36 7b47 	vsub.f64	d7, d6, d7
 800f854:	eeb0 7bc7 	vabs.f64	d7, d7
 800f858:	ed97 6b04 	vldr	d6, [r7, #16]
 800f85c:	ee36 7b07 	vadd.f64	d7, d6, d7
 800f860:	ed87 7b04 	vstr	d7, [r7, #16]
  for (int i = 1; i < n; i++) {
 800f864:	68fb      	ldr	r3, [r7, #12]
 800f866:	3301      	adds	r3, #1
 800f868:	60fb      	str	r3, [r7, #12]
 800f86a:	68fa      	ldr	r2, [r7, #12]
 800f86c:	683b      	ldr	r3, [r7, #0]
 800f86e:	429a      	cmp	r2, r3
 800f870:	dbd9      	blt.n	800f826 <compute_waveform_length+0x1c>
  }
  return wl;
 800f872:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 800f876:	ec43 2b17 	vmov	d7, r2, r3
}
 800f87a:	eeb0 0b47 	vmov.f64	d0, d7
 800f87e:	371c      	adds	r7, #28
 800f880:	46bd      	mov	sp, r7
 800f882:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f886:	4770      	bx	lr

0800f888 <compute_slope_sign_changes>:

static int compute_slope_sign_changes(uint32_t *data, int n) {
 800f888:	b480      	push	{r7}
 800f88a:	b087      	sub	sp, #28
 800f88c:	af00      	add	r7, sp, #0
 800f88e:	6078      	str	r0, [r7, #4]
 800f890:	6039      	str	r1, [r7, #0]
  int count = 0;
 800f892:	2300      	movs	r3, #0
 800f894:	617b      	str	r3, [r7, #20]
  if (n < 3)
 800f896:	683b      	ldr	r3, [r7, #0]
 800f898:	2b02      	cmp	r3, #2
 800f89a:	dc01      	bgt.n	800f8a0 <compute_slope_sign_changes+0x18>
    return 0;
 800f89c:	2300      	movs	r3, #0
 800f89e:	e02c      	b.n	800f8fa <compute_slope_sign_changes+0x72>
  int d_prev = (int)data[1] - (int)data[0];
 800f8a0:	687b      	ldr	r3, [r7, #4]
 800f8a2:	3304      	adds	r3, #4
 800f8a4:	681b      	ldr	r3, [r3, #0]
 800f8a6:	461a      	mov	r2, r3
 800f8a8:	687b      	ldr	r3, [r7, #4]
 800f8aa:	681b      	ldr	r3, [r3, #0]
 800f8ac:	1ad3      	subs	r3, r2, r3
 800f8ae:	613b      	str	r3, [r7, #16]
  for (int i = 1; i < n - 1; i++) {
 800f8b0:	2301      	movs	r3, #1
 800f8b2:	60fb      	str	r3, [r7, #12]
 800f8b4:	e01b      	b.n	800f8ee <compute_slope_sign_changes+0x66>
    int d = (int)data[i+1] - (int)data[i];
 800f8b6:	68fb      	ldr	r3, [r7, #12]
 800f8b8:	3301      	adds	r3, #1
 800f8ba:	009b      	lsls	r3, r3, #2
 800f8bc:	687a      	ldr	r2, [r7, #4]
 800f8be:	4413      	add	r3, r2
 800f8c0:	681b      	ldr	r3, [r3, #0]
 800f8c2:	4619      	mov	r1, r3
 800f8c4:	68fb      	ldr	r3, [r7, #12]
 800f8c6:	009b      	lsls	r3, r3, #2
 800f8c8:	687a      	ldr	r2, [r7, #4]
 800f8ca:	4413      	add	r3, r2
 800f8cc:	681b      	ldr	r3, [r3, #0]
 800f8ce:	1acb      	subs	r3, r1, r3
 800f8d0:	60bb      	str	r3, [r7, #8]
    if (d_prev * d < 0)
 800f8d2:	693b      	ldr	r3, [r7, #16]
 800f8d4:	68ba      	ldr	r2, [r7, #8]
 800f8d6:	fb02 f303 	mul.w	r3, r2, r3
 800f8da:	2b00      	cmp	r3, #0
 800f8dc:	da02      	bge.n	800f8e4 <compute_slope_sign_changes+0x5c>
      count++;
 800f8de:	697b      	ldr	r3, [r7, #20]
 800f8e0:	3301      	adds	r3, #1
 800f8e2:	617b      	str	r3, [r7, #20]
    d_prev = d;
 800f8e4:	68bb      	ldr	r3, [r7, #8]
 800f8e6:	613b      	str	r3, [r7, #16]
  for (int i = 1; i < n - 1; i++) {
 800f8e8:	68fb      	ldr	r3, [r7, #12]
 800f8ea:	3301      	adds	r3, #1
 800f8ec:	60fb      	str	r3, [r7, #12]
 800f8ee:	683b      	ldr	r3, [r7, #0]
 800f8f0:	3b01      	subs	r3, #1
 800f8f2:	68fa      	ldr	r2, [r7, #12]
 800f8f4:	429a      	cmp	r2, r3
 800f8f6:	dbde      	blt.n	800f8b6 <compute_slope_sign_changes+0x2e>
  }
  return count;
 800f8f8:	697b      	ldr	r3, [r7, #20]
}
 800f8fa:	4618      	mov	r0, r3
 800f8fc:	371c      	adds	r7, #28
 800f8fe:	46bd      	mov	sp, r7
 800f900:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f904:	4770      	bx	lr

0800f906 <compute_mean_absolute_value>:

static double compute_mean_absolute_value(uint32_t *data, int n) {
 800f906:	b480      	push	{r7}
 800f908:	b087      	sub	sp, #28
 800f90a:	af00      	add	r7, sp, #0
 800f90c:	6078      	str	r0, [r7, #4]
 800f90e:	6039      	str	r1, [r7, #0]
  double sum = 0.0;
 800f910:	f04f 0200 	mov.w	r2, #0
 800f914:	f04f 0300 	mov.w	r3, #0
 800f918:	e9c7 2304 	strd	r2, r3, [r7, #16]
  for (int i = 0; i < n; i++) {
 800f91c:	2300      	movs	r3, #0
 800f91e:	60fb      	str	r3, [r7, #12]
 800f920:	e011      	b.n	800f946 <compute_mean_absolute_value+0x40>
    sum += fabs((double)data[i]);
 800f922:	68fb      	ldr	r3, [r7, #12]
 800f924:	009b      	lsls	r3, r3, #2
 800f926:	687a      	ldr	r2, [r7, #4]
 800f928:	4413      	add	r3, r2
 800f92a:	681b      	ldr	r3, [r3, #0]
 800f92c:	ee07 3a90 	vmov	s15, r3
 800f930:	eeb8 7b67 	vcvt.f64.u32	d7, s15
 800f934:	ed97 6b04 	vldr	d6, [r7, #16]
 800f938:	ee36 7b07 	vadd.f64	d7, d6, d7
 800f93c:	ed87 7b04 	vstr	d7, [r7, #16]
  for (int i = 0; i < n; i++) {
 800f940:	68fb      	ldr	r3, [r7, #12]
 800f942:	3301      	adds	r3, #1
 800f944:	60fb      	str	r3, [r7, #12]
 800f946:	68fa      	ldr	r2, [r7, #12]
 800f948:	683b      	ldr	r3, [r7, #0]
 800f94a:	429a      	cmp	r2, r3
 800f94c:	dbe9      	blt.n	800f922 <compute_mean_absolute_value+0x1c>
  }
  return sum / n;
 800f94e:	683b      	ldr	r3, [r7, #0]
 800f950:	ee07 3a90 	vmov	s15, r3
 800f954:	eeb8 7be7 	vcvt.f64.s32	d7, s15
 800f958:	ed97 6b04 	vldr	d6, [r7, #16]
 800f95c:	ee86 5b07 	vdiv.f64	d5, d6, d7
 800f960:	eeb0 7b45 	vmov.f64	d7, d5
}
 800f964:	eeb0 0b47 	vmov.f64	d0, d7
 800f968:	371c      	adds	r7, #28
 800f96a:	46bd      	mov	sp, r7
 800f96c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f970:	4770      	bx	lr
	...

0800f974 <acquire_and_process_data>:

/* --- Acquire ADC Data, Extract Features, and Fill the Input Buffer --- */
int acquire_and_process_data(ai_i8* data[])
{
 800f974:	b580      	push	{r7, lr}
 800f976:	f5ad 6dfe 	sub.w	sp, sp, #2032	@ 0x7f0
 800f97a:	af00      	add	r7, sp, #0
 800f97c:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800f980:	f2a3 73ec 	subw	r3, r3, #2028	@ 0x7ec
 800f984:	6018      	str	r0, [r3, #0]
  // According to:
  //  - adc_buffer[0], adc_buffer[2], adc_buffer[4], ... -> channel 1 (200 samples)
  //  - adc_buffer[1], adc_buffer[3], adc_buffer[5], ... -> channel 2 (200 samples)
  uint32_t adc_channel1[200];
  uint32_t adc_channel2[200];
  int idx1 = 0, idx2 = 0;
 800f986:	2300      	movs	r3, #0
 800f988:	f8c7 37ec 	str.w	r3, [r7, #2028]	@ 0x7ec
 800f98c:	2300      	movs	r3, #0
 800f98e:	f8c7 37e8 	str.w	r3, [r7, #2024]	@ 0x7e8
  for (int i = 0; i < 400; i++) {
 800f992:	2300      	movs	r3, #0
 800f994:	f8c7 37e4 	str.w	r3, [r7, #2020]	@ 0x7e4
 800f998:	e03c      	b.n	800fa14 <acquire_and_process_data+0xa0>
	if ((i % 2) == 0 && idx1 < 200) {
 800f99a:	f8d7 37e4 	ldr.w	r3, [r7, #2020]	@ 0x7e4
 800f99e:	f003 0301 	and.w	r3, r3, #1
 800f9a2:	2b00      	cmp	r3, #0
 800f9a4:	d114      	bne.n	800f9d0 <acquire_and_process_data+0x5c>
 800f9a6:	f8d7 37ec 	ldr.w	r3, [r7, #2028]	@ 0x7ec
 800f9aa:	2bc7      	cmp	r3, #199	@ 0xc7
 800f9ac:	dc10      	bgt.n	800f9d0 <acquire_and_process_data+0x5c>
	  adc_channel1[idx1++] = adc_buffer[i];
 800f9ae:	4acf      	ldr	r2, [pc, #828]	@ (800fcec <acquire_and_process_data+0x378>)
 800f9b0:	f8d7 37e4 	ldr.w	r3, [r7, #2020]	@ 0x7e4
 800f9b4:	f832 1013 	ldrh.w	r1, [r2, r3, lsl #1]
 800f9b8:	f8d7 37ec 	ldr.w	r3, [r7, #2028]	@ 0x7ec
 800f9bc:	1c5a      	adds	r2, r3, #1
 800f9be:	f8c7 27ec 	str.w	r2, [r7, #2028]	@ 0x7ec
 800f9c2:	f507 62fe 	add.w	r2, r7, #2032	@ 0x7f0
 800f9c6:	f5a2 7269 	sub.w	r2, r2, #932	@ 0x3a4
 800f9ca:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
 800f9ce:	e01c      	b.n	800fa0a <acquire_and_process_data+0x96>
	} else if ((i % 2) == 1 && idx2 < 200) {
 800f9d0:	f8d7 37e4 	ldr.w	r3, [r7, #2020]	@ 0x7e4
 800f9d4:	2b00      	cmp	r3, #0
 800f9d6:	f003 0301 	and.w	r3, r3, #1
 800f9da:	bfb8      	it	lt
 800f9dc:	425b      	neglt	r3, r3
 800f9de:	2b01      	cmp	r3, #1
 800f9e0:	d113      	bne.n	800fa0a <acquire_and_process_data+0x96>
 800f9e2:	f8d7 37e8 	ldr.w	r3, [r7, #2024]	@ 0x7e8
 800f9e6:	2bc7      	cmp	r3, #199	@ 0xc7
 800f9e8:	dc0f      	bgt.n	800fa0a <acquire_and_process_data+0x96>
	  adc_channel2[idx2++] = adc_buffer[i];
 800f9ea:	4ac0      	ldr	r2, [pc, #768]	@ (800fcec <acquire_and_process_data+0x378>)
 800f9ec:	f8d7 37e4 	ldr.w	r3, [r7, #2020]	@ 0x7e4
 800f9f0:	f832 1013 	ldrh.w	r1, [r2, r3, lsl #1]
 800f9f4:	f8d7 37e8 	ldr.w	r3, [r7, #2024]	@ 0x7e8
 800f9f8:	1c5a      	adds	r2, r3, #1
 800f9fa:	f8c7 27e8 	str.w	r2, [r7, #2024]	@ 0x7e8
 800f9fe:	f507 62fe 	add.w	r2, r7, #2032	@ 0x7f0
 800fa02:	f2a2 62c4 	subw	r2, r2, #1732	@ 0x6c4
 800fa06:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
  for (int i = 0; i < 400; i++) {
 800fa0a:	f8d7 37e4 	ldr.w	r3, [r7, #2020]	@ 0x7e4
 800fa0e:	3301      	adds	r3, #1
 800fa10:	f8c7 37e4 	str.w	r3, [r7, #2020]	@ 0x7e4
 800fa14:	f8d7 37e4 	ldr.w	r3, [r7, #2020]	@ 0x7e4
 800fa18:	f5b3 7fc8 	cmp.w	r3, #400	@ 0x190
 800fa1c:	dbbd      	blt.n	800f99a <acquire_and_process_data+0x26>

  }
  // is butterworth filter needed?

  // Compute six time-domain features for channel 1.
  double mean_ch1 = compute_mean(adc_channel1, 200);
 800fa1e:	f207 434c 	addw	r3, r7, #1100	@ 0x44c
 800fa22:	21c8      	movs	r1, #200	@ 0xc8
 800fa24:	4618      	mov	r0, r3
 800fa26:	f7ff fe39 	bl	800f69c <compute_mean>
 800fa2a:	f507 63fb 	add.w	r3, r7, #2008	@ 0x7d8
 800fa2e:	ed83 0b00 	vstr	d0, [r3]
  double var_ch1  = compute_variance(adc_channel1, 200, mean_ch1);
 800fa32:	f207 434c 	addw	r3, r7, #1100	@ 0x44c
 800fa36:	f507 62fb 	add.w	r2, r7, #2008	@ 0x7d8
 800fa3a:	ed92 0b00 	vldr	d0, [r2]
 800fa3e:	21c8      	movs	r1, #200	@ 0xc8
 800fa40:	4618      	mov	r0, r3
 800fa42:	f7ff fe61 	bl	800f708 <compute_variance>
 800fa46:	f507 63fa 	add.w	r3, r7, #2000	@ 0x7d0
 800fa4a:	ed83 0b00 	vstr	d0, [r3]
  double rms_ch1  = compute_rms(adc_channel1, 200);
 800fa4e:	f207 434c 	addw	r3, r7, #1100	@ 0x44c
 800fa52:	21c8      	movs	r1, #200	@ 0xc8
 800fa54:	4618      	mov	r0, r3
 800fa56:	f7ff fe99 	bl	800f78c <compute_rms>
 800fa5a:	f507 63f9 	add.w	r3, r7, #1992	@ 0x7c8
 800fa5e:	ed83 0b00 	vstr	d0, [r3]
  double wl_ch1   = compute_waveform_length(adc_channel1, 200);
 800fa62:	f207 434c 	addw	r3, r7, #1100	@ 0x44c
 800fa66:	21c8      	movs	r1, #200	@ 0xc8
 800fa68:	4618      	mov	r0, r3
 800fa6a:	f7ff fece 	bl	800f80a <compute_waveform_length>
 800fa6e:	f507 63f8 	add.w	r3, r7, #1984	@ 0x7c0
 800fa72:	ed83 0b00 	vstr	d0, [r3]
  int    ssc_ch1  = compute_slope_sign_changes(adc_channel1, 200);
 800fa76:	f207 434c 	addw	r3, r7, #1100	@ 0x44c
 800fa7a:	21c8      	movs	r1, #200	@ 0xc8
 800fa7c:	4618      	mov	r0, r3
 800fa7e:	f7ff ff03 	bl	800f888 <compute_slope_sign_changes>
 800fa82:	f8c7 07bc 	str.w	r0, [r7, #1980]	@ 0x7bc
  double mav_ch1  = compute_mean_absolute_value(adc_channel1, 200);
 800fa86:	f207 434c 	addw	r3, r7, #1100	@ 0x44c
 800fa8a:	21c8      	movs	r1, #200	@ 0xc8
 800fa8c:	4618      	mov	r0, r3
 800fa8e:	f7ff ff3a 	bl	800f906 <compute_mean_absolute_value>
 800fa92:	f507 63f6 	add.w	r3, r7, #1968	@ 0x7b0
 800fa96:	ed83 0b00 	vstr	d0, [r3]

  // Compute six time-domain features for channel 2.
  double mean_ch2 = compute_mean(adc_channel2, 200);
 800fa9a:	f507 7396 	add.w	r3, r7, #300	@ 0x12c
 800fa9e:	21c8      	movs	r1, #200	@ 0xc8
 800faa0:	4618      	mov	r0, r3
 800faa2:	f7ff fdfb 	bl	800f69c <compute_mean>
 800faa6:	f507 63f5 	add.w	r3, r7, #1960	@ 0x7a8
 800faaa:	ed83 0b00 	vstr	d0, [r3]
  double var_ch2  = compute_variance(adc_channel2, 200, mean_ch2);
 800faae:	f507 7396 	add.w	r3, r7, #300	@ 0x12c
 800fab2:	f507 62f5 	add.w	r2, r7, #1960	@ 0x7a8
 800fab6:	ed92 0b00 	vldr	d0, [r2]
 800faba:	21c8      	movs	r1, #200	@ 0xc8
 800fabc:	4618      	mov	r0, r3
 800fabe:	f7ff fe23 	bl	800f708 <compute_variance>
 800fac2:	f507 63f4 	add.w	r3, r7, #1952	@ 0x7a0
 800fac6:	ed83 0b00 	vstr	d0, [r3]
  double rms_ch2  = compute_rms(adc_channel2, 200);
 800faca:	f507 7396 	add.w	r3, r7, #300	@ 0x12c
 800face:	21c8      	movs	r1, #200	@ 0xc8
 800fad0:	4618      	mov	r0, r3
 800fad2:	f7ff fe5b 	bl	800f78c <compute_rms>
 800fad6:	f507 63f3 	add.w	r3, r7, #1944	@ 0x798
 800fada:	ed83 0b00 	vstr	d0, [r3]
  double wl_ch2   = compute_waveform_length(adc_channel2, 200);
 800fade:	f507 7396 	add.w	r3, r7, #300	@ 0x12c
 800fae2:	21c8      	movs	r1, #200	@ 0xc8
 800fae4:	4618      	mov	r0, r3
 800fae6:	f7ff fe90 	bl	800f80a <compute_waveform_length>
 800faea:	f507 63f2 	add.w	r3, r7, #1936	@ 0x790
 800faee:	ed83 0b00 	vstr	d0, [r3]
  int    ssc_ch2  = compute_slope_sign_changes(adc_channel2, 200);
 800faf2:	f507 7396 	add.w	r3, r7, #300	@ 0x12c
 800faf6:	21c8      	movs	r1, #200	@ 0xc8
 800faf8:	4618      	mov	r0, r3
 800fafa:	f7ff fec5 	bl	800f888 <compute_slope_sign_changes>
 800fafe:	f8c7 078c 	str.w	r0, [r7, #1932]	@ 0x78c
  double mav_ch2  = compute_mean_absolute_value(adc_channel2, 200);
 800fb02:	f507 7396 	add.w	r3, r7, #300	@ 0x12c
 800fb06:	21c8      	movs	r1, #200	@ 0xc8
 800fb08:	4618      	mov	r0, r3
 800fb0a:	f7ff fefc 	bl	800f906 <compute_mean_absolute_value>
 800fb0e:	f507 63f0 	add.w	r3, r7, #1920	@ 0x780
 800fb12:	ed83 0b00 	vstr	d0, [r3]

  // Create a 12-dimensional feature vector.
  double feature_vector[12];
  feature_vector[0]  = mean_ch1;
 800fb16:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800fb1a:	f5a3 61e5 	sub.w	r1, r3, #1832	@ 0x728
 800fb1e:	f507 63fb 	add.w	r3, r7, #2008	@ 0x7d8
 800fb22:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fb26:	e9c1 2300 	strd	r2, r3, [r1]
  feature_vector[1]  = var_ch1;
 800fb2a:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800fb2e:	f5a3 61e5 	sub.w	r1, r3, #1832	@ 0x728
 800fb32:	f507 63fa 	add.w	r3, r7, #2000	@ 0x7d0
 800fb36:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fb3a:	e9c1 2302 	strd	r2, r3, [r1, #8]
  feature_vector[2]  = rms_ch1;
 800fb3e:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800fb42:	f5a3 61e5 	sub.w	r1, r3, #1832	@ 0x728
 800fb46:	f507 63f9 	add.w	r3, r7, #1992	@ 0x7c8
 800fb4a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fb4e:	e9c1 2304 	strd	r2, r3, [r1, #16]
  feature_vector[3]  = wl_ch1;
 800fb52:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800fb56:	f5a3 61e5 	sub.w	r1, r3, #1832	@ 0x728
 800fb5a:	f507 63f8 	add.w	r3, r7, #1984	@ 0x7c0
 800fb5e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fb62:	e9c1 2306 	strd	r2, r3, [r1, #24]
  feature_vector[4]  = (double)ssc_ch1;
 800fb66:	f8d7 37bc 	ldr.w	r3, [r7, #1980]	@ 0x7bc
 800fb6a:	ee07 3a90 	vmov	s15, r3
 800fb6e:	eeb8 7be7 	vcvt.f64.s32	d7, s15
 800fb72:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800fb76:	f5a3 63e5 	sub.w	r3, r3, #1832	@ 0x728
 800fb7a:	ed83 7b08 	vstr	d7, [r3, #32]
  feature_vector[5]  = mav_ch1;
 800fb7e:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800fb82:	f5a3 61e5 	sub.w	r1, r3, #1832	@ 0x728
 800fb86:	f507 63f6 	add.w	r3, r7, #1968	@ 0x7b0
 800fb8a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fb8e:	e9c1 230a 	strd	r2, r3, [r1, #40]	@ 0x28
  feature_vector[6]  = mean_ch2;
 800fb92:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800fb96:	f5a3 61e5 	sub.w	r1, r3, #1832	@ 0x728
 800fb9a:	f507 63f5 	add.w	r3, r7, #1960	@ 0x7a8
 800fb9e:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fba2:	e9c1 230c 	strd	r2, r3, [r1, #48]	@ 0x30
  feature_vector[7]  = var_ch2;
 800fba6:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800fbaa:	f5a3 61e5 	sub.w	r1, r3, #1832	@ 0x728
 800fbae:	f507 63f4 	add.w	r3, r7, #1952	@ 0x7a0
 800fbb2:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fbb6:	e9c1 230e 	strd	r2, r3, [r1, #56]	@ 0x38
  feature_vector[8]  = rms_ch2;
 800fbba:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800fbbe:	f5a3 61e5 	sub.w	r1, r3, #1832	@ 0x728
 800fbc2:	f507 63f3 	add.w	r3, r7, #1944	@ 0x798
 800fbc6:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fbca:	e9c1 2310 	strd	r2, r3, [r1, #64]	@ 0x40
  feature_vector[9]  = wl_ch2;
 800fbce:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800fbd2:	f5a3 61e5 	sub.w	r1, r3, #1832	@ 0x728
 800fbd6:	f507 63f2 	add.w	r3, r7, #1936	@ 0x790
 800fbda:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fbde:	e9c1 2312 	strd	r2, r3, [r1, #72]	@ 0x48
  feature_vector[10] = (double)ssc_ch2;
 800fbe2:	f8d7 378c 	ldr.w	r3, [r7, #1932]	@ 0x78c
 800fbe6:	ee07 3a90 	vmov	s15, r3
 800fbea:	eeb8 7be7 	vcvt.f64.s32	d7, s15
 800fbee:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800fbf2:	f5a3 63e5 	sub.w	r3, r3, #1832	@ 0x728
 800fbf6:	ed83 7b14 	vstr	d7, [r3, #80]	@ 0x50
  feature_vector[11] = mav_ch2;
 800fbfa:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800fbfe:	f5a3 61e5 	sub.w	r1, r3, #1832	@ 0x728
 800fc02:	f507 63f0 	add.w	r3, r7, #1920	@ 0x780
 800fc06:	e9d3 2300 	ldrd	r2, r3, [r3]
 800fc0a:	e9c1 2316 	strd	r2, r3, [r1, #88]	@ 0x58

  double feature_mean[12] = {14083.489580, 1181289.672021, 14109.204677, 4821.640164, 12.109226, 14083.489580, 12961.410092, 1726933.886649, 12991.066218, 6410.065705, 13.928869, 12961.410092};
 800fc0e:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800fc12:	f5a3 63f1 	sub.w	r3, r3, #1928	@ 0x788
 800fc16:	4a36      	ldr	r2, [pc, #216]	@ (800fcf0 <acquire_and_process_data+0x37c>)
 800fc18:	4618      	mov	r0, r3
 800fc1a:	4611      	mov	r1, r2
 800fc1c:	2360      	movs	r3, #96	@ 0x60
 800fc1e:	461a      	mov	r2, r3
 800fc20:	f007 fcf3 	bl	801760a <memcpy>
  double feature_std[12] = {14487.636073, 6659637.014818, 14503.375841, 4027.220441, 3.414121, 14487.636073, 16950.591105, 19153639.885626, 16978.805106, 4678.975665, 2.954818, 16950.591105};
 800fc24:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800fc28:	f5a3 63fd 	sub.w	r3, r3, #2024	@ 0x7e8
 800fc2c:	4a31      	ldr	r2, [pc, #196]	@ (800fcf4 <acquire_and_process_data+0x380>)
 800fc2e:	4618      	mov	r0, r3
 800fc30:	4611      	mov	r1, r2
 800fc32:	2360      	movs	r3, #96	@ 0x60
 800fc34:	461a      	mov	r2, r3
 800fc36:	f007 fce8 	bl	801760a <memcpy>

  // Scaling factor to convert standardized values into the int8 range.
  // For example, if the standardized features lie roughly in [-1, 1],
  // multiplying by 128 maps them to the int8 range (-128 to 127).
  double scale_factor = 128.0;
 800fc3a:	f04f 0200 	mov.w	r2, #0
 800fc3e:	4b2e      	ldr	r3, [pc, #184]	@ (800fcf8 <acquire_and_process_data+0x384>)
 800fc40:	f507 61ef 	add.w	r1, r7, #1912	@ 0x778
 800fc44:	e9c1 2300 	strd	r2, r3, [r1]

  // Apply standardization and quantization. Then form 12-input vector.
  for (int j = 0; j < 12; j++) {
 800fc48:	2300      	movs	r3, #0
 800fc4a:	f8c7 37e0 	str.w	r3, [r7, #2016]	@ 0x7e0
 800fc4e:	e043      	b.n	800fcd8 <acquire_and_process_data+0x364>
    double standardized = (feature_vector[j] - feature_mean[j]) / feature_std[j];
 800fc50:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800fc54:	f5a3 62e5 	sub.w	r2, r3, #1832	@ 0x728
 800fc58:	f8d7 37e0 	ldr.w	r3, [r7, #2016]	@ 0x7e0
 800fc5c:	00db      	lsls	r3, r3, #3
 800fc5e:	4413      	add	r3, r2
 800fc60:	ed93 6b00 	vldr	d6, [r3]
 800fc64:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800fc68:	f5a3 62f1 	sub.w	r2, r3, #1928	@ 0x788
 800fc6c:	f8d7 37e0 	ldr.w	r3, [r7, #2016]	@ 0x7e0
 800fc70:	00db      	lsls	r3, r3, #3
 800fc72:	4413      	add	r3, r2
 800fc74:	ed93 7b00 	vldr	d7, [r3]
 800fc78:	ee36 5b47 	vsub.f64	d5, d6, d7
 800fc7c:	f507 63fe 	add.w	r3, r7, #2032	@ 0x7f0
 800fc80:	f5a3 62fd 	sub.w	r2, r3, #2024	@ 0x7e8
 800fc84:	f8d7 37e0 	ldr.w	r3, [r7, #2016]	@ 0x7e0
 800fc88:	00db      	lsls	r3, r3, #3
 800fc8a:	4413      	add	r3, r2
 800fc8c:	ed93 6b00 	vldr	d6, [r3]
 800fc90:	ee85 7b06 	vdiv.f64	d7, d5, d6
 800fc94:	f507 63ee 	add.w	r3, r7, #1904	@ 0x770
 800fc98:	ed83 7b00 	vstr	d7, [r3]
    int8_t quantized = (int8_t)(standardized * scale_factor);
 800fc9c:	f507 63ee 	add.w	r3, r7, #1904	@ 0x770
 800fca0:	ed93 6b00 	vldr	d6, [r3]
 800fca4:	f507 63ef 	add.w	r3, r7, #1912	@ 0x778
 800fca8:	ed93 7b00 	vldr	d7, [r3]
 800fcac:	ee26 7b07 	vmul.f64	d7, d6, d7
 800fcb0:	eefd 7bc7 	vcvt.s32.f64	s15, d7
 800fcb4:	edc7 7a00 	vstr	s15, [r7]
 800fcb8:	783b      	ldrb	r3, [r7, #0]
 800fcba:	f887 376f 	strb.w	r3, [r7, #1903]	@ 0x76f
    ((int8_t*)data_ins[0])[j] = quantized;
 800fcbe:	4b0f      	ldr	r3, [pc, #60]	@ (800fcfc <acquire_and_process_data+0x388>)
 800fcc0:	681a      	ldr	r2, [r3, #0]
 800fcc2:	f8d7 37e0 	ldr.w	r3, [r7, #2016]	@ 0x7e0
 800fcc6:	4413      	add	r3, r2
 800fcc8:	f897 276f 	ldrb.w	r2, [r7, #1903]	@ 0x76f
 800fccc:	701a      	strb	r2, [r3, #0]
  for (int j = 0; j < 12; j++) {
 800fcce:	f8d7 37e0 	ldr.w	r3, [r7, #2016]	@ 0x7e0
 800fcd2:	3301      	adds	r3, #1
 800fcd4:	f8c7 37e0 	str.w	r3, [r7, #2016]	@ 0x7e0
 800fcd8:	f8d7 37e0 	ldr.w	r3, [r7, #2016]	@ 0x7e0
 800fcdc:	2b0b      	cmp	r3, #11
 800fcde:	ddb7      	ble.n	800fc50 <acquire_and_process_data+0x2dc>
  }
  return 0;
 800fce0:	2300      	movs	r3, #0
}
 800fce2:	4618      	mov	r0, r3
 800fce4:	f507 67fe 	add.w	r7, r7, #2032	@ 0x7f0
 800fce8:	46bd      	mov	sp, r7
 800fcea:	bd80      	pop	{r7, pc}
 800fcec:	24000ff0 	.word	0x24000ff0
 800fcf0:	08018470 	.word	0x08018470
 800fcf4:	080184d0 	.word	0x080184d0
 800fcf8:	40600000 	.word	0x40600000
 800fcfc:	24005cd4 	.word	0x24005cd4

0800fd00 <post_process>:

int post_process(ai_i8* data[])
{
 800fd00:	b580      	push	{r7, lr}
 800fd02:	b084      	sub	sp, #16
 800fd04:	af00      	add	r7, sp, #0
 800fd06:	6078      	str	r0, [r7, #4]
  */
  // When the network was converted from ONNX using STM32Cube.AI,
  // it created two outputs: "output_label" and "output_probability."
  // In the generated code, these outputs are assigned to data_outs[0] and data_outs[1] respectively.
  // The label is stored in data_outs[0] as an int8_t.
  int8_t predicted_label = *((int8_t*)data_outs[0]);
 800fd08:	4b12      	ldr	r3, [pc, #72]	@ (800fd54 <post_process+0x54>)
 800fd0a:	681b      	ldr	r3, [r3, #0]
 800fd0c:	781b      	ldrb	r3, [r3, #0]
 800fd0e:	73fb      	strb	r3, [r7, #15]

  // Map the predicted label to the corresponding state.
  if (predicted_label == 0) {
 800fd10:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800fd14:	2b00      	cmp	r3, #0
 800fd16:	d106      	bne.n	800fd26 <post_process+0x26>
	printf("Predicted State: open\r\n");
 800fd18:	480f      	ldr	r0, [pc, #60]	@ (800fd58 <post_process+0x58>)
 800fd1a:	f007 fad1 	bl	80172c0 <puts>
	state = OPEN;
 800fd1e:	4b0f      	ldr	r3, [pc, #60]	@ (800fd5c <post_process+0x5c>)
 800fd20:	2200      	movs	r2, #0
 800fd22:	701a      	strb	r2, [r3, #0]
 800fd24:	e010      	b.n	800fd48 <post_process+0x48>
  } else if (predicted_label == 1) {
 800fd26:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800fd2a:	2b01      	cmp	r3, #1
 800fd2c:	d106      	bne.n	800fd3c <post_process+0x3c>
	printf("Predicted State: closed\r\n");
 800fd2e:	480c      	ldr	r0, [pc, #48]	@ (800fd60 <post_process+0x60>)
 800fd30:	f007 fac6 	bl	80172c0 <puts>
	state = CLOSED;
 800fd34:	4b09      	ldr	r3, [pc, #36]	@ (800fd5c <post_process+0x5c>)
 800fd36:	2201      	movs	r2, #1
 800fd38:	701a      	strb	r2, [r3, #0]
 800fd3a:	e005      	b.n	800fd48 <post_process+0x48>
  } else {
	printf("Predicted State: Unknown (label %d)\r\n", predicted_label);
 800fd3c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800fd40:	4619      	mov	r1, r3
 800fd42:	4808      	ldr	r0, [pc, #32]	@ (800fd64 <post_process+0x64>)
 800fd44:	f007 fa54 	bl	80171f0 <iprintf>
  }

  return 0;
 800fd48:	2300      	movs	r3, #0
}
 800fd4a:	4618      	mov	r0, r3
 800fd4c:	3710      	adds	r7, #16
 800fd4e:	46bd      	mov	sp, r7
 800fd50:	bd80      	pop	{r7, pc}
 800fd52:	bf00      	nop
 800fd54:	24005cd8 	.word	0x24005cd8
 800fd58:	08018530 	.word	0x08018530
 800fd5c:	24001324 	.word	0x24001324
 800fd60:	08018548 	.word	0x08018548
 800fd64:	08018564 	.word	0x08018564

0800fd68 <MX_X_CUBE_AI_Init>:
/* USER CODE END 2 */

/* Entry points --------------------------------------------------------------*/

void MX_X_CUBE_AI_Init(void)
{
 800fd68:	b580      	push	{r7, lr}
 800fd6a:	af00      	add	r7, sp, #0
    /* USER CODE BEGIN 5 */
  printf("\r\nTEMPLATE - initialization\r\n");
 800fd6c:	4803      	ldr	r0, [pc, #12]	@ (800fd7c <MX_X_CUBE_AI_Init+0x14>)
 800fd6e:	f007 faa7 	bl	80172c0 <puts>

  ai_boostrap(data_activations0);
 800fd72:	4803      	ldr	r0, [pc, #12]	@ (800fd80 <MX_X_CUBE_AI_Init+0x18>)
 800fd74:	f7ff fc04 	bl	800f580 <ai_boostrap>
    /* USER CODE END 5 */
}
 800fd78:	bf00      	nop
 800fd7a:	bd80      	pop	{r7, pc}
 800fd7c:	0801858c 	.word	0x0801858c
 800fd80:	2400002c 	.word	0x2400002c

0800fd84 <MX_X_CUBE_AI_Process>:

void MX_X_CUBE_AI_Process(void)
{
 800fd84:	b580      	push	{r7, lr}
 800fd86:	b082      	sub	sp, #8
 800fd88:	af00      	add	r7, sp, #0
    /* USER CODE BEGIN 6 */
  int res = -1;
 800fd8a:	f04f 33ff 	mov.w	r3, #4294967295
 800fd8e:	607b      	str	r3, [r7, #4]

  printf("TEMPLATE - run - main loop\r\n");
 800fd90:	4816      	ldr	r0, [pc, #88]	@ (800fdec <MX_X_CUBE_AI_Process+0x68>)
 800fd92:	f007 fa95 	bl	80172c0 <puts>

  if (network) {
 800fd96:	4b16      	ldr	r3, [pc, #88]	@ (800fdf0 <MX_X_CUBE_AI_Process+0x6c>)
 800fd98:	681b      	ldr	r3, [r3, #0]
 800fd9a:	2b00      	cmp	r3, #0
 800fd9c:	d013      	beq.n	800fdc6 <MX_X_CUBE_AI_Process+0x42>

    do {
      /* 1 - acquire and pre-process input data */
      res = acquire_and_process_data(data_ins);
 800fd9e:	4815      	ldr	r0, [pc, #84]	@ (800fdf4 <MX_X_CUBE_AI_Process+0x70>)
 800fda0:	f7ff fde8 	bl	800f974 <acquire_and_process_data>
 800fda4:	6078      	str	r0, [r7, #4]
      /* 2 - process the data - call inference engine */
      if (res == 0)
 800fda6:	687b      	ldr	r3, [r7, #4]
 800fda8:	2b00      	cmp	r3, #0
 800fdaa:	d102      	bne.n	800fdb2 <MX_X_CUBE_AI_Process+0x2e>
        res = ai_run();
 800fdac:	f7ff fc4c 	bl	800f648 <ai_run>
 800fdb0:	6078      	str	r0, [r7, #4]
      /* 3- post-process the predictions */
      if (res == 0)
 800fdb2:	687b      	ldr	r3, [r7, #4]
 800fdb4:	2b00      	cmp	r3, #0
 800fdb6:	d103      	bne.n	800fdc0 <MX_X_CUBE_AI_Process+0x3c>
        res = post_process(data_outs);
 800fdb8:	480f      	ldr	r0, [pc, #60]	@ (800fdf8 <MX_X_CUBE_AI_Process+0x74>)
 800fdba:	f7ff ffa1 	bl	800fd00 <post_process>
 800fdbe:	6078      	str	r0, [r7, #4]
    } while (res==0);
 800fdc0:	687b      	ldr	r3, [r7, #4]
 800fdc2:	2b00      	cmp	r3, #0
 800fdc4:	d0eb      	beq.n	800fd9e <MX_X_CUBE_AI_Process+0x1a>
  }

  if (res) {
 800fdc6:	687b      	ldr	r3, [r7, #4]
 800fdc8:	2b00      	cmp	r3, #0
 800fdca:	d00a      	beq.n	800fde2 <MX_X_CUBE_AI_Process+0x5e>
    ai_error err = {AI_ERROR_INVALID_STATE, AI_ERROR_CODE_NETWORK};
 800fdcc:	2311      	movs	r3, #17
 800fdce:	703b      	strb	r3, [r7, #0]
 800fdd0:	683b      	ldr	r3, [r7, #0]
 800fdd2:	2210      	movs	r2, #16
 800fdd4:	f362 231f 	bfi	r3, r2, #8, #24
 800fdd8:	603b      	str	r3, [r7, #0]
    ai_log_err(err, "Process has FAILED");
 800fdda:	4908      	ldr	r1, [pc, #32]	@ (800fdfc <MX_X_CUBE_AI_Process+0x78>)
 800fddc:	6838      	ldr	r0, [r7, #0]
 800fdde:	f7ff fbad 	bl	800f53c <ai_log_err>
  }
    /* USER CODE END 6 */
}
 800fde2:	bf00      	nop
 800fde4:	3708      	adds	r7, #8
 800fde6:	46bd      	mov	sp, r7
 800fde8:	bd80      	pop	{r7, pc}
 800fdea:	bf00      	nop
 800fdec:	080185ac 	.word	0x080185ac
 800fdf0:	24005fe0 	.word	0x24005fe0
 800fdf4:	24005cd4 	.word	0x24005cd4
 800fdf8:	24005cd8 	.word	0x24005cd8
 800fdfc:	080185c8 	.word	0x080185c8

0800fe00 <network_configure_activations>:

/******************************************************************************/
AI_DECLARE_STATIC
ai_bool network_configure_activations(
  ai_network* net_ctx, const ai_network_params* params)
{
 800fe00:	b580      	push	{r7, lr}
 800fe02:	b082      	sub	sp, #8
 800fe04:	af00      	add	r7, sp, #0
 800fe06:	6078      	str	r0, [r7, #4]
 800fe08:	6039      	str	r1, [r7, #0]
  AI_ASSERT(net_ctx)

  if (ai_platform_get_activations_map(g_network_activations_map, 1, params)) {
 800fe0a:	683a      	ldr	r2, [r7, #0]
 800fe0c:	2101      	movs	r1, #1
 800fe0e:	484d      	ldr	r0, [pc, #308]	@ (800ff44 <network_configure_activations+0x144>)
 800fe10:	f000 fb76 	bl	8010500 <ai_platform_get_activations_map>
 800fe14:	4603      	mov	r3, r0
 800fe16:	2b00      	cmp	r3, #0
 800fe18:	f000 808a 	beq.w	800ff30 <network_configure_activations+0x130>
    /* Updating activations (byte) offsets */
    
    float_input_output_array.data = AI_PTR(g_network_activations_map[0] + 208);
 800fe1c:	4b49      	ldr	r3, [pc, #292]	@ (800ff44 <network_configure_activations+0x144>)
 800fe1e:	681b      	ldr	r3, [r3, #0]
 800fe20:	33d0      	adds	r3, #208	@ 0xd0
 800fe22:	4a49      	ldr	r2, [pc, #292]	@ (800ff48 <network_configure_activations+0x148>)
 800fe24:	6093      	str	r3, [r2, #8]
    float_input_output_array.data_start = AI_PTR(g_network_activations_map[0] + 208);
 800fe26:	4b47      	ldr	r3, [pc, #284]	@ (800ff44 <network_configure_activations+0x144>)
 800fe28:	681b      	ldr	r3, [r3, #0]
 800fe2a:	33d0      	adds	r3, #208	@ 0xd0
 800fe2c:	4a46      	ldr	r2, [pc, #280]	@ (800ff48 <network_configure_activations+0x148>)
 800fe2e:	60d3      	str	r3, [r2, #12]
    mul_result_output_array.data = AI_PTR(g_network_activations_map[0] + 256);
 800fe30:	4b44      	ldr	r3, [pc, #272]	@ (800ff44 <network_configure_activations+0x144>)
 800fe32:	681b      	ldr	r3, [r3, #0]
 800fe34:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fe38:	4a44      	ldr	r2, [pc, #272]	@ (800ff4c <network_configure_activations+0x14c>)
 800fe3a:	6093      	str	r3, [r2, #8]
    mul_result_output_array.data_start = AI_PTR(g_network_activations_map[0] + 256);
 800fe3c:	4b41      	ldr	r3, [pc, #260]	@ (800ff44 <network_configure_activations+0x144>)
 800fe3e:	681b      	ldr	r3, [r3, #0]
 800fe40:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fe44:	4a41      	ldr	r2, [pc, #260]	@ (800ff4c <network_configure_activations+0x14c>)
 800fe46:	60d3      	str	r3, [r2, #12]
    next_activations_output_array.data = AI_PTR(g_network_activations_map[0] + 256);
 800fe48:	4b3e      	ldr	r3, [pc, #248]	@ (800ff44 <network_configure_activations+0x144>)
 800fe4a:	681b      	ldr	r3, [r3, #0]
 800fe4c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fe50:	4a3f      	ldr	r2, [pc, #252]	@ (800ff50 <network_configure_activations+0x150>)
 800fe52:	6093      	str	r3, [r2, #8]
    next_activations_output_array.data_start = AI_PTR(g_network_activations_map[0] + 256);
 800fe54:	4b3b      	ldr	r3, [pc, #236]	@ (800ff44 <network_configure_activations+0x144>)
 800fe56:	681b      	ldr	r3, [r3, #0]
 800fe58:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fe5c:	4a3c      	ldr	r2, [pc, #240]	@ (800ff50 <network_configure_activations+0x150>)
 800fe5e:	60d3      	str	r3, [r2, #12]
    mul_result1_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 800fe60:	4b38      	ldr	r3, [pc, #224]	@ (800ff44 <network_configure_activations+0x144>)
 800fe62:	681b      	ldr	r3, [r3, #0]
 800fe64:	4a3b      	ldr	r2, [pc, #236]	@ (800ff54 <network_configure_activations+0x154>)
 800fe66:	6093      	str	r3, [r2, #8]
    mul_result1_output_array.data_start = AI_PTR(g_network_activations_map[0] + 0);
 800fe68:	4b36      	ldr	r3, [pc, #216]	@ (800ff44 <network_configure_activations+0x144>)
 800fe6a:	681b      	ldr	r3, [r3, #0]
 800fe6c:	4a39      	ldr	r2, [pc, #228]	@ (800ff54 <network_configure_activations+0x154>)
 800fe6e:	60d3      	str	r3, [r2, #12]
    next_activations1_output_array.data = AI_PTR(g_network_activations_map[0] + 256);
 800fe70:	4b34      	ldr	r3, [pc, #208]	@ (800ff44 <network_configure_activations+0x144>)
 800fe72:	681b      	ldr	r3, [r3, #0]
 800fe74:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fe78:	4a37      	ldr	r2, [pc, #220]	@ (800ff58 <network_configure_activations+0x158>)
 800fe7a:	6093      	str	r3, [r2, #8]
    next_activations1_output_array.data_start = AI_PTR(g_network_activations_map[0] + 256);
 800fe7c:	4b31      	ldr	r3, [pc, #196]	@ (800ff44 <network_configure_activations+0x144>)
 800fe7e:	681b      	ldr	r3, [r3, #0]
 800fe80:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 800fe84:	4a34      	ldr	r2, [pc, #208]	@ (800ff58 <network_configure_activations+0x158>)
 800fe86:	60d3      	str	r3, [r2, #12]
    mul_result2_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 800fe88:	4b2e      	ldr	r3, [pc, #184]	@ (800ff44 <network_configure_activations+0x144>)
 800fe8a:	681b      	ldr	r3, [r3, #0]
 800fe8c:	4a33      	ldr	r2, [pc, #204]	@ (800ff5c <network_configure_activations+0x15c>)
 800fe8e:	6093      	str	r3, [r2, #8]
    mul_result2_output_array.data_start = AI_PTR(g_network_activations_map[0] + 0);
 800fe90:	4b2c      	ldr	r3, [pc, #176]	@ (800ff44 <network_configure_activations+0x144>)
 800fe92:	681b      	ldr	r3, [r3, #0]
 800fe94:	4a31      	ldr	r2, [pc, #196]	@ (800ff5c <network_configure_activations+0x15c>)
 800fe96:	60d3      	str	r3, [r2, #12]
    out_activations_result_output_array.data = AI_PTR(g_network_activations_map[0] + 4);
 800fe98:	4b2a      	ldr	r3, [pc, #168]	@ (800ff44 <network_configure_activations+0x144>)
 800fe9a:	681b      	ldr	r3, [r3, #0]
 800fe9c:	3304      	adds	r3, #4
 800fe9e:	4a30      	ldr	r2, [pc, #192]	@ (800ff60 <network_configure_activations+0x160>)
 800fea0:	6093      	str	r3, [r2, #8]
    out_activations_result_output_array.data_start = AI_PTR(g_network_activations_map[0] + 4);
 800fea2:	4b28      	ldr	r3, [pc, #160]	@ (800ff44 <network_configure_activations+0x144>)
 800fea4:	681b      	ldr	r3, [r3, #0]
 800fea6:	3304      	adds	r3, #4
 800fea8:	4a2d      	ldr	r2, [pc, #180]	@ (800ff60 <network_configure_activations+0x160>)
 800feaa:	60d3      	str	r3, [r2, #12]
    classes_0_cast_output_array.data = AI_PTR(g_network_activations_map[0] + 8);
 800feac:	4b25      	ldr	r3, [pc, #148]	@ (800ff44 <network_configure_activations+0x144>)
 800feae:	681b      	ldr	r3, [r3, #0]
 800feb0:	3308      	adds	r3, #8
 800feb2:	4a2c      	ldr	r2, [pc, #176]	@ (800ff64 <network_configure_activations+0x164>)
 800feb4:	6093      	str	r3, [r2, #8]
    classes_0_cast_output_array.data_start = AI_PTR(g_network_activations_map[0] + 8);
 800feb6:	4b23      	ldr	r3, [pc, #140]	@ (800ff44 <network_configure_activations+0x144>)
 800feb8:	681b      	ldr	r3, [r3, #0]
 800feba:	3308      	adds	r3, #8
 800febc:	4a29      	ldr	r2, [pc, #164]	@ (800ff64 <network_configure_activations+0x164>)
 800febe:	60d3      	str	r3, [r2, #12]
    negative_class_proba_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 800fec0:	4b20      	ldr	r3, [pc, #128]	@ (800ff44 <network_configure_activations+0x144>)
 800fec2:	681b      	ldr	r3, [r3, #0]
 800fec4:	4a28      	ldr	r2, [pc, #160]	@ (800ff68 <network_configure_activations+0x168>)
 800fec6:	6093      	str	r3, [r2, #8]
    negative_class_proba_output_array.data_start = AI_PTR(g_network_activations_map[0] + 0);
 800fec8:	4b1e      	ldr	r3, [pc, #120]	@ (800ff44 <network_configure_activations+0x144>)
 800feca:	681b      	ldr	r3, [r3, #0]
 800fecc:	4a26      	ldr	r2, [pc, #152]	@ (800ff68 <network_configure_activations+0x168>)
 800fece:	60d3      	str	r3, [r2, #12]
    probabilities_output_array.data = AI_PTR(g_network_activations_map[0] + 16);
 800fed0:	4b1c      	ldr	r3, [pc, #112]	@ (800ff44 <network_configure_activations+0x144>)
 800fed2:	681b      	ldr	r3, [r3, #0]
 800fed4:	3310      	adds	r3, #16
 800fed6:	4a25      	ldr	r2, [pc, #148]	@ (800ff6c <network_configure_activations+0x16c>)
 800fed8:	6093      	str	r3, [r2, #8]
    probabilities_output_array.data_start = AI_PTR(g_network_activations_map[0] + 16);
 800feda:	4b1a      	ldr	r3, [pc, #104]	@ (800ff44 <network_configure_activations+0x144>)
 800fedc:	681b      	ldr	r3, [r3, #0]
 800fede:	3310      	adds	r3, #16
 800fee0:	4a22      	ldr	r2, [pc, #136]	@ (800ff6c <network_configure_activations+0x16c>)
 800fee2:	60d3      	str	r3, [r2, #12]
    output_probability_output_array.data = AI_PTR(g_network_activations_map[0] + 24);
 800fee4:	4b17      	ldr	r3, [pc, #92]	@ (800ff44 <network_configure_activations+0x144>)
 800fee6:	681b      	ldr	r3, [r3, #0]
 800fee8:	3318      	adds	r3, #24
 800feea:	4a21      	ldr	r2, [pc, #132]	@ (800ff70 <network_configure_activations+0x170>)
 800feec:	6093      	str	r3, [r2, #8]
    output_probability_output_array.data_start = AI_PTR(g_network_activations_map[0] + 24);
 800feee:	4b15      	ldr	r3, [pc, #84]	@ (800ff44 <network_configure_activations+0x144>)
 800fef0:	681b      	ldr	r3, [r3, #0]
 800fef2:	3318      	adds	r3, #24
 800fef4:	4a1e      	ldr	r2, [pc, #120]	@ (800ff70 <network_configure_activations+0x170>)
 800fef6:	60d3      	str	r3, [r2, #12]
    argmax_output_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 800fef8:	4b12      	ldr	r3, [pc, #72]	@ (800ff44 <network_configure_activations+0x144>)
 800fefa:	681b      	ldr	r3, [r3, #0]
 800fefc:	4a1d      	ldr	r2, [pc, #116]	@ (800ff74 <network_configure_activations+0x174>)
 800fefe:	6093      	str	r3, [r2, #8]
    argmax_output_output_array.data_start = AI_PTR(g_network_activations_map[0] + 0);
 800ff00:	4b10      	ldr	r3, [pc, #64]	@ (800ff44 <network_configure_activations+0x144>)
 800ff02:	681b      	ldr	r3, [r3, #0]
 800ff04:	4a1b      	ldr	r2, [pc, #108]	@ (800ff74 <network_configure_activations+0x174>)
 800ff06:	60d3      	str	r3, [r2, #12]
    array_feature_extractor_result_output_array.data = AI_PTR(g_network_activations_map[0] + 4);
 800ff08:	4b0e      	ldr	r3, [pc, #56]	@ (800ff44 <network_configure_activations+0x144>)
 800ff0a:	681b      	ldr	r3, [r3, #0]
 800ff0c:	3304      	adds	r3, #4
 800ff0e:	4a1a      	ldr	r2, [pc, #104]	@ (800ff78 <network_configure_activations+0x178>)
 800ff10:	6093      	str	r3, [r2, #8]
    array_feature_extractor_result_output_array.data_start = AI_PTR(g_network_activations_map[0] + 4);
 800ff12:	4b0c      	ldr	r3, [pc, #48]	@ (800ff44 <network_configure_activations+0x144>)
 800ff14:	681b      	ldr	r3, [r3, #0]
 800ff16:	3304      	adds	r3, #4
 800ff18:	4a17      	ldr	r2, [pc, #92]	@ (800ff78 <network_configure_activations+0x178>)
 800ff1a:	60d3      	str	r3, [r2, #12]
    label_output_array.data = AI_PTR(g_network_activations_map[0] + 0);
 800ff1c:	4b09      	ldr	r3, [pc, #36]	@ (800ff44 <network_configure_activations+0x144>)
 800ff1e:	681b      	ldr	r3, [r3, #0]
 800ff20:	4a16      	ldr	r2, [pc, #88]	@ (800ff7c <network_configure_activations+0x17c>)
 800ff22:	6093      	str	r3, [r2, #8]
    label_output_array.data_start = AI_PTR(g_network_activations_map[0] + 0);
 800ff24:	4b07      	ldr	r3, [pc, #28]	@ (800ff44 <network_configure_activations+0x144>)
 800ff26:	681b      	ldr	r3, [r3, #0]
 800ff28:	4a14      	ldr	r2, [pc, #80]	@ (800ff7c <network_configure_activations+0x17c>)
 800ff2a:	60d3      	str	r3, [r2, #12]
    return true;
 800ff2c:	2301      	movs	r3, #1
 800ff2e:	e005      	b.n	800ff3c <network_configure_activations+0x13c>
  }
  AI_ERROR_TRAP(net_ctx, INIT_FAILED, NETWORK_ACTIVATIONS);
 800ff30:	2213      	movs	r2, #19
 800ff32:	2130      	movs	r1, #48	@ 0x30
 800ff34:	6878      	ldr	r0, [r7, #4]
 800ff36:	f000 fb61 	bl	80105fc <ai_platform_network_set_error>
  return false;
 800ff3a:	2300      	movs	r3, #0
}
 800ff3c:	4618      	mov	r0, r3
 800ff3e:	3708      	adds	r7, #8
 800ff40:	46bd      	mov	sp, r7
 800ff42:	bd80      	pop	{r7, pc}
 800ff44:	24005fec 	.word	0x24005fec
 800ff48:	24000030 	.word	0x24000030
 800ff4c:	24000040 	.word	0x24000040
 800ff50:	24000050 	.word	0x24000050
 800ff54:	24000060 	.word	0x24000060
 800ff58:	24000070 	.word	0x24000070
 800ff5c:	24000080 	.word	0x24000080
 800ff60:	24000090 	.word	0x24000090
 800ff64:	240000a0 	.word	0x240000a0
 800ff68:	240000b0 	.word	0x240000b0
 800ff6c:	240000c0 	.word	0x240000c0
 800ff70:	240000d0 	.word	0x240000d0
 800ff74:	240000e0 	.word	0x240000e0
 800ff78:	240000f0 	.word	0x240000f0
 800ff7c:	24000100 	.word	0x24000100

0800ff80 <network_configure_weights>:

/******************************************************************************/
AI_DECLARE_STATIC
ai_bool network_configure_weights(
  ai_network* net_ctx, const ai_network_params* params)
{
 800ff80:	b580      	push	{r7, lr}
 800ff82:	b082      	sub	sp, #8
 800ff84:	af00      	add	r7, sp, #0
 800ff86:	6078      	str	r0, [r7, #4]
 800ff88:	6039      	str	r1, [r7, #0]
  AI_ASSERT(net_ctx)

  if (ai_platform_get_weights_map(g_network_weights_map, 1, params)) {
 800ff8a:	683a      	ldr	r2, [r7, #0]
 800ff8c:	2101      	movs	r1, #1
 800ff8e:	485b      	ldr	r0, [pc, #364]	@ (80100fc <network_configure_weights+0x17c>)
 800ff90:	f000 fa5e 	bl	8010450 <ai_platform_get_weights_map>
 800ff94:	4603      	mov	r3, r0
 800ff96:	2b00      	cmp	r3, #0
 800ff98:	f000 80a6 	beq.w	80100e8 <network_configure_weights+0x168>
    /* Updating weights (byte) offsets */
    
    mul_result_weights_array.format |= AI_FMT_FLAG_CONST;
 800ff9c:	4b58      	ldr	r3, [pc, #352]	@ (8010100 <network_configure_weights+0x180>)
 800ff9e:	681b      	ldr	r3, [r3, #0]
 800ffa0:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 800ffa4:	4a56      	ldr	r2, [pc, #344]	@ (8010100 <network_configure_weights+0x180>)
 800ffa6:	6013      	str	r3, [r2, #0]
    mul_result_weights_array.data = AI_PTR(g_network_weights_map[0] + 0);
 800ffa8:	4b54      	ldr	r3, [pc, #336]	@ (80100fc <network_configure_weights+0x17c>)
 800ffaa:	681b      	ldr	r3, [r3, #0]
 800ffac:	4a54      	ldr	r2, [pc, #336]	@ (8010100 <network_configure_weights+0x180>)
 800ffae:	6093      	str	r3, [r2, #8]
    mul_result_weights_array.data_start = AI_PTR(g_network_weights_map[0] + 0);
 800ffb0:	4b52      	ldr	r3, [pc, #328]	@ (80100fc <network_configure_weights+0x17c>)
 800ffb2:	681b      	ldr	r3, [r3, #0]
 800ffb4:	4a52      	ldr	r2, [pc, #328]	@ (8010100 <network_configure_weights+0x180>)
 800ffb6:	60d3      	str	r3, [r2, #12]
    mul_result_bias_array.format |= AI_FMT_FLAG_CONST;
 800ffb8:	4b52      	ldr	r3, [pc, #328]	@ (8010104 <network_configure_weights+0x184>)
 800ffba:	681b      	ldr	r3, [r3, #0]
 800ffbc:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 800ffc0:	4a50      	ldr	r2, [pc, #320]	@ (8010104 <network_configure_weights+0x184>)
 800ffc2:	6013      	str	r3, [r2, #0]
    mul_result_bias_array.data = AI_PTR(g_network_weights_map[0] + 6144);
 800ffc4:	4b4d      	ldr	r3, [pc, #308]	@ (80100fc <network_configure_weights+0x17c>)
 800ffc6:	681b      	ldr	r3, [r3, #0]
 800ffc8:	f503 53c0 	add.w	r3, r3, #6144	@ 0x1800
 800ffcc:	4a4d      	ldr	r2, [pc, #308]	@ (8010104 <network_configure_weights+0x184>)
 800ffce:	6093      	str	r3, [r2, #8]
    mul_result_bias_array.data_start = AI_PTR(g_network_weights_map[0] + 6144);
 800ffd0:	4b4a      	ldr	r3, [pc, #296]	@ (80100fc <network_configure_weights+0x17c>)
 800ffd2:	681b      	ldr	r3, [r3, #0]
 800ffd4:	f503 53c0 	add.w	r3, r3, #6144	@ 0x1800
 800ffd8:	4a4a      	ldr	r2, [pc, #296]	@ (8010104 <network_configure_weights+0x184>)
 800ffda:	60d3      	str	r3, [r2, #12]
    mul_result1_weights_array.format |= AI_FMT_FLAG_CONST;
 800ffdc:	4b4a      	ldr	r3, [pc, #296]	@ (8010108 <network_configure_weights+0x188>)
 800ffde:	681b      	ldr	r3, [r3, #0]
 800ffe0:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 800ffe4:	4a48      	ldr	r2, [pc, #288]	@ (8010108 <network_configure_weights+0x188>)
 800ffe6:	6013      	str	r3, [r2, #0]
    mul_result1_weights_array.data = AI_PTR(g_network_weights_map[0] + 6656);
 800ffe8:	4b44      	ldr	r3, [pc, #272]	@ (80100fc <network_configure_weights+0x17c>)
 800ffea:	681b      	ldr	r3, [r3, #0]
 800ffec:	f503 53d0 	add.w	r3, r3, #6656	@ 0x1a00
 800fff0:	4a45      	ldr	r2, [pc, #276]	@ (8010108 <network_configure_weights+0x188>)
 800fff2:	6093      	str	r3, [r2, #8]
    mul_result1_weights_array.data_start = AI_PTR(g_network_weights_map[0] + 6656);
 800fff4:	4b41      	ldr	r3, [pc, #260]	@ (80100fc <network_configure_weights+0x17c>)
 800fff6:	681b      	ldr	r3, [r3, #0]
 800fff8:	f503 53d0 	add.w	r3, r3, #6656	@ 0x1a00
 800fffc:	4a42      	ldr	r2, [pc, #264]	@ (8010108 <network_configure_weights+0x188>)
 800fffe:	60d3      	str	r3, [r2, #12]
    mul_result1_bias_array.format |= AI_FMT_FLAG_CONST;
 8010000:	4b42      	ldr	r3, [pc, #264]	@ (801010c <network_configure_weights+0x18c>)
 8010002:	681b      	ldr	r3, [r3, #0]
 8010004:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8010008:	4a40      	ldr	r2, [pc, #256]	@ (801010c <network_configure_weights+0x18c>)
 801000a:	6013      	str	r3, [r2, #0]
    mul_result1_bias_array.data = AI_PTR(g_network_weights_map[0] + 39424);
 801000c:	4b3b      	ldr	r3, [pc, #236]	@ (80100fc <network_configure_weights+0x17c>)
 801000e:	681b      	ldr	r3, [r3, #0]
 8010010:	f503 431a 	add.w	r3, r3, #39424	@ 0x9a00
 8010014:	4a3d      	ldr	r2, [pc, #244]	@ (801010c <network_configure_weights+0x18c>)
 8010016:	6093      	str	r3, [r2, #8]
    mul_result1_bias_array.data_start = AI_PTR(g_network_weights_map[0] + 39424);
 8010018:	4b38      	ldr	r3, [pc, #224]	@ (80100fc <network_configure_weights+0x17c>)
 801001a:	681b      	ldr	r3, [r3, #0]
 801001c:	f503 431a 	add.w	r3, r3, #39424	@ 0x9a00
 8010020:	4a3a      	ldr	r2, [pc, #232]	@ (801010c <network_configure_weights+0x18c>)
 8010022:	60d3      	str	r3, [r2, #12]
    mul_result2_weights_array.format |= AI_FMT_FLAG_CONST;
 8010024:	4b3a      	ldr	r3, [pc, #232]	@ (8010110 <network_configure_weights+0x190>)
 8010026:	681b      	ldr	r3, [r3, #0]
 8010028:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 801002c:	4a38      	ldr	r2, [pc, #224]	@ (8010110 <network_configure_weights+0x190>)
 801002e:	6013      	str	r3, [r2, #0]
    mul_result2_weights_array.data = AI_PTR(g_network_weights_map[0] + 39680);
 8010030:	4b32      	ldr	r3, [pc, #200]	@ (80100fc <network_configure_weights+0x17c>)
 8010032:	681b      	ldr	r3, [r3, #0]
 8010034:	f503 431b 	add.w	r3, r3, #39680	@ 0x9b00
 8010038:	4a35      	ldr	r2, [pc, #212]	@ (8010110 <network_configure_weights+0x190>)
 801003a:	6093      	str	r3, [r2, #8]
    mul_result2_weights_array.data_start = AI_PTR(g_network_weights_map[0] + 39680);
 801003c:	4b2f      	ldr	r3, [pc, #188]	@ (80100fc <network_configure_weights+0x17c>)
 801003e:	681b      	ldr	r3, [r3, #0]
 8010040:	f503 431b 	add.w	r3, r3, #39680	@ 0x9b00
 8010044:	4a32      	ldr	r2, [pc, #200]	@ (8010110 <network_configure_weights+0x190>)
 8010046:	60d3      	str	r3, [r2, #12]
    mul_result2_bias_array.format |= AI_FMT_FLAG_CONST;
 8010048:	4b32      	ldr	r3, [pc, #200]	@ (8010114 <network_configure_weights+0x194>)
 801004a:	681b      	ldr	r3, [r3, #0]
 801004c:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8010050:	4a30      	ldr	r2, [pc, #192]	@ (8010114 <network_configure_weights+0x194>)
 8010052:	6013      	str	r3, [r2, #0]
    mul_result2_bias_array.data = AI_PTR(g_network_weights_map[0] + 39936);
 8010054:	4b29      	ldr	r3, [pc, #164]	@ (80100fc <network_configure_weights+0x17c>)
 8010056:	681b      	ldr	r3, [r3, #0]
 8010058:	f503 431c 	add.w	r3, r3, #39936	@ 0x9c00
 801005c:	4a2d      	ldr	r2, [pc, #180]	@ (8010114 <network_configure_weights+0x194>)
 801005e:	6093      	str	r3, [r2, #8]
    mul_result2_bias_array.data_start = AI_PTR(g_network_weights_map[0] + 39936);
 8010060:	4b26      	ldr	r3, [pc, #152]	@ (80100fc <network_configure_weights+0x17c>)
 8010062:	681b      	ldr	r3, [r3, #0]
 8010064:	f503 431c 	add.w	r3, r3, #39936	@ 0x9c00
 8010068:	4a2a      	ldr	r2, [pc, #168]	@ (8010114 <network_configure_weights+0x194>)
 801006a:	60d3      	str	r3, [r2, #12]
    classes_array.format |= AI_FMT_FLAG_CONST;
 801006c:	4b2a      	ldr	r3, [pc, #168]	@ (8010118 <network_configure_weights+0x198>)
 801006e:	681b      	ldr	r3, [r3, #0]
 8010070:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 8010074:	4a28      	ldr	r2, [pc, #160]	@ (8010118 <network_configure_weights+0x198>)
 8010076:	6013      	str	r3, [r2, #0]
    classes_array.data = AI_PTR(g_network_weights_map[0] + 39940);
 8010078:	4b20      	ldr	r3, [pc, #128]	@ (80100fc <network_configure_weights+0x17c>)
 801007a:	681a      	ldr	r2, [r3, #0]
 801007c:	f649 4304 	movw	r3, #39940	@ 0x9c04
 8010080:	4413      	add	r3, r2
 8010082:	4a25      	ldr	r2, [pc, #148]	@ (8010118 <network_configure_weights+0x198>)
 8010084:	6093      	str	r3, [r2, #8]
    classes_array.data_start = AI_PTR(g_network_weights_map[0] + 39940);
 8010086:	4b1d      	ldr	r3, [pc, #116]	@ (80100fc <network_configure_weights+0x17c>)
 8010088:	681a      	ldr	r2, [r3, #0]
 801008a:	f649 4304 	movw	r3, #39940	@ 0x9c04
 801008e:	4413      	add	r3, r2
 8010090:	4a21      	ldr	r2, [pc, #132]	@ (8010118 <network_configure_weights+0x198>)
 8010092:	60d3      	str	r3, [r2, #12]
    unity_array.format |= AI_FMT_FLAG_CONST;
 8010094:	4b21      	ldr	r3, [pc, #132]	@ (801011c <network_configure_weights+0x19c>)
 8010096:	681b      	ldr	r3, [r3, #0]
 8010098:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 801009c:	4a1f      	ldr	r2, [pc, #124]	@ (801011c <network_configure_weights+0x19c>)
 801009e:	6013      	str	r3, [r2, #0]
    unity_array.data = AI_PTR(g_network_weights_map[0] + 39948);
 80100a0:	4b16      	ldr	r3, [pc, #88]	@ (80100fc <network_configure_weights+0x17c>)
 80100a2:	681a      	ldr	r2, [r3, #0]
 80100a4:	f649 430c 	movw	r3, #39948	@ 0x9c0c
 80100a8:	4413      	add	r3, r2
 80100aa:	4a1c      	ldr	r2, [pc, #112]	@ (801011c <network_configure_weights+0x19c>)
 80100ac:	6093      	str	r3, [r2, #8]
    unity_array.data_start = AI_PTR(g_network_weights_map[0] + 39948);
 80100ae:	4b13      	ldr	r3, [pc, #76]	@ (80100fc <network_configure_weights+0x17c>)
 80100b0:	681a      	ldr	r2, [r3, #0]
 80100b2:	f649 430c 	movw	r3, #39948	@ 0x9c0c
 80100b6:	4413      	add	r3, r2
 80100b8:	4a18      	ldr	r2, [pc, #96]	@ (801011c <network_configure_weights+0x19c>)
 80100ba:	60d3      	str	r3, [r2, #12]
    output_probability_classlabels_ints_array.format |= AI_FMT_FLAG_CONST;
 80100bc:	4b18      	ldr	r3, [pc, #96]	@ (8010120 <network_configure_weights+0x1a0>)
 80100be:	681b      	ldr	r3, [r3, #0]
 80100c0:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
 80100c4:	4a16      	ldr	r2, [pc, #88]	@ (8010120 <network_configure_weights+0x1a0>)
 80100c6:	6013      	str	r3, [r2, #0]
    output_probability_classlabels_ints_array.data = AI_PTR(g_network_weights_map[0] + 39952);
 80100c8:	4b0c      	ldr	r3, [pc, #48]	@ (80100fc <network_configure_weights+0x17c>)
 80100ca:	681a      	ldr	r2, [r3, #0]
 80100cc:	f649 4310 	movw	r3, #39952	@ 0x9c10
 80100d0:	4413      	add	r3, r2
 80100d2:	4a13      	ldr	r2, [pc, #76]	@ (8010120 <network_configure_weights+0x1a0>)
 80100d4:	6093      	str	r3, [r2, #8]
    output_probability_classlabels_ints_array.data_start = AI_PTR(g_network_weights_map[0] + 39952);
 80100d6:	4b09      	ldr	r3, [pc, #36]	@ (80100fc <network_configure_weights+0x17c>)
 80100d8:	681a      	ldr	r2, [r3, #0]
 80100da:	f649 4310 	movw	r3, #39952	@ 0x9c10
 80100de:	4413      	add	r3, r2
 80100e0:	4a0f      	ldr	r2, [pc, #60]	@ (8010120 <network_configure_weights+0x1a0>)
 80100e2:	60d3      	str	r3, [r2, #12]
    return true;
 80100e4:	2301      	movs	r3, #1
 80100e6:	e005      	b.n	80100f4 <network_configure_weights+0x174>
  }
  AI_ERROR_TRAP(net_ctx, INIT_FAILED, NETWORK_WEIGHTS);
 80100e8:	2212      	movs	r2, #18
 80100ea:	2130      	movs	r1, #48	@ 0x30
 80100ec:	6878      	ldr	r0, [r7, #4]
 80100ee:	f000 fa85 	bl	80105fc <ai_platform_network_set_error>
  return false;
 80100f2:	2300      	movs	r3, #0
}
 80100f4:	4618      	mov	r0, r3
 80100f6:	3708      	adds	r7, #8
 80100f8:	46bd      	mov	sp, r7
 80100fa:	bd80      	pop	{r7, pc}
 80100fc:	24005ff0 	.word	0x24005ff0
 8010100:	24000110 	.word	0x24000110
 8010104:	24000120 	.word	0x24000120
 8010108:	24000130 	.word	0x24000130
 801010c:	24000140 	.word	0x24000140
 8010110:	24000150 	.word	0x24000150
 8010114:	24000160 	.word	0x24000160
 8010118:	24000170 	.word	0x24000170
 801011c:	24000180 	.word	0x24000180
 8010120:	24000190 	.word	0x24000190

08010124 <ai_network_get_error>:
}


AI_API_ENTRY
ai_error ai_network_get_error(ai_handle network)
{
 8010124:	b580      	push	{r7, lr}
 8010126:	b082      	sub	sp, #8
 8010128:	af00      	add	r7, sp, #0
 801012a:	6078      	str	r0, [r7, #4]
  return ai_platform_network_get_error(network);
 801012c:	6878      	ldr	r0, [r7, #4]
 801012e:	f000 fa59 	bl	80105e4 <ai_platform_network_get_error>
 8010132:	4603      	mov	r3, r0
}
 8010134:	4618      	mov	r0, r3
 8010136:	3708      	adds	r7, #8
 8010138:	46bd      	mov	sp, r7
 801013a:	bd80      	pop	{r7, pc}

0801013c <ai_network_create>:


AI_API_ENTRY
ai_error ai_network_create(
  ai_handle* network, const ai_buffer* network_config)
{
 801013c:	b580      	push	{r7, lr}
 801013e:	b084      	sub	sp, #16
 8010140:	af02      	add	r7, sp, #8
 8010142:	6078      	str	r0, [r7, #4]
 8010144:	6039      	str	r1, [r7, #0]
  return ai_platform_network_create(
 8010146:	2300      	movs	r3, #0
 8010148:	9301      	str	r3, [sp, #4]
 801014a:	2305      	movs	r3, #5
 801014c:	9300      	str	r3, [sp, #0]
 801014e:	2301      	movs	r3, #1
 8010150:	4a04      	ldr	r2, [pc, #16]	@ (8010164 <ai_network_create+0x28>)
 8010152:	6839      	ldr	r1, [r7, #0]
 8010154:	6878      	ldr	r0, [r7, #4]
 8010156:	f000 fb45 	bl	80107e4 <ai_platform_network_create>
 801015a:	4603      	mov	r3, r0
    network, network_config, 
    AI_CONTEXT_OBJ(&AI_NET_OBJ_INSTANCE),
    AI_TOOLS_API_VERSION_MAJOR, AI_TOOLS_API_VERSION_MINOR, AI_TOOLS_API_VERSION_MICRO);
}
 801015c:	4618      	mov	r0, r3
 801015e:	3708      	adds	r7, #8
 8010160:	46bd      	mov	sp, r7
 8010162:	bd80      	pop	{r7, pc}
 8010164:	24000c30 	.word	0x24000c30

08010168 <ai_network_create_and_init>:


AI_API_ENTRY
ai_error ai_network_create_and_init(
  ai_handle* network, const ai_handle activations[], const ai_handle weights[])
{
 8010168:	b580      	push	{r7, lr}
 801016a:	b094      	sub	sp, #80	@ 0x50
 801016c:	af00      	add	r7, sp, #0
 801016e:	60f8      	str	r0, [r7, #12]
 8010170:	60b9      	str	r1, [r7, #8]
 8010172:	607a      	str	r2, [r7, #4]
  ai_error err;
  ai_network_params params;

  err = ai_network_create(network, AI_NETWORK_DATA_CONFIG);
 8010174:	2100      	movs	r1, #0
 8010176:	68f8      	ldr	r0, [r7, #12]
 8010178:	f7ff ffe0 	bl	801013c <ai_network_create>
 801017c:	4603      	mov	r3, r0
 801017e:	64bb      	str	r3, [r7, #72]	@ 0x48
  if (err.type != AI_ERROR_NONE) {
 8010180:	f897 3048 	ldrb.w	r3, [r7, #72]	@ 0x48
 8010184:	2b00      	cmp	r3, #0
 8010186:	d001      	beq.n	801018c <ai_network_create_and_init+0x24>
    return err;
 8010188:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 801018a:	e067      	b.n	801025c <ai_network_create_and_init+0xf4>
  }
  
  if (ai_network_data_params_get(&params) != true) {
 801018c:	f107 0310 	add.w	r3, r7, #16
 8010190:	4618      	mov	r0, r3
 8010192:	f000 f8e7 	bl	8010364 <ai_network_data_params_get>
 8010196:	4603      	mov	r3, r0
 8010198:	f083 0301 	eor.w	r3, r3, #1
 801019c:	b2db      	uxtb	r3, r3
 801019e:	2b00      	cmp	r3, #0
 80101a0:	d008      	beq.n	80101b4 <ai_network_create_and_init+0x4c>
    err = ai_network_get_error(*network);
 80101a2:	68fb      	ldr	r3, [r7, #12]
 80101a4:	681b      	ldr	r3, [r3, #0]
 80101a6:	4618      	mov	r0, r3
 80101a8:	f7ff ffbc 	bl	8010124 <ai_network_get_error>
 80101ac:	4603      	mov	r3, r0
 80101ae:	64bb      	str	r3, [r7, #72]	@ 0x48
    return err;
 80101b0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 80101b2:	e053      	b.n	801025c <ai_network_create_and_init+0xf4>
  }
#if defined(AI_NETWORK_DATA_ACTIVATIONS_COUNT)
  /* set the addresses of the activations buffers */
  for (ai_u16 idx=0; activations && idx<params.map_activations.size; idx++) {
 80101b4:	2300      	movs	r3, #0
 80101b6:	f8a7 304e 	strh.w	r3, [r7, #78]	@ 0x4e
 80101ba:	e012      	b.n	80101e2 <ai_network_create_and_init+0x7a>
    AI_BUFFER_ARRAY_ITEM_SET_ADDRESS(&params.map_activations, idx, activations[idx]);
 80101bc:	f8b7 104e 	ldrh.w	r1, [r7, #78]	@ 0x4e
 80101c0:	f8b7 304e 	ldrh.w	r3, [r7, #78]	@ 0x4e
 80101c4:	009b      	lsls	r3, r3, #2
 80101c6:	68ba      	ldr	r2, [r7, #8]
 80101c8:	4413      	add	r3, r2
 80101ca:	681a      	ldr	r2, [r3, #0]
 80101cc:	f107 0310 	add.w	r3, r7, #16
 80101d0:	330c      	adds	r3, #12
 80101d2:	4618      	mov	r0, r3
 80101d4:	f000 f92c 	bl	8010430 <ai_buffer_array_item_set_address>
  for (ai_u16 idx=0; activations && idx<params.map_activations.size; idx++) {
 80101d8:	f8b7 304e 	ldrh.w	r3, [r7, #78]	@ 0x4e
 80101dc:	3301      	adds	r3, #1
 80101de:	f8a7 304e 	strh.w	r3, [r7, #78]	@ 0x4e
 80101e2:	68bb      	ldr	r3, [r7, #8]
 80101e4:	2b00      	cmp	r3, #0
 80101e6:	d004      	beq.n	80101f2 <ai_network_create_and_init+0x8a>
 80101e8:	8bfb      	ldrh	r3, [r7, #30]
 80101ea:	f8b7 204e 	ldrh.w	r2, [r7, #78]	@ 0x4e
 80101ee:	429a      	cmp	r2, r3
 80101f0:	d3e4      	bcc.n	80101bc <ai_network_create_and_init+0x54>
  }
#endif
#if defined(AI_NETWORK_DATA_WEIGHTS_COUNT)
  /* set the addresses of the weight buffers */
  for (ai_u16 idx=0; weights && idx<params.map_weights.size; idx++) {
 80101f2:	2300      	movs	r3, #0
 80101f4:	f8a7 304c 	strh.w	r3, [r7, #76]	@ 0x4c
 80101f8:	e012      	b.n	8010220 <ai_network_create_and_init+0xb8>
    AI_BUFFER_ARRAY_ITEM_SET_ADDRESS(&params.map_weights, idx, weights[idx]);
 80101fa:	f8b7 104c 	ldrh.w	r1, [r7, #76]	@ 0x4c
 80101fe:	f8b7 304c 	ldrh.w	r3, [r7, #76]	@ 0x4c
 8010202:	009b      	lsls	r3, r3, #2
 8010204:	687a      	ldr	r2, [r7, #4]
 8010206:	4413      	add	r3, r2
 8010208:	681a      	ldr	r2, [r3, #0]
 801020a:	f107 0310 	add.w	r3, r7, #16
 801020e:	3304      	adds	r3, #4
 8010210:	4618      	mov	r0, r3
 8010212:	f000 f90d 	bl	8010430 <ai_buffer_array_item_set_address>
  for (ai_u16 idx=0; weights && idx<params.map_weights.size; idx++) {
 8010216:	f8b7 304c 	ldrh.w	r3, [r7, #76]	@ 0x4c
 801021a:	3301      	adds	r3, #1
 801021c:	f8a7 304c 	strh.w	r3, [r7, #76]	@ 0x4c
 8010220:	687b      	ldr	r3, [r7, #4]
 8010222:	2b00      	cmp	r3, #0
 8010224:	d004      	beq.n	8010230 <ai_network_create_and_init+0xc8>
 8010226:	8afb      	ldrh	r3, [r7, #22]
 8010228:	f8b7 204c 	ldrh.w	r2, [r7, #76]	@ 0x4c
 801022c:	429a      	cmp	r2, r3
 801022e:	d3e4      	bcc.n	80101fa <ai_network_create_and_init+0x92>
  }
#endif
  if (ai_network_init(*network, &params) != true) {
 8010230:	68fb      	ldr	r3, [r7, #12]
 8010232:	681b      	ldr	r3, [r3, #0]
 8010234:	f107 0210 	add.w	r2, r7, #16
 8010238:	4611      	mov	r1, r2
 801023a:	4618      	mov	r0, r3
 801023c:	f000 f846 	bl	80102cc <ai_network_init>
 8010240:	4603      	mov	r3, r0
 8010242:	f083 0301 	eor.w	r3, r3, #1
 8010246:	b2db      	uxtb	r3, r3
 8010248:	2b00      	cmp	r3, #0
 801024a:	d006      	beq.n	801025a <ai_network_create_and_init+0xf2>
    err = ai_network_get_error(*network);
 801024c:	68fb      	ldr	r3, [r7, #12]
 801024e:	681b      	ldr	r3, [r3, #0]
 8010250:	4618      	mov	r0, r3
 8010252:	f7ff ff67 	bl	8010124 <ai_network_get_error>
 8010256:	4603      	mov	r3, r0
 8010258:	64bb      	str	r3, [r7, #72]	@ 0x48
  }
  return err;
 801025a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
}
 801025c:	4618      	mov	r0, r3
 801025e:	3750      	adds	r7, #80	@ 0x50
 8010260:	46bd      	mov	sp, r7
 8010262:	bd80      	pop	{r7, pc}

08010264 <ai_network_inputs_get>:


AI_API_ENTRY
ai_buffer* ai_network_inputs_get(ai_handle network, ai_u16 *n_buffer)
{
 8010264:	b580      	push	{r7, lr}
 8010266:	b082      	sub	sp, #8
 8010268:	af00      	add	r7, sp, #0
 801026a:	6078      	str	r0, [r7, #4]
 801026c:	6039      	str	r1, [r7, #0]
  if (network == AI_HANDLE_NULL) {
 801026e:	687b      	ldr	r3, [r7, #4]
 8010270:	2b00      	cmp	r3, #0
 8010272:	d104      	bne.n	801027e <ai_network_inputs_get+0x1a>
    network = (ai_handle)&AI_NET_OBJ_INSTANCE;
 8010274:	4b06      	ldr	r3, [pc, #24]	@ (8010290 <ai_network_inputs_get+0x2c>)
 8010276:	607b      	str	r3, [r7, #4]
    AI_NETWORK_OBJ(network)->magic = AI_MAGIC_CONTEXT_TOKEN;
 8010278:	687b      	ldr	r3, [r7, #4]
 801027a:	4a06      	ldr	r2, [pc, #24]	@ (8010294 <ai_network_inputs_get+0x30>)
 801027c:	601a      	str	r2, [r3, #0]
  }
  return ai_platform_inputs_get(network, n_buffer);
 801027e:	6839      	ldr	r1, [r7, #0]
 8010280:	6878      	ldr	r0, [r7, #4]
 8010282:	f000 f9c1 	bl	8010608 <ai_platform_inputs_get>
 8010286:	4603      	mov	r3, r0
}
 8010288:	4618      	mov	r0, r3
 801028a:	3708      	adds	r7, #8
 801028c:	46bd      	mov	sp, r7
 801028e:	bd80      	pop	{r7, pc}
 8010290:	24000c30 	.word	0x24000c30
 8010294:	a1c00100 	.word	0xa1c00100

08010298 <ai_network_outputs_get>:


AI_API_ENTRY
ai_buffer* ai_network_outputs_get(ai_handle network, ai_u16 *n_buffer)
{
 8010298:	b580      	push	{r7, lr}
 801029a:	b082      	sub	sp, #8
 801029c:	af00      	add	r7, sp, #0
 801029e:	6078      	str	r0, [r7, #4]
 80102a0:	6039      	str	r1, [r7, #0]
  if (network == AI_HANDLE_NULL) {
 80102a2:	687b      	ldr	r3, [r7, #4]
 80102a4:	2b00      	cmp	r3, #0
 80102a6:	d104      	bne.n	80102b2 <ai_network_outputs_get+0x1a>
    network = (ai_handle)&AI_NET_OBJ_INSTANCE;
 80102a8:	4b06      	ldr	r3, [pc, #24]	@ (80102c4 <ai_network_outputs_get+0x2c>)
 80102aa:	607b      	str	r3, [r7, #4]
    AI_NETWORK_OBJ(network)->magic = AI_MAGIC_CONTEXT_TOKEN;
 80102ac:	687b      	ldr	r3, [r7, #4]
 80102ae:	4a06      	ldr	r2, [pc, #24]	@ (80102c8 <ai_network_outputs_get+0x30>)
 80102b0:	601a      	str	r2, [r3, #0]
  }
  return ai_platform_outputs_get(network, n_buffer);
 80102b2:	6839      	ldr	r1, [r7, #0]
 80102b4:	6878      	ldr	r0, [r7, #4]
 80102b6:	f000 fa1f 	bl	80106f8 <ai_platform_outputs_get>
 80102ba:	4603      	mov	r3, r0
}
 80102bc:	4618      	mov	r0, r3
 80102be:	3708      	adds	r7, #8
 80102c0:	46bd      	mov	sp, r7
 80102c2:	bd80      	pop	{r7, pc}
 80102c4:	24000c30 	.word	0x24000c30
 80102c8:	a1c00100 	.word	0xa1c00100

080102cc <ai_network_init>:


AI_API_ENTRY
ai_bool ai_network_init(
  ai_handle network, const ai_network_params* params)
{
 80102cc:	b580      	push	{r7, lr}
 80102ce:	b084      	sub	sp, #16
 80102d0:	af00      	add	r7, sp, #0
 80102d2:	6078      	str	r0, [r7, #4]
 80102d4:	6039      	str	r1, [r7, #0]
  ai_network* net_ctx = AI_NETWORK_OBJ(ai_platform_network_init(network, params));
 80102d6:	6839      	ldr	r1, [r7, #0]
 80102d8:	6878      	ldr	r0, [r7, #4]
 80102da:	f000 fac5 	bl	8010868 <ai_platform_network_init>
 80102de:	60f8      	str	r0, [r7, #12]
  ai_bool ok = true;
 80102e0:	2301      	movs	r3, #1
 80102e2:	72fb      	strb	r3, [r7, #11]

  if (!net_ctx) return false;
 80102e4:	68fb      	ldr	r3, [r7, #12]
 80102e6:	2b00      	cmp	r3, #0
 80102e8:	d101      	bne.n	80102ee <ai_network_init+0x22>
 80102ea:	2300      	movs	r3, #0
 80102ec:	e026      	b.n	801033c <ai_network_init+0x70>
  ok &= network_configure_weights(net_ctx, params);
 80102ee:	6839      	ldr	r1, [r7, #0]
 80102f0:	68f8      	ldr	r0, [r7, #12]
 80102f2:	f7ff fe45 	bl	800ff80 <network_configure_weights>
 80102f6:	4603      	mov	r3, r0
 80102f8:	461a      	mov	r2, r3
 80102fa:	7afb      	ldrb	r3, [r7, #11]
 80102fc:	4013      	ands	r3, r2
 80102fe:	2b00      	cmp	r3, #0
 8010300:	bf14      	ite	ne
 8010302:	2301      	movne	r3, #1
 8010304:	2300      	moveq	r3, #0
 8010306:	72fb      	strb	r3, [r7, #11]
  ok &= network_configure_activations(net_ctx, params);
 8010308:	6839      	ldr	r1, [r7, #0]
 801030a:	68f8      	ldr	r0, [r7, #12]
 801030c:	f7ff fd78 	bl	800fe00 <network_configure_activations>
 8010310:	4603      	mov	r3, r0
 8010312:	461a      	mov	r2, r3
 8010314:	7afb      	ldrb	r3, [r7, #11]
 8010316:	4013      	ands	r3, r2
 8010318:	2b00      	cmp	r3, #0
 801031a:	bf14      	ite	ne
 801031c:	2301      	movne	r3, #1
 801031e:	2300      	moveq	r3, #0
 8010320:	72fb      	strb	r3, [r7, #11]

  ok &= ai_platform_network_post_init(network);
 8010322:	6878      	ldr	r0, [r7, #4]
 8010324:	f000 fb60 	bl	80109e8 <ai_platform_network_post_init>
 8010328:	4603      	mov	r3, r0
 801032a:	461a      	mov	r2, r3
 801032c:	7afb      	ldrb	r3, [r7, #11]
 801032e:	4013      	ands	r3, r2
 8010330:	2b00      	cmp	r3, #0
 8010332:	bf14      	ite	ne
 8010334:	2301      	movne	r3, #1
 8010336:	2300      	moveq	r3, #0
 8010338:	72fb      	strb	r3, [r7, #11]

  return ok;
 801033a:	7afb      	ldrb	r3, [r7, #11]
}
 801033c:	4618      	mov	r0, r3
 801033e:	3710      	adds	r7, #16
 8010340:	46bd      	mov	sp, r7
 8010342:	bd80      	pop	{r7, pc}

08010344 <ai_network_run>:


AI_API_ENTRY
ai_i32 ai_network_run(
  ai_handle network, const ai_buffer* input, ai_buffer* output)
{
 8010344:	b580      	push	{r7, lr}
 8010346:	b084      	sub	sp, #16
 8010348:	af00      	add	r7, sp, #0
 801034a:	60f8      	str	r0, [r7, #12]
 801034c:	60b9      	str	r1, [r7, #8]
 801034e:	607a      	str	r2, [r7, #4]
  return ai_platform_network_process(network, input, output);
 8010350:	687a      	ldr	r2, [r7, #4]
 8010352:	68b9      	ldr	r1, [r7, #8]
 8010354:	68f8      	ldr	r0, [r7, #12]
 8010356:	f000 fb77 	bl	8010a48 <ai_platform_network_process>
 801035a:	4603      	mov	r3, r0
}
 801035c:	4618      	mov	r0, r3
 801035e:	3710      	adds	r7, #16
 8010360:	46bd      	mov	sp, r7
 8010362:	bd80      	pop	{r7, pc}

08010364 <ai_network_data_params_get>:
 * @ingroup network_data
 * @return true if a valid configuration is present, false otherwise
 */
AI_API_ENTRY
ai_bool ai_network_data_params_get(ai_network_params* params)
{
 8010364:	b580      	push	{r7, lr}
 8010366:	b086      	sub	sp, #24
 8010368:	af00      	add	r7, sp, #0
 801036a:	6078      	str	r0, [r7, #4]
  if (!params) return false;
 801036c:	687b      	ldr	r3, [r7, #4]
 801036e:	2b00      	cmp	r3, #0
 8010370:	d101      	bne.n	8010376 <ai_network_data_params_get+0x12>
 8010372:	2300      	movs	r3, #0
 8010374:	e016      	b.n	80103a4 <ai_network_data_params_get+0x40>
  
  const ai_buffer_array map_activations = 
 8010376:	4a0d      	ldr	r2, [pc, #52]	@ (80103ac <ai_network_data_params_get+0x48>)
 8010378:	f107 0310 	add.w	r3, r7, #16
 801037c:	e892 0003 	ldmia.w	r2, {r0, r1}
 8010380:	e883 0003 	stmia.w	r3, {r0, r1}
    AI_BUFFER_ARRAY_OBJ_INIT(AI_FLAG_NONE, AI_NETWORK_DATA_ACTIVATIONS_COUNT, g_network_data_map_activations);
  
  const ai_buffer_array map_weights = 
 8010384:	4a0a      	ldr	r2, [pc, #40]	@ (80103b0 <ai_network_data_params_get+0x4c>)
 8010386:	f107 0308 	add.w	r3, r7, #8
 801038a:	e892 0003 	ldmia.w	r2, {r0, r1}
 801038e:	e883 0003 	stmia.w	r3, {r0, r1}
    AI_BUFFER_ARRAY_OBJ_INIT(AI_FLAG_NONE, AI_NETWORK_DATA_WEIGHTS_COUNT, g_network_data_map_weights);

  return ai_platform_bind_network_params(params, &map_weights, &map_activations);
 8010392:	f107 0210 	add.w	r2, r7, #16
 8010396:	f107 0308 	add.w	r3, r7, #8
 801039a:	4619      	mov	r1, r3
 801039c:	6878      	ldr	r0, [r7, #4]
 801039e:	f000 f907 	bl	80105b0 <ai_platform_bind_network_params>
 80103a2:	4603      	mov	r3, r0
}
 80103a4:	4618      	mov	r0, r3
 80103a6:	3718      	adds	r7, #24
 80103a8:	46bd      	mov	sp, r7
 80103aa:	bd80      	pop	{r7, pc}
 80103ac:	080185fc 	.word	0x080185fc
 80103b0:	08018604 	.word	0x08018604

080103b4 <ai_buffer_get_size>:
 80103b4:	b368      	cbz	r0, 8010412 <ai_buffer_get_size+0x5e>
 80103b6:	4b17      	ldr	r3, [pc, #92]	@ (8010414 <ai_buffer_get_size+0x60>)
 80103b8:	4a17      	ldr	r2, [pc, #92]	@ (8010418 <ai_buffer_get_size+0x64>)
 80103ba:	b410      	push	{r4}
 80103bc:	6804      	ldr	r4, [r0, #0]
 80103be:	4023      	ands	r3, r4
 80103c0:	4293      	cmp	r3, r2
 80103c2:	d123      	bne.n	801040c <ai_buffer_get_size+0x58>
 80103c4:	b311      	cbz	r1, 801040c <ai_buffer_get_size+0x58>
 80103c6:	6984      	ldr	r4, [r0, #24]
 80103c8:	6862      	ldr	r2, [r4, #4]
 80103ca:	321f      	adds	r2, #31
 80103cc:	f022 021f 	bic.w	r2, r2, #31
 80103d0:	7d03      	ldrb	r3, [r0, #20]
 80103d2:	6941      	ldr	r1, [r0, #20]
 80103d4:	f1a3 0301 	sub.w	r3, r3, #1
 80103d8:	f3c1 2017 	ubfx	r0, r1, #8, #24
 80103dc:	fab3 f383 	clz	r3, r3
 80103e0:	095b      	lsrs	r3, r3, #5
 80103e2:	ebb3 2f11 	cmp.w	r3, r1, lsr #8
 80103e6:	da0c      	bge.n	8010402 <ai_buffer_get_size+0x4e>
 80103e8:	2b01      	cmp	r3, #1
 80103ea:	d103      	bne.n	80103f4 <ai_buffer_get_size+0x40>
 80103ec:	2802      	cmp	r0, #2
 80103ee:	f04f 0302 	mov.w	r3, #2
 80103f2:	d006      	beq.n	8010402 <ai_buffer_get_size+0x4e>
 80103f4:	f854 1023 	ldr.w	r1, [r4, r3, lsl #2]
 80103f8:	3301      	adds	r3, #1
 80103fa:	4298      	cmp	r0, r3
 80103fc:	fb01 f202 	mul.w	r2, r1, r2
 8010400:	d1f2      	bne.n	80103e8 <ai_buffer_get_size+0x34>
 8010402:	ea22 70e2 	bic.w	r0, r2, r2, asr #31
 8010406:	f85d 4b04 	ldr.w	r4, [sp], #4
 801040a:	4770      	bx	lr
 801040c:	6984      	ldr	r4, [r0, #24]
 801040e:	6862      	ldr	r2, [r4, #4]
 8010410:	e7de      	b.n	80103d0 <ai_buffer_get_size+0x1c>
 8010412:	4770      	bx	lr
 8010414:	017fffff 	.word	0x017fffff
 8010418:	000400c0 	.word	0x000400c0

0801041c <ai_buffer_array_sane>:
 801041c:	b138      	cbz	r0, 801042e <ai_buffer_array_sane+0x12>
 801041e:	6843      	ldr	r3, [r0, #4]
 8010420:	b123      	cbz	r3, 801042c <ai_buffer_array_sane+0x10>
 8010422:	8840      	ldrh	r0, [r0, #2]
 8010424:	3800      	subs	r0, #0
 8010426:	bf18      	it	ne
 8010428:	2001      	movne	r0, #1
 801042a:	4770      	bx	lr
 801042c:	4618      	mov	r0, r3
 801042e:	4770      	bx	lr

08010430 <ai_buffer_array_item_set_address>:
 8010430:	b150      	cbz	r0, 8010448 <ai_buffer_array_item_set_address+0x18>
 8010432:	6843      	ldr	r3, [r0, #4]
 8010434:	b14b      	cbz	r3, 801044a <ai_buffer_array_item_set_address+0x1a>
 8010436:	8840      	ldrh	r0, [r0, #2]
 8010438:	b900      	cbnz	r0, 801043c <ai_buffer_array_item_set_address+0xc>
 801043a:	4770      	bx	lr
 801043c:	ebc1 01c1 	rsb	r1, r1, r1, lsl #3
 8010440:	2001      	movs	r0, #1
 8010442:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8010446:	605a      	str	r2, [r3, #4]
 8010448:	4770      	bx	lr
 801044a:	4618      	mov	r0, r3
 801044c:	4770      	bx	lr
 801044e:	bf00      	nop

08010450 <ai_platform_get_weights_map>:
 8010450:	2900      	cmp	r1, #0
 8010452:	bf18      	it	ne
 8010454:	2800      	cmpne	r0, #0
 8010456:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8010458:	bf0c      	ite	eq
 801045a:	2401      	moveq	r4, #1
 801045c:	2400      	movne	r4, #0
 801045e:	2a00      	cmp	r2, #0
 8010460:	bf08      	it	eq
 8010462:	f044 0401 	orreq.w	r4, r4, #1
 8010466:	b114      	cbz	r4, 801046e <ai_platform_get_weights_map+0x1e>
 8010468:	2400      	movs	r4, #0
 801046a:	4620      	mov	r0, r4
 801046c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801046e:	4616      	mov	r6, r2
 8010470:	4b22      	ldr	r3, [pc, #136]	@ (80104fc <ai_platform_get_weights_map+0xac>)
 8010472:	6812      	ldr	r2, [r2, #0]
 8010474:	4605      	mov	r5, r0
 8010476:	460f      	mov	r7, r1
 8010478:	429a      	cmp	r2, r3
 801047a:	d022      	beq.n	80104c2 <ai_platform_get_weights_map+0x72>
 801047c:	6870      	ldr	r0, [r6, #4]
 801047e:	2800      	cmp	r0, #0
 8010480:	d0f2      	beq.n	8010468 <ai_platform_get_weights_map+0x18>
 8010482:	6806      	ldr	r6, [r0, #0]
 8010484:	429e      	cmp	r6, r3
 8010486:	d006      	beq.n	8010496 <ai_platform_get_weights_map+0x46>
 8010488:	f1a1 0401 	sub.w	r4, r1, #1
 801048c:	6028      	str	r0, [r5, #0]
 801048e:	fab4 f484 	clz	r4, r4
 8010492:	0964      	lsrs	r4, r4, #5
 8010494:	e7e9      	b.n	801046a <ai_platform_get_weights_map+0x1a>
 8010496:	3d04      	subs	r5, #4
 8010498:	4602      	mov	r2, r0
 801049a:	4621      	mov	r1, r4
 801049c:	e000      	b.n	80104a0 <ai_platform_get_weights_map+0x50>
 801049e:	4619      	mov	r1, r3
 80104a0:	f852 3f04 	ldr.w	r3, [r2, #4]!
 80104a4:	42b3      	cmp	r3, r6
 80104a6:	d025      	beq.n	80104f4 <ai_platform_get_weights_map+0xa4>
 80104a8:	f845 3f04 	str.w	r3, [r5, #4]!
 80104ac:	1c4b      	adds	r3, r1, #1
 80104ae:	429f      	cmp	r7, r3
 80104b0:	d8f5      	bhi.n	801049e <ai_platform_get_weights_map+0x4e>
 80104b2:	d1da      	bne.n	801046a <ai_platform_get_weights_map+0x1a>
 80104b4:	3102      	adds	r1, #2
 80104b6:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
 80104ba:	42b3      	cmp	r3, r6
 80104bc:	d1d5      	bne.n	801046a <ai_platform_get_weights_map+0x1a>
 80104be:	2401      	movs	r4, #1
 80104c0:	e7d3      	b.n	801046a <ai_platform_get_weights_map+0x1a>
 80104c2:	1d30      	adds	r0, r6, #4
 80104c4:	f7ff ffaa 	bl	801041c <ai_buffer_array_sane>
 80104c8:	2800      	cmp	r0, #0
 80104ca:	d0cd      	beq.n	8010468 <ai_platform_get_weights_map+0x18>
 80104cc:	88f3      	ldrh	r3, [r6, #6]
 80104ce:	429f      	cmp	r7, r3
 80104d0:	d1ca      	bne.n	8010468 <ai_platform_get_weights_map+0x18>
 80104d2:	3d04      	subs	r5, #4
 80104d4:	4622      	mov	r2, r4
 80104d6:	68b3      	ldr	r3, [r6, #8]
 80104d8:	4423      	add	r3, r4
 80104da:	341c      	adds	r4, #28
 80104dc:	685b      	ldr	r3, [r3, #4]
 80104de:	b123      	cbz	r3, 80104ea <ai_platform_get_weights_map+0x9a>
 80104e0:	3201      	adds	r2, #1
 80104e2:	f845 3f04 	str.w	r3, [r5, #4]!
 80104e6:	4297      	cmp	r7, r2
 80104e8:	d8f5      	bhi.n	80104d6 <ai_platform_get_weights_map+0x86>
 80104ea:	1abc      	subs	r4, r7, r2
 80104ec:	fab4 f484 	clz	r4, r4
 80104f0:	0964      	lsrs	r4, r4, #5
 80104f2:	e7ba      	b.n	801046a <ai_platform_get_weights_map+0x1a>
 80104f4:	428f      	cmp	r7, r1
 80104f6:	d1b8      	bne.n	801046a <ai_platform_get_weights_map+0x1a>
 80104f8:	e7e1      	b.n	80104be <ai_platform_get_weights_map+0x6e>
 80104fa:	bf00      	nop
 80104fc:	a1facade 	.word	0xa1facade

08010500 <ai_platform_get_activations_map>:
 8010500:	2900      	cmp	r1, #0
 8010502:	bf18      	it	ne
 8010504:	2800      	cmpne	r0, #0
 8010506:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8010508:	bf0c      	ite	eq
 801050a:	2401      	moveq	r4, #1
 801050c:	2400      	movne	r4, #0
 801050e:	2a00      	cmp	r2, #0
 8010510:	bf08      	it	eq
 8010512:	f044 0401 	orreq.w	r4, r4, #1
 8010516:	b114      	cbz	r4, 801051e <ai_platform_get_activations_map+0x1e>
 8010518:	2400      	movs	r4, #0
 801051a:	4620      	mov	r0, r4
 801051c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 801051e:	4616      	mov	r6, r2
 8010520:	4b22      	ldr	r3, [pc, #136]	@ (80105ac <ai_platform_get_activations_map+0xac>)
 8010522:	6812      	ldr	r2, [r2, #0]
 8010524:	4605      	mov	r5, r0
 8010526:	460f      	mov	r7, r1
 8010528:	429a      	cmp	r2, r3
 801052a:	d022      	beq.n	8010572 <ai_platform_get_activations_map+0x72>
 801052c:	6a30      	ldr	r0, [r6, #32]
 801052e:	2800      	cmp	r0, #0
 8010530:	d0f2      	beq.n	8010518 <ai_platform_get_activations_map+0x18>
 8010532:	6806      	ldr	r6, [r0, #0]
 8010534:	429e      	cmp	r6, r3
 8010536:	d006      	beq.n	8010546 <ai_platform_get_activations_map+0x46>
 8010538:	f1a1 0401 	sub.w	r4, r1, #1
 801053c:	6028      	str	r0, [r5, #0]
 801053e:	fab4 f484 	clz	r4, r4
 8010542:	0964      	lsrs	r4, r4, #5
 8010544:	e7e9      	b.n	801051a <ai_platform_get_activations_map+0x1a>
 8010546:	3d04      	subs	r5, #4
 8010548:	4602      	mov	r2, r0
 801054a:	4621      	mov	r1, r4
 801054c:	e000      	b.n	8010550 <ai_platform_get_activations_map+0x50>
 801054e:	4619      	mov	r1, r3
 8010550:	f852 3f04 	ldr.w	r3, [r2, #4]!
 8010554:	42b3      	cmp	r3, r6
 8010556:	d026      	beq.n	80105a6 <ai_platform_get_activations_map+0xa6>
 8010558:	f845 3f04 	str.w	r3, [r5, #4]!
 801055c:	1c4b      	adds	r3, r1, #1
 801055e:	429f      	cmp	r7, r3
 8010560:	d8f5      	bhi.n	801054e <ai_platform_get_activations_map+0x4e>
 8010562:	d1da      	bne.n	801051a <ai_platform_get_activations_map+0x1a>
 8010564:	3102      	adds	r1, #2
 8010566:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
 801056a:	42b3      	cmp	r3, r6
 801056c:	d1d5      	bne.n	801051a <ai_platform_get_activations_map+0x1a>
 801056e:	2401      	movs	r4, #1
 8010570:	e7d3      	b.n	801051a <ai_platform_get_activations_map+0x1a>
 8010572:	f106 000c 	add.w	r0, r6, #12
 8010576:	f7ff ff51 	bl	801041c <ai_buffer_array_sane>
 801057a:	2800      	cmp	r0, #0
 801057c:	d0cc      	beq.n	8010518 <ai_platform_get_activations_map+0x18>
 801057e:	89f3      	ldrh	r3, [r6, #14]
 8010580:	429f      	cmp	r7, r3
 8010582:	d1c9      	bne.n	8010518 <ai_platform_get_activations_map+0x18>
 8010584:	3d04      	subs	r5, #4
 8010586:	4622      	mov	r2, r4
 8010588:	6933      	ldr	r3, [r6, #16]
 801058a:	4423      	add	r3, r4
 801058c:	341c      	adds	r4, #28
 801058e:	685b      	ldr	r3, [r3, #4]
 8010590:	b123      	cbz	r3, 801059c <ai_platform_get_activations_map+0x9c>
 8010592:	3201      	adds	r2, #1
 8010594:	f845 3f04 	str.w	r3, [r5, #4]!
 8010598:	4297      	cmp	r7, r2
 801059a:	d8f5      	bhi.n	8010588 <ai_platform_get_activations_map+0x88>
 801059c:	1abc      	subs	r4, r7, r2
 801059e:	fab4 f484 	clz	r4, r4
 80105a2:	0964      	lsrs	r4, r4, #5
 80105a4:	e7b9      	b.n	801051a <ai_platform_get_activations_map+0x1a>
 80105a6:	428f      	cmp	r7, r1
 80105a8:	d1b7      	bne.n	801051a <ai_platform_get_activations_map+0x1a>
 80105aa:	e7e0      	b.n	801056e <ai_platform_get_activations_map+0x6e>
 80105ac:	a1facade 	.word	0xa1facade

080105b0 <ai_platform_bind_network_params>:
 80105b0:	2a00      	cmp	r2, #0
 80105b2:	bf18      	it	ne
 80105b4:	2900      	cmpne	r1, #0
 80105b6:	d010      	beq.n	80105da <ai_platform_bind_network_params+0x2a>
 80105b8:	b178      	cbz	r0, 80105da <ai_platform_bind_network_params+0x2a>
 80105ba:	4603      	mov	r3, r0
 80105bc:	4808      	ldr	r0, [pc, #32]	@ (80105e0 <ai_platform_bind_network_params+0x30>)
 80105be:	f103 0c0c 	add.w	ip, r3, #12
 80105c2:	f843 0b04 	str.w	r0, [r3], #4
 80105c6:	c903      	ldmia	r1, {r0, r1}
 80105c8:	e883 0003 	stmia.w	r3, {r0, r1}
 80105cc:	2301      	movs	r3, #1
 80105ce:	e892 0003 	ldmia.w	r2, {r0, r1}
 80105d2:	e88c 0003 	stmia.w	ip, {r0, r1}
 80105d6:	4618      	mov	r0, r3
 80105d8:	4770      	bx	lr
 80105da:	2300      	movs	r3, #0
 80105dc:	4618      	mov	r0, r3
 80105de:	4770      	bx	lr
 80105e0:	a1facade 	.word	0xa1facade

080105e4 <ai_platform_network_get_error>:
 80105e4:	4b04      	ldr	r3, [pc, #16]	@ (80105f8 <ai_platform_network_get_error+0x14>)
 80105e6:	6802      	ldr	r2, [r0, #0]
 80105e8:	4393      	bics	r3, r2
 80105ea:	d102      	bne.n	80105f2 <ai_platform_network_get_error+0xe>
 80105ec:	300c      	adds	r0, #12
 80105ee:	f000 bc73 	b.w	8010ed8 <core_get_error>
 80105f2:	f241 0010 	movw	r0, #4112	@ 0x1010
 80105f6:	4770      	bx	lr
 80105f8:	a1c00100 	.word	0xa1c00100

080105fc <ai_platform_network_set_error>:
 80105fc:	b110      	cbz	r0, 8010604 <ai_platform_network_set_error+0x8>
 80105fe:	300c      	adds	r0, #12
 8010600:	f000 bc70 	b.w	8010ee4 <core_set_error>
 8010604:	4770      	bx	lr
 8010606:	bf00      	nop

08010608 <ai_platform_inputs_get>:
 8010608:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801060c:	4b39      	ldr	r3, [pc, #228]	@ (80106f4 <ai_platform_inputs_get+0xec>)
 801060e:	b085      	sub	sp, #20
 8010610:	6802      	ldr	r2, [r0, #0]
 8010612:	4393      	bics	r3, r2
 8010614:	e9cd 1002 	strd	r1, r0, [sp, #8]
 8010618:	d162      	bne.n	80106e0 <ai_platform_inputs_get+0xd8>
 801061a:	8e03      	ldrh	r3, [r0, #48]	@ 0x30
 801061c:	2b00      	cmp	r3, #0
 801061e:	d051      	beq.n	80106c4 <ai_platform_inputs_get+0xbc>
 8010620:	f8d0 a034 	ldr.w	sl, [r0, #52]	@ 0x34
 8010624:	f1ba 0f00 	cmp.w	sl, #0
 8010628:	d04c      	beq.n	80106c4 <ai_platform_inputs_get+0xbc>
 801062a:	f04f 0900 	mov.w	r9, #0
 801062e:	464d      	mov	r5, r9
 8010630:	e016      	b.n	8010660 <ai_platform_inputs_get+0x58>
 8010632:	9901      	ldr	r1, [sp, #4]
 8010634:	2301      	movs	r3, #1
 8010636:	f848 3001 	str.w	r3, [r8, r1]
 801063a:	69b1      	ldr	r1, [r6, #24]
 801063c:	f04f 0301 	mov.w	r3, #1
 8010640:	684e      	ldr	r6, [r1, #4]
 8010642:	3501      	adds	r5, #1
 8010644:	f109 091c 	add.w	r9, r9, #28
 8010648:	7523      	strb	r3, [r4, #20]
 801064a:	2300      	movs	r3, #0
 801064c:	6961      	ldr	r1, [r4, #20]
 801064e:	6020      	str	r0, [r4, #0]
 8010650:	f36b 211f 	bfi	r1, fp, #8, #24
 8010654:	e9c4 c701 	strd	ip, r7, [r4, #4]
 8010658:	e9c4 3603 	strd	r3, r6, [r4, #12]
 801065c:	e9c4 1205 	strd	r1, r2, [r4, #20]
 8010660:	f8ba 3000 	ldrh.w	r3, [sl]
 8010664:	b2ac      	uxth	r4, r5
 8010666:	42ab      	cmp	r3, r5
 8010668:	ea4f 03c5 	mov.w	r3, r5, lsl #3
 801066c:	9301      	str	r3, [sp, #4]
 801066e:	d93b      	bls.n	80106e8 <ai_platform_inputs_get+0xe0>
 8010670:	f8da 3004 	ldr.w	r3, [sl, #4]
 8010674:	2b00      	cmp	r3, #0
 8010676:	d037      	beq.n	80106e8 <ai_platform_inputs_get+0xe0>
 8010678:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
 801067c:	2e00      	cmp	r6, #0
 801067e:	d033      	beq.n	80106e8 <ai_platform_inputs_get+0xe0>
 8010680:	f8da 3008 	ldr.w	r3, [sl, #8]
 8010684:	69b2      	ldr	r2, [r6, #24]
 8010686:	e9d3 4801 	ldrd	r4, r8, [r3, #4]
 801068a:	6810      	ldr	r0, [r2, #0]
 801068c:	68b3      	ldr	r3, [r6, #8]
 801068e:	eb08 07c5 	add.w	r7, r8, r5, lsl #3
 8010692:	68f2      	ldr	r2, [r6, #12]
 8010694:	444c      	add	r4, r9
 8010696:	f3c3 2b17 	ubfx	fp, r3, #8, #24
 801069a:	9200      	str	r2, [sp, #0]
 801069c:	f006 fa90 	bl	8016bc0 <ai_array_to_buffer_fmt>
 80106a0:	69b1      	ldr	r1, [r6, #24]
 80106a2:	9a00      	ldr	r2, [sp, #0]
 80106a4:	f8d1 c008 	ldr.w	ip, [r1, #8]
 80106a8:	2f00      	cmp	r7, #0
 80106aa:	d0c7      	beq.n	801063c <ai_platform_inputs_get+0x34>
 80106ac:	2100      	movs	r1, #0
 80106ae:	f848 1035 	str.w	r1, [r8, r5, lsl #3]
 80106b2:	6831      	ldr	r1, [r6, #0]
 80106b4:	6079      	str	r1, [r7, #4]
 80106b6:	b111      	cbz	r1, 80106be <ai_platform_inputs_get+0xb6>
 80106b8:	8849      	ldrh	r1, [r1, #2]
 80106ba:	2900      	cmp	r1, #0
 80106bc:	d1b9      	bne.n	8010632 <ai_platform_inputs_get+0x2a>
 80106be:	69b1      	ldr	r1, [r6, #24]
 80106c0:	2700      	movs	r7, #0
 80106c2:	e7bb      	b.n	801063c <ai_platform_inputs_get+0x34>
 80106c4:	9803      	ldr	r0, [sp, #12]
 80106c6:	2400      	movs	r4, #0
 80106c8:	2218      	movs	r2, #24
 80106ca:	2111      	movs	r1, #17
 80106cc:	300c      	adds	r0, #12
 80106ce:	f000 fc09 	bl	8010ee4 <core_set_error>
 80106d2:	4620      	mov	r0, r4
 80106d4:	9b02      	ldr	r3, [sp, #8]
 80106d6:	b103      	cbz	r3, 80106da <ai_platform_inputs_get+0xd2>
 80106d8:	801c      	strh	r4, [r3, #0]
 80106da:	b005      	add	sp, #20
 80106dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80106e0:	2000      	movs	r0, #0
 80106e2:	b005      	add	sp, #20
 80106e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80106e8:	2c00      	cmp	r4, #0
 80106ea:	d0eb      	beq.n	80106c4 <ai_platform_inputs_get+0xbc>
 80106ec:	f8da 3008 	ldr.w	r3, [sl, #8]
 80106f0:	6858      	ldr	r0, [r3, #4]
 80106f2:	e7ef      	b.n	80106d4 <ai_platform_inputs_get+0xcc>
 80106f4:	a1c00100 	.word	0xa1c00100

080106f8 <ai_platform_outputs_get>:
 80106f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80106fc:	4b38      	ldr	r3, [pc, #224]	@ (80107e0 <ai_platform_outputs_get+0xe8>)
 80106fe:	b085      	sub	sp, #20
 8010700:	6802      	ldr	r2, [r0, #0]
 8010702:	4393      	bics	r3, r2
 8010704:	e9cd 1002 	strd	r1, r0, [sp, #8]
 8010708:	d15f      	bne.n	80107ca <ai_platform_outputs_get+0xd2>
 801070a:	8e03      	ldrh	r3, [r0, #48]	@ 0x30
 801070c:	2b01      	cmp	r3, #1
 801070e:	d94e      	bls.n	80107ae <ai_platform_outputs_get+0xb6>
 8010710:	f04f 0900 	mov.w	r9, #0
 8010714:	f8d0 a034 	ldr.w	sl, [r0, #52]	@ 0x34
 8010718:	464d      	mov	r5, r9
 801071a:	e016      	b.n	801074a <ai_platform_outputs_get+0x52>
 801071c:	9901      	ldr	r1, [sp, #4]
 801071e:	2301      	movs	r3, #1
 8010720:	f848 3001 	str.w	r3, [r8, r1]
 8010724:	69b1      	ldr	r1, [r6, #24]
 8010726:	f04f 0301 	mov.w	r3, #1
 801072a:	684e      	ldr	r6, [r1, #4]
 801072c:	3501      	adds	r5, #1
 801072e:	f109 091c 	add.w	r9, r9, #28
 8010732:	7523      	strb	r3, [r4, #20]
 8010734:	2300      	movs	r3, #0
 8010736:	6961      	ldr	r1, [r4, #20]
 8010738:	6020      	str	r0, [r4, #0]
 801073a:	f36b 211f 	bfi	r1, fp, #8, #24
 801073e:	e9c4 c701 	strd	ip, r7, [r4, #4]
 8010742:	e9c4 3603 	strd	r3, r6, [r4, #12]
 8010746:	e9c4 1205 	strd	r1, r2, [r4, #20]
 801074a:	f8ba 300c 	ldrh.w	r3, [sl, #12]
 801074e:	b2ac      	uxth	r4, r5
 8010750:	42ab      	cmp	r3, r5
 8010752:	ea4f 03c5 	mov.w	r3, r5, lsl #3
 8010756:	9301      	str	r3, [sp, #4]
 8010758:	d93b      	bls.n	80107d2 <ai_platform_outputs_get+0xda>
 801075a:	f8da 3010 	ldr.w	r3, [sl, #16]
 801075e:	2b00      	cmp	r3, #0
 8010760:	d037      	beq.n	80107d2 <ai_platform_outputs_get+0xda>
 8010762:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
 8010766:	2e00      	cmp	r6, #0
 8010768:	d033      	beq.n	80107d2 <ai_platform_outputs_get+0xda>
 801076a:	f8da 3014 	ldr.w	r3, [sl, #20]
 801076e:	69b2      	ldr	r2, [r6, #24]
 8010770:	e9d3 4801 	ldrd	r4, r8, [r3, #4]
 8010774:	6810      	ldr	r0, [r2, #0]
 8010776:	68b3      	ldr	r3, [r6, #8]
 8010778:	eb08 07c5 	add.w	r7, r8, r5, lsl #3
 801077c:	68f2      	ldr	r2, [r6, #12]
 801077e:	444c      	add	r4, r9
 8010780:	f3c3 2b17 	ubfx	fp, r3, #8, #24
 8010784:	9200      	str	r2, [sp, #0]
 8010786:	f006 fa1b 	bl	8016bc0 <ai_array_to_buffer_fmt>
 801078a:	69b1      	ldr	r1, [r6, #24]
 801078c:	9a00      	ldr	r2, [sp, #0]
 801078e:	f8d1 c008 	ldr.w	ip, [r1, #8]
 8010792:	2f00      	cmp	r7, #0
 8010794:	d0c7      	beq.n	8010726 <ai_platform_outputs_get+0x2e>
 8010796:	2100      	movs	r1, #0
 8010798:	f848 1035 	str.w	r1, [r8, r5, lsl #3]
 801079c:	6831      	ldr	r1, [r6, #0]
 801079e:	6079      	str	r1, [r7, #4]
 80107a0:	b111      	cbz	r1, 80107a8 <ai_platform_outputs_get+0xb0>
 80107a2:	8849      	ldrh	r1, [r1, #2]
 80107a4:	2900      	cmp	r1, #0
 80107a6:	d1b9      	bne.n	801071c <ai_platform_outputs_get+0x24>
 80107a8:	69b1      	ldr	r1, [r6, #24]
 80107aa:	2700      	movs	r7, #0
 80107ac:	e7bb      	b.n	8010726 <ai_platform_outputs_get+0x2e>
 80107ae:	9803      	ldr	r0, [sp, #12]
 80107b0:	2400      	movs	r4, #0
 80107b2:	2218      	movs	r2, #24
 80107b4:	2111      	movs	r1, #17
 80107b6:	300c      	adds	r0, #12
 80107b8:	f000 fb94 	bl	8010ee4 <core_set_error>
 80107bc:	4620      	mov	r0, r4
 80107be:	9b02      	ldr	r3, [sp, #8]
 80107c0:	b103      	cbz	r3, 80107c4 <ai_platform_outputs_get+0xcc>
 80107c2:	801c      	strh	r4, [r3, #0]
 80107c4:	b005      	add	sp, #20
 80107c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80107ca:	2000      	movs	r0, #0
 80107cc:	b005      	add	sp, #20
 80107ce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80107d2:	2c00      	cmp	r4, #0
 80107d4:	d0eb      	beq.n	80107ae <ai_platform_outputs_get+0xb6>
 80107d6:	f8da 3014 	ldr.w	r3, [sl, #20]
 80107da:	6858      	ldr	r0, [r3, #4]
 80107dc:	e7ef      	b.n	80107be <ai_platform_outputs_get+0xc6>
 80107de:	bf00      	nop
 80107e0:	a1c00100 	.word	0xa1c00100

080107e4 <ai_platform_network_create>:
 80107e4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80107e8:	b083      	sub	sp, #12
 80107ea:	f89d 8028 	ldrb.w	r8, [sp, #40]	@ 0x28
 80107ee:	f89d 902c 	ldrb.w	r9, [sp, #44]	@ 0x2c
 80107f2:	b320      	cbz	r0, 801083e <ai_platform_network_create+0x5a>
 80107f4:	6002      	str	r2, [r0, #0]
 80107f6:	4616      	mov	r6, r2
 80107f8:	461f      	mov	r7, r3
 80107fa:	4604      	mov	r4, r0
 80107fc:	f000 fb6a 	bl	8010ed4 <core_init>
 8010800:	b970      	cbnz	r0, 8010820 <ai_platform_network_create+0x3c>
 8010802:	2530      	movs	r5, #48	@ 0x30
 8010804:	2300      	movs	r3, #0
 8010806:	6023      	str	r3, [r4, #0]
 8010808:	2410      	movs	r4, #16
 801080a:	464a      	mov	r2, r9
 801080c:	4641      	mov	r1, r8
 801080e:	4638      	mov	r0, r7
 8010810:	f006 fa80 	bl	8016d14 <ai_version_get>
 8010814:	60b0      	str	r0, [r6, #8]
 8010816:	ea45 2004 	orr.w	r0, r5, r4, lsl #8
 801081a:	b003      	add	sp, #12
 801081c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8010820:	2200      	movs	r2, #0
 8010822:	4641      	mov	r1, r8
 8010824:	4638      	mov	r0, r7
 8010826:	f006 fa75 	bl	8016d14 <ai_version_get>
 801082a:	4605      	mov	r5, r0
 801082c:	2200      	movs	r2, #0
 801082e:	2105      	movs	r1, #5
 8010830:	2001      	movs	r0, #1
 8010832:	f006 fa6f 	bl	8016d14 <ai_version_get>
 8010836:	4285      	cmp	r5, r0
 8010838:	d008      	beq.n	801084c <ai_platform_network_create+0x68>
 801083a:	2501      	movs	r5, #1
 801083c:	e7e2      	b.n	8010804 <ai_platform_network_create+0x20>
 801083e:	2510      	movs	r5, #16
 8010840:	462c      	mov	r4, r5
 8010842:	ea45 2004 	orr.w	r0, r5, r4, lsl #8
 8010846:	b003      	add	sp, #12
 8010848:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801084c:	4b05      	ldr	r3, [pc, #20]	@ (8010864 <ai_platform_network_create+0x80>)
 801084e:	a801      	add	r0, sp, #4
 8010850:	9301      	str	r3, [sp, #4]
 8010852:	f000 fb53 	bl	8010efc <ai_check_custom_types>
 8010856:	b110      	cbz	r0, 801085e <ai_platform_network_create+0x7a>
 8010858:	2400      	movs	r4, #0
 801085a:	4625      	mov	r5, r4
 801085c:	e7d5      	b.n	801080a <ai_platform_network_create+0x26>
 801085e:	2502      	movs	r5, #2
 8010860:	e7d0      	b.n	8010804 <ai_platform_network_create+0x20>
 8010862:	bf00      	nop
 8010864:	84048403 	.word	0x84048403

08010868 <ai_platform_network_init>:
 8010868:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801086c:	4a5c      	ldr	r2, [pc, #368]	@ (80109e0 <ai_platform_network_init+0x178>)
 801086e:	460c      	mov	r4, r1
 8010870:	6801      	ldr	r1, [r0, #0]
 8010872:	438a      	bics	r2, r1
 8010874:	d133      	bne.n	80108de <ai_platform_network_init+0x76>
 8010876:	4605      	mov	r5, r0
 8010878:	2c00      	cmp	r4, #0
 801087a:	f000 8093 	beq.w	80109a4 <ai_platform_network_init+0x13c>
 801087e:	f8d4 b000 	ldr.w	fp, [r4]
 8010882:	4a58      	ldr	r2, [pc, #352]	@ (80109e4 <ai_platform_network_init+0x17c>)
 8010884:	4593      	cmp	fp, r2
 8010886:	d10f      	bne.n	80108a8 <ai_platform_network_init+0x40>
 8010888:	e9d4 e803 	ldrd	lr, r8, [r4, #12]
 801088c:	e9d4 6701 	ldrd	r6, r7, [r4, #4]
 8010890:	4b53      	ldr	r3, [pc, #332]	@ (80109e0 <ai_platform_network_init+0x178>)
 8010892:	ea4f 4a1e 	mov.w	sl, lr, lsr #16
 8010896:	0c32      	lsrs	r2, r6, #16
 8010898:	4299      	cmp	r1, r3
 801089a:	d02c      	beq.n	80108f6 <ai_platform_network_init+0x8e>
 801089c:	2303      	movs	r3, #3
 801089e:	462c      	mov	r4, r5
 80108a0:	612b      	str	r3, [r5, #16]
 80108a2:	4620      	mov	r0, r4
 80108a4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80108a8:	4627      	mov	r7, r4
 80108aa:	2101      	movs	r1, #1
 80108ac:	6864      	ldr	r4, [r4, #4]
 80108ae:	4638      	mov	r0, r7
 80108b0:	f107 081c 	add.w	r8, r7, #28
 80108b4:	f7ff fd7e 	bl	80103b4 <ai_buffer_get_size>
 80108b8:	4606      	mov	r6, r0
 80108ba:	2101      	movs	r1, #1
 80108bc:	4640      	mov	r0, r8
 80108be:	f8d7 9020 	ldr.w	r9, [r7, #32]
 80108c2:	f7ff fd77 	bl	80103b4 <ai_buffer_get_size>
 80108c6:	b976      	cbnz	r6, 80108e6 <ai_platform_network_init+0x7e>
 80108c8:	2800      	cmp	r0, #0
 80108ca:	d150      	bne.n	801096e <ai_platform_network_init+0x106>
 80108cc:	4680      	mov	r8, r0
 80108ce:	4686      	mov	lr, r0
 80108d0:	4606      	mov	r6, r0
 80108d2:	4607      	mov	r7, r0
 80108d4:	ea4f 4e0e 	mov.w	lr, lr, lsl #16
 80108d8:	6829      	ldr	r1, [r5, #0]
 80108da:	0436      	lsls	r6, r6, #16
 80108dc:	e7d8      	b.n	8010890 <ai_platform_network_init+0x28>
 80108de:	2400      	movs	r4, #0
 80108e0:	4620      	mov	r0, r4
 80108e2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80108e6:	2800      	cmp	r0, #0
 80108e8:	d13b      	bne.n	8010962 <ai_platform_network_init+0xfa>
 80108ea:	4680      	mov	r8, r0
 80108ec:	4686      	mov	lr, r0
 80108ee:	2c00      	cmp	r4, #0
 80108f0:	d05e      	beq.n	80109b0 <ai_platform_network_init+0x148>
 80108f2:	2601      	movs	r6, #1
 80108f4:	e7ee      	b.n	80108d4 <ai_platform_network_init+0x6c>
 80108f6:	8c6b      	ldrh	r3, [r5, #34]	@ 0x22
 80108f8:	4293      	cmp	r3, r2
 80108fa:	4b3a      	ldr	r3, [pc, #232]	@ (80109e4 <ai_platform_network_init+0x17c>)
 80108fc:	d33e      	bcc.n	801097c <ai_platform_network_init+0x114>
 80108fe:	459b      	cmp	fp, r3
 8010900:	d03e      	beq.n	8010980 <ai_platform_network_init+0x118>
 8010902:	b1a2      	cbz	r2, 801092e <ai_platform_network_init+0xc6>
 8010904:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 8010908:	f04f 0c00 	mov.w	ip, #0
 801090c:	ea4f 0982 	mov.w	r9, r2, lsl #2
 8010910:	6a6c      	ldr	r4, [r5, #36]	@ 0x24
 8010912:	eb07 0b0c 	add.w	fp, r7, ip
 8010916:	4464      	add	r4, ip
 8010918:	f10c 0c1c 	add.w	ip, ip, #28
 801091c:	e8bb 000f 	ldmia.w	fp!, {r0, r1, r2, r3}
 8010920:	45cc      	cmp	ip, r9
 8010922:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8010924:	e89b 0007 	ldmia.w	fp, {r0, r1, r2}
 8010928:	e884 0007 	stmia.w	r4, {r0, r1, r2}
 801092c:	d1f0      	bne.n	8010910 <ai_platform_network_init+0xa8>
 801092e:	8d6b      	ldrh	r3, [r5, #42]	@ 0x2a
 8010930:	622e      	str	r6, [r5, #32]
 8010932:	4553      	cmp	r3, sl
 8010934:	d34b      	bcc.n	80109ce <ai_platform_network_init+0x166>
 8010936:	f1ba 0f00 	cmp.w	sl, #0
 801093a:	d025      	beq.n	8010988 <ai_platform_network_init+0x120>
 801093c:	ebca 0aca 	rsb	sl, sl, sl, lsl #3
 8010940:	2700      	movs	r7, #0
 8010942:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8010946:	6aec      	ldr	r4, [r5, #44]	@ 0x2c
 8010948:	eb08 0607 	add.w	r6, r8, r7
 801094c:	443c      	add	r4, r7
 801094e:	371c      	adds	r7, #28
 8010950:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 8010952:	4557      	cmp	r7, sl
 8010954:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8010956:	e896 0007 	ldmia.w	r6, {r0, r1, r2}
 801095a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
 801095e:	d1f2      	bne.n	8010946 <ai_platform_network_init+0xde>
 8010960:	e012      	b.n	8010988 <ai_platform_network_init+0x120>
 8010962:	f1b9 0f00 	cmp.w	r9, #0
 8010966:	d015      	beq.n	8010994 <ai_platform_network_init+0x12c>
 8010968:	f04f 0e01 	mov.w	lr, #1
 801096c:	e7bf      	b.n	80108ee <ai_platform_network_init+0x86>
 801096e:	f1b9 0f00 	cmp.w	r9, #0
 8010972:	d00f      	beq.n	8010994 <ai_platform_network_init+0x12c>
 8010974:	f04f 0e01 	mov.w	lr, #1
 8010978:	4637      	mov	r7, r6
 801097a:	e7ab      	b.n	80108d4 <ai_platform_network_init+0x6c>
 801097c:	459b      	cmp	fp, r3
 801097e:	d11e      	bne.n	80109be <ai_platform_network_init+0x156>
 8010980:	f8c5 802c 	str.w	r8, [r5, #44]	@ 0x2c
 8010984:	e9c5 6708 	strd	r6, r7, [r5, #32]
 8010988:	4628      	mov	r0, r5
 801098a:	f8c5 e028 	str.w	lr, [r5, #40]	@ 0x28
 801098e:	f000 fadd 	bl	8010f4c <ai_layers_init_all>
 8010992:	e783      	b.n	801089c <ai_platform_network_init+0x34>
 8010994:	2213      	movs	r2, #19
 8010996:	2110      	movs	r1, #16
 8010998:	f105 000c 	add.w	r0, r5, #12
 801099c:	2400      	movs	r4, #0
 801099e:	f000 faa1 	bl	8010ee4 <core_set_error>
 80109a2:	e77e      	b.n	80108a2 <ai_platform_network_init+0x3a>
 80109a4:	2211      	movs	r2, #17
 80109a6:	2110      	movs	r1, #16
 80109a8:	300c      	adds	r0, #12
 80109aa:	f000 fa9b 	bl	8010ee4 <core_set_error>
 80109ae:	e778      	b.n	80108a2 <ai_platform_network_init+0x3a>
 80109b0:	2212      	movs	r2, #18
 80109b2:	2110      	movs	r1, #16
 80109b4:	f105 000c 	add.w	r0, r5, #12
 80109b8:	f000 fa94 	bl	8010ee4 <core_set_error>
 80109bc:	e771      	b.n	80108a2 <ai_platform_network_init+0x3a>
 80109be:	2212      	movs	r2, #18
 80109c0:	2116      	movs	r1, #22
 80109c2:	f105 000c 	add.w	r0, r5, #12
 80109c6:	2400      	movs	r4, #0
 80109c8:	f000 fa8c 	bl	8010ee4 <core_set_error>
 80109cc:	e769      	b.n	80108a2 <ai_platform_network_init+0x3a>
 80109ce:	2213      	movs	r2, #19
 80109d0:	2116      	movs	r1, #22
 80109d2:	f105 000c 	add.w	r0, r5, #12
 80109d6:	2400      	movs	r4, #0
 80109d8:	f000 fa84 	bl	8010ee4 <core_set_error>
 80109dc:	e761      	b.n	80108a2 <ai_platform_network_init+0x3a>
 80109de:	bf00      	nop
 80109e0:	a1c00100 	.word	0xa1c00100
 80109e4:	a1facade 	.word	0xa1facade

080109e8 <ai_platform_network_post_init>:
 80109e8:	b538      	push	{r3, r4, r5, lr}
 80109ea:	4b16      	ldr	r3, [pc, #88]	@ (8010a44 <ai_platform_network_post_init+0x5c>)
 80109ec:	6802      	ldr	r2, [r0, #0]
 80109ee:	ea02 0103 	and.w	r1, r2, r3
 80109f2:	4393      	bics	r3, r2
 80109f4:	d108      	bne.n	8010a08 <ai_platform_network_post_init+0x20>
 80109f6:	6903      	ldr	r3, [r0, #16]
 80109f8:	4604      	mov	r4, r0
 80109fa:	f013 0502 	ands.w	r5, r3, #2
 80109fe:	d005      	beq.n	8010a0c <ai_platform_network_post_init+0x24>
 8010a00:	428a      	cmp	r2, r1
 8010a02:	d00a      	beq.n	8010a1a <ai_platform_network_post_init+0x32>
 8010a04:	2001      	movs	r0, #1
 8010a06:	bd38      	pop	{r3, r4, r5, pc}
 8010a08:	2000      	movs	r0, #0
 8010a0a:	bd38      	pop	{r3, r4, r5, pc}
 8010a0c:	2210      	movs	r2, #16
 8010a0e:	2111      	movs	r1, #17
 8010a10:	300c      	adds	r0, #12
 8010a12:	f000 fa67 	bl	8010ee4 <core_set_error>
 8010a16:	4628      	mov	r0, r5
 8010a18:	bd38      	pop	{r3, r4, r5, pc}
 8010a1a:	f000 faa5 	bl	8010f68 <ai_layers_post_init_all>
 8010a1e:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8010a20:	2b00      	cmp	r3, #0
 8010a22:	d0ef      	beq.n	8010a04 <ai_platform_network_post_init+0x1c>
 8010a24:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
 8010a26:	e008      	b.n	8010a3a <ai_platform_network_post_init+0x52>
 8010a28:	e9d4 3210 	ldrd	r3, r2, [r4, #64]	@ 0x40
 8010a2c:	4798      	blx	r3
 8010a2e:	692b      	ldr	r3, [r5, #16]
 8010a30:	42ab      	cmp	r3, r5
 8010a32:	461d      	mov	r5, r3
 8010a34:	d0e6      	beq.n	8010a04 <ai_platform_network_post_init+0x1c>
 8010a36:	2b00      	cmp	r3, #0
 8010a38:	d0e4      	beq.n	8010a04 <ai_platform_network_post_init+0x1c>
 8010a3a:	4629      	mov	r1, r5
 8010a3c:	2000      	movs	r0, #0
 8010a3e:	2d00      	cmp	r5, #0
 8010a40:	d1f2      	bne.n	8010a28 <ai_platform_network_post_init+0x40>
 8010a42:	e7df      	b.n	8010a04 <ai_platform_network_post_init+0x1c>
 8010a44:	a1c00100 	.word	0xa1c00100

08010a48 <ai_platform_network_process>:
 8010a48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8010a4c:	b085      	sub	sp, #20
 8010a4e:	4bb7      	ldr	r3, [pc, #732]	@ (8010d2c <ai_platform_network_process+0x2e4>)
 8010a50:	9202      	str	r2, [sp, #8]
 8010a52:	6802      	ldr	r2, [r0, #0]
 8010a54:	4393      	bics	r3, r2
 8010a56:	f040 8142 	bne.w	8010cde <ai_platform_network_process+0x296>
 8010a5a:	8e03      	ldrh	r3, [r0, #48]	@ 0x30
 8010a5c:	4605      	mov	r5, r0
 8010a5e:	2b00      	cmp	r3, #0
 8010a60:	f000 8126 	beq.w	8010cb0 <ai_platform_network_process+0x268>
 8010a64:	6903      	ldr	r3, [r0, #16]
 8010a66:	2200      	movs	r2, #0
 8010a68:	f8d0 8034 	ldr.w	r8, [r0, #52]	@ 0x34
 8010a6c:	f003 0303 	and.w	r3, r3, #3
 8010a70:	6182      	str	r2, [r0, #24]
 8010a72:	2b03      	cmp	r3, #3
 8010a74:	f040 8122 	bne.w	8010cbc <ai_platform_network_process+0x274>
 8010a78:	2900      	cmp	r1, #0
 8010a7a:	f000 8136 	beq.w	8010cea <ai_platform_network_process+0x2a2>
 8010a7e:	fab8 f788 	clz	r7, r8
 8010a82:	097f      	lsrs	r7, r7, #5
 8010a84:	f1b8 0f00 	cmp.w	r8, #0
 8010a88:	f000 812f 	beq.w	8010cea <ai_platform_network_process+0x2a2>
 8010a8c:	f8b8 3000 	ldrh.w	r3, [r8]
 8010a90:	2b00      	cmp	r3, #0
 8010a92:	f000 812a 	beq.w	8010cea <ai_platform_network_process+0x2a2>
 8010a96:	698b      	ldr	r3, [r1, #24]
 8010a98:	460e      	mov	r6, r1
 8010a9a:	9003      	str	r0, [sp, #12]
 8010a9c:	681b      	ldr	r3, [r3, #0]
 8010a9e:	9301      	str	r3, [sp, #4]
 8010aa0:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8010aa4:	2b00      	cmp	r3, #0
 8010aa6:	d072      	beq.n	8010b8e <ai_platform_network_process+0x146>
 8010aa8:	f853 4027 	ldr.w	r4, [r3, r7, lsl #2]
 8010aac:	2c00      	cmp	r4, #0
 8010aae:	d06e      	beq.n	8010b8e <ai_platform_network_process+0x146>
 8010ab0:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8010ab4:	ea4f 1b07 	mov.w	fp, r7, lsl #4
 8010ab8:	f8d3 a000 	ldr.w	sl, [r3]
 8010abc:	eb1a 1907 	adds.w	r9, sl, r7, lsl #4
 8010ac0:	f000 8112 	beq.w	8010ce8 <ai_platform_network_process+0x2a0>
 8010ac4:	69a3      	ldr	r3, [r4, #24]
 8010ac6:	2101      	movs	r1, #1
 8010ac8:	4630      	mov	r0, r6
 8010aca:	685d      	ldr	r5, [r3, #4]
 8010acc:	f7ff fc72 	bl	80103b4 <ai_buffer_get_size>
 8010ad0:	4285      	cmp	r5, r0
 8010ad2:	f0c0 8115 	bcc.w	8010d00 <ai_platform_network_process+0x2b8>
 8010ad6:	68e0      	ldr	r0, [r4, #12]
 8010ad8:	69b1      	ldr	r1, [r6, #24]
 8010ada:	68c2      	ldr	r2, [r0, #12]
 8010adc:	68cb      	ldr	r3, [r1, #12]
 8010ade:	429a      	cmp	r2, r3
 8010ae0:	f040 810e 	bne.w	8010d00 <ai_platform_network_process+0x2b8>
 8010ae4:	6882      	ldr	r2, [r0, #8]
 8010ae6:	688b      	ldr	r3, [r1, #8]
 8010ae8:	429a      	cmp	r2, r3
 8010aea:	f040 8109 	bne.w	8010d00 <ai_platform_network_process+0x2b8>
 8010aee:	6842      	ldr	r2, [r0, #4]
 8010af0:	684b      	ldr	r3, [r1, #4]
 8010af2:	429a      	cmp	r2, r3
 8010af4:	f040 8104 	bne.w	8010d00 <ai_platform_network_process+0x2b8>
 8010af8:	69a3      	ldr	r3, [r4, #24]
 8010afa:	e9d3 0100 	ldrd	r0, r1, [r3]
 8010afe:	f006 f8f7 	bl	8016cf0 <ai_array_get_data_byte_size>
 8010b02:	4605      	mov	r5, r0
 8010b04:	4620      	mov	r0, r4
 8010b06:	f006 f90b 	bl	8016d20 <get_tensor_byte_size>
 8010b0a:	4285      	cmp	r5, r0
 8010b0c:	f0c0 80f8 	bcc.w	8010d00 <ai_platform_network_process+0x2b8>
 8010b10:	69a3      	ldr	r3, [r4, #24]
 8010b12:	6818      	ldr	r0, [r3, #0]
 8010b14:	f006 f854 	bl	8016bc0 <ai_array_to_buffer_fmt>
 8010b18:	6833      	ldr	r3, [r6, #0]
 8010b1a:	4058      	eors	r0, r3
 8010b1c:	f030 407e 	bics.w	r0, r0, #4261412864	@ 0xfe000000
 8010b20:	f040 81a4 	bne.w	8010e6c <ai_platform_network_process+0x424>
 8010b24:	6873      	ldr	r3, [r6, #4]
 8010b26:	2b00      	cmp	r3, #0
 8010b28:	f000 80de 	beq.w	8010ce8 <ai_platform_network_process+0x2a0>
 8010b2c:	69b3      	ldr	r3, [r6, #24]
 8010b2e:	681b      	ldr	r3, [r3, #0]
 8010b30:	2b00      	cmp	r3, #0
 8010b32:	f000 81a4 	beq.w	8010e7e <ai_platform_network_process+0x436>
 8010b36:	9a01      	ldr	r2, [sp, #4]
 8010b38:	4620      	mov	r0, r4
 8010b3a:	3701      	adds	r7, #1
 8010b3c:	361c      	adds	r6, #28
 8010b3e:	429a      	cmp	r2, r3
 8010b40:	bf38      	it	cc
 8010b42:	461a      	movcc	r2, r3
 8010b44:	9201      	str	r2, [sp, #4]
 8010b46:	f006 f8eb 	bl	8016d20 <get_tensor_byte_size>
 8010b4a:	f8c9 0008 	str.w	r0, [r9, #8]
 8010b4e:	f856 3c04 	ldr.w	r3, [r6, #-4]
 8010b52:	681b      	ldr	r3, [r3, #0]
 8010b54:	fb00 f303 	mul.w	r3, r0, r3
 8010b58:	f8c9 300c 	str.w	r3, [r9, #12]
 8010b5c:	f856 1c18 	ldr.w	r1, [r6, #-24]
 8010b60:	440b      	add	r3, r1
 8010b62:	f8c9 1004 	str.w	r1, [r9, #4]
 8010b66:	f84a 300b 	str.w	r3, [sl, fp]
 8010b6a:	69a0      	ldr	r0, [r4, #24]
 8010b6c:	6803      	ldr	r3, [r0, #0]
 8010b6e:	009a      	lsls	r2, r3, #2
 8010b70:	f100 80af 	bmi.w	8010cd2 <ai_platform_network_process+0x28a>
 8010b74:	e9d0 3202 	ldrd	r3, r2, [r0, #8]
 8010b78:	1a9b      	subs	r3, r3, r2
 8010b7a:	4419      	add	r1, r3
 8010b7c:	6081      	str	r1, [r0, #8]
 8010b7e:	69a3      	ldr	r3, [r4, #24]
 8010b80:	f8d9 2004 	ldr.w	r2, [r9, #4]
 8010b84:	60da      	str	r2, [r3, #12]
 8010b86:	f8b8 3000 	ldrh.w	r3, [r8]
 8010b8a:	42bb      	cmp	r3, r7
 8010b8c:	d888      	bhi.n	8010aa0 <ai_platform_network_process+0x58>
 8010b8e:	9d03      	ldr	r5, [sp, #12]
 8010b90:	9b02      	ldr	r3, [sp, #8]
 8010b92:	8e2a      	ldrh	r2, [r5, #48]	@ 0x30
 8010b94:	2b00      	cmp	r3, #0
 8010b96:	f000 817b 	beq.w	8010e90 <ai_platform_network_process+0x448>
 8010b9a:	2a01      	cmp	r2, #1
 8010b9c:	f240 80bd 	bls.w	8010d1a <ai_platform_network_process+0x2d2>
 8010ba0:	f8d5 9034 	ldr.w	r9, [r5, #52]	@ 0x34
 8010ba4:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8010ba8:	2b00      	cmp	r3, #0
 8010baa:	f000 80b6 	beq.w	8010d1a <ai_platform_network_process+0x2d2>
 8010bae:	2700      	movs	r7, #0
 8010bb0:	f8dd b008 	ldr.w	fp, [sp, #8]
 8010bb4:	9502      	str	r5, [sp, #8]
 8010bb6:	f8d9 3010 	ldr.w	r3, [r9, #16]
 8010bba:	2b00      	cmp	r3, #0
 8010bbc:	f000 80bd 	beq.w	8010d3a <ai_platform_network_process+0x2f2>
 8010bc0:	f853 6027 	ldr.w	r6, [r3, r7, lsl #2]
 8010bc4:	2e00      	cmp	r6, #0
 8010bc6:	f000 80b8 	beq.w	8010d3a <ai_platform_network_process+0x2f2>
 8010bca:	f8d9 3014 	ldr.w	r3, [r9, #20]
 8010bce:	ea4f 1a07 	mov.w	sl, r7, lsl #4
 8010bd2:	681c      	ldr	r4, [r3, #0]
 8010bd4:	eb14 1807 	adds.w	r8, r4, r7, lsl #4
 8010bd8:	f000 8170 	beq.w	8010ebc <ai_platform_network_process+0x474>
 8010bdc:	69b3      	ldr	r3, [r6, #24]
 8010bde:	2101      	movs	r1, #1
 8010be0:	4658      	mov	r0, fp
 8010be2:	685d      	ldr	r5, [r3, #4]
 8010be4:	f7ff fbe6 	bl	80103b4 <ai_buffer_get_size>
 8010be8:	4285      	cmp	r5, r0
 8010bea:	f0c0 8095 	bcc.w	8010d18 <ai_platform_network_process+0x2d0>
 8010bee:	68f0      	ldr	r0, [r6, #12]
 8010bf0:	f8db 1018 	ldr.w	r1, [fp, #24]
 8010bf4:	68c2      	ldr	r2, [r0, #12]
 8010bf6:	68cb      	ldr	r3, [r1, #12]
 8010bf8:	429a      	cmp	r2, r3
 8010bfa:	f040 808d 	bne.w	8010d18 <ai_platform_network_process+0x2d0>
 8010bfe:	6882      	ldr	r2, [r0, #8]
 8010c00:	688b      	ldr	r3, [r1, #8]
 8010c02:	429a      	cmp	r2, r3
 8010c04:	f040 8088 	bne.w	8010d18 <ai_platform_network_process+0x2d0>
 8010c08:	6842      	ldr	r2, [r0, #4]
 8010c0a:	684b      	ldr	r3, [r1, #4]
 8010c0c:	429a      	cmp	r2, r3
 8010c0e:	f040 8083 	bne.w	8010d18 <ai_platform_network_process+0x2d0>
 8010c12:	69b3      	ldr	r3, [r6, #24]
 8010c14:	e9d3 0100 	ldrd	r0, r1, [r3]
 8010c18:	f006 f86a 	bl	8016cf0 <ai_array_get_data_byte_size>
 8010c1c:	9003      	str	r0, [sp, #12]
 8010c1e:	4630      	mov	r0, r6
 8010c20:	f006 f87e 	bl	8016d20 <get_tensor_byte_size>
 8010c24:	9b03      	ldr	r3, [sp, #12]
 8010c26:	4283      	cmp	r3, r0
 8010c28:	d376      	bcc.n	8010d18 <ai_platform_network_process+0x2d0>
 8010c2a:	69b3      	ldr	r3, [r6, #24]
 8010c2c:	6818      	ldr	r0, [r3, #0]
 8010c2e:	f005 ffc7 	bl	8016bc0 <ai_array_to_buffer_fmt>
 8010c32:	f8db 3000 	ldr.w	r3, [fp]
 8010c36:	4058      	eors	r0, r3
 8010c38:	f030 407e 	bics.w	r0, r0, #4261412864	@ 0xfe000000
 8010c3c:	f040 812c 	bne.w	8010e98 <ai_platform_network_process+0x450>
 8010c40:	f8db 3004 	ldr.w	r3, [fp, #4]
 8010c44:	2b00      	cmp	r3, #0
 8010c46:	f000 8139 	beq.w	8010ebc <ai_platform_network_process+0x474>
 8010c4a:	f8db 3018 	ldr.w	r3, [fp, #24]
 8010c4e:	681b      	ldr	r3, [r3, #0]
 8010c50:	2b00      	cmp	r3, #0
 8010c52:	f000 812a 	beq.w	8010eaa <ai_platform_network_process+0x462>
 8010c56:	9a01      	ldr	r2, [sp, #4]
 8010c58:	4630      	mov	r0, r6
 8010c5a:	3701      	adds	r7, #1
 8010c5c:	f10b 0b1c 	add.w	fp, fp, #28
 8010c60:	429a      	cmp	r2, r3
 8010c62:	bf38      	it	cc
 8010c64:	461a      	movcc	r2, r3
 8010c66:	9201      	str	r2, [sp, #4]
 8010c68:	f006 f85a 	bl	8016d20 <get_tensor_byte_size>
 8010c6c:	f8c8 0008 	str.w	r0, [r8, #8]
 8010c70:	f85b 3c04 	ldr.w	r3, [fp, #-4]
 8010c74:	681b      	ldr	r3, [r3, #0]
 8010c76:	fb00 f303 	mul.w	r3, r0, r3
 8010c7a:	f8c8 300c 	str.w	r3, [r8, #12]
 8010c7e:	f85b 1c18 	ldr.w	r1, [fp, #-24]
 8010c82:	440b      	add	r3, r1
 8010c84:	f8c8 1004 	str.w	r1, [r8, #4]
 8010c88:	f844 300a 	str.w	r3, [r4, sl]
 8010c8c:	69b0      	ldr	r0, [r6, #24]
 8010c8e:	6803      	ldr	r3, [r0, #0]
 8010c90:	009b      	lsls	r3, r3, #2
 8010c92:	d44d      	bmi.n	8010d30 <ai_platform_network_process+0x2e8>
 8010c94:	e9d0 3202 	ldrd	r3, r2, [r0, #8]
 8010c98:	1a9b      	subs	r3, r3, r2
 8010c9a:	4419      	add	r1, r3
 8010c9c:	6081      	str	r1, [r0, #8]
 8010c9e:	69b3      	ldr	r3, [r6, #24]
 8010ca0:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8010ca4:	60da      	str	r2, [r3, #12]
 8010ca6:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8010caa:	42bb      	cmp	r3, r7
 8010cac:	d883      	bhi.n	8010bb6 <ai_platform_network_process+0x16e>
 8010cae:	e044      	b.n	8010d3a <ai_platform_network_process+0x2f2>
 8010cb0:	6902      	ldr	r2, [r0, #16]
 8010cb2:	6183      	str	r3, [r0, #24]
 8010cb4:	f002 0203 	and.w	r2, r2, #3
 8010cb8:	2a03      	cmp	r2, #3
 8010cba:	d016      	beq.n	8010cea <ai_platform_network_process+0x2a2>
 8010cbc:	2230      	movs	r2, #48	@ 0x30
 8010cbe:	2111      	movs	r1, #17
 8010cc0:	f105 000c 	add.w	r0, r5, #12
 8010cc4:	2400      	movs	r4, #0
 8010cc6:	f000 f90d 	bl	8010ee4 <core_set_error>
 8010cca:	4620      	mov	r0, r4
 8010ccc:	b005      	add	sp, #20
 8010cce:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8010cd2:	f8b8 3000 	ldrh.w	r3, [r8]
 8010cd6:	429f      	cmp	r7, r3
 8010cd8:	f4ff aee2 	bcc.w	8010aa0 <ai_platform_network_process+0x58>
 8010cdc:	e757      	b.n	8010b8e <ai_platform_network_process+0x146>
 8010cde:	2400      	movs	r4, #0
 8010ce0:	4620      	mov	r0, r4
 8010ce2:	b005      	add	sp, #20
 8010ce4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8010ce8:	9d03      	ldr	r5, [sp, #12]
 8010cea:	2400      	movs	r4, #0
 8010cec:	2217      	movs	r2, #23
 8010cee:	2112      	movs	r1, #18
 8010cf0:	f105 000c 	add.w	r0, r5, #12
 8010cf4:	f000 f8f6 	bl	8010ee4 <core_set_error>
 8010cf8:	4620      	mov	r0, r4
 8010cfa:	b005      	add	sp, #20
 8010cfc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8010d00:	9d03      	ldr	r5, [sp, #12]
 8010d02:	2400      	movs	r4, #0
 8010d04:	2218      	movs	r2, #24
 8010d06:	2112      	movs	r1, #18
 8010d08:	f105 000c 	add.w	r0, r5, #12
 8010d0c:	f000 f8ea 	bl	8010ee4 <core_set_error>
 8010d10:	4620      	mov	r0, r4
 8010d12:	b005      	add	sp, #20
 8010d14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8010d18:	9d02      	ldr	r5, [sp, #8]
 8010d1a:	2218      	movs	r2, #24
 8010d1c:	2113      	movs	r1, #19
 8010d1e:	f105 000c 	add.w	r0, r5, #12
 8010d22:	2400      	movs	r4, #0
 8010d24:	f000 f8de 	bl	8010ee4 <core_set_error>
 8010d28:	e7cf      	b.n	8010cca <ai_platform_network_process+0x282>
 8010d2a:	bf00      	nop
 8010d2c:	a1c00100 	.word	0xa1c00100
 8010d30:	f8b9 300c 	ldrh.w	r3, [r9, #12]
 8010d34:	429f      	cmp	r7, r3
 8010d36:	f4ff af3e 	bcc.w	8010bb6 <ai_platform_network_process+0x16e>
 8010d3a:	9d02      	ldr	r5, [sp, #8]
 8010d3c:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 8010d40:	8e2a      	ldrh	r2, [r5, #48]	@ 0x30
 8010d42:	832b      	strh	r3, [r5, #24]
 8010d44:	2a00      	cmp	r2, #0
 8010d46:	f040 808b 	bne.w	8010e60 <ai_platform_network_process+0x418>
 8010d4a:	4616      	mov	r6, r2
 8010d4c:	4617      	mov	r7, r2
 8010d4e:	8b6c      	ldrh	r4, [r5, #26]
 8010d50:	429c      	cmp	r4, r3
 8010d52:	d2ba      	bcs.n	8010cca <ai_platform_network_process+0x282>
 8010d54:	46ab      	mov	fp, r5
 8010d56:	2e00      	cmp	r6, #0
 8010d58:	d030      	beq.n	8010dbc <ai_platform_network_process+0x374>
 8010d5a:	f04f 0800 	mov.w	r8, #0
 8010d5e:	e014      	b.n	8010d8a <ai_platform_network_process+0x342>
 8010d60:	6882      	ldr	r2, [r0, #8]
 8010d62:	68c5      	ldr	r5, [r0, #12]
 8010d64:	6863      	ldr	r3, [r4, #4]
 8010d66:	1b52      	subs	r2, r2, r5
 8010d68:	4413      	add	r3, r2
 8010d6a:	6083      	str	r3, [r0, #8]
 8010d6c:	698b      	ldr	r3, [r1, #24]
 8010d6e:	6862      	ldr	r2, [r4, #4]
 8010d70:	60da      	str	r2, [r3, #12]
 8010d72:	f859 200a 	ldr.w	r2, [r9, sl]
 8010d76:	f108 0801 	add.w	r8, r8, #1
 8010d7a:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
 8010d7e:	440b      	add	r3, r1
 8010d80:	4293      	cmp	r3, r2
 8010d82:	d301      	bcc.n	8010d88 <ai_platform_network_process+0x340>
 8010d84:	68e3      	ldr	r3, [r4, #12]
 8010d86:	1ad3      	subs	r3, r2, r3
 8010d88:	6063      	str	r3, [r4, #4]
 8010d8a:	8833      	ldrh	r3, [r6, #0]
 8010d8c:	ea4f 1a08 	mov.w	sl, r8, lsl #4
 8010d90:	4543      	cmp	r3, r8
 8010d92:	d913      	bls.n	8010dbc <ai_platform_network_process+0x374>
 8010d94:	6873      	ldr	r3, [r6, #4]
 8010d96:	b18b      	cbz	r3, 8010dbc <ai_platform_network_process+0x374>
 8010d98:	f853 1028 	ldr.w	r1, [r3, r8, lsl #2]
 8010d9c:	b171      	cbz	r1, 8010dbc <ai_platform_network_process+0x374>
 8010d9e:	6988      	ldr	r0, [r1, #24]
 8010da0:	68b2      	ldr	r2, [r6, #8]
 8010da2:	6803      	ldr	r3, [r0, #0]
 8010da4:	f8d2 9000 	ldr.w	r9, [r2]
 8010da8:	009d      	lsls	r5, r3, #2
 8010daa:	eb09 1408 	add.w	r4, r9, r8, lsl #4
 8010dae:	d5d7      	bpl.n	8010d60 <ai_platform_network_process+0x318>
 8010db0:	6881      	ldr	r1, [r0, #8]
 8010db2:	68a2      	ldr	r2, [r4, #8]
 8010db4:	6860      	ldr	r0, [r4, #4]
 8010db6:	f005 fe47 	bl	8016a48 <st_int8_copy>
 8010dba:	e7da      	b.n	8010d72 <ai_platform_network_process+0x32a>
 8010dbc:	4658      	mov	r0, fp
 8010dbe:	f000 f8e7 	bl	8010f90 <ai_layers_forward_all>
 8010dc2:	2f00      	cmp	r7, #0
 8010dc4:	d03d      	beq.n	8010e42 <ai_platform_network_process+0x3fa>
 8010dc6:	2400      	movs	r4, #0
 8010dc8:	e016      	b.n	8010df8 <ai_platform_network_process+0x3b0>
 8010dca:	e9d8 3201 	ldrd	r3, r2, [r8, #4]
 8010dce:	f859 100a 	ldr.w	r1, [r9, sl]
 8010dd2:	4413      	add	r3, r2
 8010dd4:	428b      	cmp	r3, r1
 8010dd6:	d302      	bcc.n	8010dde <ai_platform_network_process+0x396>
 8010dd8:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8010ddc:	1acb      	subs	r3, r1, r3
 8010dde:	f8c8 3004 	str.w	r3, [r8, #4]
 8010de2:	6981      	ldr	r1, [r0, #24]
 8010de4:	e9d1 2502 	ldrd	r2, r5, [r1, #8]
 8010de8:	1b52      	subs	r2, r2, r5
 8010dea:	4413      	add	r3, r2
 8010dec:	608b      	str	r3, [r1, #8]
 8010dee:	6983      	ldr	r3, [r0, #24]
 8010df0:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8010df4:	60da      	str	r2, [r3, #12]
 8010df6:	3401      	adds	r4, #1
 8010df8:	883b      	ldrh	r3, [r7, #0]
 8010dfa:	42a3      	cmp	r3, r4
 8010dfc:	d921      	bls.n	8010e42 <ai_platform_network_process+0x3fa>
 8010dfe:	687b      	ldr	r3, [r7, #4]
 8010e00:	b1fb      	cbz	r3, 8010e42 <ai_platform_network_process+0x3fa>
 8010e02:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8010e06:	b1e0      	cbz	r0, 8010e42 <ai_platform_network_process+0x3fa>
 8010e08:	68ba      	ldr	r2, [r7, #8]
 8010e0a:	ea4f 1a04 	mov.w	sl, r4, lsl #4
 8010e0e:	6983      	ldr	r3, [r0, #24]
 8010e10:	f8d2 9000 	ldr.w	r9, [r2]
 8010e14:	681a      	ldr	r2, [r3, #0]
 8010e16:	eb09 1804 	add.w	r8, r9, r4, lsl #4
 8010e1a:	0092      	lsls	r2, r2, #2
 8010e1c:	d5d5      	bpl.n	8010dca <ai_platform_network_process+0x382>
 8010e1e:	6898      	ldr	r0, [r3, #8]
 8010e20:	e9d8 1201 	ldrd	r1, r2, [r8, #4]
 8010e24:	f005 fe10 	bl	8016a48 <st_int8_copy>
 8010e28:	f859 200a 	ldr.w	r2, [r9, sl]
 8010e2c:	e9d8 3101 	ldrd	r3, r1, [r8, #4]
 8010e30:	440b      	add	r3, r1
 8010e32:	4293      	cmp	r3, r2
 8010e34:	d302      	bcc.n	8010e3c <ai_platform_network_process+0x3f4>
 8010e36:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8010e3a:	1ad3      	subs	r3, r2, r3
 8010e3c:	f8c8 3004 	str.w	r3, [r8, #4]
 8010e40:	e7d9      	b.n	8010df6 <ai_platform_network_process+0x3ae>
 8010e42:	f8bb 401a 	ldrh.w	r4, [fp, #26]
 8010e46:	f8bb 3018 	ldrh.w	r3, [fp, #24]
 8010e4a:	3401      	adds	r4, #1
 8010e4c:	b2a4      	uxth	r4, r4
 8010e4e:	42a3      	cmp	r3, r4
 8010e50:	f8ab 401a 	strh.w	r4, [fp, #26]
 8010e54:	f63f af7f 	bhi.w	8010d56 <ai_platform_network_process+0x30e>
 8010e58:	4620      	mov	r0, r4
 8010e5a:	b005      	add	sp, #20
 8010e5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8010e60:	2a01      	cmp	r2, #1
 8010e62:	6b6e      	ldr	r6, [r5, #52]	@ 0x34
 8010e64:	d033      	beq.n	8010ece <ai_platform_network_process+0x486>
 8010e66:	f106 070c 	add.w	r7, r6, #12
 8010e6a:	e770      	b.n	8010d4e <ai_platform_network_process+0x306>
 8010e6c:	9d03      	ldr	r5, [sp, #12]
 8010e6e:	2219      	movs	r2, #25
 8010e70:	2112      	movs	r1, #18
 8010e72:	2400      	movs	r4, #0
 8010e74:	f105 000c 	add.w	r0, r5, #12
 8010e78:	f000 f834 	bl	8010ee4 <core_set_error>
 8010e7c:	e725      	b.n	8010cca <ai_platform_network_process+0x282>
 8010e7e:	9d03      	ldr	r5, [sp, #12]
 8010e80:	4604      	mov	r4, r0
 8010e82:	2221      	movs	r2, #33	@ 0x21
 8010e84:	2112      	movs	r1, #18
 8010e86:	f105 000c 	add.w	r0, r5, #12
 8010e8a:	f000 f82b 	bl	8010ee4 <core_set_error>
 8010e8e:	e71c      	b.n	8010cca <ai_platform_network_process+0x282>
 8010e90:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 8010e94:	832b      	strh	r3, [r5, #24]
 8010e96:	e755      	b.n	8010d44 <ai_platform_network_process+0x2fc>
 8010e98:	9d02      	ldr	r5, [sp, #8]
 8010e9a:	2219      	movs	r2, #25
 8010e9c:	2113      	movs	r1, #19
 8010e9e:	2400      	movs	r4, #0
 8010ea0:	f105 000c 	add.w	r0, r5, #12
 8010ea4:	f000 f81e 	bl	8010ee4 <core_set_error>
 8010ea8:	e70f      	b.n	8010cca <ai_platform_network_process+0x282>
 8010eaa:	9d02      	ldr	r5, [sp, #8]
 8010eac:	4604      	mov	r4, r0
 8010eae:	2221      	movs	r2, #33	@ 0x21
 8010eb0:	2113      	movs	r1, #19
 8010eb2:	f105 000c 	add.w	r0, r5, #12
 8010eb6:	f000 f815 	bl	8010ee4 <core_set_error>
 8010eba:	e706      	b.n	8010cca <ai_platform_network_process+0x282>
 8010ebc:	9d02      	ldr	r5, [sp, #8]
 8010ebe:	2217      	movs	r2, #23
 8010ec0:	2113      	movs	r1, #19
 8010ec2:	2400      	movs	r4, #0
 8010ec4:	f105 000c 	add.w	r0, r5, #12
 8010ec8:	f000 f80c 	bl	8010ee4 <core_set_error>
 8010ecc:	e6fd      	b.n	8010cca <ai_platform_network_process+0x282>
 8010ece:	2700      	movs	r7, #0
 8010ed0:	e73d      	b.n	8010d4e <ai_platform_network_process+0x306>
 8010ed2:	bf00      	nop

08010ed4 <core_init>:
 8010ed4:	2001      	movs	r0, #1
 8010ed6:	4770      	bx	lr

08010ed8 <core_get_error>:
 8010ed8:	4603      	mov	r3, r0
 8010eda:	2200      	movs	r2, #0
 8010edc:	6800      	ldr	r0, [r0, #0]
 8010ede:	601a      	str	r2, [r3, #0]
 8010ee0:	4770      	bx	lr
 8010ee2:	bf00      	nop

08010ee4 <core_set_error>:
 8010ee4:	4603      	mov	r3, r0
 8010ee6:	7800      	ldrb	r0, [r0, #0]
 8010ee8:	b108      	cbz	r0, 8010eee <core_set_error+0xa>
 8010eea:	2000      	movs	r0, #0
 8010eec:	4770      	bx	lr
 8010eee:	7019      	strb	r1, [r3, #0]
 8010ef0:	2001      	movs	r0, #1
 8010ef2:	6819      	ldr	r1, [r3, #0]
 8010ef4:	f362 211f 	bfi	r1, r2, #8, #24
 8010ef8:	6019      	str	r1, [r3, #0]
 8010efa:	4770      	bx	lr

08010efc <ai_check_custom_types>:
 8010efc:	b082      	sub	sp, #8
 8010efe:	4b12      	ldr	r3, [pc, #72]	@ (8010f48 <ai_check_custom_types+0x4c>)
 8010f00:	9301      	str	r3, [sp, #4]
 8010f02:	b118      	cbz	r0, 8010f0c <ai_check_custom_types+0x10>
 8010f04:	7803      	ldrb	r3, [r0, #0]
 8010f06:	2b03      	cmp	r3, #3
 8010f08:	d002      	beq.n	8010f10 <ai_check_custom_types+0x14>
 8010f0a:	2000      	movs	r0, #0
 8010f0c:	b002      	add	sp, #8
 8010f0e:	4770      	bx	lr
 8010f10:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8010f14:	4293      	cmp	r3, r2
 8010f16:	d004      	beq.n	8010f22 <ai_check_custom_types+0x26>
 8010f18:	2001      	movs	r0, #1
 8010f1a:	f080 0001 	eor.w	r0, r0, #1
 8010f1e:	b002      	add	sp, #8
 8010f20:	4770      	bx	lr
 8010f22:	7842      	ldrb	r2, [r0, #1]
 8010f24:	3001      	adds	r0, #1
 8010f26:	f89d 3005 	ldrb.w	r3, [sp, #5]
 8010f2a:	429a      	cmp	r2, r3
 8010f2c:	d1f4      	bne.n	8010f18 <ai_check_custom_types+0x1c>
 8010f2e:	f810 2f01 	ldrb.w	r2, [r0, #1]!
 8010f32:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8010f36:	429a      	cmp	r2, r3
 8010f38:	d1ee      	bne.n	8010f18 <ai_check_custom_types+0x1c>
 8010f3a:	7842      	ldrb	r2, [r0, #1]
 8010f3c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8010f40:	429a      	cmp	r2, r3
 8010f42:	d1e9      	bne.n	8010f18 <ai_check_custom_types+0x1c>
 8010f44:	2000      	movs	r0, #0
 8010f46:	e7e8      	b.n	8010f1a <ai_check_custom_types+0x1e>
 8010f48:	84048403 	.word	0x84048403

08010f4c <ai_layers_init_all>:
 8010f4c:	2100      	movs	r1, #0
 8010f4e:	6b83      	ldr	r3, [r0, #56]	@ 0x38
 8010f50:	b13b      	cbz	r3, 8010f62 <ai_layers_init_all+0x16>
 8010f52:	691a      	ldr	r2, [r3, #16]
 8010f54:	3101      	adds	r1, #1
 8010f56:	60d8      	str	r0, [r3, #12]
 8010f58:	429a      	cmp	r2, r3
 8010f5a:	4613      	mov	r3, r2
 8010f5c:	d001      	beq.n	8010f62 <ai_layers_init_all+0x16>
 8010f5e:	2a00      	cmp	r2, #0
 8010f60:	d1f6      	bne.n	8010f50 <ai_layers_init_all+0x4>
 8010f62:	4608      	mov	r0, r1
 8010f64:	4770      	bx	lr
 8010f66:	bf00      	nop

08010f68 <ai_layers_post_init_all>:
 8010f68:	b538      	push	{r3, r4, r5, lr}
 8010f6a:	2500      	movs	r5, #0
 8010f6c:	6b84      	ldr	r4, [r0, #56]	@ 0x38
 8010f6e:	b16c      	cbz	r4, 8010f8c <ai_layers_post_init_all+0x24>
 8010f70:	6863      	ldr	r3, [r4, #4]
 8010f72:	07db      	lsls	r3, r3, #31
 8010f74:	d504      	bpl.n	8010f80 <ai_layers_post_init_all+0x18>
 8010f76:	6a23      	ldr	r3, [r4, #32]
 8010f78:	4620      	mov	r0, r4
 8010f7a:	b10b      	cbz	r3, 8010f80 <ai_layers_post_init_all+0x18>
 8010f7c:	3501      	adds	r5, #1
 8010f7e:	4798      	blx	r3
 8010f80:	6923      	ldr	r3, [r4, #16]
 8010f82:	42a3      	cmp	r3, r4
 8010f84:	461c      	mov	r4, r3
 8010f86:	d001      	beq.n	8010f8c <ai_layers_post_init_all+0x24>
 8010f88:	2b00      	cmp	r3, #0
 8010f8a:	d1f0      	bne.n	8010f6e <ai_layers_post_init_all+0x6>
 8010f8c:	4628      	mov	r0, r5
 8010f8e:	bd38      	pop	{r3, r4, r5, pc}

08010f90 <ai_layers_forward_all>:
 8010f90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8010f94:	f8d0 8040 	ldr.w	r8, [r0, #64]	@ 0x40
 8010f98:	4604      	mov	r4, r0
 8010f9a:	f1b8 0f00 	cmp.w	r8, #0
 8010f9e:	d02a      	beq.n	8010ff6 <ai_layers_forward_all+0x66>
 8010fa0:	6b81      	ldr	r1, [r0, #56]	@ 0x38
 8010fa2:	63c1      	str	r1, [r0, #60]	@ 0x3c
 8010fa4:	b319      	cbz	r1, 8010fee <ai_layers_forward_all+0x5e>
 8010fa6:	6c42      	ldr	r2, [r0, #68]	@ 0x44
 8010fa8:	2001      	movs	r0, #1
 8010faa:	47c0      	blx	r8
 8010fac:	6be6      	ldr	r6, [r4, #60]	@ 0x3c
 8010fae:	b1f6      	cbz	r6, 8010fee <ai_layers_forward_all+0x5e>
 8010fb0:	2700      	movs	r7, #0
 8010fb2:	4631      	mov	r1, r6
 8010fb4:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 8010fb6:	2002      	movs	r0, #2
 8010fb8:	47c0      	blx	r8
 8010fba:	6be5      	ldr	r5, [r4, #60]	@ 0x3c
 8010fbc:	4628      	mov	r0, r5
 8010fbe:	696b      	ldr	r3, [r5, #20]
 8010fc0:	4798      	blx	r3
 8010fc2:	692e      	ldr	r6, [r5, #16]
 8010fc4:	2003      	movs	r0, #3
 8010fc6:	6c62      	ldr	r2, [r4, #68]	@ 0x44
 8010fc8:	42b5      	cmp	r5, r6
 8010fca:	6be1      	ldr	r1, [r4, #60]	@ 0x3c
 8010fcc:	d007      	beq.n	8010fde <ai_layers_forward_all+0x4e>
 8010fce:	47c0      	blx	r8
 8010fd0:	3701      	adds	r7, #1
 8010fd2:	63e6      	str	r6, [r4, #60]	@ 0x3c
 8010fd4:	2e00      	cmp	r6, #0
 8010fd6:	d1ec      	bne.n	8010fb2 <ai_layers_forward_all+0x22>
 8010fd8:	4638      	mov	r0, r7
 8010fda:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8010fde:	2003      	movs	r0, #3
 8010fe0:	3701      	adds	r7, #1
 8010fe2:	47c0      	blx	r8
 8010fe4:	2300      	movs	r3, #0
 8010fe6:	4638      	mov	r0, r7
 8010fe8:	63e3      	str	r3, [r4, #60]	@ 0x3c
 8010fea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8010fee:	2700      	movs	r7, #0
 8010ff0:	4638      	mov	r0, r7
 8010ff2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8010ff6:	6b85      	ldr	r5, [r0, #56]	@ 0x38
 8010ff8:	63c5      	str	r5, [r0, #60]	@ 0x3c
 8010ffa:	2d00      	cmp	r5, #0
 8010ffc:	d0f7      	beq.n	8010fee <ai_layers_forward_all+0x5e>
 8010ffe:	4647      	mov	r7, r8
 8011000:	696b      	ldr	r3, [r5, #20]
 8011002:	4628      	mov	r0, r5
 8011004:	4798      	blx	r3
 8011006:	462b      	mov	r3, r5
 8011008:	692d      	ldr	r5, [r5, #16]
 801100a:	429d      	cmp	r5, r3
 801100c:	d004      	beq.n	8011018 <ai_layers_forward_all+0x88>
 801100e:	3701      	adds	r7, #1
 8011010:	63e5      	str	r5, [r4, #60]	@ 0x3c
 8011012:	2d00      	cmp	r5, #0
 8011014:	d1f4      	bne.n	8011000 <ai_layers_forward_all+0x70>
 8011016:	e7df      	b.n	8010fd8 <ai_layers_forward_all+0x48>
 8011018:	2300      	movs	r3, #0
 801101a:	3701      	adds	r7, #1
 801101c:	63e3      	str	r3, [r4, #60]	@ 0x3c
 801101e:	e7db      	b.n	8010fd8 <ai_layers_forward_all+0x48>

08011020 <forward_dense>:
 8011020:	6982      	ldr	r2, [r0, #24]
 8011022:	8813      	ldrh	r3, [r2, #0]
 8011024:	2b00      	cmp	r3, #0
 8011026:	d043      	beq.n	80110b0 <forward_dense+0x90>
 8011028:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801102c:	6855      	ldr	r5, [r2, #4]
 801102e:	b08e      	sub	sp, #56	@ 0x38
 8011030:	6869      	ldr	r1, [r5, #4]
 8011032:	b101      	cbz	r1, 8011036 <forward_dense+0x16>
 8011034:	6809      	ldr	r1, [r1, #0]
 8011036:	2b01      	cmp	r3, #1
 8011038:	d069      	beq.n	801110e <forward_dense+0xee>
 801103a:	692a      	ldr	r2, [r5, #16]
 801103c:	b102      	cbz	r2, 8011040 <forward_dense+0x20>
 801103e:	6812      	ldr	r2, [r2, #0]
 8011040:	2b02      	cmp	r3, #2
 8011042:	d061      	beq.n	8011108 <forward_dense+0xe8>
 8011044:	69ec      	ldr	r4, [r5, #28]
 8011046:	2c00      	cmp	r4, #0
 8011048:	d057      	beq.n	80110fa <forward_dense+0xda>
 801104a:	8b2e      	ldrh	r6, [r5, #24]
 801104c:	6820      	ldr	r0, [r4, #0]
 801104e:	2e01      	cmp	r6, #1
 8011050:	d955      	bls.n	80110fe <forward_dense+0xde>
 8011052:	6864      	ldr	r4, [r4, #4]
 8011054:	f8d0 9018 	ldr.w	r9, [r0, #24]
 8011058:	2b03      	cmp	r3, #3
 801105a:	68d0      	ldr	r0, [r2, #12]
 801105c:	68cf      	ldr	r7, [r1, #12]
 801105e:	f8d0 e004 	ldr.w	lr, [r0, #4]
 8011062:	f8d7 a004 	ldr.w	sl, [r7, #4]
 8011066:	e9d0 7602 	ldrd	r7, r6, [r0, #8]
 801106a:	f8d9 0000 	ldr.w	r0, [r9]
 801106e:	fb06 f807 	mul.w	r8, r6, r7
 8011072:	f020 4c7e 	bic.w	ip, r0, #4261412864	@ 0xfe000000
 8011076:	d044      	beq.n	8011102 <forward_dense+0xe2>
 8011078:	6aad      	ldr	r5, [r5, #40]	@ 0x28
 801107a:	b11d      	cbz	r5, 8011084 <forward_dense+0x64>
 801107c:	682d      	ldr	r5, [r5, #0]
 801107e:	b10d      	cbz	r5, 8011084 <forward_dense+0x64>
 8011080:	69ab      	ldr	r3, [r5, #24]
 8011082:	689d      	ldr	r5, [r3, #8]
 8011084:	6992      	ldr	r2, [r2, #24]
 8011086:	698b      	ldr	r3, [r1, #24]
 8011088:	6890      	ldr	r0, [r2, #8]
 801108a:	6899      	ldr	r1, [r3, #8]
 801108c:	b10c      	cbz	r4, 8011092 <forward_dense+0x72>
 801108e:	69a3      	ldr	r3, [r4, #24]
 8011090:	689c      	ldr	r4, [r3, #8]
 8011092:	4b20      	ldr	r3, [pc, #128]	@ (8011114 <forward_dense+0xf4>)
 8011094:	459c      	cmp	ip, r3
 8011096:	e9d9 2902 	ldrd	r2, r9, [r9, #8]
 801109a:	d023      	beq.n	80110e4 <forward_dense+0xc4>
 801109c:	4e1e      	ldr	r6, [pc, #120]	@ (8011118 <forward_dense+0xf8>)
 801109e:	45b4      	cmp	ip, r6
 80110a0:	d015      	beq.n	80110ce <forward_dense+0xae>
 80110a2:	f5a3 039c 	sub.w	r3, r3, #5111808	@ 0x4e0000
 80110a6:	459c      	cmp	ip, r3
 80110a8:	d004      	beq.n	80110b4 <forward_dense+0x94>
 80110aa:	b00e      	add	sp, #56	@ 0x38
 80110ac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80110b0:	685b      	ldr	r3, [r3, #4]
 80110b2:	deff      	udf	#255	@ 0xff
 80110b4:	e9cd 0107 	strd	r0, r1, [sp, #28]
 80110b8:	a807      	add	r0, sp, #28
 80110ba:	9209      	str	r2, [sp, #36]	@ 0x24
 80110bc:	e9cd 4a0a 	strd	r4, sl, [sp, #40]	@ 0x28
 80110c0:	e9cd e80c 	strd	lr, r8, [sp, #48]	@ 0x30
 80110c4:	f004 ff88 	bl	8015fd8 <forward_lite_dense_if32of32wf32>
 80110c8:	b00e      	add	sp, #56	@ 0x38
 80110ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80110ce:	464b      	mov	r3, r9
 80110d0:	9500      	str	r5, [sp, #0]
 80110d2:	e9cd e803 	strd	lr, r8, [sp, #12]
 80110d6:	e9cd 4a01 	strd	r4, sl, [sp, #4]
 80110da:	f005 f8db 	bl	8016294 <forward_lite_dense_if32of32wf32_lut4>
 80110de:	b00e      	add	sp, #56	@ 0x38
 80110e0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80110e4:	464b      	mov	r3, r9
 80110e6:	9500      	str	r5, [sp, #0]
 80110e8:	e9cd e803 	strd	lr, r8, [sp, #12]
 80110ec:	e9cd 4a01 	strd	r4, sl, [sp, #4]
 80110f0:	f005 f9fa 	bl	80164e8 <forward_lite_dense_if32of32wf32_lut8>
 80110f4:	b00e      	add	sp, #56	@ 0x38
 80110f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80110fa:	4620      	mov	r0, r4
 80110fc:	e7aa      	b.n	8011054 <forward_dense+0x34>
 80110fe:	2400      	movs	r4, #0
 8011100:	e7a8      	b.n	8011054 <forward_dense+0x34>
 8011102:	2300      	movs	r3, #0
 8011104:	685b      	ldr	r3, [r3, #4]
 8011106:	deff      	udf	#255	@ 0xff
 8011108:	2300      	movs	r3, #0
 801110a:	685b      	ldr	r3, [r3, #4]
 801110c:	deff      	udf	#255	@ 0xff
 801110e:	2300      	movs	r3, #0
 8011110:	685b      	ldr	r3, [r3, #4]
 8011112:	deff      	udf	#255	@ 0xff
 8011114:	00d01040 	.word	0x00d01040
 8011118:	00f01040 	.word	0x00f01040

0801111c <_array_handle_get_as_float>:
 801111c:	b508      	push	{r3, lr}
 801111e:	4b34      	ldr	r3, [pc, #208]	@ (80111f0 <_array_handle_get_as_float+0xd4>)
 8011120:	4299      	cmp	r1, r3
 8011122:	d05c      	beq.n	80111de <_array_handle_get_as_float+0xc2>
 8011124:	dc22      	bgt.n	801116c <_array_handle_get_as_float+0x50>
 8011126:	f5a3 03fc 	sub.w	r3, r3, #8257536	@ 0x7e0000
 801112a:	4299      	cmp	r1, r3
 801112c:	d05a      	beq.n	80111e4 <_array_handle_get_as_float+0xc8>
 801112e:	dd0f      	ble.n	8011150 <_array_handle_get_as_float+0x34>
 8011130:	4b30      	ldr	r3, [pc, #192]	@ (80111f4 <_array_handle_get_as_float+0xd8>)
 8011132:	4299      	cmp	r1, r3
 8011134:	d03a      	beq.n	80111ac <_array_handle_get_as_float+0x90>
 8011136:	f503 33f2 	add.w	r3, r3, #123904	@ 0x1e400
 801113a:	4299      	cmp	r1, r3
 801113c:	d133      	bne.n	80111a6 <_array_handle_get_as_float+0x8a>
 801113e:	7803      	ldrb	r3, [r0, #0]
 8011140:	eeb7 0a00 	vmov.f32	s0, #112	@ 0x3f800000  1.0
 8011144:	eddf 7a2c 	vldr	s15, [pc, #176]	@ 80111f8 <_array_handle_get_as_float+0xdc>
 8011148:	2b00      	cmp	r3, #0
 801114a:	fe07 0a80 	vseleq.f32	s0, s15, s0
 801114e:	bd08      	pop	{r3, pc}
 8011150:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
 8011154:	4299      	cmp	r1, r3
 8011156:	d030      	beq.n	80111ba <_array_handle_get_as_float+0x9e>
 8011158:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 801115c:	4299      	cmp	r1, r3
 801115e:	d122      	bne.n	80111a6 <_array_handle_get_as_float+0x8a>
 8011160:	8803      	ldrh	r3, [r0, #0]
 8011162:	ee00 3a10 	vmov	s0, r3
 8011166:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 801116a:	bd08      	pop	{r3, pc}
 801116c:	4b23      	ldr	r3, [pc, #140]	@ (80111fc <_array_handle_get_as_float+0xe0>)
 801116e:	4299      	cmp	r1, r3
 8011170:	d029      	beq.n	80111c6 <_array_handle_get_as_float+0xaa>
 8011172:	dd09      	ble.n	8011188 <_array_handle_get_as_float+0x6c>
 8011174:	4b22      	ldr	r3, [pc, #136]	@ (8011200 <_array_handle_get_as_float+0xe4>)
 8011176:	4299      	cmp	r1, r3
 8011178:	d115      	bne.n	80111a6 <_array_handle_get_as_float+0x8a>
 801117a:	e9d0 0100 	ldrd	r0, r1, [r0]
 801117e:	f7ef f9d7 	bl	8000530 <__aeabi_l2f>
 8011182:	ee00 0a10 	vmov	s0, r0
 8011186:	bd08      	pop	{r3, pc}
 8011188:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
 801118c:	4299      	cmp	r1, r3
 801118e:	d01f      	beq.n	80111d0 <_array_handle_get_as_float+0xb4>
 8011190:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8011194:	4299      	cmp	r1, r3
 8011196:	d106      	bne.n	80111a6 <_array_handle_get_as_float+0x8a>
 8011198:	f9b0 3000 	ldrsh.w	r3, [r0]
 801119c:	ee00 3a10 	vmov	s0, r3
 80111a0:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 80111a4:	bd08      	pop	{r3, pc}
 80111a6:	ed9f 0a14 	vldr	s0, [pc, #80]	@ 80111f8 <_array_handle_get_as_float+0xdc>
 80111aa:	bd08      	pop	{r3, pc}
 80111ac:	e9d0 0100 	ldrd	r0, r1, [r0]
 80111b0:	f7ef f9b6 	bl	8000520 <__aeabi_ul2f>
 80111b4:	ee00 0a10 	vmov	s0, r0
 80111b8:	bd08      	pop	{r3, pc}
 80111ba:	7803      	ldrb	r3, [r0, #0]
 80111bc:	ee00 3a10 	vmov	s0, r3
 80111c0:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 80111c4:	bd08      	pop	{r3, pc}
 80111c6:	ed90 0a00 	vldr	s0, [r0]
 80111ca:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 80111ce:	bd08      	pop	{r3, pc}
 80111d0:	f990 3000 	ldrsb.w	r3, [r0]
 80111d4:	ee00 3a10 	vmov	s0, r3
 80111d8:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 80111dc:	bd08      	pop	{r3, pc}
 80111de:	ed90 0a00 	vldr	s0, [r0]
 80111e2:	bd08      	pop	{r3, pc}
 80111e4:	ed90 0a00 	vldr	s0, [r0]
 80111e8:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 80111ec:	bd08      	pop	{r3, pc}
 80111ee:	bf00      	nop
 80111f0:	00821040 	.word	0x00821040
 80111f4:	00042040 	.word	0x00042040
 80111f8:	00000000 	.word	0x00000000
 80111fc:	00841040 	.word	0x00841040
 8011200:	00842040 	.word	0x00842040

08011204 <forward_cast>:
 8011204:	6983      	ldr	r3, [r0, #24]
 8011206:	881a      	ldrh	r2, [r3, #0]
 8011208:	2a00      	cmp	r2, #0
 801120a:	f000 816d 	beq.w	80114e8 <forward_cast+0x2e4>
 801120e:	6859      	ldr	r1, [r3, #4]
 8011210:	684b      	ldr	r3, [r1, #4]
 8011212:	2b00      	cmp	r3, #0
 8011214:	f000 81d0 	beq.w	80115b8 <forward_cast+0x3b4>
 8011218:	2a01      	cmp	r2, #1
 801121a:	681b      	ldr	r3, [r3, #0]
 801121c:	f003 86ab 	beq.w	8014f76 <forward_cast+0x3d72>
 8011220:	690a      	ldr	r2, [r1, #16]
 8011222:	2a00      	cmp	r2, #0
 8011224:	f003 86a4 	beq.w	8014f70 <forward_cast+0x3d6c>
 8011228:	6812      	ldr	r2, [r2, #0]
 801122a:	b103      	cbz	r3, 801122e <forward_cast+0x2a>
 801122c:	699b      	ldr	r3, [r3, #24]
 801122e:	2a00      	cmp	r2, #0
 8011230:	f003 869e 	beq.w	8014f70 <forward_cast+0x3d6c>
 8011234:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8011238:	ed2d 8b02 	vpush	{d8}
 801123c:	6996      	ldr	r6, [r2, #24]
 801123e:	b085      	sub	sp, #20
 8011240:	681a      	ldr	r2, [r3, #0]
 8011242:	69c7      	ldr	r7, [r0, #28]
 8011244:	f022 447e 	bic.w	r4, r2, #4261412864	@ 0xfe000000
 8011248:	4610      	mov	r0, r2
 801124a:	6832      	ldr	r2, [r6, #0]
 801124c:	f027 477e 	bic.w	r7, r7, #4261412864	@ 0xfe000000
 8011250:	f8df 82f4 	ldr.w	r8, [pc, #756]	@ 8011548 <forward_cast+0x344>
 8011254:	f3c4 2983 	ubfx	r9, r4, #10, #4
 8011258:	f022 4a7e 	bic.w	sl, r2, #4261412864	@ 0xfe000000
 801125c:	6859      	ldr	r1, [r3, #4]
 801125e:	68dd      	ldr	r5, [r3, #12]
 8011260:	f005 fd1e 	bl	8016ca0 <ai_array_get_byte_size>
 8011264:	f3ca 2383 	ubfx	r3, sl, #10, #4
 8011268:	4547      	cmp	r7, r8
 801126a:	68f6      	ldr	r6, [r6, #12]
 801126c:	eb05 0b00 	add.w	fp, r5, r0
 8011270:	9301      	str	r3, [sp, #4]
 8011272:	f000 81fd 	beq.w	8011670 <forward_cast+0x46c>
 8011276:	f300 8089 	bgt.w	801138c <forward_cast+0x188>
 801127a:	4baa      	ldr	r3, [pc, #680]	@ (8011524 <forward_cast+0x320>)
 801127c:	429f      	cmp	r7, r3
 801127e:	f000 8246 	beq.w	801170e <forward_cast+0x50a>
 8011282:	dd2c      	ble.n	80112de <forward_cast+0xda>
 8011284:	4aa8      	ldr	r2, [pc, #672]	@ (8011528 <forward_cast+0x324>)
 8011286:	4297      	cmp	r7, r2
 8011288:	d124      	bne.n	80112d4 <forward_cast+0xd0>
 801128a:	45c2      	cmp	sl, r8
 801128c:	f001 8123 	beq.w	80124d6 <forward_cast+0x12d2>
 8011290:	f300 8672 	bgt.w	8011f78 <forward_cast+0xd74>
 8011294:	459a      	cmp	sl, r3
 8011296:	f001 87a3 	beq.w	80131e0 <forward_cast+0x1fdc>
 801129a:	f300 8653 	bgt.w	8011f44 <forward_cast+0xd40>
 801129e:	4ba3      	ldr	r3, [pc, #652]	@ (801152c <forward_cast+0x328>)
 80112a0:	459a      	cmp	sl, r3
 80112a2:	f001 85c6 	beq.w	8012e32 <forward_cast+0x1c2e>
 80112a6:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80112aa:	459a      	cmp	sl, r3
 80112ac:	d112      	bne.n	80112d4 <forward_cast+0xd0>
 80112ae:	455d      	cmp	r5, fp
 80112b0:	d210      	bcs.n	80112d4 <forward_cast+0xd0>
 80112b2:	9f01      	ldr	r7, [sp, #4]
 80112b4:	4628      	mov	r0, r5
 80112b6:	4621      	mov	r1, r4
 80112b8:	f7ff ff30 	bl	801111c <_array_handle_get_as_float>
 80112bc:	eeb5 0a40 	vcmp.f32	s0, #0.0
 80112c0:	444d      	add	r5, r9
 80112c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80112c6:	bf14      	ite	ne
 80112c8:	2301      	movne	r3, #1
 80112ca:	2300      	moveq	r3, #0
 80112cc:	45ab      	cmp	fp, r5
 80112ce:	8033      	strh	r3, [r6, #0]
 80112d0:	443e      	add	r6, r7
 80112d2:	d8ef      	bhi.n	80112b4 <forward_cast+0xb0>
 80112d4:	b005      	add	sp, #20
 80112d6:	ecbd 8b02 	vpop	{d8}
 80112da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80112de:	4a93      	ldr	r2, [pc, #588]	@ (801152c <forward_cast+0x328>)
 80112e0:	4297      	cmp	r7, r2
 80112e2:	f000 8103 	beq.w	80114ec <forward_cast+0x2e8>
 80112e6:	4992      	ldr	r1, [pc, #584]	@ (8011530 <forward_cast+0x32c>)
 80112e8:	428f      	cmp	r7, r1
 80112ea:	d1f3      	bne.n	80112d4 <forward_cast+0xd0>
 80112ec:	45c2      	cmp	sl, r8
 80112ee:	f001 8033 	beq.w	8012358 <forward_cast+0x1154>
 80112f2:	f300 8780 	bgt.w	80121f6 <forward_cast+0xff2>
 80112f6:	459a      	cmp	sl, r3
 80112f8:	f002 8302 	beq.w	8013900 <forward_cast+0x26fc>
 80112fc:	4f89      	ldr	r7, [pc, #548]	@ (8011524 <forward_cast+0x320>)
 80112fe:	45ba      	cmp	sl, r7
 8011300:	f300 85de 	bgt.w	8011ec0 <forward_cast+0xcbc>
 8011304:	f8df 8224 	ldr.w	r8, [pc, #548]	@ 801152c <forward_cast+0x328>
 8011308:	45c2      	cmp	sl, r8
 801130a:	f002 82ab 	beq.w	8013864 <forward_cast+0x2660>
 801130e:	4b88      	ldr	r3, [pc, #544]	@ (8011530 <forward_cast+0x32c>)
 8011310:	459a      	cmp	sl, r3
 8011312:	d1df      	bne.n	80112d4 <forward_cast+0xd0>
 8011314:	455d      	cmp	r5, fp
 8011316:	d2dd      	bcs.n	80112d4 <forward_cast+0xd0>
 8011318:	f8df a22c 	ldr.w	sl, [pc, #556]	@ 8011548 <forward_cast+0x344>
 801131c:	4b85      	ldr	r3, [pc, #532]	@ (8011534 <forward_cast+0x330>)
 801131e:	4a86      	ldr	r2, [pc, #536]	@ (8011538 <forward_cast+0x334>)
 8011320:	e019      	b.n	8011356 <forward_cast+0x152>
 8011322:	42bc      	cmp	r4, r7
 8011324:	f003 846f 	beq.w	8014c06 <forward_cast+0x3a02>
 8011328:	f341 8165 	ble.w	80125f6 <forward_cast+0x13f2>
 801132c:	4983      	ldr	r1, [pc, #524]	@ (801153c <forward_cast+0x338>)
 801132e:	428c      	cmp	r4, r1
 8011330:	f002 879c 	beq.w	801426c <forward_cast+0x3068>
 8011334:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 8011338:	428c      	cmp	r4, r1
 801133a:	f041 83af 	bne.w	8012a9c <forward_cast+0x1898>
 801133e:	7828      	ldrb	r0, [r5, #0]
 8011340:	3800      	subs	r0, #0
 8011342:	bf18      	it	ne
 8011344:	2001      	movne	r0, #1
 8011346:	f380 0010 	usat	r0, #16, r0
 801134a:	444d      	add	r5, r9
 801134c:	9901      	ldr	r1, [sp, #4]
 801134e:	8030      	strh	r0, [r6, #0]
 8011350:	45ab      	cmp	fp, r5
 8011352:	440e      	add	r6, r1
 8011354:	d9be      	bls.n	80112d4 <forward_cast+0xd0>
 8011356:	4554      	cmp	r4, sl
 8011358:	f002 86f2 	beq.w	8014140 <forward_cast+0x2f3c>
 801135c:	dde1      	ble.n	8011322 <forward_cast+0x11e>
 801135e:	4978      	ldr	r1, [pc, #480]	@ (8011540 <forward_cast+0x33c>)
 8011360:	428c      	cmp	r4, r1
 8011362:	f002 8688 	beq.w	8014076 <forward_cast+0x2e72>
 8011366:	f341 82c5 	ble.w	80128f4 <forward_cast+0x16f0>
 801136a:	4976      	ldr	r1, [pc, #472]	@ (8011544 <forward_cast+0x340>)
 801136c:	428c      	cmp	r4, r1
 801136e:	f041 8395 	bne.w	8012a9c <forward_cast+0x1898>
 8011372:	e9d5 0100 	ldrd	r0, r1, [r5]
 8011376:	f7ef f8db 	bl	8000530 <__aeabi_l2f>
 801137a:	ee07 0a90 	vmov	s15, r0
 801137e:	4b6d      	ldr	r3, [pc, #436]	@ (8011534 <forward_cast+0x330>)
 8011380:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8011384:	4a6c      	ldr	r2, [pc, #432]	@ (8011538 <forward_cast+0x334>)
 8011386:	ee17 0a90 	vmov	r0, s15
 801138a:	e7dc      	b.n	8011346 <forward_cast+0x142>
 801138c:	4b6a      	ldr	r3, [pc, #424]	@ (8011538 <forward_cast+0x334>)
 801138e:	429f      	cmp	r7, r3
 8011390:	f000 811b 	beq.w	80115ca <forward_cast+0x3c6>
 8011394:	4a6a      	ldr	r2, [pc, #424]	@ (8011540 <forward_cast+0x33c>)
 8011396:	4297      	cmp	r7, r2
 8011398:	d14e      	bne.n	8011438 <forward_cast+0x234>
 801139a:	45c2      	cmp	sl, r8
 801139c:	f001 801d 	beq.w	80123da <forward_cast+0x11d6>
 80113a0:	f300 82f4 	bgt.w	801198c <forward_cast+0x788>
 80113a4:	4a5f      	ldr	r2, [pc, #380]	@ (8011524 <forward_cast+0x320>)
 80113a6:	4592      	cmp	sl, r2
 80113a8:	f001 8770 	beq.w	801328c <forward_cast+0x2088>
 80113ac:	f300 82aa 	bgt.w	8011904 <forward_cast+0x700>
 80113b0:	4b5e      	ldr	r3, [pc, #376]	@ (801152c <forward_cast+0x328>)
 80113b2:	459a      	cmp	sl, r3
 80113b4:	f001 84f0 	beq.w	8012d98 <forward_cast+0x1b94>
 80113b8:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80113bc:	459a      	cmp	sl, r3
 80113be:	d189      	bne.n	80112d4 <forward_cast+0xd0>
 80113c0:	455d      	cmp	r5, fp
 80113c2:	d287      	bcs.n	80112d4 <forward_cast+0xd0>
 80113c4:	f8df a180 	ldr.w	sl, [pc, #384]	@ 8011548 <forward_cast+0x344>
 80113c8:	f8df 8178 	ldr.w	r8, [pc, #376]	@ 8011544 <forward_cast+0x340>
 80113cc:	4f59      	ldr	r7, [pc, #356]	@ (8011534 <forward_cast+0x330>)
 80113ce:	4b55      	ldr	r3, [pc, #340]	@ (8011524 <forward_cast+0x320>)
 80113d0:	4a5a      	ldr	r2, [pc, #360]	@ (801153c <forward_cast+0x338>)
 80113d2:	e016      	b.n	8011402 <forward_cast+0x1fe>
 80113d4:	429c      	cmp	r4, r3
 80113d6:	f003 8044 	beq.w	8014462 <forward_cast+0x325e>
 80113da:	f341 8217 	ble.w	801280c <forward_cast+0x1608>
 80113de:	4294      	cmp	r4, r2
 80113e0:	f003 8141 	beq.w	8014666 <forward_cast+0x3462>
 80113e4:	4950      	ldr	r1, [pc, #320]	@ (8011528 <forward_cast+0x324>)
 80113e6:	428c      	cmp	r4, r1
 80113e8:	f041 8218 	bne.w	801281c <forward_cast+0x1618>
 80113ec:	7829      	ldrb	r1, [r5, #0]
 80113ee:	3900      	subs	r1, #0
 80113f0:	bf18      	it	ne
 80113f2:	2101      	movne	r1, #1
 80113f4:	444d      	add	r5, r9
 80113f6:	8031      	strh	r1, [r6, #0]
 80113f8:	9901      	ldr	r1, [sp, #4]
 80113fa:	45ab      	cmp	fp, r5
 80113fc:	440e      	add	r6, r1
 80113fe:	f67f af69 	bls.w	80112d4 <forward_cast+0xd0>
 8011402:	4554      	cmp	r4, sl
 8011404:	f003 829c 	beq.w	8014940 <forward_cast+0x373c>
 8011408:	dde4      	ble.n	80113d4 <forward_cast+0x1d0>
 801140a:	494d      	ldr	r1, [pc, #308]	@ (8011540 <forward_cast+0x33c>)
 801140c:	428c      	cmp	r4, r1
 801140e:	f002 8623 	beq.w	8014058 <forward_cast+0x2e54>
 8011412:	f341 81ae 	ble.w	8012772 <forward_cast+0x156e>
 8011416:	4544      	cmp	r4, r8
 8011418:	f041 8200 	bne.w	801281c <forward_cast+0x1618>
 801141c:	e9d5 0100 	ldrd	r0, r1, [r5]
 8011420:	f7ef f886 	bl	8000530 <__aeabi_l2f>
 8011424:	ee07 0a90 	vmov	s15, r0
 8011428:	4a44      	ldr	r2, [pc, #272]	@ (801153c <forward_cast+0x338>)
 801142a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801142e:	ee17 3a90 	vmov	r3, s15
 8011432:	b299      	uxth	r1, r3
 8011434:	4b3b      	ldr	r3, [pc, #236]	@ (8011524 <forward_cast+0x320>)
 8011436:	e7dd      	b.n	80113f4 <forward_cast+0x1f0>
 8011438:	493e      	ldr	r1, [pc, #248]	@ (8011534 <forward_cast+0x330>)
 801143a:	428f      	cmp	r7, r1
 801143c:	f47f af4a 	bne.w	80112d4 <forward_cast+0xd0>
 8011440:	45c2      	cmp	sl, r8
 8011442:	f001 8007 	beq.w	8012454 <forward_cast+0x1250>
 8011446:	f300 85df 	bgt.w	8012008 <forward_cast+0xe04>
 801144a:	4b36      	ldr	r3, [pc, #216]	@ (8011524 <forward_cast+0x320>)
 801144c:	459a      	cmp	sl, r3
 801144e:	f002 81f3 	beq.w	8013838 <forward_cast+0x2634>
 8011452:	f300 8216 	bgt.w	8011882 <forward_cast+0x67e>
 8011456:	4f35      	ldr	r7, [pc, #212]	@ (801152c <forward_cast+0x328>)
 8011458:	45ba      	cmp	sl, r7
 801145a:	f002 819f 	beq.w	801379c <forward_cast+0x2598>
 801145e:	f5a3 6300 	sub.w	r3, r3, #2048	@ 0x800
 8011462:	459a      	cmp	sl, r3
 8011464:	f47f af36 	bne.w	80112d4 <forward_cast+0xd0>
 8011468:	455d      	cmp	r5, fp
 801146a:	f4bf af33 	bcs.w	80112d4 <forward_cast+0xd0>
 801146e:	f8df a0d8 	ldr.w	sl, [pc, #216]	@ 8011548 <forward_cast+0x344>
 8011472:	f8df 80d0 	ldr.w	r8, [pc, #208]	@ 8011544 <forward_cast+0x340>
 8011476:	4b30      	ldr	r3, [pc, #192]	@ (8011538 <forward_cast+0x334>)
 8011478:	4a2a      	ldr	r2, [pc, #168]	@ (8011524 <forward_cast+0x320>)
 801147a:	e01b      	b.n	80114b4 <forward_cast+0x2b0>
 801147c:	4294      	cmp	r4, r2
 801147e:	f003 8047 	beq.w	8014510 <forward_cast+0x330c>
 8011482:	f341 81da 	ble.w	801283a <forward_cast+0x1636>
 8011486:	492d      	ldr	r1, [pc, #180]	@ (801153c <forward_cast+0x338>)
 8011488:	428c      	cmp	r4, r1
 801148a:	f003 805c 	beq.w	8014546 <forward_cast+0x3342>
 801148e:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 8011492:	428c      	cmp	r4, r1
 8011494:	f041 8314 	bne.w	8012ac0 <forward_cast+0x18bc>
 8011498:	7828      	ldrb	r0, [r5, #0]
 801149a:	3800      	subs	r0, #0
 801149c:	bf18      	it	ne
 801149e:	2001      	movne	r0, #1
 80114a0:	f300 0007 	ssat	r0, #8, r0
 80114a4:	444d      	add	r5, r9
 80114a6:	b240      	sxtb	r0, r0
 80114a8:	9901      	ldr	r1, [sp, #4]
 80114aa:	45ab      	cmp	fp, r5
 80114ac:	8030      	strh	r0, [r6, #0]
 80114ae:	440e      	add	r6, r1
 80114b0:	f67f af10 	bls.w	80112d4 <forward_cast+0xd0>
 80114b4:	4554      	cmp	r4, sl
 80114b6:	f002 879a 	beq.w	80143ee <forward_cast+0x31ea>
 80114ba:	dddf      	ble.n	801147c <forward_cast+0x278>
 80114bc:	4920      	ldr	r1, [pc, #128]	@ (8011540 <forward_cast+0x33c>)
 80114be:	428c      	cmp	r4, r1
 80114c0:	f002 848a 	beq.w	8013dd8 <forward_cast+0x2bd4>
 80114c4:	f341 8140 	ble.w	8012748 <forward_cast+0x1544>
 80114c8:	4544      	cmp	r4, r8
 80114ca:	f041 82f9 	bne.w	8012ac0 <forward_cast+0x18bc>
 80114ce:	e9d5 0100 	ldrd	r0, r1, [r5]
 80114d2:	f7ef f82d 	bl	8000530 <__aeabi_l2f>
 80114d6:	ee07 0a90 	vmov	s15, r0
 80114da:	4b17      	ldr	r3, [pc, #92]	@ (8011538 <forward_cast+0x334>)
 80114dc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80114e0:	4a10      	ldr	r2, [pc, #64]	@ (8011524 <forward_cast+0x320>)
 80114e2:	ee17 0a90 	vmov	r0, s15
 80114e6:	e7db      	b.n	80114a0 <forward_cast+0x29c>
 80114e8:	6853      	ldr	r3, [r2, #4]
 80114ea:	deff      	udf	#255	@ 0xff
 80114ec:	45c2      	cmp	sl, r8
 80114ee:	f002 82cd 	beq.w	8013a8c <forward_cast+0x2888>
 80114f2:	f300 849d 	bgt.w	8011e30 <forward_cast+0xc2c>
 80114f6:	459a      	cmp	sl, r3
 80114f8:	f002 8268 	beq.w	80139cc <forward_cast+0x27c8>
 80114fc:	f300 847f 	bgt.w	8011dfe <forward_cast+0xbfa>
 8011500:	4f0a      	ldr	r7, [pc, #40]	@ (801152c <forward_cast+0x328>)
 8011502:	45ba      	cmp	sl, r7
 8011504:	f002 824d 	beq.w	80139a2 <forward_cast+0x279e>
 8011508:	4b09      	ldr	r3, [pc, #36]	@ (8011530 <forward_cast+0x32c>)
 801150a:	459a      	cmp	sl, r3
 801150c:	f47f aee2 	bne.w	80112d4 <forward_cast+0xd0>
 8011510:	455d      	cmp	r5, fp
 8011512:	f4bf aedf 	bcs.w	80112d4 <forward_cast+0xd0>
 8011516:	f8df a030 	ldr.w	sl, [pc, #48]	@ 8011548 <forward_cast+0x344>
 801151a:	f8df 8028 	ldr.w	r8, [pc, #40]	@ 8011544 <forward_cast+0x340>
 801151e:	4b06      	ldr	r3, [pc, #24]	@ (8011538 <forward_cast+0x334>)
 8011520:	4a00      	ldr	r2, [pc, #0]	@ (8011524 <forward_cast+0x320>)
 8011522:	e02f      	b.n	8011584 <forward_cast+0x380>
 8011524:	00041040 	.word	0x00041040
 8011528:	00060440 	.word	0x00060440
 801152c:	00040440 	.word	0x00040440
 8011530:	00040840 	.word	0x00040840
 8011534:	00840440 	.word	0x00840440
 8011538:	00840840 	.word	0x00840840
 801153c:	00042040 	.word	0x00042040
 8011540:	00841040 	.word	0x00841040
 8011544:	00842040 	.word	0x00842040
 8011548:	00821040 	.word	0x00821040
 801154c:	4294      	cmp	r4, r2
 801154e:	f003 8169 	beq.w	8014824 <forward_cast+0x3620>
 8011552:	f341 80a2 	ble.w	801269a <forward_cast+0x1496>
 8011556:	49a8      	ldr	r1, [pc, #672]	@ (80117f8 <forward_cast+0x5f4>)
 8011558:	428c      	cmp	r4, r1
 801155a:	f003 8155 	beq.w	8014808 <forward_cast+0x3604>
 801155e:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 8011562:	428c      	cmp	r4, r1
 8011564:	f041 827f 	bne.w	8012a66 <forward_cast+0x1862>
 8011568:	7828      	ldrb	r0, [r5, #0]
 801156a:	3800      	subs	r0, #0
 801156c:	bf18      	it	ne
 801156e:	2001      	movne	r0, #1
 8011570:	f380 0008 	usat	r0, #8, r0
 8011574:	444d      	add	r5, r9
 8011576:	b2c0      	uxtb	r0, r0
 8011578:	9901      	ldr	r1, [sp, #4]
 801157a:	45ab      	cmp	fp, r5
 801157c:	8030      	strh	r0, [r6, #0]
 801157e:	440e      	add	r6, r1
 8011580:	f67f aea8 	bls.w	80112d4 <forward_cast+0xd0>
 8011584:	4554      	cmp	r4, sl
 8011586:	f002 8702 	beq.w	801438e <forward_cast+0x318a>
 801158a:	dddf      	ble.n	801154c <forward_cast+0x348>
 801158c:	499b      	ldr	r1, [pc, #620]	@ (80117fc <forward_cast+0x5f8>)
 801158e:	428c      	cmp	r4, r1
 8011590:	f002 8595 	beq.w	80140be <forward_cast+0x2eba>
 8011594:	f341 81d7 	ble.w	8012946 <forward_cast+0x1742>
 8011598:	4544      	cmp	r4, r8
 801159a:	f041 8264 	bne.w	8012a66 <forward_cast+0x1862>
 801159e:	e9d5 0100 	ldrd	r0, r1, [r5]
 80115a2:	f7ee ffc5 	bl	8000530 <__aeabi_l2f>
 80115a6:	ee07 0a90 	vmov	s15, r0
 80115aa:	4b95      	ldr	r3, [pc, #596]	@ (8011800 <forward_cast+0x5fc>)
 80115ac:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80115b0:	4a94      	ldr	r2, [pc, #592]	@ (8011804 <forward_cast+0x600>)
 80115b2:	ee17 0a90 	vmov	r0, s15
 80115b6:	e7db      	b.n	8011570 <forward_cast+0x36c>
 80115b8:	2a01      	cmp	r2, #1
 80115ba:	f003 84dc 	beq.w	8014f76 <forward_cast+0x3d72>
 80115be:	690a      	ldr	r2, [r1, #16]
 80115c0:	2a00      	cmp	r2, #0
 80115c2:	f003 84d5 	beq.w	8014f70 <forward_cast+0x3d6c>
 80115c6:	6812      	ldr	r2, [r2, #0]
 80115c8:	e631      	b.n	801122e <forward_cast+0x2a>
 80115ca:	45c2      	cmp	sl, r8
 80115cc:	f001 85a3 	beq.w	8013116 <forward_cast+0x1f12>
 80115d0:	f300 82f5 	bgt.w	8011bbe <forward_cast+0x9ba>
 80115d4:	4b8b      	ldr	r3, [pc, #556]	@ (8011804 <forward_cast+0x600>)
 80115d6:	459a      	cmp	sl, r3
 80115d8:	f002 8081 	beq.w	80136de <forward_cast+0x24da>
 80115dc:	f300 8218 	bgt.w	8011a10 <forward_cast+0x80c>
 80115e0:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
 80115e4:	459a      	cmp	sl, r3
 80115e6:	f002 8028 	beq.w	801363a <forward_cast+0x2436>
 80115ea:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80115ee:	459a      	cmp	sl, r3
 80115f0:	f47f ae70 	bne.w	80112d4 <forward_cast+0xd0>
 80115f4:	455d      	cmp	r5, fp
 80115f6:	f4bf ae6d 	bcs.w	80112d4 <forward_cast+0xd0>
 80115fa:	f8df a220 	ldr.w	sl, [pc, #544]	@ 801181c <forward_cast+0x618>
 80115fe:	f8df 8218 	ldr.w	r8, [pc, #536]	@ 8011818 <forward_cast+0x614>
 8011602:	4f81      	ldr	r7, [pc, #516]	@ (8011808 <forward_cast+0x604>)
 8011604:	4b7f      	ldr	r3, [pc, #508]	@ (8011804 <forward_cast+0x600>)
 8011606:	4a7c      	ldr	r2, [pc, #496]	@ (80117f8 <forward_cast+0x5f4>)
 8011608:	e018      	b.n	801163c <forward_cast+0x438>
 801160a:	429c      	cmp	r4, r3
 801160c:	f003 832e 	beq.w	8014c6c <forward_cast+0x3a68>
 8011610:	f340 87e5 	ble.w	80125de <forward_cast+0x13da>
 8011614:	4294      	cmp	r4, r2
 8011616:	f003 8311 	beq.w	8014c3c <forward_cast+0x3a38>
 801161a:	497c      	ldr	r1, [pc, #496]	@ (801180c <forward_cast+0x608>)
 801161c:	428c      	cmp	r4, r1
 801161e:	f041 823a 	bne.w	8012a96 <forward_cast+0x1892>
 8011622:	7828      	ldrb	r0, [r5, #0]
 8011624:	3800      	subs	r0, #0
 8011626:	bf18      	it	ne
 8011628:	2001      	movne	r0, #1
 801162a:	f300 000f 	ssat	r0, #16, r0
 801162e:	444d      	add	r5, r9
 8011630:	9901      	ldr	r1, [sp, #4]
 8011632:	8030      	strh	r0, [r6, #0]
 8011634:	45ab      	cmp	fp, r5
 8011636:	440e      	add	r6, r1
 8011638:	f67f ae4c 	bls.w	80112d4 <forward_cast+0xd0>
 801163c:	4554      	cmp	r4, sl
 801163e:	f002 84d7 	beq.w	8013ff0 <forward_cast+0x2dec>
 8011642:	dde2      	ble.n	801160a <forward_cast+0x406>
 8011644:	496d      	ldr	r1, [pc, #436]	@ (80117fc <forward_cast+0x5f8>)
 8011646:	428c      	cmp	r4, r1
 8011648:	f002 83a8 	beq.w	8013d9c <forward_cast+0x2b98>
 801164c:	f341 8146 	ble.w	80128dc <forward_cast+0x16d8>
 8011650:	4544      	cmp	r4, r8
 8011652:	f041 8220 	bne.w	8012a96 <forward_cast+0x1892>
 8011656:	e9d5 0100 	ldrd	r0, r1, [r5]
 801165a:	f7ee ff69 	bl	8000530 <__aeabi_l2f>
 801165e:	ee07 0a90 	vmov	s15, r0
 8011662:	4b68      	ldr	r3, [pc, #416]	@ (8011804 <forward_cast+0x600>)
 8011664:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8011668:	4a63      	ldr	r2, [pc, #396]	@ (80117f8 <forward_cast+0x5f4>)
 801166a:	ee17 0a90 	vmov	r0, s15
 801166e:	e7dc      	b.n	801162a <forward_cast+0x426>
 8011670:	45ba      	cmp	sl, r7
 8011672:	f001 827d 	beq.w	8012b70 <forward_cast+0x196c>
 8011676:	f300 80b0 	bgt.w	80117da <forward_cast+0x5d6>
 801167a:	f8df 8188 	ldr.w	r8, [pc, #392]	@ 8011804 <forward_cast+0x600>
 801167e:	45c2      	cmp	sl, r8
 8011680:	f001 878f 	beq.w	80135a2 <forward_cast+0x239e>
 8011684:	f300 8093 	bgt.w	80117ae <forward_cast+0x5aa>
 8011688:	4a61      	ldr	r2, [pc, #388]	@ (8011810 <forward_cast+0x60c>)
 801168a:	4592      	cmp	sl, r2
 801168c:	f001 873c 	beq.w	8013508 <forward_cast+0x2304>
 8011690:	4b60      	ldr	r3, [pc, #384]	@ (8011814 <forward_cast+0x610>)
 8011692:	459a      	cmp	sl, r3
 8011694:	f47f ae1e 	bne.w	80112d4 <forward_cast+0xd0>
 8011698:	455d      	cmp	r5, fp
 801169a:	f4bf ae1b 	bcs.w	80112d4 <forward_cast+0xd0>
 801169e:	f8df a15c 	ldr.w	sl, [pc, #348]	@ 80117fc <forward_cast+0x5f8>
 80116a2:	4b59      	ldr	r3, [pc, #356]	@ (8011808 <forward_cast+0x604>)
 80116a4:	e018      	b.n	80116d8 <forward_cast+0x4d4>
 80116a6:	4544      	cmp	r4, r8
 80116a8:	f003 80e2 	beq.w	8014870 <forward_cast+0x366c>
 80116ac:	f340 87c2 	ble.w	8012634 <forward_cast+0x1430>
 80116b0:	4951      	ldr	r1, [pc, #324]	@ (80117f8 <forward_cast+0x5f4>)
 80116b2:	428c      	cmp	r4, r1
 80116b4:	f003 80cd 	beq.w	8014852 <forward_cast+0x364e>
 80116b8:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 80116bc:	428c      	cmp	r4, r1
 80116be:	f041 813f 	bne.w	8012940 <forward_cast+0x173c>
 80116c2:	7829      	ldrb	r1, [r5, #0]
 80116c4:	3900      	subs	r1, #0
 80116c6:	bf18      	it	ne
 80116c8:	2101      	movne	r1, #1
 80116ca:	444d      	add	r5, r9
 80116cc:	8031      	strh	r1, [r6, #0]
 80116ce:	9901      	ldr	r1, [sp, #4]
 80116d0:	45ab      	cmp	fp, r5
 80116d2:	440e      	add	r6, r1
 80116d4:	f67f adfe 	bls.w	80112d4 <forward_cast+0xd0>
 80116d8:	42bc      	cmp	r4, r7
 80116da:	f002 8544 	beq.w	8014166 <forward_cast+0x2f62>
 80116de:	dde2      	ble.n	80116a6 <forward_cast+0x4a2>
 80116e0:	4554      	cmp	r4, sl
 80116e2:	f002 833c 	beq.w	8013d5e <forward_cast+0x2b5a>
 80116e6:	f341 8124 	ble.w	8012932 <forward_cast+0x172e>
 80116ea:	494b      	ldr	r1, [pc, #300]	@ (8011818 <forward_cast+0x614>)
 80116ec:	428c      	cmp	r4, r1
 80116ee:	f041 8127 	bne.w	8012940 <forward_cast+0x173c>
 80116f2:	e9d5 0100 	ldrd	r0, r1, [r5]
 80116f6:	f7ee ff1b 	bl	8000530 <__aeabi_l2f>
 80116fa:	ee07 0a90 	vmov	s15, r0
 80116fe:	4a44      	ldr	r2, [pc, #272]	@ (8011810 <forward_cast+0x60c>)
 8011700:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8011704:	ee17 3a90 	vmov	r3, s15
 8011708:	b299      	uxth	r1, r3
 801170a:	4b3f      	ldr	r3, [pc, #252]	@ (8011808 <forward_cast+0x604>)
 801170c:	e7dd      	b.n	80116ca <forward_cast+0x4c6>
 801170e:	45c2      	cmp	sl, r8
 8011710:	f001 82e9 	beq.w	8012ce6 <forward_cast+0x1ae2>
 8011714:	f300 8215 	bgt.w	8011b42 <forward_cast+0x93e>
 8011718:	45ba      	cmp	sl, r7
 801171a:	f001 8698 	beq.w	801344e <forward_cast+0x224a>
 801171e:	f300 81bb 	bgt.w	8011a98 <forward_cast+0x894>
 8011722:	4b3b      	ldr	r3, [pc, #236]	@ (8011810 <forward_cast+0x60c>)
 8011724:	459a      	cmp	sl, r3
 8011726:	f001 8645 	beq.w	80133b4 <forward_cast+0x21b0>
 801172a:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 801172e:	459a      	cmp	sl, r3
 8011730:	f47f add0 	bne.w	80112d4 <forward_cast+0xd0>
 8011734:	455d      	cmp	r5, fp
 8011736:	f4bf adcd 	bcs.w	80112d4 <forward_cast+0xd0>
 801173a:	f8df a0e0 	ldr.w	sl, [pc, #224]	@ 801181c <forward_cast+0x618>
 801173e:	f8df 80d8 	ldr.w	r8, [pc, #216]	@ 8011818 <forward_cast+0x614>
 8011742:	4f31      	ldr	r7, [pc, #196]	@ (8011808 <forward_cast+0x604>)
 8011744:	4b2f      	ldr	r3, [pc, #188]	@ (8011804 <forward_cast+0x600>)
 8011746:	4a2c      	ldr	r2, [pc, #176]	@ (80117f8 <forward_cast+0x5f4>)
 8011748:	e016      	b.n	8011778 <forward_cast+0x574>
 801174a:	429c      	cmp	r4, r3
 801174c:	f002 86b2 	beq.w	80144b4 <forward_cast+0x32b0>
 8011750:	f341 8047 	ble.w	80127e2 <forward_cast+0x15de>
 8011754:	4294      	cmp	r4, r2
 8011756:	f002 869e 	beq.w	8014496 <forward_cast+0x3292>
 801175a:	492c      	ldr	r1, [pc, #176]	@ (801180c <forward_cast+0x608>)
 801175c:	428c      	cmp	r4, r1
 801175e:	f041 8052 	bne.w	8012806 <forward_cast+0x1602>
 8011762:	7829      	ldrb	r1, [r5, #0]
 8011764:	3900      	subs	r1, #0
 8011766:	bf18      	it	ne
 8011768:	2101      	movne	r1, #1
 801176a:	444d      	add	r5, r9
 801176c:	8031      	strh	r1, [r6, #0]
 801176e:	9901      	ldr	r1, [sp, #4]
 8011770:	45ab      	cmp	fp, r5
 8011772:	440e      	add	r6, r1
 8011774:	f67f adae 	bls.w	80112d4 <forward_cast+0xd0>
 8011778:	4554      	cmp	r4, sl
 801177a:	f002 8793 	beq.w	80146a4 <forward_cast+0x34a0>
 801177e:	dde4      	ble.n	801174a <forward_cast+0x546>
 8011780:	491e      	ldr	r1, [pc, #120]	@ (80117fc <forward_cast+0x5f8>)
 8011782:	428c      	cmp	r4, r1
 8011784:	f002 82cf 	beq.w	8013d26 <forward_cast+0x2b22>
 8011788:	f341 8036 	ble.w	80127f8 <forward_cast+0x15f4>
 801178c:	4544      	cmp	r4, r8
 801178e:	f041 803a 	bne.w	8012806 <forward_cast+0x1602>
 8011792:	e9d5 0100 	ldrd	r0, r1, [r5]
 8011796:	f7ee fecb 	bl	8000530 <__aeabi_l2f>
 801179a:	ee07 0a90 	vmov	s15, r0
 801179e:	4a16      	ldr	r2, [pc, #88]	@ (80117f8 <forward_cast+0x5f4>)
 80117a0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80117a4:	ee17 3a90 	vmov	r3, s15
 80117a8:	b299      	uxth	r1, r3
 80117aa:	4b16      	ldr	r3, [pc, #88]	@ (8011804 <forward_cast+0x600>)
 80117ac:	e7dd      	b.n	801176a <forward_cast+0x566>
 80117ae:	4b17      	ldr	r3, [pc, #92]	@ (801180c <forward_cast+0x608>)
 80117b0:	459a      	cmp	sl, r3
 80117b2:	f47f ad8f 	bne.w	80112d4 <forward_cast+0xd0>
 80117b6:	455d      	cmp	r5, fp
 80117b8:	f4bf ad8c 	bcs.w	80112d4 <forward_cast+0xd0>
 80117bc:	9f01      	ldr	r7, [sp, #4]
 80117be:	4628      	mov	r0, r5
 80117c0:	4621      	mov	r1, r4
 80117c2:	f7ff fcab 	bl	801111c <_array_handle_get_as_float>
 80117c6:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 80117ca:	444d      	add	r5, r9
 80117cc:	ee17 3a90 	vmov	r3, s15
 80117d0:	45ab      	cmp	fp, r5
 80117d2:	7033      	strb	r3, [r6, #0]
 80117d4:	443e      	add	r6, r7
 80117d6:	d8f2      	bhi.n	80117be <forward_cast+0x5ba>
 80117d8:	e57c      	b.n	80112d4 <forward_cast+0xd0>
 80117da:	f8df 8024 	ldr.w	r8, [pc, #36]	@ 8011800 <forward_cast+0x5fc>
 80117de:	45c2      	cmp	sl, r8
 80117e0:	f001 844e 	beq.w	8013080 <forward_cast+0x1e7c>
 80117e4:	4a05      	ldr	r2, [pc, #20]	@ (80117fc <forward_cast+0x5f8>)
 80117e6:	4592      	cmp	sl, r2
 80117e8:	f040 8464 	bne.w	80120b4 <forward_cast+0xeb0>
 80117ec:	455d      	cmp	r5, fp
 80117ee:	f4bf ad71 	bcs.w	80112d4 <forward_cast+0xd0>
 80117f2:	4b01      	ldr	r3, [pc, #4]	@ (80117f8 <forward_cast+0x5f4>)
 80117f4:	4a05      	ldr	r2, [pc, #20]	@ (801180c <forward_cast+0x608>)
 80117f6:	e02a      	b.n	801184e <forward_cast+0x64a>
 80117f8:	00042040 	.word	0x00042040
 80117fc:	00841040 	.word	0x00841040
 8011800:	00840840 	.word	0x00840840
 8011804:	00041040 	.word	0x00041040
 8011808:	00840440 	.word	0x00840440
 801180c:	00060440 	.word	0x00060440
 8011810:	00040440 	.word	0x00040440
 8011814:	00040840 	.word	0x00040840
 8011818:	00842040 	.word	0x00842040
 801181c:	00821040 	.word	0x00821040
 8011820:	49a5      	ldr	r1, [pc, #660]	@ (8011ab8 <forward_cast+0x8b4>)
 8011822:	428c      	cmp	r4, r1
 8011824:	f002 84b2 	beq.w	801418c <forward_cast+0x2f88>
 8011828:	f340 86aa 	ble.w	8012580 <forward_cast+0x137c>
 801182c:	429c      	cmp	r4, r3
 801182e:	f002 87b4 	beq.w	801479a <forward_cast+0x3596>
 8011832:	4294      	cmp	r4, r2
 8011834:	f041 8120 	bne.w	8012a78 <forward_cast+0x1874>
 8011838:	7828      	ldrb	r0, [r5, #0]
 801183a:	3800      	subs	r0, #0
 801183c:	bf18      	it	ne
 801183e:	2001      	movne	r0, #1
 8011840:	444d      	add	r5, r9
 8011842:	9901      	ldr	r1, [sp, #4]
 8011844:	6030      	str	r0, [r6, #0]
 8011846:	45ab      	cmp	fp, r5
 8011848:	440e      	add	r6, r1
 801184a:	f67f ad43 	bls.w	80112d4 <forward_cast+0xd0>
 801184e:	42bc      	cmp	r4, r7
 8011850:	f003 827b 	beq.w	8014d4a <forward_cast+0x3b46>
 8011854:	dde4      	ble.n	8011820 <forward_cast+0x61c>
 8011856:	4554      	cmp	r4, sl
 8011858:	f002 82e6 	beq.w	8013e28 <forward_cast+0x2c24>
 801185c:	f341 809c 	ble.w	8012998 <forward_cast+0x1794>
 8011860:	4996      	ldr	r1, [pc, #600]	@ (8011abc <forward_cast+0x8b8>)
 8011862:	428c      	cmp	r4, r1
 8011864:	f041 8108 	bne.w	8012a78 <forward_cast+0x1874>
 8011868:	e9d5 0100 	ldrd	r0, r1, [r5]
 801186c:	f7ee fe60 	bl	8000530 <__aeabi_l2f>
 8011870:	ee07 0a90 	vmov	s15, r0
 8011874:	4b92      	ldr	r3, [pc, #584]	@ (8011ac0 <forward_cast+0x8bc>)
 8011876:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801187a:	4a92      	ldr	r2, [pc, #584]	@ (8011ac4 <forward_cast+0x8c0>)
 801187c:	ee17 0a90 	vmov	r0, s15
 8011880:	e7de      	b.n	8011840 <forward_cast+0x63c>
 8011882:	4b90      	ldr	r3, [pc, #576]	@ (8011ac4 <forward_cast+0x8c0>)
 8011884:	459a      	cmp	sl, r3
 8011886:	f47f ad25 	bne.w	80112d4 <forward_cast+0xd0>
 801188a:	455d      	cmp	r5, fp
 801188c:	f4bf ad22 	bcs.w	80112d4 <forward_cast+0xd0>
 8011890:	2700      	movs	r7, #0
 8011892:	f8df 823c 	ldr.w	r8, [pc, #572]	@ 8011ad0 <forward_cast+0x8cc>
 8011896:	4b8c      	ldr	r3, [pc, #560]	@ (8011ac8 <forward_cast+0x8c4>)
 8011898:	4a87      	ldr	r2, [pc, #540]	@ (8011ab8 <forward_cast+0x8b4>)
 801189a:	e018      	b.n	80118ce <forward_cast+0x6ca>
 801189c:	4294      	cmp	r4, r2
 801189e:	f002 84a2 	beq.w	80141e6 <forward_cast+0x2fe2>
 80118a2:	f340 8704 	ble.w	80126ae <forward_cast+0x14aa>
 80118a6:	4986      	ldr	r1, [pc, #536]	@ (8011ac0 <forward_cast+0x8bc>)
 80118a8:	428c      	cmp	r4, r1
 80118aa:	f002 85be 	beq.w	801442a <forward_cast+0x3226>
 80118ae:	4554      	cmp	r4, sl
 80118b0:	f041 8100 	bne.w	8012ab4 <forward_cast+0x18b0>
 80118b4:	7828      	ldrb	r0, [r5, #0]
 80118b6:	3800      	subs	r0, #0
 80118b8:	bf18      	it	ne
 80118ba:	2001      	movne	r0, #1
 80118bc:	f300 0007 	ssat	r0, #8, r0
 80118c0:	444d      	add	r5, r9
 80118c2:	9901      	ldr	r1, [sp, #4]
 80118c4:	55f0      	strb	r0, [r6, r7]
 80118c6:	45ab      	cmp	fp, r5
 80118c8:	440f      	add	r7, r1
 80118ca:	f67f ad03 	bls.w	80112d4 <forward_cast+0xd0>
 80118ce:	497f      	ldr	r1, [pc, #508]	@ (8011acc <forward_cast+0x8c8>)
 80118d0:	428c      	cmp	r4, r1
 80118d2:	f002 854a 	beq.w	801436a <forward_cast+0x3166>
 80118d6:	dde1      	ble.n	801189c <forward_cast+0x698>
 80118d8:	4544      	cmp	r4, r8
 80118da:	f002 829b 	beq.w	8013e14 <forward_cast+0x2c10>
 80118de:	f341 8050 	ble.w	8012982 <forward_cast+0x177e>
 80118e2:	4976      	ldr	r1, [pc, #472]	@ (8011abc <forward_cast+0x8b8>)
 80118e4:	428c      	cmp	r4, r1
 80118e6:	f041 80e5 	bne.w	8012ab4 <forward_cast+0x18b0>
 80118ea:	e9d5 0100 	ldrd	r0, r1, [r5]
 80118ee:	f7ee fe1f 	bl	8000530 <__aeabi_l2f>
 80118f2:	ee07 0a90 	vmov	s15, r0
 80118f6:	4b74      	ldr	r3, [pc, #464]	@ (8011ac8 <forward_cast+0x8c4>)
 80118f8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80118fc:	4a6e      	ldr	r2, [pc, #440]	@ (8011ab8 <forward_cast+0x8b4>)
 80118fe:	ee17 0a90 	vmov	r0, s15
 8011902:	e7db      	b.n	80118bc <forward_cast+0x6b8>
 8011904:	4b6f      	ldr	r3, [pc, #444]	@ (8011ac4 <forward_cast+0x8c0>)
 8011906:	459a      	cmp	sl, r3
 8011908:	f47f ace4 	bne.w	80112d4 <forward_cast+0xd0>
 801190c:	455d      	cmp	r5, fp
 801190e:	f4bf ace1 	bcs.w	80112d4 <forward_cast+0xd0>
 8011912:	2700      	movs	r7, #0
 8011914:	f8df a1b4 	ldr.w	sl, [pc, #436]	@ 8011acc <forward_cast+0x8c8>
 8011918:	f8df 81a0 	ldr.w	r8, [pc, #416]	@ 8011abc <forward_cast+0x8b8>
 801191c:	4b6a      	ldr	r3, [pc, #424]	@ (8011ac8 <forward_cast+0x8c4>)
 801191e:	4a66      	ldr	r2, [pc, #408]	@ (8011ab8 <forward_cast+0x8b4>)
 8011920:	e018      	b.n	8011954 <forward_cast+0x750>
 8011922:	4294      	cmp	r4, r2
 8011924:	f002 844a 	beq.w	80141bc <forward_cast+0x2fb8>
 8011928:	f340 866f 	ble.w	801260a <forward_cast+0x1406>
 801192c:	4964      	ldr	r1, [pc, #400]	@ (8011ac0 <forward_cast+0x8bc>)
 801192e:	428c      	cmp	r4, r1
 8011930:	f002 8482 	beq.w	8014238 <forward_cast+0x3034>
 8011934:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 8011938:	428c      	cmp	r4, r1
 801193a:	f040 86d6 	bne.w	80126ea <forward_cast+0x14e6>
 801193e:	7829      	ldrb	r1, [r5, #0]
 8011940:	3900      	subs	r1, #0
 8011942:	bf18      	it	ne
 8011944:	2101      	movne	r1, #1
 8011946:	444d      	add	r5, r9
 8011948:	55f1      	strb	r1, [r6, r7]
 801194a:	9901      	ldr	r1, [sp, #4]
 801194c:	45ab      	cmp	fp, r5
 801194e:	440f      	add	r7, r1
 8011950:	f67f acc0 	bls.w	80112d4 <forward_cast+0xd0>
 8011954:	4554      	cmp	r4, sl
 8011956:	f002 8510 	beq.w	801437a <forward_cast+0x3176>
 801195a:	dde2      	ble.n	8011922 <forward_cast+0x71e>
 801195c:	495c      	ldr	r1, [pc, #368]	@ (8011ad0 <forward_cast+0x8cc>)
 801195e:	428c      	cmp	r4, r1
 8011960:	f002 8539 	beq.w	80143d6 <forward_cast+0x31d2>
 8011964:	f340 86bb 	ble.w	80126de <forward_cast+0x14da>
 8011968:	4544      	cmp	r4, r8
 801196a:	f040 86be 	bne.w	80126ea <forward_cast+0x14e6>
 801196e:	e9d5 0100 	ldrd	r0, r1, [r5]
 8011972:	f7ee fddd 	bl	8000530 <__aeabi_l2f>
 8011976:	ee07 0a90 	vmov	s15, r0
 801197a:	4b53      	ldr	r3, [pc, #332]	@ (8011ac8 <forward_cast+0x8c4>)
 801197c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8011980:	4a4d      	ldr	r2, [pc, #308]	@ (8011ab8 <forward_cast+0x8b4>)
 8011982:	edcd 7a02 	vstr	s15, [sp, #8]
 8011986:	f89d 1008 	ldrb.w	r1, [sp, #8]
 801198a:	e7dc      	b.n	8011946 <forward_cast+0x742>
 801198c:	459a      	cmp	sl, r3
 801198e:	f001 82ae 	beq.w	8012eee <forward_cast+0x1cea>
 8011992:	45ba      	cmp	sl, r7
 8011994:	f040 8154 	bne.w	8011c40 <forward_cast+0xa3c>
 8011998:	455d      	cmp	r5, fp
 801199a:	f4bf ac9b 	bcs.w	80112d4 <forward_cast+0xd0>
 801199e:	f8df a12c 	ldr.w	sl, [pc, #300]	@ 8011acc <forward_cast+0x8c8>
 80119a2:	f8df 8118 	ldr.w	r8, [pc, #280]	@ 8011abc <forward_cast+0x8b8>
 80119a6:	4f4b      	ldr	r7, [pc, #300]	@ (8011ad4 <forward_cast+0x8d0>)
 80119a8:	4b43      	ldr	r3, [pc, #268]	@ (8011ab8 <forward_cast+0x8b4>)
 80119aa:	4a45      	ldr	r2, [pc, #276]	@ (8011ac0 <forward_cast+0x8bc>)
 80119ac:	e016      	b.n	80119dc <forward_cast+0x7d8>
 80119ae:	429c      	cmp	r4, r3
 80119b0:	f003 8152 	beq.w	8014c58 <forward_cast+0x3a54>
 80119b4:	f340 85fd 	ble.w	80125b2 <forward_cast+0x13ae>
 80119b8:	4294      	cmp	r4, r2
 80119ba:	f003 8116 	beq.w	8014bea <forward_cast+0x39e6>
 80119be:	4941      	ldr	r1, [pc, #260]	@ (8011ac4 <forward_cast+0x8c0>)
 80119c0:	428c      	cmp	r4, r1
 80119c2:	f041 8062 	bne.w	8012a8a <forward_cast+0x1886>
 80119c6:	7828      	ldrb	r0, [r5, #0]
 80119c8:	3800      	subs	r0, #0
 80119ca:	bf18      	it	ne
 80119cc:	2001      	movne	r0, #1
 80119ce:	444d      	add	r5, r9
 80119d0:	9901      	ldr	r1, [sp, #4]
 80119d2:	6030      	str	r0, [r6, #0]
 80119d4:	45ab      	cmp	fp, r5
 80119d6:	440e      	add	r6, r1
 80119d8:	f67f ac7c 	bls.w	80112d4 <forward_cast+0xd0>
 80119dc:	4554      	cmp	r4, sl
 80119de:	f003 807d 	beq.w	8014adc <forward_cast+0x38d8>
 80119e2:	dde4      	ble.n	80119ae <forward_cast+0x7aa>
 80119e4:	493a      	ldr	r1, [pc, #232]	@ (8011ad0 <forward_cast+0x8cc>)
 80119e6:	428c      	cmp	r4, r1
 80119e8:	f002 823d 	beq.w	8013e66 <forward_cast+0x2c62>
 80119ec:	f341 800d 	ble.w	8012a0a <forward_cast+0x1806>
 80119f0:	4544      	cmp	r4, r8
 80119f2:	f041 804a 	bne.w	8012a8a <forward_cast+0x1886>
 80119f6:	e9d5 0100 	ldrd	r0, r1, [r5]
 80119fa:	f7ee fd99 	bl	8000530 <__aeabi_l2f>
 80119fe:	ee07 0a90 	vmov	s15, r0
 8011a02:	4b2d      	ldr	r3, [pc, #180]	@ (8011ab8 <forward_cast+0x8b4>)
 8011a04:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8011a08:	4a2d      	ldr	r2, [pc, #180]	@ (8011ac0 <forward_cast+0x8bc>)
 8011a0a:	ee17 0a90 	vmov	r0, s15
 8011a0e:	e7de      	b.n	80119ce <forward_cast+0x7ca>
 8011a10:	4b2c      	ldr	r3, [pc, #176]	@ (8011ac4 <forward_cast+0x8c0>)
 8011a12:	459a      	cmp	sl, r3
 8011a14:	f47f ac5e 	bne.w	80112d4 <forward_cast+0xd0>
 8011a18:	455d      	cmp	r5, fp
 8011a1a:	f4bf ac5b 	bcs.w	80112d4 <forward_cast+0xd0>
 8011a1e:	2700      	movs	r7, #0
 8011a20:	f8df a0a8 	ldr.w	sl, [pc, #168]	@ 8011acc <forward_cast+0x8c8>
 8011a24:	f8df 8094 	ldr.w	r8, [pc, #148]	@ 8011abc <forward_cast+0x8b8>
 8011a28:	4b27      	ldr	r3, [pc, #156]	@ (8011ac8 <forward_cast+0x8c4>)
 8011a2a:	4a23      	ldr	r2, [pc, #140]	@ (8011ab8 <forward_cast+0x8b4>)
 8011a2c:	e01a      	b.n	8011a64 <forward_cast+0x860>
 8011a2e:	4294      	cmp	r4, r2
 8011a30:	f003 809d 	beq.w	8014b6e <forward_cast+0x396a>
 8011a34:	f340 86a7 	ble.w	8012786 <forward_cast+0x1582>
 8011a38:	4921      	ldr	r1, [pc, #132]	@ (8011ac0 <forward_cast+0x8bc>)
 8011a3a:	428c      	cmp	r4, r1
 8011a3c:	f002 879e 	beq.w	801497c <forward_cast+0x3778>
 8011a40:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 8011a44:	428c      	cmp	r4, r1
 8011a46:	f041 8006 	bne.w	8012a56 <forward_cast+0x1852>
 8011a4a:	7828      	ldrb	r0, [r5, #0]
 8011a4c:	3800      	subs	r0, #0
 8011a4e:	bf18      	it	ne
 8011a50:	2001      	movne	r0, #1
 8011a52:	f300 000f 	ssat	r0, #16, r0
 8011a56:	444d      	add	r5, r9
 8011a58:	9901      	ldr	r1, [sp, #4]
 8011a5a:	55f0      	strb	r0, [r6, r7]
 8011a5c:	45ab      	cmp	fp, r5
 8011a5e:	440f      	add	r7, r1
 8011a60:	f67f ac38 	bls.w	80112d4 <forward_cast+0xd0>
 8011a64:	4554      	cmp	r4, sl
 8011a66:	f003 812b 	beq.w	8014cc0 <forward_cast+0x3abc>
 8011a6a:	dde0      	ble.n	8011a2e <forward_cast+0x82a>
 8011a6c:	4918      	ldr	r1, [pc, #96]	@ (8011ad0 <forward_cast+0x8cc>)
 8011a6e:	428c      	cmp	r4, r1
 8011a70:	f002 81e8 	beq.w	8013e44 <forward_cast+0x2c40>
 8011a74:	f340 871a 	ble.w	80128ac <forward_cast+0x16a8>
 8011a78:	4544      	cmp	r4, r8
 8011a7a:	f040 87ec 	bne.w	8012a56 <forward_cast+0x1852>
 8011a7e:	e9d5 0100 	ldrd	r0, r1, [r5]
 8011a82:	f7ee fd55 	bl	8000530 <__aeabi_l2f>
 8011a86:	ee07 0a90 	vmov	s15, r0
 8011a8a:	4b0f      	ldr	r3, [pc, #60]	@ (8011ac8 <forward_cast+0x8c4>)
 8011a8c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8011a90:	4a09      	ldr	r2, [pc, #36]	@ (8011ab8 <forward_cast+0x8b4>)
 8011a92:	ee17 0a90 	vmov	r0, s15
 8011a96:	e7dc      	b.n	8011a52 <forward_cast+0x84e>
 8011a98:	4b0a      	ldr	r3, [pc, #40]	@ (8011ac4 <forward_cast+0x8c0>)
 8011a9a:	459a      	cmp	sl, r3
 8011a9c:	f47f ac1a 	bne.w	80112d4 <forward_cast+0xd0>
 8011aa0:	455d      	cmp	r5, fp
 8011aa2:	f4bf ac17 	bcs.w	80112d4 <forward_cast+0xd0>
 8011aa6:	2700      	movs	r7, #0
 8011aa8:	f8df a020 	ldr.w	sl, [pc, #32]	@ 8011acc <forward_cast+0x8c8>
 8011aac:	f8df 800c 	ldr.w	r8, [pc, #12]	@ 8011abc <forward_cast+0x8b8>
 8011ab0:	4b05      	ldr	r3, [pc, #20]	@ (8011ac8 <forward_cast+0x8c4>)
 8011ab2:	4a01      	ldr	r2, [pc, #4]	@ (8011ab8 <forward_cast+0x8b4>)
 8011ab4:	e029      	b.n	8011b0a <forward_cast+0x906>
 8011ab6:	bf00      	nop
 8011ab8:	00041040 	.word	0x00041040
 8011abc:	00842040 	.word	0x00842040
 8011ac0:	00042040 	.word	0x00042040
 8011ac4:	00060440 	.word	0x00060440
 8011ac8:	00840840 	.word	0x00840840
 8011acc:	00821040 	.word	0x00821040
 8011ad0:	00841040 	.word	0x00841040
 8011ad4:	00840440 	.word	0x00840440
 8011ad8:	4294      	cmp	r4, r2
 8011ada:	f002 8585 	beq.w	80145e8 <forward_cast+0x33e4>
 8011ade:	f340 86cb 	ble.w	8012878 <forward_cast+0x1674>
 8011ae2:	49a4      	ldr	r1, [pc, #656]	@ (8011d74 <forward_cast+0xb70>)
 8011ae4:	428c      	cmp	r4, r1
 8011ae6:	f002 856f 	beq.w	80145c8 <forward_cast+0x33c4>
 8011aea:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 8011aee:	428c      	cmp	r4, r1
 8011af0:	f040 86c9 	bne.w	8012886 <forward_cast+0x1682>
 8011af4:	7829      	ldrb	r1, [r5, #0]
 8011af6:	3900      	subs	r1, #0
 8011af8:	bf18      	it	ne
 8011afa:	2101      	movne	r1, #1
 8011afc:	444d      	add	r5, r9
 8011afe:	55f1      	strb	r1, [r6, r7]
 8011b00:	9901      	ldr	r1, [sp, #4]
 8011b02:	45ab      	cmp	fp, r5
 8011b04:	440f      	add	r7, r1
 8011b06:	f67f abe5 	bls.w	80112d4 <forward_cast+0xd0>
 8011b0a:	4554      	cmp	r4, sl
 8011b0c:	f002 861e 	beq.w	801474c <forward_cast+0x3548>
 8011b10:	dde2      	ble.n	8011ad8 <forward_cast+0x8d4>
 8011b12:	4999      	ldr	r1, [pc, #612]	@ (8011d78 <forward_cast+0xb74>)
 8011b14:	428c      	cmp	r4, r1
 8011b16:	f002 82ec 	beq.w	80140f2 <forward_cast+0x2eee>
 8011b1a:	f340 8698 	ble.w	801284e <forward_cast+0x164a>
 8011b1e:	4544      	cmp	r4, r8
 8011b20:	f040 86b1 	bne.w	8012886 <forward_cast+0x1682>
 8011b24:	e9d5 0100 	ldrd	r0, r1, [r5]
 8011b28:	f7ee fd02 	bl	8000530 <__aeabi_l2f>
 8011b2c:	ee07 0a90 	vmov	s15, r0
 8011b30:	4b92      	ldr	r3, [pc, #584]	@ (8011d7c <forward_cast+0xb78>)
 8011b32:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8011b36:	4a92      	ldr	r2, [pc, #584]	@ (8011d80 <forward_cast+0xb7c>)
 8011b38:	edcd 7a02 	vstr	s15, [sp, #8]
 8011b3c:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8011b40:	e7dc      	b.n	8011afc <forward_cast+0x8f8>
 8011b42:	4a8e      	ldr	r2, [pc, #568]	@ (8011d7c <forward_cast+0xb78>)
 8011b44:	4592      	cmp	sl, r2
 8011b46:	f001 818a 	beq.w	8012e5e <forward_cast+0x1c5a>
 8011b4a:	4b8b      	ldr	r3, [pc, #556]	@ (8011d78 <forward_cast+0xb74>)
 8011b4c:	459a      	cmp	sl, r3
 8011b4e:	f040 80bb 	bne.w	8011cc8 <forward_cast+0xac4>
 8011b52:	455d      	cmp	r5, fp
 8011b54:	f4bf abbe 	bcs.w	80112d4 <forward_cast+0xd0>
 8011b58:	4b86      	ldr	r3, [pc, #536]	@ (8011d74 <forward_cast+0xb70>)
 8011b5a:	e016      	b.n	8011b8a <forward_cast+0x986>
 8011b5c:	42bc      	cmp	r4, r7
 8011b5e:	f002 8638 	beq.w	80147d2 <forward_cast+0x35ce>
 8011b62:	f340 84f3 	ble.w	801254c <forward_cast+0x1348>
 8011b66:	429c      	cmp	r4, r3
 8011b68:	f002 8625 	beq.w	80147b6 <forward_cast+0x35b2>
 8011b6c:	4985      	ldr	r1, [pc, #532]	@ (8011d84 <forward_cast+0xb80>)
 8011b6e:	428c      	cmp	r4, r1
 8011b70:	f040 8785 	bne.w	8012a7e <forward_cast+0x187a>
 8011b74:	7828      	ldrb	r0, [r5, #0]
 8011b76:	3800      	subs	r0, #0
 8011b78:	bf18      	it	ne
 8011b7a:	2001      	movne	r0, #1
 8011b7c:	444d      	add	r5, r9
 8011b7e:	9901      	ldr	r1, [sp, #4]
 8011b80:	6030      	str	r0, [r6, #0]
 8011b82:	45ab      	cmp	fp, r5
 8011b84:	440e      	add	r6, r1
 8011b86:	f67f aba5 	bls.w	80112d4 <forward_cast+0xd0>
 8011b8a:	4544      	cmp	r4, r8
 8011b8c:	f002 85fd 	beq.w	801478a <forward_cast+0x3586>
 8011b90:	dde4      	ble.n	8011b5c <forward_cast+0x958>
 8011b92:	4554      	cmp	r4, sl
 8011b94:	f002 81a7 	beq.w	8013ee6 <forward_cast+0x2ce2>
 8011b98:	f340 874b 	ble.w	8012a32 <forward_cast+0x182e>
 8011b9c:	497a      	ldr	r1, [pc, #488]	@ (8011d88 <forward_cast+0xb84>)
 8011b9e:	428c      	cmp	r4, r1
 8011ba0:	f040 876d 	bne.w	8012a7e <forward_cast+0x187a>
 8011ba4:	e9d5 0100 	ldrd	r0, r1, [r5]
 8011ba8:	f7ee fcc2 	bl	8000530 <__aeabi_l2f>
 8011bac:	ee07 0a90 	vmov	s15, r0
 8011bb0:	4a72      	ldr	r2, [pc, #456]	@ (8011d7c <forward_cast+0xb78>)
 8011bb2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8011bb6:	4b6f      	ldr	r3, [pc, #444]	@ (8011d74 <forward_cast+0xb70>)
 8011bb8:	ee17 0a90 	vmov	r0, s15
 8011bbc:	e7de      	b.n	8011b7c <forward_cast+0x978>
 8011bbe:	45ba      	cmp	sl, r7
 8011bc0:	f001 83ab 	beq.w	801331a <forward_cast+0x2116>
 8011bc4:	4b6c      	ldr	r3, [pc, #432]	@ (8011d78 <forward_cast+0xb74>)
 8011bc6:	459a      	cmp	sl, r3
 8011bc8:	f040 80c3 	bne.w	8011d52 <forward_cast+0xb4e>
 8011bcc:	455d      	cmp	r5, fp
 8011bce:	f4bf ab81 	bcs.w	80112d4 <forward_cast+0xd0>
 8011bd2:	4b68      	ldr	r3, [pc, #416]	@ (8011d74 <forward_cast+0xb70>)
 8011bd4:	4a6b      	ldr	r2, [pc, #428]	@ (8011d84 <forward_cast+0xb80>)
 8011bd6:	e019      	b.n	8011c0c <forward_cast+0xa08>
 8011bd8:	4969      	ldr	r1, [pc, #420]	@ (8011d80 <forward_cast+0xb7c>)
 8011bda:	428c      	cmp	r4, r1
 8011bdc:	f002 83f1 	beq.w	80143c2 <forward_cast+0x31be>
 8011be0:	f340 854e 	ble.w	8012680 <forward_cast+0x147c>
 8011be4:	429c      	cmp	r4, r3
 8011be6:	f002 830b 	beq.w	8014200 <forward_cast+0x2ffc>
 8011bea:	4294      	cmp	r4, r2
 8011bec:	f040 875c 	bne.w	8012aa8 <forward_cast+0x18a4>
 8011bf0:	7828      	ldrb	r0, [r5, #0]
 8011bf2:	3800      	subs	r0, #0
 8011bf4:	bf18      	it	ne
 8011bf6:	2001      	movne	r0, #1
 8011bf8:	f300 000f 	ssat	r0, #16, r0
 8011bfc:	444d      	add	r5, r9
 8011bfe:	b200      	sxth	r0, r0
 8011c00:	9901      	ldr	r1, [sp, #4]
 8011c02:	45ab      	cmp	fp, r5
 8011c04:	6030      	str	r0, [r6, #0]
 8011c06:	440e      	add	r6, r1
 8011c08:	f67f ab64 	bls.w	80112d4 <forward_cast+0xd0>
 8011c0c:	4544      	cmp	r4, r8
 8011c0e:	f002 8685 	beq.w	801491c <forward_cast+0x3718>
 8011c12:	dde1      	ble.n	8011bd8 <forward_cast+0x9d4>
 8011c14:	4554      	cmp	r4, sl
 8011c16:	f002 8158 	beq.w	8013eca <forward_cast+0x2cc6>
 8011c1a:	f340 8675 	ble.w	8012908 <forward_cast+0x1704>
 8011c1e:	495a      	ldr	r1, [pc, #360]	@ (8011d88 <forward_cast+0xb84>)
 8011c20:	428c      	cmp	r4, r1
 8011c22:	f040 8741 	bne.w	8012aa8 <forward_cast+0x18a4>
 8011c26:	e9d5 0100 	ldrd	r0, r1, [r5]
 8011c2a:	f7ee fc81 	bl	8000530 <__aeabi_l2f>
 8011c2e:	ee07 0a90 	vmov	s15, r0
 8011c32:	4b50      	ldr	r3, [pc, #320]	@ (8011d74 <forward_cast+0xb70>)
 8011c34:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8011c38:	4a52      	ldr	r2, [pc, #328]	@ (8011d84 <forward_cast+0xb80>)
 8011c3a:	ee17 0a90 	vmov	r0, s15
 8011c3e:	e7db      	b.n	8011bf8 <forward_cast+0x9f4>
 8011c40:	4b52      	ldr	r3, [pc, #328]	@ (8011d8c <forward_cast+0xb88>)
 8011c42:	459a      	cmp	sl, r3
 8011c44:	f47f ab46 	bne.w	80112d4 <forward_cast+0xd0>
 8011c48:	455d      	cmp	r5, fp
 8011c4a:	f4bf ab43 	bcs.w	80112d4 <forward_cast+0xd0>
 8011c4e:	2700      	movs	r7, #0
 8011c50:	f8df a13c 	ldr.w	sl, [pc, #316]	@ 8011d90 <forward_cast+0xb8c>
 8011c54:	f8df 8130 	ldr.w	r8, [pc, #304]	@ 8011d88 <forward_cast+0xb84>
 8011c58:	4b48      	ldr	r3, [pc, #288]	@ (8011d7c <forward_cast+0xb78>)
 8011c5a:	4a49      	ldr	r2, [pc, #292]	@ (8011d80 <forward_cast+0xb7c>)
 8011c5c:	e018      	b.n	8011c90 <forward_cast+0xa8c>
 8011c5e:	4294      	cmp	r4, r2
 8011c60:	f002 8776 	beq.w	8014b50 <forward_cast+0x394c>
 8011c64:	f340 852f 	ble.w	80126c6 <forward_cast+0x14c2>
 8011c68:	4942      	ldr	r1, [pc, #264]	@ (8011d74 <forward_cast+0xb70>)
 8011c6a:	428c      	cmp	r4, r1
 8011c6c:	f002 81da 	beq.w	8014024 <forward_cast+0x2e20>
 8011c70:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 8011c74:	428c      	cmp	r4, r1
 8011c76:	f040 86ae 	bne.w	80129d6 <forward_cast+0x17d2>
 8011c7a:	7829      	ldrb	r1, [r5, #0]
 8011c7c:	3900      	subs	r1, #0
 8011c7e:	bf18      	it	ne
 8011c80:	2101      	movne	r1, #1
 8011c82:	444d      	add	r5, r9
 8011c84:	55f1      	strb	r1, [r6, r7]
 8011c86:	9901      	ldr	r1, [sp, #4]
 8011c88:	45ab      	cmp	fp, r5
 8011c8a:	440f      	add	r7, r1
 8011c8c:	f67f ab22 	bls.w	80112d4 <forward_cast+0xd0>
 8011c90:	4554      	cmp	r4, sl
 8011c92:	f002 8316 	beq.w	80142c2 <forward_cast+0x30be>
 8011c96:	dde2      	ble.n	8011c5e <forward_cast+0xa5a>
 8011c98:	4937      	ldr	r1, [pc, #220]	@ (8011d78 <forward_cast+0xb74>)
 8011c9a:	428c      	cmp	r4, r1
 8011c9c:	f002 8101 	beq.w	8013ea2 <forward_cast+0x2c9e>
 8011ca0:	f340 8691 	ble.w	80129c6 <forward_cast+0x17c2>
 8011ca4:	4544      	cmp	r4, r8
 8011ca6:	f040 8696 	bne.w	80129d6 <forward_cast+0x17d2>
 8011caa:	e9d5 0100 	ldrd	r0, r1, [r5]
 8011cae:	f7ee fc3f 	bl	8000530 <__aeabi_l2f>
 8011cb2:	ee07 0a90 	vmov	s15, r0
 8011cb6:	4b31      	ldr	r3, [pc, #196]	@ (8011d7c <forward_cast+0xb78>)
 8011cb8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8011cbc:	4a30      	ldr	r2, [pc, #192]	@ (8011d80 <forward_cast+0xb7c>)
 8011cbe:	edcd 7a02 	vstr	s15, [sp, #8]
 8011cc2:	f99d 1008 	ldrsb.w	r1, [sp, #8]
 8011cc6:	e7dc      	b.n	8011c82 <forward_cast+0xa7e>
 8011cc8:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
 8011ccc:	459a      	cmp	sl, r3
 8011cce:	f47f ab01 	bne.w	80112d4 <forward_cast+0xd0>
 8011cd2:	455d      	cmp	r5, fp
 8011cd4:	f4bf aafe 	bcs.w	80112d4 <forward_cast+0xd0>
 8011cd8:	2700      	movs	r7, #0
 8011cda:	f8df a0b4 	ldr.w	sl, [pc, #180]	@ 8011d90 <forward_cast+0xb8c>
 8011cde:	f8df 80a8 	ldr.w	r8, [pc, #168]	@ 8011d88 <forward_cast+0xb84>
 8011ce2:	4b26      	ldr	r3, [pc, #152]	@ (8011d7c <forward_cast+0xb78>)
 8011ce4:	4a26      	ldr	r2, [pc, #152]	@ (8011d80 <forward_cast+0xb7c>)
 8011ce6:	e018      	b.n	8011d1a <forward_cast+0xb16>
 8011ce8:	4294      	cmp	r4, r2
 8011cea:	f002 8327 	beq.w	801433c <forward_cast+0x3138>
 8011cee:	f340 84bd 	ble.w	801266c <forward_cast+0x1468>
 8011cf2:	4920      	ldr	r1, [pc, #128]	@ (8011d74 <forward_cast+0xb70>)
 8011cf4:	428c      	cmp	r4, r1
 8011cf6:	f002 8311 	beq.w	801431c <forward_cast+0x3118>
 8011cfa:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 8011cfe:	428c      	cmp	r4, r1
 8011d00:	f040 84bb 	bne.w	801267a <forward_cast+0x1476>
 8011d04:	7829      	ldrb	r1, [r5, #0]
 8011d06:	3900      	subs	r1, #0
 8011d08:	bf18      	it	ne
 8011d0a:	2101      	movne	r1, #1
 8011d0c:	444d      	add	r5, r9
 8011d0e:	55f1      	strb	r1, [r6, r7]
 8011d10:	9901      	ldr	r1, [sp, #4]
 8011d12:	45ab      	cmp	fp, r5
 8011d14:	440f      	add	r7, r1
 8011d16:	f67f aadd 	bls.w	80112d4 <forward_cast+0xd0>
 8011d1a:	4554      	cmp	r4, sl
 8011d1c:	f002 82db 	beq.w	80142d6 <forward_cast+0x30d2>
 8011d20:	dde2      	ble.n	8011ce8 <forward_cast+0xae4>
 8011d22:	4915      	ldr	r1, [pc, #84]	@ (8011d78 <forward_cast+0xb74>)
 8011d24:	428c      	cmp	r4, r1
 8011d26:	f002 82e0 	beq.w	80142ea <forward_cast+0x30e6>
 8011d2a:	f340 844e 	ble.w	80125ca <forward_cast+0x13c6>
 8011d2e:	4544      	cmp	r4, r8
 8011d30:	f040 84a3 	bne.w	801267a <forward_cast+0x1476>
 8011d34:	e9d5 0100 	ldrd	r0, r1, [r5]
 8011d38:	f7ee fbfa 	bl	8000530 <__aeabi_l2f>
 8011d3c:	ee07 0a90 	vmov	s15, r0
 8011d40:	4b0e      	ldr	r3, [pc, #56]	@ (8011d7c <forward_cast+0xb78>)
 8011d42:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8011d46:	4a0e      	ldr	r2, [pc, #56]	@ (8011d80 <forward_cast+0xb7c>)
 8011d48:	edcd 7a02 	vstr	s15, [sp, #8]
 8011d4c:	f99d 1008 	ldrsb.w	r1, [sp, #8]
 8011d50:	e7dc      	b.n	8011d0c <forward_cast+0xb08>
 8011d52:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
 8011d56:	459a      	cmp	sl, r3
 8011d58:	f47f aabc 	bne.w	80112d4 <forward_cast+0xd0>
 8011d5c:	455d      	cmp	r5, fp
 8011d5e:	f4bf aab9 	bcs.w	80112d4 <forward_cast+0xd0>
 8011d62:	2700      	movs	r7, #0
 8011d64:	f8df a028 	ldr.w	sl, [pc, #40]	@ 8011d90 <forward_cast+0xb8c>
 8011d68:	f8df 801c 	ldr.w	r8, [pc, #28]	@ 8011d88 <forward_cast+0xb84>
 8011d6c:	4b03      	ldr	r3, [pc, #12]	@ (8011d7c <forward_cast+0xb78>)
 8011d6e:	4a04      	ldr	r2, [pc, #16]	@ (8011d80 <forward_cast+0xb7c>)
 8011d70:	e02b      	b.n	8011dca <forward_cast+0xbc6>
 8011d72:	bf00      	nop
 8011d74:	00042040 	.word	0x00042040
 8011d78:	00841040 	.word	0x00841040
 8011d7c:	00840840 	.word	0x00840840
 8011d80:	00041040 	.word	0x00041040
 8011d84:	00060440 	.word	0x00060440
 8011d88:	00842040 	.word	0x00842040
 8011d8c:	00840440 	.word	0x00840440
 8011d90:	00821040 	.word	0x00821040
 8011d94:	4294      	cmp	r4, r2
 8011d96:	f002 836f 	beq.w	8014478 <forward_cast+0x3274>
 8011d9a:	f340 8542 	ble.w	8012822 <forward_cast+0x161e>
 8011d9e:	49a3      	ldr	r1, [pc, #652]	@ (801202c <forward_cast+0xe28>)
 8011da0:	428c      	cmp	r4, r1
 8011da2:	f002 8350 	beq.w	8014446 <forward_cast+0x3242>
 8011da6:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 8011daa:	428c      	cmp	r4, r1
 8011dac:	f040 8685 	bne.w	8012aba <forward_cast+0x18b6>
 8011db0:	7828      	ldrb	r0, [r5, #0]
 8011db2:	3800      	subs	r0, #0
 8011db4:	bf18      	it	ne
 8011db6:	2001      	movne	r0, #1
 8011db8:	f300 000f 	ssat	r0, #16, r0
 8011dbc:	444d      	add	r5, r9
 8011dbe:	9901      	ldr	r1, [sp, #4]
 8011dc0:	55f0      	strb	r0, [r6, r7]
 8011dc2:	45ab      	cmp	fp, r5
 8011dc4:	440f      	add	r7, r1
 8011dc6:	f67f aa85 	bls.w	80112d4 <forward_cast+0xd0>
 8011dca:	4554      	cmp	r4, sl
 8011dcc:	f002 85ce 	beq.w	801496c <forward_cast+0x3768>
 8011dd0:	dde0      	ble.n	8011d94 <forward_cast+0xb90>
 8011dd2:	4997      	ldr	r1, [pc, #604]	@ (8012030 <forward_cast+0xe2c>)
 8011dd4:	428c      	cmp	r4, r1
 8011dd6:	f002 8057 	beq.w	8013e88 <forward_cast+0x2c84>
 8011dda:	f340 84e0 	ble.w	801279e <forward_cast+0x159a>
 8011dde:	4544      	cmp	r4, r8
 8011de0:	f040 866b 	bne.w	8012aba <forward_cast+0x18b6>
 8011de4:	e9d5 0100 	ldrd	r0, r1, [r5]
 8011de8:	f7ee fba2 	bl	8000530 <__aeabi_l2f>
 8011dec:	ee07 0a90 	vmov	s15, r0
 8011df0:	4b90      	ldr	r3, [pc, #576]	@ (8012034 <forward_cast+0xe30>)
 8011df2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8011df6:	4a90      	ldr	r2, [pc, #576]	@ (8012038 <forward_cast+0xe34>)
 8011df8:	ee17 0a90 	vmov	r0, s15
 8011dfc:	e7dc      	b.n	8011db8 <forward_cast+0xbb4>
 8011dfe:	4b8f      	ldr	r3, [pc, #572]	@ (801203c <forward_cast+0xe38>)
 8011e00:	459a      	cmp	sl, r3
 8011e02:	f47f aa67 	bne.w	80112d4 <forward_cast+0xd0>
 8011e06:	455d      	cmp	r5, fp
 8011e08:	f4bf aa64 	bcs.w	80112d4 <forward_cast+0xd0>
 8011e0c:	9f01      	ldr	r7, [sp, #4]
 8011e0e:	4621      	mov	r1, r4
 8011e10:	4628      	mov	r0, r5
 8011e12:	f7ff f983 	bl	801111c <_array_handle_get_as_float>
 8011e16:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8011e1a:	ee17 3a90 	vmov	r3, s15
 8011e1e:	f383 0308 	usat	r3, #8, r3
 8011e22:	444d      	add	r5, r9
 8011e24:	7033      	strb	r3, [r6, #0]
 8011e26:	443e      	add	r6, r7
 8011e28:	45ab      	cmp	fp, r5
 8011e2a:	d8f0      	bhi.n	8011e0e <forward_cast+0xc0a>
 8011e2c:	f7ff ba52 	b.w	80112d4 <forward_cast+0xd0>
 8011e30:	4b80      	ldr	r3, [pc, #512]	@ (8012034 <forward_cast+0xe30>)
 8011e32:	459a      	cmp	sl, r3
 8011e34:	f001 810e 	beq.w	8013054 <forward_cast+0x1e50>
 8011e38:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8011e3c:	459a      	cmp	sl, r3
 8011e3e:	f040 821f 	bne.w	8012280 <forward_cast+0x107c>
 8011e42:	455d      	cmp	r5, fp
 8011e44:	f4bf aa46 	bcs.w	80112d4 <forward_cast+0xd0>
 8011e48:	f8df a1f8 	ldr.w	sl, [pc, #504]	@ 8012044 <forward_cast+0xe40>
 8011e4c:	f8df 81f8 	ldr.w	r8, [pc, #504]	@ 8012048 <forward_cast+0xe44>
 8011e50:	4f7b      	ldr	r7, [pc, #492]	@ (8012040 <forward_cast+0xe3c>)
 8011e52:	4b79      	ldr	r3, [pc, #484]	@ (8012038 <forward_cast+0xe34>)
 8011e54:	4a75      	ldr	r2, [pc, #468]	@ (801202c <forward_cast+0xe28>)
 8011e56:	e019      	b.n	8011e8c <forward_cast+0xc88>
 8011e58:	429c      	cmp	r4, r3
 8011e5a:	f002 818d 	beq.w	8014178 <forward_cast+0x2f74>
 8011e5e:	f340 8353 	ble.w	8012508 <forward_cast+0x1304>
 8011e62:	4294      	cmp	r4, r2
 8011e64:	f002 8443 	beq.w	80146ee <forward_cast+0x34ea>
 8011e68:	4974      	ldr	r1, [pc, #464]	@ (801203c <forward_cast+0xe38>)
 8011e6a:	428c      	cmp	r4, r1
 8011e6c:	f040 85fe 	bne.w	8012a6c <forward_cast+0x1868>
 8011e70:	7828      	ldrb	r0, [r5, #0]
 8011e72:	3800      	subs	r0, #0
 8011e74:	bf18      	it	ne
 8011e76:	2001      	movne	r0, #1
 8011e78:	f380 0008 	usat	r0, #8, r0
 8011e7c:	444d      	add	r5, r9
 8011e7e:	b2c0      	uxtb	r0, r0
 8011e80:	9901      	ldr	r1, [sp, #4]
 8011e82:	45ab      	cmp	fp, r5
 8011e84:	6030      	str	r0, [r6, #0]
 8011e86:	440e      	add	r6, r1
 8011e88:	f67f aa24 	bls.w	80112d4 <forward_cast+0xd0>
 8011e8c:	4554      	cmp	r4, sl
 8011e8e:	f002 8771 	beq.w	8014d74 <forward_cast+0x3b70>
 8011e92:	dde1      	ble.n	8011e58 <forward_cast+0xc54>
 8011e94:	4966      	ldr	r1, [pc, #408]	@ (8012030 <forward_cast+0xe2c>)
 8011e96:	428c      	cmp	r4, r1
 8011e98:	f002 83f7 	beq.w	801468a <forward_cast+0x3486>
 8011e9c:	f340 833f 	ble.w	801251e <forward_cast+0x131a>
 8011ea0:	4544      	cmp	r4, r8
 8011ea2:	f040 85e3 	bne.w	8012a6c <forward_cast+0x1868>
 8011ea6:	e9d5 0100 	ldrd	r0, r1, [r5]
 8011eaa:	f7ee fb41 	bl	8000530 <__aeabi_l2f>
 8011eae:	ee07 0a90 	vmov	s15, r0
 8011eb2:	4b61      	ldr	r3, [pc, #388]	@ (8012038 <forward_cast+0xe34>)
 8011eb4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8011eb8:	4a5c      	ldr	r2, [pc, #368]	@ (801202c <forward_cast+0xe28>)
 8011eba:	ee17 0a90 	vmov	r0, s15
 8011ebe:	e7db      	b.n	8011e78 <forward_cast+0xc74>
 8011ec0:	4b5e      	ldr	r3, [pc, #376]	@ (801203c <forward_cast+0xe38>)
 8011ec2:	459a      	cmp	sl, r3
 8011ec4:	f47f aa06 	bne.w	80112d4 <forward_cast+0xd0>
 8011ec8:	455d      	cmp	r5, fp
 8011eca:	f4bf aa03 	bcs.w	80112d4 <forward_cast+0xd0>
 8011ece:	f04f 0800 	mov.w	r8, #0
 8011ed2:	4b5b      	ldr	r3, [pc, #364]	@ (8012040 <forward_cast+0xe3c>)
 8011ed4:	4a57      	ldr	r2, [pc, #348]	@ (8012034 <forward_cast+0xe30>)
 8011ed6:	e019      	b.n	8011f0c <forward_cast+0xd08>
 8011ed8:	42bc      	cmp	r4, r7
 8011eda:	f002 81bd 	beq.w	8014258 <forward_cast+0x3054>
 8011ede:	f340 8407 	ble.w	80126f0 <forward_cast+0x14ec>
 8011ee2:	4952      	ldr	r1, [pc, #328]	@ (801202c <forward_cast+0xe28>)
 8011ee4:	428c      	cmp	r4, r1
 8011ee6:	f002 8199 	beq.w	801421c <forward_cast+0x3018>
 8011eea:	4554      	cmp	r4, sl
 8011eec:	f040 85df 	bne.w	8012aae <forward_cast+0x18aa>
 8011ef0:	7828      	ldrb	r0, [r5, #0]
 8011ef2:	3800      	subs	r0, #0
 8011ef4:	bf18      	it	ne
 8011ef6:	2001      	movne	r0, #1
 8011ef8:	f380 0010 	usat	r0, #16, r0
 8011efc:	444d      	add	r5, r9
 8011efe:	9901      	ldr	r1, [sp, #4]
 8011f00:	f806 0008 	strb.w	r0, [r6, r8]
 8011f04:	45ab      	cmp	fp, r5
 8011f06:	4488      	add	r8, r1
 8011f08:	f67f a9e4 	bls.w	80112d4 <forward_cast+0xd0>
 8011f0c:	494d      	ldr	r1, [pc, #308]	@ (8012044 <forward_cast+0xe40>)
 8011f0e:	428c      	cmp	r4, r1
 8011f10:	f002 8223 	beq.w	801435a <forward_cast+0x3156>
 8011f14:	dde0      	ble.n	8011ed8 <forward_cast+0xcd4>
 8011f16:	4946      	ldr	r1, [pc, #280]	@ (8012030 <forward_cast+0xe2c>)
 8011f18:	428c      	cmp	r4, r1
 8011f1a:	f002 8093 	beq.w	8014044 <forward_cast+0x2e40>
 8011f1e:	f340 855d 	ble.w	80129dc <forward_cast+0x17d8>
 8011f22:	4949      	ldr	r1, [pc, #292]	@ (8012048 <forward_cast+0xe44>)
 8011f24:	428c      	cmp	r4, r1
 8011f26:	f040 85c2 	bne.w	8012aae <forward_cast+0x18aa>
 8011f2a:	e9d5 0100 	ldrd	r0, r1, [r5]
 8011f2e:	f7ee faff 	bl	8000530 <__aeabi_l2f>
 8011f32:	ee07 0a90 	vmov	s15, r0
 8011f36:	4b42      	ldr	r3, [pc, #264]	@ (8012040 <forward_cast+0xe3c>)
 8011f38:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8011f3c:	4a3d      	ldr	r2, [pc, #244]	@ (8012034 <forward_cast+0xe30>)
 8011f3e:	ee17 0a90 	vmov	r0, s15
 8011f42:	e7d9      	b.n	8011ef8 <forward_cast+0xcf4>
 8011f44:	4b3d      	ldr	r3, [pc, #244]	@ (801203c <forward_cast+0xe38>)
 8011f46:	459a      	cmp	sl, r3
 8011f48:	f47f a9c4 	bne.w	80112d4 <forward_cast+0xd0>
 8011f4c:	455d      	cmp	r5, fp
 8011f4e:	f4bf a9c1 	bcs.w	80112d4 <forward_cast+0xd0>
 8011f52:	9f01      	ldr	r7, [sp, #4]
 8011f54:	4628      	mov	r0, r5
 8011f56:	4621      	mov	r1, r4
 8011f58:	f7ff f8e0 	bl	801111c <_array_handle_get_as_float>
 8011f5c:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8011f60:	444d      	add	r5, r9
 8011f62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8011f66:	bf14      	ite	ne
 8011f68:	2301      	movne	r3, #1
 8011f6a:	2300      	moveq	r3, #0
 8011f6c:	45ab      	cmp	fp, r5
 8011f6e:	7033      	strb	r3, [r6, #0]
 8011f70:	443e      	add	r6, r7
 8011f72:	d8ef      	bhi.n	8011f54 <forward_cast+0xd50>
 8011f74:	f7ff b9ae 	b.w	80112d4 <forward_cast+0xd0>
 8011f78:	4b2e      	ldr	r3, [pc, #184]	@ (8012034 <forward_cast+0xe30>)
 8011f7a:	459a      	cmp	sl, r3
 8011f7c:	f001 8014 	beq.w	8012fa8 <forward_cast+0x1da4>
 8011f80:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8011f84:	459a      	cmp	sl, r3
 8011f86:	f040 80da 	bne.w	801213e <forward_cast+0xf3a>
 8011f8a:	455d      	cmp	r5, fp
 8011f8c:	f4bf a9a2 	bcs.w	80112d4 <forward_cast+0xd0>
 8011f90:	f8df a0b0 	ldr.w	sl, [pc, #176]	@ 8012044 <forward_cast+0xe40>
 8011f94:	f8df 80b0 	ldr.w	r8, [pc, #176]	@ 8012048 <forward_cast+0xe44>
 8011f98:	4f29      	ldr	r7, [pc, #164]	@ (8012040 <forward_cast+0xe3c>)
 8011f9a:	4b27      	ldr	r3, [pc, #156]	@ (8012038 <forward_cast+0xe34>)
 8011f9c:	4a23      	ldr	r2, [pc, #140]	@ (801202c <forward_cast+0xe28>)
 8011f9e:	e016      	b.n	8011fce <forward_cast+0xdca>
 8011fa0:	429c      	cmp	r4, r3
 8011fa2:	f002 83c3 	beq.w	801472c <forward_cast+0x3528>
 8011fa6:	f340 82dd 	ble.w	8012564 <forward_cast+0x1360>
 8011faa:	4294      	cmp	r4, r2
 8011fac:	f002 83ad 	beq.w	801470a <forward_cast+0x3506>
 8011fb0:	4922      	ldr	r1, [pc, #136]	@ (801203c <forward_cast+0xe38>)
 8011fb2:	428c      	cmp	r4, r1
 8011fb4:	f040 855d 	bne.w	8012a72 <forward_cast+0x186e>
 8011fb8:	7829      	ldrb	r1, [r5, #0]
 8011fba:	3900      	subs	r1, #0
 8011fbc:	bf18      	it	ne
 8011fbe:	2101      	movne	r1, #1
 8011fc0:	444d      	add	r5, r9
 8011fc2:	6031      	str	r1, [r6, #0]
 8011fc4:	9901      	ldr	r1, [sp, #4]
 8011fc6:	45ab      	cmp	fp, r5
 8011fc8:	440e      	add	r6, r1
 8011fca:	f67f a983 	bls.w	80112d4 <forward_cast+0xd0>
 8011fce:	4554      	cmp	r4, sl
 8011fd0:	f002 83c6 	beq.w	8014760 <forward_cast+0x355c>
 8011fd4:	dde4      	ble.n	8011fa0 <forward_cast+0xd9c>
 8011fd6:	4916      	ldr	r1, [pc, #88]	@ (8012030 <forward_cast+0xe2c>)
 8011fd8:	428c      	cmp	r4, r1
 8011fda:	f002 805a 	beq.w	8014092 <forward_cast+0x2e8e>
 8011fde:	f340 8506 	ble.w	80129ee <forward_cast+0x17ea>
 8011fe2:	4544      	cmp	r4, r8
 8011fe4:	f040 8545 	bne.w	8012a72 <forward_cast+0x186e>
 8011fe8:	e9d5 0100 	ldrd	r0, r1, [r5]
 8011fec:	f7ee faa0 	bl	8000530 <__aeabi_l2f>
 8011ff0:	ee07 0a90 	vmov	s15, r0
 8011ff4:	4b10      	ldr	r3, [pc, #64]	@ (8012038 <forward_cast+0xe34>)
 8011ff6:	eef5 7a40 	vcmp.f32	s15, #0.0
 8011ffa:	4a0c      	ldr	r2, [pc, #48]	@ (801202c <forward_cast+0xe28>)
 8011ffc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012000:	bf14      	ite	ne
 8012002:	2101      	movne	r1, #1
 8012004:	2100      	moveq	r1, #0
 8012006:	e7db      	b.n	8011fc0 <forward_cast+0xdbc>
 8012008:	459a      	cmp	sl, r3
 801200a:	f000 8560 	beq.w	8012ace <forward_cast+0x18ca>
 801200e:	4592      	cmp	sl, r2
 8012010:	f040 80b0 	bne.w	8012174 <forward_cast+0xf70>
 8012014:	455d      	cmp	r5, fp
 8012016:	f4bf a95d 	bcs.w	80112d4 <forward_cast+0xd0>
 801201a:	f8df a028 	ldr.w	sl, [pc, #40]	@ 8012044 <forward_cast+0xe40>
 801201e:	f8df 8028 	ldr.w	r8, [pc, #40]	@ 8012048 <forward_cast+0xe44>
 8012022:	4f07      	ldr	r7, [pc, #28]	@ (8012040 <forward_cast+0xe3c>)
 8012024:	4b04      	ldr	r3, [pc, #16]	@ (8012038 <forward_cast+0xe34>)
 8012026:	4a01      	ldr	r2, [pc, #4]	@ (801202c <forward_cast+0xe28>)
 8012028:	e02a      	b.n	8012080 <forward_cast+0xe7c>
 801202a:	bf00      	nop
 801202c:	00042040 	.word	0x00042040
 8012030:	00841040 	.word	0x00841040
 8012034:	00840840 	.word	0x00840840
 8012038:	00041040 	.word	0x00041040
 801203c:	00060440 	.word	0x00060440
 8012040:	00840440 	.word	0x00840440
 8012044:	00821040 	.word	0x00821040
 8012048:	00842040 	.word	0x00842040
 801204c:	429c      	cmp	r4, r3
 801204e:	f002 82a3 	beq.w	8014598 <forward_cast+0x3394>
 8012052:	f340 8405 	ble.w	8012860 <forward_cast+0x165c>
 8012056:	4294      	cmp	r4, r2
 8012058:	f002 83c8 	beq.w	80147ec <forward_cast+0x35e8>
 801205c:	49b6      	ldr	r1, [pc, #728]	@ (8012338 <forward_cast+0x1134>)
 801205e:	428c      	cmp	r4, r1
 8012060:	f040 84fe 	bne.w	8012a60 <forward_cast+0x185c>
 8012064:	7828      	ldrb	r0, [r5, #0]
 8012066:	3800      	subs	r0, #0
 8012068:	bf18      	it	ne
 801206a:	2001      	movne	r0, #1
 801206c:	f300 0007 	ssat	r0, #8, r0
 8012070:	444d      	add	r5, r9
 8012072:	b240      	sxtb	r0, r0
 8012074:	9901      	ldr	r1, [sp, #4]
 8012076:	45ab      	cmp	fp, r5
 8012078:	6030      	str	r0, [r6, #0]
 801207a:	440e      	add	r6, r1
 801207c:	f67f a92a 	bls.w	80112d4 <forward_cast+0xd0>
 8012080:	4554      	cmp	r4, sl
 8012082:	f002 84e7 	beq.w	8014a54 <forward_cast+0x3850>
 8012086:	dde1      	ble.n	801204c <forward_cast+0xe48>
 8012088:	49ac      	ldr	r1, [pc, #688]	@ (801233c <forward_cast+0x1138>)
 801208a:	428c      	cmp	r4, r1
 801208c:	f001 8554 	beq.w	8013b38 <forward_cast+0x2934>
 8012090:	f340 8418 	ble.w	80128c4 <forward_cast+0x16c0>
 8012094:	4544      	cmp	r4, r8
 8012096:	f040 84e3 	bne.w	8012a60 <forward_cast+0x185c>
 801209a:	e9d5 0100 	ldrd	r0, r1, [r5]
 801209e:	f7ee fa47 	bl	8000530 <__aeabi_l2f>
 80120a2:	ee07 0a90 	vmov	s15, r0
 80120a6:	4ba6      	ldr	r3, [pc, #664]	@ (8012340 <forward_cast+0x113c>)
 80120a8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80120ac:	4aa5      	ldr	r2, [pc, #660]	@ (8012344 <forward_cast+0x1140>)
 80120ae:	ee17 0a90 	vmov	r0, s15
 80120b2:	e7db      	b.n	801206c <forward_cast+0xe68>
 80120b4:	4ba4      	ldr	r3, [pc, #656]	@ (8012348 <forward_cast+0x1144>)
 80120b6:	459a      	cmp	sl, r3
 80120b8:	f47f a90c 	bne.w	80112d4 <forward_cast+0xd0>
 80120bc:	455d      	cmp	r5, fp
 80120be:	f4bf a909 	bcs.w	80112d4 <forward_cast+0xd0>
 80120c2:	2300      	movs	r3, #0
 80120c4:	4619      	mov	r1, r3
 80120c6:	464b      	mov	r3, r9
 80120c8:	46b9      	mov	r9, r7
 80120ca:	4637      	mov	r7, r6
 80120cc:	460e      	mov	r6, r1
 80120ce:	e019      	b.n	8012104 <forward_cast+0xf00>
 80120d0:	499b      	ldr	r1, [pc, #620]	@ (8012340 <forward_cast+0x113c>)
 80120d2:	428c      	cmp	r4, r1
 80120d4:	f002 80e6 	beq.w	80142a4 <forward_cast+0x30a0>
 80120d8:	f340 825f 	ble.w	801259a <forward_cast+0x1396>
 80120dc:	4999      	ldr	r1, [pc, #612]	@ (8012344 <forward_cast+0x1140>)
 80120de:	428c      	cmp	r4, r1
 80120e0:	f001 8687 	beq.w	8013df2 <forward_cast+0x2bee>
 80120e4:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 80120e8:	428c      	cmp	r4, r1
 80120ea:	f040 8447 	bne.w	801297c <forward_cast+0x1778>
 80120ee:	7829      	ldrb	r1, [r5, #0]
 80120f0:	3900      	subs	r1, #0
 80120f2:	bf18      	it	ne
 80120f4:	2101      	movne	r1, #1
 80120f6:	441d      	add	r5, r3
 80120f8:	55b9      	strb	r1, [r7, r6]
 80120fa:	9901      	ldr	r1, [sp, #4]
 80120fc:	45ab      	cmp	fp, r5
 80120fe:	440e      	add	r6, r1
 8012100:	f67f a8e8 	bls.w	80112d4 <forward_cast+0xd0>
 8012104:	454c      	cmp	r4, r9
 8012106:	f002 8336 	beq.w	8014776 <forward_cast+0x3572>
 801210a:	dde1      	ble.n	80120d0 <forward_cast+0xecc>
 801210c:	4294      	cmp	r4, r2
 801210e:	f001 87e0 	beq.w	80140d2 <forward_cast+0x2ece>
 8012112:	f340 842d 	ble.w	8012970 <forward_cast+0x176c>
 8012116:	498d      	ldr	r1, [pc, #564]	@ (801234c <forward_cast+0x1148>)
 8012118:	428c      	cmp	r4, r1
 801211a:	f040 842f 	bne.w	801297c <forward_cast+0x1778>
 801211e:	9303      	str	r3, [sp, #12]
 8012120:	e9d5 0100 	ldrd	r0, r1, [r5]
 8012124:	f7ee fa04 	bl	8000530 <__aeabi_l2f>
 8012128:	ee07 0a90 	vmov	s15, r0
 801212c:	4a83      	ldr	r2, [pc, #524]	@ (801233c <forward_cast+0x1138>)
 801212e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8012132:	9b03      	ldr	r3, [sp, #12]
 8012134:	edcd 7a02 	vstr	s15, [sp, #8]
 8012138:	f99d 1008 	ldrsb.w	r1, [sp, #8]
 801213c:	e7db      	b.n	80120f6 <forward_cast+0xef2>
 801213e:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
 8012142:	459a      	cmp	sl, r3
 8012144:	f47f a8c6 	bne.w	80112d4 <forward_cast+0xd0>
 8012148:	455d      	cmp	r5, fp
 801214a:	f4bf a8c3 	bcs.w	80112d4 <forward_cast+0xd0>
 801214e:	9f01      	ldr	r7, [sp, #4]
 8012150:	4628      	mov	r0, r5
 8012152:	4621      	mov	r1, r4
 8012154:	f7fe ffe2 	bl	801111c <_array_handle_get_as_float>
 8012158:	eeb5 0a40 	vcmp.f32	s0, #0.0
 801215c:	444d      	add	r5, r9
 801215e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012162:	bf14      	ite	ne
 8012164:	2301      	movne	r3, #1
 8012166:	2300      	moveq	r3, #0
 8012168:	45ab      	cmp	fp, r5
 801216a:	7033      	strb	r3, [r6, #0]
 801216c:	443e      	add	r6, r7
 801216e:	d8ef      	bhi.n	8012150 <forward_cast+0xf4c>
 8012170:	f7ff b8b0 	b.w	80112d4 <forward_cast+0xd0>
 8012174:	4b74      	ldr	r3, [pc, #464]	@ (8012348 <forward_cast+0x1144>)
 8012176:	459a      	cmp	sl, r3
 8012178:	f47f a8ac 	bne.w	80112d4 <forward_cast+0xd0>
 801217c:	455d      	cmp	r5, fp
 801217e:	f4bf a8a9 	bcs.w	80112d4 <forward_cast+0xd0>
 8012182:	2700      	movs	r7, #0
 8012184:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 801233c <forward_cast+0x1138>
 8012188:	4b6d      	ldr	r3, [pc, #436]	@ (8012340 <forward_cast+0x113c>)
 801218a:	4a6e      	ldr	r2, [pc, #440]	@ (8012344 <forward_cast+0x1140>)
 801218c:	e018      	b.n	80121c0 <forward_cast+0xfbc>
 801218e:	429c      	cmp	r4, r3
 8012190:	f002 80ba 	beq.w	8014308 <forward_cast+0x3104>
 8012194:	f340 8243 	ble.w	801261e <forward_cast+0x141a>
 8012198:	4294      	cmp	r4, r2
 801219a:	f002 8541 	beq.w	8014c20 <forward_cast+0x3a1c>
 801219e:	4966      	ldr	r1, [pc, #408]	@ (8012338 <forward_cast+0x1134>)
 80121a0:	428c      	cmp	r4, r1
 80121a2:	f040 8475 	bne.w	8012a90 <forward_cast+0x188c>
 80121a6:	7828      	ldrb	r0, [r5, #0]
 80121a8:	3800      	subs	r0, #0
 80121aa:	bf18      	it	ne
 80121ac:	2001      	movne	r0, #1
 80121ae:	f300 0007 	ssat	r0, #8, r0
 80121b2:	444d      	add	r5, r9
 80121b4:	9901      	ldr	r1, [sp, #4]
 80121b6:	55f0      	strb	r0, [r6, r7]
 80121b8:	45ab      	cmp	fp, r5
 80121ba:	440f      	add	r7, r1
 80121bc:	f67f a88a 	bls.w	80112d4 <forward_cast+0xd0>
 80121c0:	4963      	ldr	r1, [pc, #396]	@ (8012350 <forward_cast+0x114c>)
 80121c2:	428c      	cmp	r4, r1
 80121c4:	f002 839c 	beq.w	8014900 <forward_cast+0x36fc>
 80121c8:	dde1      	ble.n	801218e <forward_cast+0xf8a>
 80121ca:	4544      	cmp	r4, r8
 80121cc:	f001 84f6 	beq.w	8013bbc <forward_cast+0x29b8>
 80121d0:	f340 83a5 	ble.w	801291e <forward_cast+0x171a>
 80121d4:	495d      	ldr	r1, [pc, #372]	@ (801234c <forward_cast+0x1148>)
 80121d6:	428c      	cmp	r4, r1
 80121d8:	f040 845a 	bne.w	8012a90 <forward_cast+0x188c>
 80121dc:	e9d5 0100 	ldrd	r0, r1, [r5]
 80121e0:	f7ee f9a6 	bl	8000530 <__aeabi_l2f>
 80121e4:	ee07 0a90 	vmov	s15, r0
 80121e8:	4b55      	ldr	r3, [pc, #340]	@ (8012340 <forward_cast+0x113c>)
 80121ea:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80121ee:	4a55      	ldr	r2, [pc, #340]	@ (8012344 <forward_cast+0x1140>)
 80121f0:	ee17 0a90 	vmov	r0, s15
 80121f4:	e7db      	b.n	80121ae <forward_cast+0xfaa>
 80121f6:	4b57      	ldr	r3, [pc, #348]	@ (8012354 <forward_cast+0x1150>)
 80121f8:	459a      	cmp	sl, r3
 80121fa:	f000 8510 	beq.w	8012c1e <forward_cast+0x1a1a>
 80121fe:	4f4f      	ldr	r7, [pc, #316]	@ (801233c <forward_cast+0x1138>)
 8012200:	45ba      	cmp	sl, r7
 8012202:	d157      	bne.n	80122b4 <forward_cast+0x10b0>
 8012204:	455d      	cmp	r5, fp
 8012206:	f4bf a865 	bcs.w	80112d4 <forward_cast+0xd0>
 801220a:	f8df 8140 	ldr.w	r8, [pc, #320]	@ 801234c <forward_cast+0x1148>
 801220e:	4f4e      	ldr	r7, [pc, #312]	@ (8012348 <forward_cast+0x1144>)
 8012210:	4b4c      	ldr	r3, [pc, #304]	@ (8012344 <forward_cast+0x1140>)
 8012212:	4a49      	ldr	r2, [pc, #292]	@ (8012338 <forward_cast+0x1134>)
 8012214:	e01a      	b.n	801224c <forward_cast+0x1048>
 8012216:	f5a1 01fc 	sub.w	r1, r1, #8257536	@ 0x7e0000
 801221a:	428c      	cmp	r4, r1
 801221c:	f001 87c0 	beq.w	80141a0 <forward_cast+0x2f9c>
 8012220:	f340 8188 	ble.w	8012534 <forward_cast+0x1330>
 8012224:	429c      	cmp	r4, r3
 8012226:	f002 84d2 	beq.w	8014bce <forward_cast+0x39ca>
 801222a:	4294      	cmp	r4, r2
 801222c:	f040 842a 	bne.w	8012a84 <forward_cast+0x1880>
 8012230:	7828      	ldrb	r0, [r5, #0]
 8012232:	3800      	subs	r0, #0
 8012234:	bf18      	it	ne
 8012236:	2001      	movne	r0, #1
 8012238:	f380 0010 	usat	r0, #16, r0
 801223c:	444d      	add	r5, r9
 801223e:	b280      	uxth	r0, r0
 8012240:	9901      	ldr	r1, [sp, #4]
 8012242:	45ab      	cmp	fp, r5
 8012244:	6030      	str	r0, [r6, #0]
 8012246:	440e      	add	r6, r1
 8012248:	f67f a844 	bls.w	80112d4 <forward_cast+0xd0>
 801224c:	4940      	ldr	r1, [pc, #256]	@ (8012350 <forward_cast+0x114c>)
 801224e:	428c      	cmp	r4, r1
 8012250:	f002 8455 	beq.w	8014afe <forward_cast+0x38fa>
 8012254:	dddf      	ble.n	8012216 <forward_cast+0x1012>
 8012256:	4554      	cmp	r4, sl
 8012258:	f001 875a 	beq.w	8014110 <forward_cast+0x2f0c>
 801225c:	f340 83e0 	ble.w	8012a20 <forward_cast+0x181c>
 8012260:	4544      	cmp	r4, r8
 8012262:	f040 840f 	bne.w	8012a84 <forward_cast+0x1880>
 8012266:	e9d5 0100 	ldrd	r0, r1, [r5]
 801226a:	f7ee f961 	bl	8000530 <__aeabi_l2f>
 801226e:	ee07 0a90 	vmov	s15, r0
 8012272:	4b34      	ldr	r3, [pc, #208]	@ (8012344 <forward_cast+0x1140>)
 8012274:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8012278:	4a2f      	ldr	r2, [pc, #188]	@ (8012338 <forward_cast+0x1134>)
 801227a:	ee17 0a90 	vmov	r0, s15
 801227e:	e7db      	b.n	8012238 <forward_cast+0x1034>
 8012280:	f5a3 6340 	sub.w	r3, r3, #3072	@ 0xc00
 8012284:	459a      	cmp	sl, r3
 8012286:	f47f a825 	bne.w	80112d4 <forward_cast+0xd0>
 801228a:	455d      	cmp	r5, fp
 801228c:	f4bf a822 	bcs.w	80112d4 <forward_cast+0xd0>
 8012290:	9f01      	ldr	r7, [sp, #4]
 8012292:	4621      	mov	r1, r4
 8012294:	4628      	mov	r0, r5
 8012296:	f7fe ff41 	bl	801111c <_array_handle_get_as_float>
 801229a:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 801229e:	ee17 3a90 	vmov	r3, s15
 80122a2:	f383 0308 	usat	r3, #8, r3
 80122a6:	444d      	add	r5, r9
 80122a8:	7033      	strb	r3, [r6, #0]
 80122aa:	443e      	add	r6, r7
 80122ac:	45ab      	cmp	fp, r5
 80122ae:	d8f0      	bhi.n	8012292 <forward_cast+0x108e>
 80122b0:	f7ff b810 	b.w	80112d4 <forward_cast+0xd0>
 80122b4:	f5a3 6380 	sub.w	r3, r3, #1024	@ 0x400
 80122b8:	459a      	cmp	sl, r3
 80122ba:	f47f a80b 	bne.w	80112d4 <forward_cast+0xd0>
 80122be:	455d      	cmp	r5, fp
 80122c0:	f4bf a808 	bcs.w	80112d4 <forward_cast+0xd0>
 80122c4:	f04f 0800 	mov.w	r8, #0
 80122c8:	4b1d      	ldr	r3, [pc, #116]	@ (8012340 <forward_cast+0x113c>)
 80122ca:	4a1e      	ldr	r2, [pc, #120]	@ (8012344 <forward_cast+0x1140>)
 80122cc:	e019      	b.n	8012302 <forward_cast+0x10fe>
 80122ce:	429c      	cmp	r4, r3
 80122d0:	f002 8370 	beq.w	80149b4 <forward_cast+0x37b0>
 80122d4:	f340 822d 	ble.w	8012732 <forward_cast+0x152e>
 80122d8:	4294      	cmp	r4, r2
 80122da:	f002 835d 	beq.w	8014998 <forward_cast+0x3794>
 80122de:	4916      	ldr	r1, [pc, #88]	@ (8012338 <forward_cast+0x1134>)
 80122e0:	428c      	cmp	r4, r1
 80122e2:	f040 83bb 	bne.w	8012a5c <forward_cast+0x1858>
 80122e6:	7828      	ldrb	r0, [r5, #0]
 80122e8:	3800      	subs	r0, #0
 80122ea:	bf18      	it	ne
 80122ec:	2001      	movne	r0, #1
 80122ee:	f380 0010 	usat	r0, #16, r0
 80122f2:	444d      	add	r5, r9
 80122f4:	9901      	ldr	r1, [sp, #4]
 80122f6:	f806 0008 	strb.w	r0, [r6, r8]
 80122fa:	45ab      	cmp	fp, r5
 80122fc:	4488      	add	r8, r1
 80122fe:	f67e afe9 	bls.w	80112d4 <forward_cast+0xd0>
 8012302:	4913      	ldr	r1, [pc, #76]	@ (8012350 <forward_cast+0x114c>)
 8012304:	428c      	cmp	r4, r1
 8012306:	f002 81d6 	beq.w	80146b6 <forward_cast+0x34b2>
 801230a:	dde0      	ble.n	80122ce <forward_cast+0x10ca>
 801230c:	42bc      	cmp	r4, r7
 801230e:	f002 8603 	beq.w	8014f18 <forward_cast+0x3d14>
 8012312:	f340 825c 	ble.w	80127ce <forward_cast+0x15ca>
 8012316:	490d      	ldr	r1, [pc, #52]	@ (801234c <forward_cast+0x1148>)
 8012318:	428c      	cmp	r4, r1
 801231a:	f040 839f 	bne.w	8012a5c <forward_cast+0x1858>
 801231e:	e9d5 0100 	ldrd	r0, r1, [r5]
 8012322:	f7ee f905 	bl	8000530 <__aeabi_l2f>
 8012326:	ee07 0a90 	vmov	s15, r0
 801232a:	4b05      	ldr	r3, [pc, #20]	@ (8012340 <forward_cast+0x113c>)
 801232c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8012330:	4a04      	ldr	r2, [pc, #16]	@ (8012344 <forward_cast+0x1140>)
 8012332:	ee17 0a90 	vmov	r0, s15
 8012336:	e7da      	b.n	80122ee <forward_cast+0x10ea>
 8012338:	00060440 	.word	0x00060440
 801233c:	00841040 	.word	0x00841040
 8012340:	00041040 	.word	0x00041040
 8012344:	00042040 	.word	0x00042040
 8012348:	00840440 	.word	0x00840440
 801234c:	00842040 	.word	0x00842040
 8012350:	00821040 	.word	0x00821040
 8012354:	00840840 	.word	0x00840840
 8012358:	455d      	cmp	r5, fp
 801235a:	f4be afbb 	bcs.w	80112d4 <forward_cast+0xd0>
 801235e:	4fba      	ldr	r7, [pc, #744]	@ (8012648 <forward_cast+0x1444>)
 8012360:	f8df 82f8 	ldr.w	r8, [pc, #760]	@ 801265c <forward_cast+0x1458>
 8012364:	e020      	b.n	80123a8 <forward_cast+0x11a4>
 8012366:	429c      	cmp	r4, r3
 8012368:	f002 8109 	beq.w	801457e <forward_cast+0x337a>
 801236c:	f340 81cc 	ble.w	8012708 <forward_cast+0x1504>
 8012370:	49b6      	ldr	r1, [pc, #728]	@ (801264c <forward_cast+0x1448>)
 8012372:	428c      	cmp	r4, r1
 8012374:	f002 80f5 	beq.w	8014562 <forward_cast+0x335e>
 8012378:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 801237c:	428c      	cmp	r4, r1
 801237e:	f040 83a2 	bne.w	8012ac6 <forward_cast+0x18c2>
 8012382:	7828      	ldrb	r0, [r5, #0]
 8012384:	3800      	subs	r0, #0
 8012386:	bf18      	it	ne
 8012388:	2001      	movne	r0, #1
 801238a:	f380 0010 	usat	r0, #16, r0
 801238e:	b280      	uxth	r0, r0
 8012390:	444d      	add	r5, r9
 8012392:	9901      	ldr	r1, [sp, #4]
 8012394:	ee07 0a90 	vmov	s15, r0
 8012398:	45ab      	cmp	fp, r5
 801239a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801239e:	edc6 7a00 	vstr	s15, [r6]
 80123a2:	440e      	add	r6, r1
 80123a4:	f67e af96 	bls.w	80112d4 <forward_cast+0xd0>
 80123a8:	4554      	cmp	r4, sl
 80123aa:	f002 80a5 	beq.w	80144f8 <forward_cast+0x32f4>
 80123ae:	ddda      	ble.n	8012366 <forward_cast+0x1162>
 80123b0:	42bc      	cmp	r4, r7
 80123b2:	f001 85d0 	beq.w	8013f56 <forward_cast+0x2d52>
 80123b6:	f340 81b0 	ble.w	801271a <forward_cast+0x1516>
 80123ba:	4544      	cmp	r4, r8
 80123bc:	f040 8383 	bne.w	8012ac6 <forward_cast+0x18c2>
 80123c0:	e9d5 0100 	ldrd	r0, r1, [r5]
 80123c4:	f7ee f8b4 	bl	8000530 <__aeabi_l2f>
 80123c8:	ee07 0a90 	vmov	s15, r0
 80123cc:	4ba0      	ldr	r3, [pc, #640]	@ (8012650 <forward_cast+0x144c>)
 80123ce:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80123d2:	4aa0      	ldr	r2, [pc, #640]	@ (8012654 <forward_cast+0x1450>)
 80123d4:	ee17 0a90 	vmov	r0, s15
 80123d8:	e7d7      	b.n	801238a <forward_cast+0x1186>
 80123da:	455d      	cmp	r5, fp
 80123dc:	f4be af7a 	bcs.w	80112d4 <forward_cast+0xd0>
 80123e0:	ed9f 8a9d 	vldr	s16, [pc, #628]	@ 8012658 <forward_cast+0x1454>
 80123e4:	4a9d      	ldr	r2, [pc, #628]	@ (801265c <forward_cast+0x1458>)
 80123e6:	f8df 8280 	ldr.w	r8, [pc, #640]	@ 8012668 <forward_cast+0x1464>
 80123ea:	e01a      	b.n	8012422 <forward_cast+0x121e>
 80123ec:	4998      	ldr	r1, [pc, #608]	@ (8012650 <forward_cast+0x144c>)
 80123ee:	428c      	cmp	r4, r1
 80123f0:	f002 8225 	beq.w	801483e <forward_cast+0x363a>
 80123f4:	f340 824a 	ble.w	801288c <forward_cast+0x1688>
 80123f8:	4994      	ldr	r1, [pc, #592]	@ (801264c <forward_cast+0x1448>)
 80123fa:	428c      	cmp	r4, r1
 80123fc:	f001 8744 	beq.w	8014288 <forward_cast+0x3084>
 8012400:	4544      	cmp	r4, r8
 8012402:	f040 834e 	bne.w	8012aa2 <forward_cast+0x189e>
 8012406:	7829      	ldrb	r1, [r5, #0]
 8012408:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 801240c:	2900      	cmp	r1, #0
 801240e:	fe48 7a27 	vseleq.f32	s15, s16, s15
 8012412:	444d      	add	r5, r9
 8012414:	9901      	ldr	r1, [sp, #4]
 8012416:	edc6 7a00 	vstr	s15, [r6]
 801241a:	45ab      	cmp	fp, r5
 801241c:	440e      	add	r6, r1
 801241e:	f67e af59 	bls.w	80112d4 <forward_cast+0xd0>
 8012422:	4554      	cmp	r4, sl
 8012424:	f002 8060 	beq.w	80144e8 <forward_cast+0x32e4>
 8012428:	dde0      	ble.n	80123ec <forward_cast+0x11e8>
 801242a:	42bc      	cmp	r4, r7
 801242c:	f001 85a0 	beq.w	8013f70 <forward_cast+0x2d6c>
 8012430:	f340 82bc 	ble.w	80129ac <forward_cast+0x17a8>
 8012434:	4294      	cmp	r4, r2
 8012436:	f040 8334 	bne.w	8012aa2 <forward_cast+0x189e>
 801243a:	e9d5 0100 	ldrd	r0, r1, [r5]
 801243e:	f7ee f877 	bl	8000530 <__aeabi_l2f>
 8012442:	ee07 0a90 	vmov	s15, r0
 8012446:	4b86      	ldr	r3, [pc, #536]	@ (8012660 <forward_cast+0x145c>)
 8012448:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801244c:	4a83      	ldr	r2, [pc, #524]	@ (801265c <forward_cast+0x1458>)
 801244e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8012452:	e7de      	b.n	8012412 <forward_cast+0x120e>
 8012454:	455d      	cmp	r5, fp
 8012456:	f4be af3d 	bcs.w	80112d4 <forward_cast+0xd0>
 801245a:	f8df 8200 	ldr.w	r8, [pc, #512]	@ 801265c <forward_cast+0x1458>
 801245e:	e021      	b.n	80124a4 <forward_cast+0x12a0>
 8012460:	497b      	ldr	r1, [pc, #492]	@ (8012650 <forward_cast+0x144c>)
 8012462:	428c      	cmp	r4, r1
 8012464:	f002 8061 	beq.w	801452a <forward_cast+0x3326>
 8012468:	f340 81a5 	ble.w	80127b6 <forward_cast+0x15b2>
 801246c:	4977      	ldr	r1, [pc, #476]	@ (801264c <forward_cast+0x1448>)
 801246e:	428c      	cmp	r4, r1
 8012470:	f002 8418 	beq.w	8014ca4 <forward_cast+0x3aa0>
 8012474:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 8012478:	428c      	cmp	r4, r1
 801247a:	f040 8326 	bne.w	8012aca <forward_cast+0x18c6>
 801247e:	7828      	ldrb	r0, [r5, #0]
 8012480:	3800      	subs	r0, #0
 8012482:	bf18      	it	ne
 8012484:	2001      	movne	r0, #1
 8012486:	f300 0007 	ssat	r0, #8, r0
 801248a:	b240      	sxtb	r0, r0
 801248c:	444d      	add	r5, r9
 801248e:	9901      	ldr	r1, [sp, #4]
 8012490:	ee07 0a90 	vmov	s15, r0
 8012494:	45ab      	cmp	fp, r5
 8012496:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801249a:	edc6 7a00 	vstr	s15, [r6]
 801249e:	440e      	add	r6, r1
 80124a0:	f67e af18 	bls.w	80112d4 <forward_cast+0xd0>
 80124a4:	4554      	cmp	r4, sl
 80124a6:	f001 87aa 	beq.w	80143fe <forward_cast+0x31fa>
 80124aa:	ddd9      	ble.n	8012460 <forward_cast+0x125c>
 80124ac:	4294      	cmp	r4, r2
 80124ae:	f001 87ae 	beq.w	801440e <forward_cast+0x320a>
 80124b2:	f340 8155 	ble.w	8012760 <forward_cast+0x155c>
 80124b6:	4544      	cmp	r4, r8
 80124b8:	f040 8307 	bne.w	8012aca <forward_cast+0x18c6>
 80124bc:	e9d5 0100 	ldrd	r0, r1, [r5]
 80124c0:	f7ee f836 	bl	8000530 <__aeabi_l2f>
 80124c4:	ee07 0a90 	vmov	s15, r0
 80124c8:	4b65      	ldr	r3, [pc, #404]	@ (8012660 <forward_cast+0x145c>)
 80124ca:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80124ce:	4a5e      	ldr	r2, [pc, #376]	@ (8012648 <forward_cast+0x1444>)
 80124d0:	ee17 0a90 	vmov	r0, s15
 80124d4:	e7d7      	b.n	8012486 <forward_cast+0x1282>
 80124d6:	455d      	cmp	r5, fp
 80124d8:	f4be aefc 	bcs.w	80112d4 <forward_cast+0xd0>
 80124dc:	f04f 587e 	mov.w	r8, #1065353216	@ 0x3f800000
 80124e0:	2700      	movs	r7, #0
 80124e2:	4628      	mov	r0, r5
 80124e4:	4621      	mov	r1, r4
 80124e6:	f7fe fe19 	bl	801111c <_array_handle_get_as_float>
 80124ea:	eeb5 0a40 	vcmp.f32	s0, #0.0
 80124ee:	444d      	add	r5, r9
 80124f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80124f4:	f000 82a7 	beq.w	8012a46 <forward_cast+0x1842>
 80124f8:	9b01      	ldr	r3, [sp, #4]
 80124fa:	45ab      	cmp	fp, r5
 80124fc:	f8c6 8000 	str.w	r8, [r6]
 8012500:	441e      	add	r6, r3
 8012502:	d8ee      	bhi.n	80124e2 <forward_cast+0x12de>
 8012504:	f7fe bee6 	b.w	80112d4 <forward_cast+0xd0>
 8012508:	4952      	ldr	r1, [pc, #328]	@ (8012654 <forward_cast+0x1450>)
 801250a:	428c      	cmp	r4, r1
 801250c:	f002 80c7 	beq.w	801469e <forward_cast+0x349a>
 8012510:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012514:	428c      	cmp	r4, r1
 8012516:	f040 82a9 	bne.w	8012a6c <forward_cast+0x1868>
 801251a:	8828      	ldrh	r0, [r5, #0]
 801251c:	e4ac      	b.n	8011e78 <forward_cast+0xc74>
 801251e:	42bc      	cmp	r4, r7
 8012520:	f001 8648 	beq.w	80141b4 <forward_cast+0x2fb0>
 8012524:	f5a1 6100 	sub.w	r1, r1, #2048	@ 0x800
 8012528:	428c      	cmp	r4, r1
 801252a:	f040 829f 	bne.w	8012a6c <forward_cast+0x1868>
 801252e:	f9b5 0000 	ldrsh.w	r0, [r5]
 8012532:	e4a1      	b.n	8011e78 <forward_cast+0xc74>
 8012534:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 8012538:	428c      	cmp	r4, r1
 801253a:	f002 8154 	beq.w	80147e6 <forward_cast+0x35e2>
 801253e:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012542:	428c      	cmp	r4, r1
 8012544:	f040 829e 	bne.w	8012a84 <forward_cast+0x1880>
 8012548:	8828      	ldrh	r0, [r5, #0]
 801254a:	e675      	b.n	8012238 <forward_cast+0x1034>
 801254c:	4941      	ldr	r1, [pc, #260]	@ (8012654 <forward_cast+0x1450>)
 801254e:	428c      	cmp	r4, r1
 8012550:	f002 80f9 	beq.w	8014746 <forward_cast+0x3542>
 8012554:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012558:	428c      	cmp	r4, r1
 801255a:	f040 8290 	bne.w	8012a7e <forward_cast+0x187a>
 801255e:	8828      	ldrh	r0, [r5, #0]
 8012560:	f7ff bb0c 	b.w	8011b7c <forward_cast+0x978>
 8012564:	493b      	ldr	r1, [pc, #236]	@ (8012654 <forward_cast+0x1450>)
 8012566:	428c      	cmp	r4, r1
 8012568:	f43f ad26 	beq.w	8011fb8 <forward_cast+0xdb4>
 801256c:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012570:	428c      	cmp	r4, r1
 8012572:	f040 827e 	bne.w	8012a72 <forward_cast+0x186e>
 8012576:	8829      	ldrh	r1, [r5, #0]
 8012578:	3900      	subs	r1, #0
 801257a:	bf18      	it	ne
 801257c:	2101      	movne	r1, #1
 801257e:	e51f      	b.n	8011fc0 <forward_cast+0xdbc>
 8012580:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 8012584:	428c      	cmp	r4, r1
 8012586:	f001 8699 	beq.w	80142bc <forward_cast+0x30b8>
 801258a:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 801258e:	428c      	cmp	r4, r1
 8012590:	f040 8272 	bne.w	8012a78 <forward_cast+0x1874>
 8012594:	8828      	ldrh	r0, [r5, #0]
 8012596:	f7ff b953 	b.w	8011840 <forward_cast+0x63c>
 801259a:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 801259e:	428c      	cmp	r4, r1
 80125a0:	d004      	beq.n	80125ac <forward_cast+0x13a8>
 80125a2:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 80125a6:	428c      	cmp	r4, r1
 80125a8:	f040 81e8 	bne.w	801297c <forward_cast+0x1778>
 80125ac:	f995 1000 	ldrsb.w	r1, [r5]
 80125b0:	e5a1      	b.n	80120f6 <forward_cast+0xef2>
 80125b2:	4928      	ldr	r1, [pc, #160]	@ (8012654 <forward_cast+0x1450>)
 80125b4:	428c      	cmp	r4, r1
 80125b6:	f001 86a4 	beq.w	8014302 <forward_cast+0x30fe>
 80125ba:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 80125be:	428c      	cmp	r4, r1
 80125c0:	f040 8263 	bne.w	8012a8a <forward_cast+0x1886>
 80125c4:	8828      	ldrh	r0, [r5, #0]
 80125c6:	f7ff ba02 	b.w	80119ce <forward_cast+0x7ca>
 80125ca:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 80125ce:	428c      	cmp	r4, r1
 80125d0:	d001      	beq.n	80125d6 <forward_cast+0x13d2>
 80125d2:	429c      	cmp	r4, r3
 80125d4:	d151      	bne.n	801267a <forward_cast+0x1476>
 80125d6:	f995 1000 	ldrsb.w	r1, [r5]
 80125da:	f7ff bb97 	b.w	8011d0c <forward_cast+0xb08>
 80125de:	491d      	ldr	r1, [pc, #116]	@ (8012654 <forward_cast+0x1450>)
 80125e0:	428c      	cmp	r4, r1
 80125e2:	f002 831a 	beq.w	8014c1a <forward_cast+0x3a16>
 80125e6:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 80125ea:	428c      	cmp	r4, r1
 80125ec:	f040 8253 	bne.w	8012a96 <forward_cast+0x1892>
 80125f0:	8828      	ldrh	r0, [r5, #0]
 80125f2:	f7ff b81a 	b.w	801162a <forward_cast+0x426>
 80125f6:	4544      	cmp	r4, r8
 80125f8:	f001 85f2 	beq.w	80141e0 <forward_cast+0x2fdc>
 80125fc:	4919      	ldr	r1, [pc, #100]	@ (8012664 <forward_cast+0x1460>)
 80125fe:	428c      	cmp	r4, r1
 8012600:	f040 824c 	bne.w	8012a9c <forward_cast+0x1898>
 8012604:	8828      	ldrh	r0, [r5, #0]
 8012606:	f7fe be9e 	b.w	8011346 <forward_cast+0x142>
 801260a:	4912      	ldr	r1, [pc, #72]	@ (8012654 <forward_cast+0x1450>)
 801260c:	428c      	cmp	r4, r1
 801260e:	d003      	beq.n	8012618 <forward_cast+0x1414>
 8012610:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012614:	428c      	cmp	r4, r1
 8012616:	d168      	bne.n	80126ea <forward_cast+0x14e6>
 8012618:	7829      	ldrb	r1, [r5, #0]
 801261a:	f7ff b994 	b.w	8011946 <forward_cast+0x742>
 801261e:	490d      	ldr	r1, [pc, #52]	@ (8012654 <forward_cast+0x1450>)
 8012620:	428c      	cmp	r4, r1
 8012622:	f002 8130 	beq.w	8014886 <forward_cast+0x3682>
 8012626:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 801262a:	428c      	cmp	r4, r1
 801262c:	f040 8230 	bne.w	8012a90 <forward_cast+0x188c>
 8012630:	8828      	ldrh	r0, [r5, #0]
 8012632:	e5bc      	b.n	80121ae <forward_cast+0xfaa>
 8012634:	4294      	cmp	r4, r2
 8012636:	f001 868d 	beq.w	8014354 <forward_cast+0x3150>
 801263a:	490a      	ldr	r1, [pc, #40]	@ (8012664 <forward_cast+0x1460>)
 801263c:	428c      	cmp	r4, r1
 801263e:	f040 817f 	bne.w	8012940 <forward_cast+0x173c>
 8012642:	8829      	ldrh	r1, [r5, #0]
 8012644:	f7ff b841 	b.w	80116ca <forward_cast+0x4c6>
 8012648:	00841040 	.word	0x00841040
 801264c:	00042040 	.word	0x00042040
 8012650:	00041040 	.word	0x00041040
 8012654:	00040440 	.word	0x00040440
 8012658:	00000000 	.word	0x00000000
 801265c:	00842040 	.word	0x00842040
 8012660:	00840840 	.word	0x00840840
 8012664:	00040840 	.word	0x00040840
 8012668:	00060440 	.word	0x00060440
 801266c:	49bc      	ldr	r1, [pc, #752]	@ (8012960 <forward_cast+0x175c>)
 801266e:	428c      	cmp	r4, r1
 8012670:	d0b1      	beq.n	80125d6 <forward_cast+0x13d2>
 8012672:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012676:	428c      	cmp	r4, r1
 8012678:	d0ad      	beq.n	80125d6 <forward_cast+0x13d2>
 801267a:	2100      	movs	r1, #0
 801267c:	f7ff bb46 	b.w	8011d0c <forward_cast+0xb08>
 8012680:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 8012684:	428c      	cmp	r4, r1
 8012686:	f002 80d7 	beq.w	8014838 <forward_cast+0x3634>
 801268a:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 801268e:	428c      	cmp	r4, r1
 8012690:	f040 820a 	bne.w	8012aa8 <forward_cast+0x18a4>
 8012694:	8828      	ldrh	r0, [r5, #0]
 8012696:	f7ff baaf 	b.w	8011bf8 <forward_cast+0x9f4>
 801269a:	42bc      	cmp	r4, r7
 801269c:	f001 85ad 	beq.w	80141fa <forward_cast+0x2ff6>
 80126a0:	49b0      	ldr	r1, [pc, #704]	@ (8012964 <forward_cast+0x1760>)
 80126a2:	428c      	cmp	r4, r1
 80126a4:	f040 81df 	bne.w	8012a66 <forward_cast+0x1862>
 80126a8:	8828      	ldrh	r0, [r5, #0]
 80126aa:	f7fe bf61 	b.w	8011570 <forward_cast+0x36c>
 80126ae:	49ac      	ldr	r1, [pc, #688]	@ (8012960 <forward_cast+0x175c>)
 80126b0:	428c      	cmp	r4, r1
 80126b2:	f002 8259 	beq.w	8014b68 <forward_cast+0x3964>
 80126b6:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 80126ba:	428c      	cmp	r4, r1
 80126bc:	f040 81fa 	bne.w	8012ab4 <forward_cast+0x18b0>
 80126c0:	8828      	ldrh	r0, [r5, #0]
 80126c2:	f7ff b8fb 	b.w	80118bc <forward_cast+0x6b8>
 80126c6:	49a6      	ldr	r1, [pc, #664]	@ (8012960 <forward_cast+0x175c>)
 80126c8:	428c      	cmp	r4, r1
 80126ca:	d004      	beq.n	80126d6 <forward_cast+0x14d2>
 80126cc:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 80126d0:	428c      	cmp	r4, r1
 80126d2:	f040 8180 	bne.w	80129d6 <forward_cast+0x17d2>
 80126d6:	f995 1000 	ldrsb.w	r1, [r5]
 80126da:	f7ff bad2 	b.w	8011c82 <forward_cast+0xa7e>
 80126de:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 80126e2:	428c      	cmp	r4, r1
 80126e4:	d098      	beq.n	8012618 <forward_cast+0x1414>
 80126e6:	429c      	cmp	r4, r3
 80126e8:	d096      	beq.n	8012618 <forward_cast+0x1414>
 80126ea:	2100      	movs	r1, #0
 80126ec:	f7ff b92b 	b.w	8011946 <forward_cast+0x742>
 80126f0:	499b      	ldr	r1, [pc, #620]	@ (8012960 <forward_cast+0x175c>)
 80126f2:	428c      	cmp	r4, r1
 80126f4:	f001 874d 	beq.w	8014592 <forward_cast+0x338e>
 80126f8:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 80126fc:	428c      	cmp	r4, r1
 80126fe:	f040 81d6 	bne.w	8012aae <forward_cast+0x18aa>
 8012702:	8828      	ldrh	r0, [r5, #0]
 8012704:	f7ff bbf8 	b.w	8011ef8 <forward_cast+0xcf4>
 8012708:	4294      	cmp	r4, r2
 801270a:	f001 842e 	beq.w	8013f6a <forward_cast+0x2d66>
 801270e:	4995      	ldr	r1, [pc, #596]	@ (8012964 <forward_cast+0x1760>)
 8012710:	428c      	cmp	r4, r1
 8012712:	f040 81d8 	bne.w	8012ac6 <forward_cast+0x18c2>
 8012716:	8828      	ldrh	r0, [r5, #0]
 8012718:	e637      	b.n	801238a <forward_cast+0x1186>
 801271a:	4993      	ldr	r1, [pc, #588]	@ (8012968 <forward_cast+0x1764>)
 801271c:	428c      	cmp	r4, r1
 801271e:	f002 8153 	beq.w	80149c8 <forward_cast+0x37c4>
 8012722:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012726:	428c      	cmp	r4, r1
 8012728:	f040 81cd 	bne.w	8012ac6 <forward_cast+0x18c2>
 801272c:	f9b5 0000 	ldrsh.w	r0, [r5]
 8012730:	e62b      	b.n	801238a <forward_cast+0x1186>
 8012732:	498b      	ldr	r1, [pc, #556]	@ (8012960 <forward_cast+0x175c>)
 8012734:	428c      	cmp	r4, r1
 8012736:	f001 8359 	beq.w	8013dec <forward_cast+0x2be8>
 801273a:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 801273e:	428c      	cmp	r4, r1
 8012740:	f040 818c 	bne.w	8012a5c <forward_cast+0x1858>
 8012744:	8828      	ldrh	r0, [r5, #0]
 8012746:	e5d2      	b.n	80122ee <forward_cast+0x10ea>
 8012748:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 801274c:	428c      	cmp	r4, r1
 801274e:	f001 8668 	beq.w	8014422 <forward_cast+0x321e>
 8012752:	429c      	cmp	r4, r3
 8012754:	f040 81b4 	bne.w	8012ac0 <forward_cast+0x18bc>
 8012758:	f9b5 0000 	ldrsh.w	r0, [r5]
 801275c:	f7fe bea0 	b.w	80114a0 <forward_cast+0x29c>
 8012760:	42bc      	cmp	r4, r7
 8012762:	f001 8484 	beq.w	801406e <forward_cast+0x2e6a>
 8012766:	429c      	cmp	r4, r3
 8012768:	f040 81af 	bne.w	8012aca <forward_cast+0x18c6>
 801276c:	f9b5 0000 	ldrsh.w	r0, [r5]
 8012770:	e689      	b.n	8012486 <forward_cast+0x1282>
 8012772:	42bc      	cmp	r4, r7
 8012774:	f002 8205 	beq.w	8014b82 <forward_cast+0x397e>
 8012778:	f5a1 6100 	sub.w	r1, r1, #2048	@ 0x800
 801277c:	428c      	cmp	r4, r1
 801277e:	d14d      	bne.n	801281c <forward_cast+0x1618>
 8012780:	8829      	ldrh	r1, [r5, #0]
 8012782:	f7fe be37 	b.w	80113f4 <forward_cast+0x1f0>
 8012786:	4976      	ldr	r1, [pc, #472]	@ (8012960 <forward_cast+0x175c>)
 8012788:	428c      	cmp	r4, r1
 801278a:	f001 8387 	beq.w	8013e9c <forward_cast+0x2c98>
 801278e:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012792:	428c      	cmp	r4, r1
 8012794:	f040 815f 	bne.w	8012a56 <forward_cast+0x1852>
 8012798:	8828      	ldrh	r0, [r5, #0]
 801279a:	f7ff b95a 	b.w	8011a52 <forward_cast+0x84e>
 801279e:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 80127a2:	428c      	cmp	r4, r1
 80127a4:	f001 86cb 	beq.w	801453e <forward_cast+0x333a>
 80127a8:	429c      	cmp	r4, r3
 80127aa:	f040 8186 	bne.w	8012aba <forward_cast+0x18b6>
 80127ae:	f9b5 0000 	ldrsh.w	r0, [r5]
 80127b2:	f7ff bb01 	b.w	8011db8 <forward_cast+0xbb4>
 80127b6:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 80127ba:	428c      	cmp	r4, r1
 80127bc:	f002 83b6 	beq.w	8014f2c <forward_cast+0x3d28>
 80127c0:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 80127c4:	428c      	cmp	r4, r1
 80127c6:	f040 8180 	bne.w	8012aca <forward_cast+0x18c6>
 80127ca:	8828      	ldrh	r0, [r5, #0]
 80127cc:	e65b      	b.n	8012486 <forward_cast+0x1282>
 80127ce:	4554      	cmp	r4, sl
 80127d0:	f001 867b 	beq.w	80144ca <forward_cast+0x32c6>
 80127d4:	4965      	ldr	r1, [pc, #404]	@ (801296c <forward_cast+0x1768>)
 80127d6:	428c      	cmp	r4, r1
 80127d8:	f040 8140 	bne.w	8012a5c <forward_cast+0x1858>
 80127dc:	f9b5 0000 	ldrsh.w	r0, [r5]
 80127e0:	e585      	b.n	80122ee <forward_cast+0x10ea>
 80127e2:	495f      	ldr	r1, [pc, #380]	@ (8012960 <forward_cast+0x175c>)
 80127e4:	428c      	cmp	r4, r1
 80127e6:	f001 82b7 	beq.w	8013d58 <forward_cast+0x2b54>
 80127ea:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 80127ee:	428c      	cmp	r4, r1
 80127f0:	d109      	bne.n	8012806 <forward_cast+0x1602>
 80127f2:	8829      	ldrh	r1, [r5, #0]
 80127f4:	f7fe bfb9 	b.w	801176a <forward_cast+0x566>
 80127f8:	42bc      	cmp	r4, r7
 80127fa:	f001 8647 	beq.w	801448c <forward_cast+0x3288>
 80127fe:	f5a1 6100 	sub.w	r1, r1, #2048	@ 0x800
 8012802:	428c      	cmp	r4, r1
 8012804:	d0f5      	beq.n	80127f2 <forward_cast+0x15ee>
 8012806:	2100      	movs	r1, #0
 8012808:	f7fe bfaf 	b.w	801176a <forward_cast+0x566>
 801280c:	4954      	ldr	r1, [pc, #336]	@ (8012960 <forward_cast+0x175c>)
 801280e:	428c      	cmp	r4, r1
 8012810:	f001 8738 	beq.w	8014684 <forward_cast+0x3480>
 8012814:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012818:	428c      	cmp	r4, r1
 801281a:	d0b1      	beq.n	8012780 <forward_cast+0x157c>
 801281c:	2100      	movs	r1, #0
 801281e:	f7fe bde9 	b.w	80113f4 <forward_cast+0x1f0>
 8012822:	494f      	ldr	r1, [pc, #316]	@ (8012960 <forward_cast+0x175c>)
 8012824:	428c      	cmp	r4, r1
 8012826:	f001 867d 	beq.w	8014524 <forward_cast+0x3320>
 801282a:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 801282e:	428c      	cmp	r4, r1
 8012830:	f040 8143 	bne.w	8012aba <forward_cast+0x18b6>
 8012834:	8828      	ldrh	r0, [r5, #0]
 8012836:	f7ff babf 	b.w	8011db8 <forward_cast+0xbb4>
 801283a:	42bc      	cmp	r4, r7
 801283c:	f001 8465 	beq.w	801410a <forward_cast+0x2f06>
 8012840:	4948      	ldr	r1, [pc, #288]	@ (8012964 <forward_cast+0x1760>)
 8012842:	428c      	cmp	r4, r1
 8012844:	f040 813c 	bne.w	8012ac0 <forward_cast+0x18bc>
 8012848:	8828      	ldrh	r0, [r5, #0]
 801284a:	f7fe be29 	b.w	80114a0 <forward_cast+0x29c>
 801284e:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 8012852:	428c      	cmp	r4, r1
 8012854:	d001      	beq.n	801285a <forward_cast+0x1656>
 8012856:	429c      	cmp	r4, r3
 8012858:	d115      	bne.n	8012886 <forward_cast+0x1682>
 801285a:	7829      	ldrb	r1, [r5, #0]
 801285c:	f7ff b94e 	b.w	8011afc <forward_cast+0x8f8>
 8012860:	493f      	ldr	r1, [pc, #252]	@ (8012960 <forward_cast+0x175c>)
 8012862:	428c      	cmp	r4, r1
 8012864:	f001 86cc 	beq.w	8014600 <forward_cast+0x33fc>
 8012868:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 801286c:	428c      	cmp	r4, r1
 801286e:	f040 80f7 	bne.w	8012a60 <forward_cast+0x185c>
 8012872:	8828      	ldrh	r0, [r5, #0]
 8012874:	f7ff bbfa 	b.w	801206c <forward_cast+0xe68>
 8012878:	4939      	ldr	r1, [pc, #228]	@ (8012960 <forward_cast+0x175c>)
 801287a:	428c      	cmp	r4, r1
 801287c:	d0ed      	beq.n	801285a <forward_cast+0x1656>
 801287e:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012882:	428c      	cmp	r4, r1
 8012884:	d0e9      	beq.n	801285a <forward_cast+0x1656>
 8012886:	2100      	movs	r1, #0
 8012888:	f7ff b938 	b.w	8011afc <forward_cast+0x8f8>
 801288c:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 8012890:	428c      	cmp	r4, r1
 8012892:	f001 82e1 	beq.w	8013e58 <forward_cast+0x2c54>
 8012896:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 801289a:	428c      	cmp	r4, r1
 801289c:	f040 8101 	bne.w	8012aa2 <forward_cast+0x189e>
 80128a0:	8829      	ldrh	r1, [r5, #0]
 80128a2:	ee07 1a90 	vmov	s15, r1
 80128a6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80128aa:	e5b2      	b.n	8012412 <forward_cast+0x120e>
 80128ac:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 80128b0:	428c      	cmp	r4, r1
 80128b2:	f001 814b 	beq.w	8013b4c <forward_cast+0x2948>
 80128b6:	429c      	cmp	r4, r3
 80128b8:	f040 80cd 	bne.w	8012a56 <forward_cast+0x1852>
 80128bc:	f9b5 0000 	ldrsh.w	r0, [r5]
 80128c0:	f7ff b8c7 	b.w	8011a52 <forward_cast+0x84e>
 80128c4:	42bc      	cmp	r4, r7
 80128c6:	f001 8273 	beq.w	8013db0 <forward_cast+0x2bac>
 80128ca:	f5a1 6100 	sub.w	r1, r1, #2048	@ 0x800
 80128ce:	428c      	cmp	r4, r1
 80128d0:	f040 80c6 	bne.w	8012a60 <forward_cast+0x185c>
 80128d4:	f9b5 0000 	ldrsh.w	r0, [r5]
 80128d8:	f7ff bbc8 	b.w	801206c <forward_cast+0xe68>
 80128dc:	42bc      	cmp	r4, r7
 80128de:	f001 83d4 	beq.w	801408a <forward_cast+0x2e86>
 80128e2:	f5a1 6100 	sub.w	r1, r1, #2048	@ 0x800
 80128e6:	428c      	cmp	r4, r1
 80128e8:	f040 80d5 	bne.w	8012a96 <forward_cast+0x1892>
 80128ec:	f9b5 0000 	ldrsh.w	r0, [r5]
 80128f0:	f7fe be9b 	b.w	801162a <forward_cast+0x426>
 80128f4:	429c      	cmp	r4, r3
 80128f6:	f001 82f2 	beq.w	8013ede <forward_cast+0x2cda>
 80128fa:	4294      	cmp	r4, r2
 80128fc:	f040 80ce 	bne.w	8012a9c <forward_cast+0x1898>
 8012900:	f9b5 0000 	ldrsh.w	r0, [r5]
 8012904:	f7fe bd1f 	b.w	8011346 <forward_cast+0x142>
 8012908:	4917      	ldr	r1, [pc, #92]	@ (8012968 <forward_cast+0x1764>)
 801290a:	428c      	cmp	r4, r1
 801290c:	f001 8160 	beq.w	8013bd0 <forward_cast+0x29cc>
 8012910:	42bc      	cmp	r4, r7
 8012912:	f040 80c9 	bne.w	8012aa8 <forward_cast+0x18a4>
 8012916:	f9b5 0000 	ldrsh.w	r0, [r5]
 801291a:	f7ff b96d 	b.w	8011bf8 <forward_cast+0x9f4>
 801291e:	4554      	cmp	r4, sl
 8012920:	f001 8228 	beq.w	8013d74 <forward_cast+0x2b70>
 8012924:	4911      	ldr	r1, [pc, #68]	@ (801296c <forward_cast+0x1768>)
 8012926:	428c      	cmp	r4, r1
 8012928:	f040 80b2 	bne.w	8012a90 <forward_cast+0x188c>
 801292c:	f9b5 0000 	ldrsh.w	r0, [r5]
 8012930:	e43d      	b.n	80121ae <forward_cast+0xfaa>
 8012932:	429c      	cmp	r4, r3
 8012934:	f001 83be 	beq.w	80140b4 <forward_cast+0x2eb0>
 8012938:	490c      	ldr	r1, [pc, #48]	@ (801296c <forward_cast+0x1768>)
 801293a:	428c      	cmp	r4, r1
 801293c:	f43f ae81 	beq.w	8012642 <forward_cast+0x143e>
 8012940:	2100      	movs	r1, #0
 8012942:	f7fe bec2 	b.w	80116ca <forward_cast+0x4c6>
 8012946:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 801294a:	428c      	cmp	r4, r1
 801294c:	f001 83cd 	beq.w	80140ea <forward_cast+0x2ee6>
 8012950:	429c      	cmp	r4, r3
 8012952:	f040 8088 	bne.w	8012a66 <forward_cast+0x1862>
 8012956:	f9b5 0000 	ldrsh.w	r0, [r5]
 801295a:	f7fe be09 	b.w	8011570 <forward_cast+0x36c>
 801295e:	bf00      	nop
 8012960:	00040440 	.word	0x00040440
 8012964:	00040840 	.word	0x00040840
 8012968:	00840440 	.word	0x00840440
 801296c:	00840840 	.word	0x00840840
 8012970:	4554      	cmp	r4, sl
 8012972:	f43f ae1b 	beq.w	80125ac <forward_cast+0x13a8>
 8012976:	4544      	cmp	r4, r8
 8012978:	f43f ae18 	beq.w	80125ac <forward_cast+0x13a8>
 801297c:	2100      	movs	r1, #0
 801297e:	f7ff bbba 	b.w	80120f6 <forward_cast+0xef2>
 8012982:	49ac      	ldr	r1, [pc, #688]	@ (8012c34 <forward_cast+0x1a30>)
 8012984:	428c      	cmp	r4, r1
 8012986:	f001 8259 	beq.w	8013e3c <forward_cast+0x2c38>
 801298a:	429c      	cmp	r4, r3
 801298c:	f040 8092 	bne.w	8012ab4 <forward_cast+0x18b0>
 8012990:	f9b5 0000 	ldrsh.w	r0, [r5]
 8012994:	f7fe bf92 	b.w	80118bc <forward_cast+0x6b8>
 8012998:	49a6      	ldr	r1, [pc, #664]	@ (8012c34 <forward_cast+0x1a30>)
 801299a:	428c      	cmp	r4, r1
 801299c:	f001 82f2 	beq.w	8013f84 <forward_cast+0x2d80>
 80129a0:	4544      	cmp	r4, r8
 80129a2:	d169      	bne.n	8012a78 <forward_cast+0x1874>
 80129a4:	f9b5 0000 	ldrsh.w	r0, [r5]
 80129a8:	f7fe bf4a 	b.w	8011840 <forward_cast+0x63c>
 80129ac:	49a1      	ldr	r1, [pc, #644]	@ (8012c34 <forward_cast+0x1a30>)
 80129ae:	428c      	cmp	r4, r1
 80129b0:	f001 8283 	beq.w	8013eba <forward_cast+0x2cb6>
 80129b4:	429c      	cmp	r4, r3
 80129b6:	d174      	bne.n	8012aa2 <forward_cast+0x189e>
 80129b8:	f9b5 1000 	ldrsh.w	r1, [r5]
 80129bc:	ee07 1a90 	vmov	s15, r1
 80129c0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80129c4:	e525      	b.n	8012412 <forward_cast+0x120e>
 80129c6:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 80129ca:	428c      	cmp	r4, r1
 80129cc:	f43f ae83 	beq.w	80126d6 <forward_cast+0x14d2>
 80129d0:	429c      	cmp	r4, r3
 80129d2:	f43f ae80 	beq.w	80126d6 <forward_cast+0x14d2>
 80129d6:	2100      	movs	r1, #0
 80129d8:	f7ff b953 	b.w	8011c82 <forward_cast+0xa7e>
 80129dc:	429c      	cmp	r4, r3
 80129de:	f001 8365 	beq.w	80140ac <forward_cast+0x2ea8>
 80129e2:	4294      	cmp	r4, r2
 80129e4:	d163      	bne.n	8012aae <forward_cast+0x18aa>
 80129e6:	f9b5 0000 	ldrsh.w	r0, [r5]
 80129ea:	f7ff ba85 	b.w	8011ef8 <forward_cast+0xcf4>
 80129ee:	42bc      	cmp	r4, r7
 80129f0:	f001 8243 	beq.w	8013e7a <forward_cast+0x2c76>
 80129f4:	f5a1 6100 	sub.w	r1, r1, #2048	@ 0x800
 80129f8:	428c      	cmp	r4, r1
 80129fa:	d13a      	bne.n	8012a72 <forward_cast+0x186e>
 80129fc:	f9b5 1000 	ldrsh.w	r1, [r5]
 8012a00:	3900      	subs	r1, #0
 8012a02:	bf18      	it	ne
 8012a04:	2101      	movne	r1, #1
 8012a06:	f7ff badb 	b.w	8011fc0 <forward_cast+0xdbc>
 8012a0a:	42bc      	cmp	r4, r7
 8012a0c:	f001 838a 	beq.w	8014124 <forward_cast+0x2f20>
 8012a10:	f5a1 6100 	sub.w	r1, r1, #2048	@ 0x800
 8012a14:	428c      	cmp	r4, r1
 8012a16:	d138      	bne.n	8012a8a <forward_cast+0x1886>
 8012a18:	f9b5 0000 	ldrsh.w	r0, [r5]
 8012a1c:	f7fe bfd7 	b.w	80119ce <forward_cast+0x7ca>
 8012a20:	42bc      	cmp	r4, r7
 8012a22:	f001 826a 	beq.w	8013efa <forward_cast+0x2cf6>
 8012a26:	4984      	ldr	r1, [pc, #528]	@ (8012c38 <forward_cast+0x1a34>)
 8012a28:	428c      	cmp	r4, r1
 8012a2a:	d12b      	bne.n	8012a84 <forward_cast+0x1880>
 8012a2c:	f9b5 0000 	ldrsh.w	r0, [r5]
 8012a30:	e402      	b.n	8012238 <forward_cast+0x1034>
 8012a32:	4980      	ldr	r1, [pc, #512]	@ (8012c34 <forward_cast+0x1a30>)
 8012a34:	428c      	cmp	r4, r1
 8012a36:	f001 8567 	beq.w	8014508 <forward_cast+0x3304>
 8012a3a:	4294      	cmp	r4, r2
 8012a3c:	d11f      	bne.n	8012a7e <forward_cast+0x187a>
 8012a3e:	f9b5 0000 	ldrsh.w	r0, [r5]
 8012a42:	f7ff b89b 	b.w	8011b7c <forward_cast+0x978>
 8012a46:	9b01      	ldr	r3, [sp, #4]
 8012a48:	45ab      	cmp	fp, r5
 8012a4a:	6037      	str	r7, [r6, #0]
 8012a4c:	441e      	add	r6, r3
 8012a4e:	f63f ad48 	bhi.w	80124e2 <forward_cast+0x12de>
 8012a52:	f7fe bc3f 	b.w	80112d4 <forward_cast+0xd0>
 8012a56:	2000      	movs	r0, #0
 8012a58:	f7fe bffb 	b.w	8011a52 <forward_cast+0x84e>
 8012a5c:	2000      	movs	r0, #0
 8012a5e:	e446      	b.n	80122ee <forward_cast+0x10ea>
 8012a60:	2000      	movs	r0, #0
 8012a62:	f7ff bb03 	b.w	801206c <forward_cast+0xe68>
 8012a66:	2000      	movs	r0, #0
 8012a68:	f7fe bd82 	b.w	8011570 <forward_cast+0x36c>
 8012a6c:	2000      	movs	r0, #0
 8012a6e:	f7ff ba03 	b.w	8011e78 <forward_cast+0xc74>
 8012a72:	2100      	movs	r1, #0
 8012a74:	f7ff baa4 	b.w	8011fc0 <forward_cast+0xdbc>
 8012a78:	2000      	movs	r0, #0
 8012a7a:	f7fe bee1 	b.w	8011840 <forward_cast+0x63c>
 8012a7e:	2000      	movs	r0, #0
 8012a80:	f7ff b87c 	b.w	8011b7c <forward_cast+0x978>
 8012a84:	2000      	movs	r0, #0
 8012a86:	f7ff bbd7 	b.w	8012238 <forward_cast+0x1034>
 8012a8a:	2000      	movs	r0, #0
 8012a8c:	f7fe bf9f 	b.w	80119ce <forward_cast+0x7ca>
 8012a90:	2000      	movs	r0, #0
 8012a92:	f7ff bb8c 	b.w	80121ae <forward_cast+0xfaa>
 8012a96:	2000      	movs	r0, #0
 8012a98:	f7fe bdc7 	b.w	801162a <forward_cast+0x426>
 8012a9c:	2000      	movs	r0, #0
 8012a9e:	f7fe bc52 	b.w	8011346 <forward_cast+0x142>
 8012aa2:	eef0 7a48 	vmov.f32	s15, s16
 8012aa6:	e4b4      	b.n	8012412 <forward_cast+0x120e>
 8012aa8:	2000      	movs	r0, #0
 8012aaa:	f7ff b8a5 	b.w	8011bf8 <forward_cast+0x9f4>
 8012aae:	2000      	movs	r0, #0
 8012ab0:	f7ff ba22 	b.w	8011ef8 <forward_cast+0xcf4>
 8012ab4:	2000      	movs	r0, #0
 8012ab6:	f7fe bf01 	b.w	80118bc <forward_cast+0x6b8>
 8012aba:	2000      	movs	r0, #0
 8012abc:	f7ff b97c 	b.w	8011db8 <forward_cast+0xbb4>
 8012ac0:	2000      	movs	r0, #0
 8012ac2:	f7fe bced 	b.w	80114a0 <forward_cast+0x29c>
 8012ac6:	2000      	movs	r0, #0
 8012ac8:	e45f      	b.n	801238a <forward_cast+0x1186>
 8012aca:	2000      	movs	r0, #0
 8012acc:	e4db      	b.n	8012486 <forward_cast+0x1282>
 8012ace:	455d      	cmp	r5, fp
 8012ad0:	f4be ac00 	bcs.w	80112d4 <forward_cast+0xd0>
 8012ad4:	f8df a180 	ldr.w	sl, [pc, #384]	@ 8012c58 <forward_cast+0x1a54>
 8012ad8:	f8df 8178 	ldr.w	r8, [pc, #376]	@ 8012c54 <forward_cast+0x1a50>
 8012adc:	4f55      	ldr	r7, [pc, #340]	@ (8012c34 <forward_cast+0x1a30>)
 8012ade:	4b57      	ldr	r3, [pc, #348]	@ (8012c3c <forward_cast+0x1a38>)
 8012ae0:	4a57      	ldr	r2, [pc, #348]	@ (8012c40 <forward_cast+0x1a3c>)
 8012ae2:	e017      	b.n	8012b14 <forward_cast+0x1910>
 8012ae4:	429c      	cmp	r4, r3
 8012ae6:	f002 80d3 	beq.w	8014c90 <forward_cast+0x3a8c>
 8012aea:	dd2b      	ble.n	8012b44 <forward_cast+0x1940>
 8012aec:	4294      	cmp	r4, r2
 8012aee:	f001 877c 	beq.w	80149ea <forward_cast+0x37e6>
 8012af2:	4954      	ldr	r1, [pc, #336]	@ (8012c44 <forward_cast+0x1a40>)
 8012af4:	428c      	cmp	r4, r1
 8012af6:	d139      	bne.n	8012b6c <forward_cast+0x1968>
 8012af8:	7828      	ldrb	r0, [r5, #0]
 8012afa:	3800      	subs	r0, #0
 8012afc:	bf18      	it	ne
 8012afe:	2001      	movne	r0, #1
 8012b00:	f300 0007 	ssat	r0, #8, r0
 8012b04:	444d      	add	r5, r9
 8012b06:	b240      	sxtb	r0, r0
 8012b08:	9901      	ldr	r1, [sp, #4]
 8012b0a:	45ab      	cmp	fp, r5
 8012b0c:	8030      	strh	r0, [r6, #0]
 8012b0e:	440e      	add	r6, r1
 8012b10:	f67e abe0 	bls.w	80112d4 <forward_cast+0xd0>
 8012b14:	4554      	cmp	r4, sl
 8012b16:	f002 80b3 	beq.w	8014c80 <forward_cast+0x3a7c>
 8012b1a:	dde3      	ble.n	8012ae4 <forward_cast+0x18e0>
 8012b1c:	494a      	ldr	r1, [pc, #296]	@ (8012c48 <forward_cast+0x1a44>)
 8012b1e:	428c      	cmp	r4, r1
 8012b20:	f001 8756 	beq.w	80149d0 <forward_cast+0x37cc>
 8012b24:	dd18      	ble.n	8012b58 <forward_cast+0x1954>
 8012b26:	4544      	cmp	r4, r8
 8012b28:	d120      	bne.n	8012b6c <forward_cast+0x1968>
 8012b2a:	e9d5 0100 	ldrd	r0, r1, [r5]
 8012b2e:	f7ed fcff 	bl	8000530 <__aeabi_l2f>
 8012b32:	ee07 0a90 	vmov	s15, r0
 8012b36:	4b41      	ldr	r3, [pc, #260]	@ (8012c3c <forward_cast+0x1a38>)
 8012b38:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8012b3c:	4a40      	ldr	r2, [pc, #256]	@ (8012c40 <forward_cast+0x1a3c>)
 8012b3e:	ee17 0a90 	vmov	r0, s15
 8012b42:	e7dd      	b.n	8012b00 <forward_cast+0x18fc>
 8012b44:	4941      	ldr	r1, [pc, #260]	@ (8012c4c <forward_cast+0x1a48>)
 8012b46:	428c      	cmp	r4, r1
 8012b48:	f001 874c 	beq.w	80149e4 <forward_cast+0x37e0>
 8012b4c:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012b50:	428c      	cmp	r4, r1
 8012b52:	d10b      	bne.n	8012b6c <forward_cast+0x1968>
 8012b54:	8828      	ldrh	r0, [r5, #0]
 8012b56:	e7d3      	b.n	8012b00 <forward_cast+0x18fc>
 8012b58:	42bc      	cmp	r4, r7
 8012b5a:	f001 8754 	beq.w	8014a06 <forward_cast+0x3802>
 8012b5e:	f5a1 6100 	sub.w	r1, r1, #2048	@ 0x800
 8012b62:	428c      	cmp	r4, r1
 8012b64:	d102      	bne.n	8012b6c <forward_cast+0x1968>
 8012b66:	f9b5 0000 	ldrsh.w	r0, [r5]
 8012b6a:	e7c9      	b.n	8012b00 <forward_cast+0x18fc>
 8012b6c:	2000      	movs	r0, #0
 8012b6e:	e7c7      	b.n	8012b00 <forward_cast+0x18fc>
 8012b70:	455d      	cmp	r5, fp
 8012b72:	f4be abaf 	bcs.w	80112d4 <forward_cast+0xd0>
 8012b76:	ed9f 8a36 	vldr	s16, [pc, #216]	@ 8012c50 <forward_cast+0x1a4c>
 8012b7a:	4a33      	ldr	r2, [pc, #204]	@ (8012c48 <forward_cast+0x1a44>)
 8012b7c:	4b35      	ldr	r3, [pc, #212]	@ (8012c54 <forward_cast+0x1a50>)
 8012b7e:	f8df 80c0 	ldr.w	r8, [pc, #192]	@ 8012c40 <forward_cast+0x1a3c>
 8012b82:	4f30      	ldr	r7, [pc, #192]	@ (8012c44 <forward_cast+0x1a40>)
 8012b84:	e017      	b.n	8012bb6 <forward_cast+0x19b2>
 8012b86:	492d      	ldr	r1, [pc, #180]	@ (8012c3c <forward_cast+0x1a38>)
 8012b88:	428c      	cmp	r4, r1
 8012b8a:	f001 86c1 	beq.w	8014910 <forward_cast+0x370c>
 8012b8e:	dd25      	ble.n	8012bdc <forward_cast+0x19d8>
 8012b90:	4544      	cmp	r4, r8
 8012b92:	f001 8749 	beq.w	8014a28 <forward_cast+0x3824>
 8012b96:	42bc      	cmp	r4, r7
 8012b98:	d13e      	bne.n	8012c18 <forward_cast+0x1a14>
 8012b9a:	7829      	ldrb	r1, [r5, #0]
 8012b9c:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 8012ba0:	2900      	cmp	r1, #0
 8012ba2:	fe48 7a27 	vseleq.f32	s15, s16, s15
 8012ba6:	444d      	add	r5, r9
 8012ba8:	9901      	ldr	r1, [sp, #4]
 8012baa:	edc6 7a00 	vstr	s15, [r6]
 8012bae:	45ab      	cmp	fp, r5
 8012bb0:	440e      	add	r6, r1
 8012bb2:	f67e ab8f 	bls.w	80112d4 <forward_cast+0xd0>
 8012bb6:	4554      	cmp	r4, sl
 8012bb8:	f001 8748 	beq.w	8014a4c <forward_cast+0x3848>
 8012bbc:	dde3      	ble.n	8012b86 <forward_cast+0x1982>
 8012bbe:	4294      	cmp	r4, r2
 8012bc0:	f001 8725 	beq.w	8014a0e <forward_cast+0x380a>
 8012bc4:	dd19      	ble.n	8012bfa <forward_cast+0x19f6>
 8012bc6:	429c      	cmp	r4, r3
 8012bc8:	d126      	bne.n	8012c18 <forward_cast+0x1a14>
 8012bca:	e9d5 0100 	ldrd	r0, r1, [r5]
 8012bce:	f7ed fcaf 	bl	8000530 <__aeabi_l2f>
 8012bd2:	4a1d      	ldr	r2, [pc, #116]	@ (8012c48 <forward_cast+0x1a44>)
 8012bd4:	ee07 0a90 	vmov	s15, r0
 8012bd8:	4b1e      	ldr	r3, [pc, #120]	@ (8012c54 <forward_cast+0x1a50>)
 8012bda:	e7e4      	b.n	8012ba6 <forward_cast+0x19a2>
 8012bdc:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 8012be0:	428c      	cmp	r4, r1
 8012be2:	f001 871a 	beq.w	8014a1a <forward_cast+0x3816>
 8012be6:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012bea:	428c      	cmp	r4, r1
 8012bec:	d114      	bne.n	8012c18 <forward_cast+0x1a14>
 8012bee:	8829      	ldrh	r1, [r5, #0]
 8012bf0:	ee07 1a90 	vmov	s15, r1
 8012bf4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8012bf8:	e7d5      	b.n	8012ba6 <forward_cast+0x19a2>
 8012bfa:	490e      	ldr	r1, [pc, #56]	@ (8012c34 <forward_cast+0x1a30>)
 8012bfc:	428c      	cmp	r4, r1
 8012bfe:	f001 871d 	beq.w	8014a3c <forward_cast+0x3838>
 8012c02:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012c06:	428c      	cmp	r4, r1
 8012c08:	d106      	bne.n	8012c18 <forward_cast+0x1a14>
 8012c0a:	f9b5 1000 	ldrsh.w	r1, [r5]
 8012c0e:	ee07 1a90 	vmov	s15, r1
 8012c12:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8012c16:	e7c6      	b.n	8012ba6 <forward_cast+0x19a2>
 8012c18:	eef0 7a48 	vmov.f32	s15, s16
 8012c1c:	e7c3      	b.n	8012ba6 <forward_cast+0x19a2>
 8012c1e:	455d      	cmp	r5, fp
 8012c20:	f4be ab58 	bcs.w	80112d4 <forward_cast+0xd0>
 8012c24:	f8df a030 	ldr.w	sl, [pc, #48]	@ 8012c58 <forward_cast+0x1a54>
 8012c28:	f8df 8028 	ldr.w	r8, [pc, #40]	@ 8012c54 <forward_cast+0x1a50>
 8012c2c:	4f01      	ldr	r7, [pc, #4]	@ (8012c34 <forward_cast+0x1a30>)
 8012c2e:	4b03      	ldr	r3, [pc, #12]	@ (8012c3c <forward_cast+0x1a38>)
 8012c30:	4a03      	ldr	r2, [pc, #12]	@ (8012c40 <forward_cast+0x1a3c>)
 8012c32:	e02a      	b.n	8012c8a <forward_cast+0x1a86>
 8012c34:	00840440 	.word	0x00840440
 8012c38:	00840840 	.word	0x00840840
 8012c3c:	00041040 	.word	0x00041040
 8012c40:	00042040 	.word	0x00042040
 8012c44:	00060440 	.word	0x00060440
 8012c48:	00841040 	.word	0x00841040
 8012c4c:	00040440 	.word	0x00040440
 8012c50:	00000000 	.word	0x00000000
 8012c54:	00842040 	.word	0x00842040
 8012c58:	00821040 	.word	0x00821040
 8012c5c:	429c      	cmp	r4, r3
 8012c5e:	f001 8709 	beq.w	8014a74 <forward_cast+0x3870>
 8012c62:	dd2a      	ble.n	8012cba <forward_cast+0x1ab6>
 8012c64:	4294      	cmp	r4, r2
 8012c66:	f001 871c 	beq.w	8014aa2 <forward_cast+0x389e>
 8012c6a:	49a4      	ldr	r1, [pc, #656]	@ (8012efc <forward_cast+0x1cf8>)
 8012c6c:	428c      	cmp	r4, r1
 8012c6e:	d138      	bne.n	8012ce2 <forward_cast+0x1ade>
 8012c70:	7828      	ldrb	r0, [r5, #0]
 8012c72:	3800      	subs	r0, #0
 8012c74:	bf18      	it	ne
 8012c76:	2001      	movne	r0, #1
 8012c78:	f380 0010 	usat	r0, #16, r0
 8012c7c:	444d      	add	r5, r9
 8012c7e:	9901      	ldr	r1, [sp, #4]
 8012c80:	8030      	strh	r0, [r6, #0]
 8012c82:	45ab      	cmp	fp, r5
 8012c84:	440e      	add	r6, r1
 8012c86:	f67e ab25 	bls.w	80112d4 <forward_cast+0xd0>
 8012c8a:	4554      	cmp	r4, sl
 8012c8c:	f001 86ea 	beq.w	8014a64 <forward_cast+0x3860>
 8012c90:	dde4      	ble.n	8012c5c <forward_cast+0x1a58>
 8012c92:	499b      	ldr	r1, [pc, #620]	@ (8012f00 <forward_cast+0x1cfc>)
 8012c94:	428c      	cmp	r4, r1
 8012c96:	f001 86f7 	beq.w	8014a88 <forward_cast+0x3884>
 8012c9a:	dd18      	ble.n	8012cce <forward_cast+0x1aca>
 8012c9c:	4544      	cmp	r4, r8
 8012c9e:	d120      	bne.n	8012ce2 <forward_cast+0x1ade>
 8012ca0:	e9d5 0100 	ldrd	r0, r1, [r5]
 8012ca4:	f7ed fc44 	bl	8000530 <__aeabi_l2f>
 8012ca8:	ee07 0a90 	vmov	s15, r0
 8012cac:	4b95      	ldr	r3, [pc, #596]	@ (8012f04 <forward_cast+0x1d00>)
 8012cae:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8012cb2:	4a95      	ldr	r2, [pc, #596]	@ (8012f08 <forward_cast+0x1d04>)
 8012cb4:	ee17 0a90 	vmov	r0, s15
 8012cb8:	e7de      	b.n	8012c78 <forward_cast+0x1a74>
 8012cba:	4994      	ldr	r1, [pc, #592]	@ (8012f0c <forward_cast+0x1d08>)
 8012cbc:	428c      	cmp	r4, r1
 8012cbe:	f001 86ed 	beq.w	8014a9c <forward_cast+0x3898>
 8012cc2:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012cc6:	428c      	cmp	r4, r1
 8012cc8:	d10b      	bne.n	8012ce2 <forward_cast+0x1ade>
 8012cca:	8828      	ldrh	r0, [r5, #0]
 8012ccc:	e7d4      	b.n	8012c78 <forward_cast+0x1a74>
 8012cce:	42bc      	cmp	r4, r7
 8012cd0:	f001 86f5 	beq.w	8014abe <forward_cast+0x38ba>
 8012cd4:	f5a1 6100 	sub.w	r1, r1, #2048	@ 0x800
 8012cd8:	428c      	cmp	r4, r1
 8012cda:	d102      	bne.n	8012ce2 <forward_cast+0x1ade>
 8012cdc:	f9b5 0000 	ldrsh.w	r0, [r5]
 8012ce0:	e7ca      	b.n	8012c78 <forward_cast+0x1a74>
 8012ce2:	2000      	movs	r0, #0
 8012ce4:	e7c8      	b.n	8012c78 <forward_cast+0x1a74>
 8012ce6:	455d      	cmp	r5, fp
 8012ce8:	f4be aaf4 	bcs.w	80112d4 <forward_cast+0xd0>
 8012cec:	ed9f 8a88 	vldr	s16, [pc, #544]	@ 8012f10 <forward_cast+0x1d0c>
 8012cf0:	4a83      	ldr	r2, [pc, #524]	@ (8012f00 <forward_cast+0x1cfc>)
 8012cf2:	4b88      	ldr	r3, [pc, #544]	@ (8012f14 <forward_cast+0x1d10>)
 8012cf4:	f8df 8204 	ldr.w	r8, [pc, #516]	@ 8012efc <forward_cast+0x1cf8>
 8012cf8:	e017      	b.n	8012d2a <forward_cast+0x1b26>
 8012cfa:	42bc      	cmp	r4, r7
 8012cfc:	f001 8616 	beq.w	801492c <forward_cast+0x3728>
 8012d00:	dd2a      	ble.n	8012d58 <forward_cast+0x1b54>
 8012d02:	4981      	ldr	r1, [pc, #516]	@ (8012f08 <forward_cast+0x1d04>)
 8012d04:	428c      	cmp	r4, r1
 8012d06:	f001 87f4 	beq.w	8014cf2 <forward_cast+0x3aee>
 8012d0a:	4544      	cmp	r4, r8
 8012d0c:	d141      	bne.n	8012d92 <forward_cast+0x1b8e>
 8012d0e:	7829      	ldrb	r1, [r5, #0]
 8012d10:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 8012d14:	2900      	cmp	r1, #0
 8012d16:	fe48 7a27 	vseleq.f32	s15, s16, s15
 8012d1a:	444d      	add	r5, r9
 8012d1c:	9901      	ldr	r1, [sp, #4]
 8012d1e:	edc6 7a00 	vstr	s15, [r6]
 8012d22:	45ab      	cmp	fp, r5
 8012d24:	440e      	add	r6, r1
 8012d26:	f67e aad5 	bls.w	80112d4 <forward_cast+0xd0>
 8012d2a:	4554      	cmp	r4, sl
 8012d2c:	f001 85e0 	beq.w	80148f0 <forward_cast+0x36ec>
 8012d30:	dde3      	ble.n	8012cfa <forward_cast+0x1af6>
 8012d32:	4294      	cmp	r4, r2
 8012d34:	f001 87cc 	beq.w	8014cd0 <forward_cast+0x3acc>
 8012d38:	dd1c      	ble.n	8012d74 <forward_cast+0x1b70>
 8012d3a:	429c      	cmp	r4, r3
 8012d3c:	d129      	bne.n	8012d92 <forward_cast+0x1b8e>
 8012d3e:	e9d5 0100 	ldrd	r0, r1, [r5]
 8012d42:	f7ed fbf5 	bl	8000530 <__aeabi_l2f>
 8012d46:	ee07 0a90 	vmov	s15, r0
 8012d4a:	4a6d      	ldr	r2, [pc, #436]	@ (8012f00 <forward_cast+0x1cfc>)
 8012d4c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8012d50:	4b70      	ldr	r3, [pc, #448]	@ (8012f14 <forward_cast+0x1d10>)
 8012d52:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8012d56:	e7e0      	b.n	8012d1a <forward_cast+0x1b16>
 8012d58:	496c      	ldr	r1, [pc, #432]	@ (8012f0c <forward_cast+0x1d08>)
 8012d5a:	428c      	cmp	r4, r1
 8012d5c:	f001 87c2 	beq.w	8014ce4 <forward_cast+0x3ae0>
 8012d60:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012d64:	428c      	cmp	r4, r1
 8012d66:	d114      	bne.n	8012d92 <forward_cast+0x1b8e>
 8012d68:	8829      	ldrh	r1, [r5, #0]
 8012d6a:	ee07 1a90 	vmov	s15, r1
 8012d6e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8012d72:	e7d2      	b.n	8012d1a <forward_cast+0x1b16>
 8012d74:	4968      	ldr	r1, [pc, #416]	@ (8012f18 <forward_cast+0x1d14>)
 8012d76:	428c      	cmp	r4, r1
 8012d78:	f001 87c9 	beq.w	8014d0e <forward_cast+0x3b0a>
 8012d7c:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012d80:	428c      	cmp	r4, r1
 8012d82:	d106      	bne.n	8012d92 <forward_cast+0x1b8e>
 8012d84:	f9b5 1000 	ldrsh.w	r1, [r5]
 8012d88:	ee07 1a90 	vmov	s15, r1
 8012d8c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8012d90:	e7c3      	b.n	8012d1a <forward_cast+0x1b16>
 8012d92:	eef0 7a48 	vmov.f32	s15, s16
 8012d96:	e7c0      	b.n	8012d1a <forward_cast+0x1b16>
 8012d98:	455d      	cmp	r5, fp
 8012d9a:	f4be aa9b 	bcs.w	80112d4 <forward_cast+0xd0>
 8012d9e:	2700      	movs	r7, #0
 8012da0:	f8df a17c 	ldr.w	sl, [pc, #380]	@ 8012f20 <forward_cast+0x1d1c>
 8012da4:	f8df 816c 	ldr.w	r8, [pc, #364]	@ 8012f14 <forward_cast+0x1d10>
 8012da8:	4b5c      	ldr	r3, [pc, #368]	@ (8012f1c <forward_cast+0x1d18>)
 8012daa:	4a56      	ldr	r2, [pc, #344]	@ (8012f04 <forward_cast+0x1d00>)
 8012dac:	e016      	b.n	8012ddc <forward_cast+0x1bd8>
 8012dae:	4294      	cmp	r4, r2
 8012db0:	f001 8592 	beq.w	80148d8 <forward_cast+0x36d4>
 8012db4:	dd2c      	ble.n	8012e10 <forward_cast+0x1c0c>
 8012db6:	4954      	ldr	r1, [pc, #336]	@ (8012f08 <forward_cast+0x1d04>)
 8012db8:	428c      	cmp	r4, r1
 8012dba:	f001 8573 	beq.w	80148a4 <forward_cast+0x36a0>
 8012dbe:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 8012dc2:	428c      	cmp	r4, r1
 8012dc4:	d133      	bne.n	8012e2e <forward_cast+0x1c2a>
 8012dc6:	7829      	ldrb	r1, [r5, #0]
 8012dc8:	3900      	subs	r1, #0
 8012dca:	bf18      	it	ne
 8012dcc:	2101      	movne	r1, #1
 8012dce:	444d      	add	r5, r9
 8012dd0:	55f1      	strb	r1, [r6, r7]
 8012dd2:	9901      	ldr	r1, [sp, #4]
 8012dd4:	45ab      	cmp	fp, r5
 8012dd6:	440f      	add	r7, r1
 8012dd8:	f67e aa7c 	bls.w	80112d4 <forward_cast+0xd0>
 8012ddc:	4554      	cmp	r4, sl
 8012dde:	f001 8571 	beq.w	80148c4 <forward_cast+0x36c0>
 8012de2:	dde4      	ble.n	8012dae <forward_cast+0x1baa>
 8012de4:	4946      	ldr	r1, [pc, #280]	@ (8012f00 <forward_cast+0x1cfc>)
 8012de6:	428c      	cmp	r4, r1
 8012de8:	f001 8550 	beq.w	801488c <forward_cast+0x3688>
 8012dec:	dd19      	ble.n	8012e22 <forward_cast+0x1c1e>
 8012dee:	4544      	cmp	r4, r8
 8012df0:	d11d      	bne.n	8012e2e <forward_cast+0x1c2a>
 8012df2:	e9d5 0100 	ldrd	r0, r1, [r5]
 8012df6:	f7ed fb9b 	bl	8000530 <__aeabi_l2f>
 8012dfa:	ee07 0a90 	vmov	s15, r0
 8012dfe:	4b47      	ldr	r3, [pc, #284]	@ (8012f1c <forward_cast+0x1d18>)
 8012e00:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8012e04:	4a3f      	ldr	r2, [pc, #252]	@ (8012f04 <forward_cast+0x1d00>)
 8012e06:	edcd 7a02 	vstr	s15, [sp, #8]
 8012e0a:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8012e0e:	e7de      	b.n	8012dce <forward_cast+0x1bca>
 8012e10:	493e      	ldr	r1, [pc, #248]	@ (8012f0c <forward_cast+0x1d08>)
 8012e12:	428c      	cmp	r4, r1
 8012e14:	d003      	beq.n	8012e1e <forward_cast+0x1c1a>
 8012e16:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012e1a:	428c      	cmp	r4, r1
 8012e1c:	d107      	bne.n	8012e2e <forward_cast+0x1c2a>
 8012e1e:	7829      	ldrb	r1, [r5, #0]
 8012e20:	e7d5      	b.n	8012dce <forward_cast+0x1bca>
 8012e22:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 8012e26:	428c      	cmp	r4, r1
 8012e28:	d0f9      	beq.n	8012e1e <forward_cast+0x1c1a>
 8012e2a:	429c      	cmp	r4, r3
 8012e2c:	d0f7      	beq.n	8012e1e <forward_cast+0x1c1a>
 8012e2e:	2100      	movs	r1, #0
 8012e30:	e7cd      	b.n	8012dce <forward_cast+0x1bca>
 8012e32:	455d      	cmp	r5, fp
 8012e34:	f4be aa4e 	bcs.w	80112d4 <forward_cast+0xd0>
 8012e38:	9f01      	ldr	r7, [sp, #4]
 8012e3a:	4628      	mov	r0, r5
 8012e3c:	4621      	mov	r1, r4
 8012e3e:	f7fe f96d 	bl	801111c <_array_handle_get_as_float>
 8012e42:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8012e46:	444d      	add	r5, r9
 8012e48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012e4c:	bf14      	ite	ne
 8012e4e:	2301      	movne	r3, #1
 8012e50:	2300      	moveq	r3, #0
 8012e52:	45ab      	cmp	fp, r5
 8012e54:	7033      	strb	r3, [r6, #0]
 8012e56:	443e      	add	r6, r7
 8012e58:	d8ef      	bhi.n	8012e3a <forward_cast+0x1c36>
 8012e5a:	f7fe ba3b 	b.w	80112d4 <forward_cast+0xd0>
 8012e5e:	455d      	cmp	r5, fp
 8012e60:	f4be aa38 	bcs.w	80112d4 <forward_cast+0xd0>
 8012e64:	4b28      	ldr	r3, [pc, #160]	@ (8012f08 <forward_cast+0x1d04>)
 8012e66:	4a25      	ldr	r2, [pc, #148]	@ (8012efc <forward_cast+0x1cf8>)
 8012e68:	e013      	b.n	8012e92 <forward_cast+0x1c8e>
 8012e6a:	42bc      	cmp	r4, r7
 8012e6c:	f001 8434 	beq.w	80146d8 <forward_cast+0x34d4>
 8012e70:	dd29      	ble.n	8012ec6 <forward_cast+0x1cc2>
 8012e72:	429c      	cmp	r4, r3
 8012e74:	f001 8698 	beq.w	8014ba8 <forward_cast+0x39a4>
 8012e78:	4294      	cmp	r4, r2
 8012e7a:	d136      	bne.n	8012eea <forward_cast+0x1ce6>
 8012e7c:	7829      	ldrb	r1, [r5, #0]
 8012e7e:	3900      	subs	r1, #0
 8012e80:	bf18      	it	ne
 8012e82:	2101      	movne	r1, #1
 8012e84:	444d      	add	r5, r9
 8012e86:	8031      	strh	r1, [r6, #0]
 8012e88:	9901      	ldr	r1, [sp, #4]
 8012e8a:	45ab      	cmp	fp, r5
 8012e8c:	440e      	add	r6, r1
 8012e8e:	f67e aa21 	bls.w	80112d4 <forward_cast+0xd0>
 8012e92:	4544      	cmp	r4, r8
 8012e94:	f001 8417 	beq.w	80146c6 <forward_cast+0x34c2>
 8012e98:	dde7      	ble.n	8012e6a <forward_cast+0x1c66>
 8012e9a:	4919      	ldr	r1, [pc, #100]	@ (8012f00 <forward_cast+0x1cfc>)
 8012e9c:	428c      	cmp	r4, r1
 8012e9e:	f001 8675 	beq.w	8014b8c <forward_cast+0x3988>
 8012ea2:	dd1b      	ble.n	8012edc <forward_cast+0x1cd8>
 8012ea4:	491b      	ldr	r1, [pc, #108]	@ (8012f14 <forward_cast+0x1d10>)
 8012ea6:	428c      	cmp	r4, r1
 8012ea8:	d11f      	bne.n	8012eea <forward_cast+0x1ce6>
 8012eaa:	e9d5 0100 	ldrd	r0, r1, [r5]
 8012eae:	f7ed fb3f 	bl	8000530 <__aeabi_l2f>
 8012eb2:	ee07 0a90 	vmov	s15, r0
 8012eb6:	4a11      	ldr	r2, [pc, #68]	@ (8012efc <forward_cast+0x1cf8>)
 8012eb8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8012ebc:	ee17 3a90 	vmov	r3, s15
 8012ec0:	b219      	sxth	r1, r3
 8012ec2:	4b11      	ldr	r3, [pc, #68]	@ (8012f08 <forward_cast+0x1d04>)
 8012ec4:	e7de      	b.n	8012e84 <forward_cast+0x1c80>
 8012ec6:	4911      	ldr	r1, [pc, #68]	@ (8012f0c <forward_cast+0x1d08>)
 8012ec8:	428c      	cmp	r4, r1
 8012eca:	f001 866a 	beq.w	8014ba2 <forward_cast+0x399e>
 8012ece:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012ed2:	428c      	cmp	r4, r1
 8012ed4:	d109      	bne.n	8012eea <forward_cast+0x1ce6>
 8012ed6:	f9b5 1000 	ldrsh.w	r1, [r5]
 8012eda:	e7d3      	b.n	8012e84 <forward_cast+0x1c80>
 8012edc:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 8012ee0:	428c      	cmp	r4, r1
 8012ee2:	f001 8670 	beq.w	8014bc6 <forward_cast+0x39c2>
 8012ee6:	4554      	cmp	r4, sl
 8012ee8:	d0f5      	beq.n	8012ed6 <forward_cast+0x1cd2>
 8012eea:	2100      	movs	r1, #0
 8012eec:	e7ca      	b.n	8012e84 <forward_cast+0x1c80>
 8012eee:	455d      	cmp	r5, fp
 8012ef0:	f4be a9f0 	bcs.w	80112d4 <forward_cast+0xd0>
 8012ef4:	4b04      	ldr	r3, [pc, #16]	@ (8012f08 <forward_cast+0x1d04>)
 8012ef6:	4a01      	ldr	r2, [pc, #4]	@ (8012efc <forward_cast+0x1cf8>)
 8012ef8:	e029      	b.n	8012f4e <forward_cast+0x1d4a>
 8012efa:	bf00      	nop
 8012efc:	00060440 	.word	0x00060440
 8012f00:	00841040 	.word	0x00841040
 8012f04:	00041040 	.word	0x00041040
 8012f08:	00042040 	.word	0x00042040
 8012f0c:	00040440 	.word	0x00040440
 8012f10:	00000000 	.word	0x00000000
 8012f14:	00842040 	.word	0x00842040
 8012f18:	00840440 	.word	0x00840440
 8012f1c:	00840840 	.word	0x00840840
 8012f20:	00821040 	.word	0x00821040
 8012f24:	49a6      	ldr	r1, [pc, #664]	@ (80131c0 <forward_cast+0x1fbc>)
 8012f26:	428c      	cmp	r4, r1
 8012f28:	f001 85cd 	beq.w	8014ac6 <forward_cast+0x38c2>
 8012f2c:	dd28      	ble.n	8012f80 <forward_cast+0x1d7c>
 8012f2e:	429c      	cmp	r4, r3
 8012f30:	f001 85fb 	beq.w	8014b2a <forward_cast+0x3926>
 8012f34:	4294      	cmp	r4, r2
 8012f36:	d135      	bne.n	8012fa4 <forward_cast+0x1da0>
 8012f38:	7829      	ldrb	r1, [r5, #0]
 8012f3a:	3900      	subs	r1, #0
 8012f3c:	bf18      	it	ne
 8012f3e:	2101      	movne	r1, #1
 8012f40:	444d      	add	r5, r9
 8012f42:	8031      	strh	r1, [r6, #0]
 8012f44:	9901      	ldr	r1, [sp, #4]
 8012f46:	45ab      	cmp	fp, r5
 8012f48:	440e      	add	r6, r1
 8012f4a:	f67e a9c3 	bls.w	80112d4 <forward_cast+0xd0>
 8012f4e:	4544      	cmp	r4, r8
 8012f50:	f001 85cc 	beq.w	8014aec <forward_cast+0x38e8>
 8012f54:	dde6      	ble.n	8012f24 <forward_cast+0x1d20>
 8012f56:	42bc      	cmp	r4, r7
 8012f58:	f001 85d9 	beq.w	8014b0e <forward_cast+0x390a>
 8012f5c:	dd1c      	ble.n	8012f98 <forward_cast+0x1d94>
 8012f5e:	4999      	ldr	r1, [pc, #612]	@ (80131c4 <forward_cast+0x1fc0>)
 8012f60:	428c      	cmp	r4, r1
 8012f62:	d11f      	bne.n	8012fa4 <forward_cast+0x1da0>
 8012f64:	e9d5 0100 	ldrd	r0, r1, [r5]
 8012f68:	f7ed fae2 	bl	8000530 <__aeabi_l2f>
 8012f6c:	ee07 0a90 	vmov	s15, r0
 8012f70:	4a95      	ldr	r2, [pc, #596]	@ (80131c8 <forward_cast+0x1fc4>)
 8012f72:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8012f76:	ee17 3a90 	vmov	r3, s15
 8012f7a:	b219      	sxth	r1, r3
 8012f7c:	4b93      	ldr	r3, [pc, #588]	@ (80131cc <forward_cast+0x1fc8>)
 8012f7e:	e7df      	b.n	8012f40 <forward_cast+0x1d3c>
 8012f80:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 8012f84:	428c      	cmp	r4, r1
 8012f86:	f001 85cd 	beq.w	8014b24 <forward_cast+0x3920>
 8012f8a:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8012f8e:	428c      	cmp	r4, r1
 8012f90:	d108      	bne.n	8012fa4 <forward_cast+0x1da0>
 8012f92:	f9b5 1000 	ldrsh.w	r1, [r5]
 8012f96:	e7d3      	b.n	8012f40 <forward_cast+0x1d3c>
 8012f98:	498d      	ldr	r1, [pc, #564]	@ (80131d0 <forward_cast+0x1fcc>)
 8012f9a:	428c      	cmp	r4, r1
 8012f9c:	f001 85d4 	beq.w	8014b48 <forward_cast+0x3944>
 8012fa0:	4554      	cmp	r4, sl
 8012fa2:	d0f6      	beq.n	8012f92 <forward_cast+0x1d8e>
 8012fa4:	2100      	movs	r1, #0
 8012fa6:	e7cb      	b.n	8012f40 <forward_cast+0x1d3c>
 8012fa8:	455d      	cmp	r5, fp
 8012faa:	f4be a993 	bcs.w	80112d4 <forward_cast+0xd0>
 8012fae:	f8df a22c 	ldr.w	sl, [pc, #556]	@ 80131dc <forward_cast+0x1fd8>
 8012fb2:	f8df 8210 	ldr.w	r8, [pc, #528]	@ 80131c4 <forward_cast+0x1fc0>
 8012fb6:	4f86      	ldr	r7, [pc, #536]	@ (80131d0 <forward_cast+0x1fcc>)
 8012fb8:	4b81      	ldr	r3, [pc, #516]	@ (80131c0 <forward_cast+0x1fbc>)
 8012fba:	4a84      	ldr	r2, [pc, #528]	@ (80131cc <forward_cast+0x1fc8>)
 8012fbc:	e014      	b.n	8012fe8 <forward_cast+0x1de4>
 8012fbe:	429c      	cmp	r4, r3
 8012fc0:	f001 832c 	beq.w	801461c <forward_cast+0x3418>
 8012fc4:	dd2b      	ble.n	801301e <forward_cast+0x1e1a>
 8012fc6:	4294      	cmp	r4, r2
 8012fc8:	f001 8335 	beq.w	8014636 <forward_cast+0x3432>
 8012fcc:	497e      	ldr	r1, [pc, #504]	@ (80131c8 <forward_cast+0x1fc4>)
 8012fce:	428c      	cmp	r4, r1
 8012fd0:	d13e      	bne.n	8013050 <forward_cast+0x1e4c>
 8012fd2:	7829      	ldrb	r1, [r5, #0]
 8012fd4:	3900      	subs	r1, #0
 8012fd6:	bf18      	it	ne
 8012fd8:	2101      	movne	r1, #1
 8012fda:	444d      	add	r5, r9
 8012fdc:	8031      	strh	r1, [r6, #0]
 8012fde:	9901      	ldr	r1, [sp, #4]
 8012fe0:	45ab      	cmp	fp, r5
 8012fe2:	440e      	add	r6, r1
 8012fe4:	f67e a976 	bls.w	80112d4 <forward_cast+0xd0>
 8012fe8:	4554      	cmp	r4, sl
 8012fea:	f001 830c 	beq.w	8014606 <forward_cast+0x3402>
 8012fee:	dde6      	ble.n	8012fbe <forward_cast+0x1dba>
 8012ff0:	4978      	ldr	r1, [pc, #480]	@ (80131d4 <forward_cast+0x1fd0>)
 8012ff2:	428c      	cmp	r4, r1
 8012ff4:	f001 86b1 	beq.w	8014d5a <forward_cast+0x3b56>
 8012ff8:	dd1d      	ble.n	8013036 <forward_cast+0x1e32>
 8012ffa:	4544      	cmp	r4, r8
 8012ffc:	d128      	bne.n	8013050 <forward_cast+0x1e4c>
 8012ffe:	e9d5 0100 	ldrd	r0, r1, [r5]
 8013002:	f7ed fa95 	bl	8000530 <__aeabi_l2f>
 8013006:	ee07 0a90 	vmov	s15, r0
 801300a:	4b6d      	ldr	r3, [pc, #436]	@ (80131c0 <forward_cast+0x1fbc>)
 801300c:	eef5 7a40 	vcmp.f32	s15, #0.0
 8013010:	4a6e      	ldr	r2, [pc, #440]	@ (80131cc <forward_cast+0x1fc8>)
 8013012:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8013016:	bf14      	ite	ne
 8013018:	2101      	movne	r1, #1
 801301a:	2100      	moveq	r1, #0
 801301c:	e7dd      	b.n	8012fda <forward_cast+0x1dd6>
 801301e:	496e      	ldr	r1, [pc, #440]	@ (80131d8 <forward_cast+0x1fd4>)
 8013020:	428c      	cmp	r4, r1
 8013022:	d0d6      	beq.n	8012fd2 <forward_cast+0x1dce>
 8013024:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8013028:	428c      	cmp	r4, r1
 801302a:	d111      	bne.n	8013050 <forward_cast+0x1e4c>
 801302c:	8829      	ldrh	r1, [r5, #0]
 801302e:	3900      	subs	r1, #0
 8013030:	bf18      	it	ne
 8013032:	2101      	movne	r1, #1
 8013034:	e7d1      	b.n	8012fda <forward_cast+0x1dd6>
 8013036:	42bc      	cmp	r4, r7
 8013038:	f001 830e 	beq.w	8014658 <forward_cast+0x3454>
 801303c:	f5a1 6100 	sub.w	r1, r1, #2048	@ 0x800
 8013040:	428c      	cmp	r4, r1
 8013042:	d105      	bne.n	8013050 <forward_cast+0x1e4c>
 8013044:	f9b5 1000 	ldrsh.w	r1, [r5]
 8013048:	3900      	subs	r1, #0
 801304a:	bf18      	it	ne
 801304c:	2101      	movne	r1, #1
 801304e:	e7c4      	b.n	8012fda <forward_cast+0x1dd6>
 8013050:	2100      	movs	r1, #0
 8013052:	e7c2      	b.n	8012fda <forward_cast+0x1dd6>
 8013054:	455d      	cmp	r5, fp
 8013056:	f4be a93d 	bcs.w	80112d4 <forward_cast+0xd0>
 801305a:	9f01      	ldr	r7, [sp, #4]
 801305c:	4621      	mov	r1, r4
 801305e:	4628      	mov	r0, r5
 8013060:	f7fe f85c 	bl	801111c <_array_handle_get_as_float>
 8013064:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8013068:	ee17 3a90 	vmov	r3, s15
 801306c:	f383 0308 	usat	r3, #8, r3
 8013070:	444d      	add	r5, r9
 8013072:	b2db      	uxtb	r3, r3
 8013074:	45ab      	cmp	fp, r5
 8013076:	8033      	strh	r3, [r6, #0]
 8013078:	443e      	add	r6, r7
 801307a:	d8ef      	bhi.n	801305c <forward_cast+0x1e58>
 801307c:	f7fe b92a 	b.w	80112d4 <forward_cast+0xd0>
 8013080:	455d      	cmp	r5, fp
 8013082:	f4be a927 	bcs.w	80112d4 <forward_cast+0xd0>
 8013086:	f8df 813c 	ldr.w	r8, [pc, #316]	@ 80131c4 <forward_cast+0x1fc0>
 801308a:	4b50      	ldr	r3, [pc, #320]	@ (80131cc <forward_cast+0x1fc8>)
 801308c:	4a4e      	ldr	r2, [pc, #312]	@ (80131c8 <forward_cast+0x1fc4>)
 801308e:	e014      	b.n	80130ba <forward_cast+0x1eb6>
 8013090:	494b      	ldr	r1, [pc, #300]	@ (80131c0 <forward_cast+0x1fbc>)
 8013092:	428c      	cmp	r4, r1
 8013094:	f001 821d 	beq.w	80144d2 <forward_cast+0x32ce>
 8013098:	dd28      	ble.n	80130ec <forward_cast+0x1ee8>
 801309a:	429c      	cmp	r4, r3
 801309c:	f001 8680 	beq.w	8014da0 <forward_cast+0x3b9c>
 80130a0:	4294      	cmp	r4, r2
 80130a2:	d136      	bne.n	8013112 <forward_cast+0x1f0e>
 80130a4:	7829      	ldrb	r1, [r5, #0]
 80130a6:	3900      	subs	r1, #0
 80130a8:	bf18      	it	ne
 80130aa:	2101      	movne	r1, #1
 80130ac:	444d      	add	r5, r9
 80130ae:	8031      	strh	r1, [r6, #0]
 80130b0:	9901      	ldr	r1, [sp, #4]
 80130b2:	45ab      	cmp	fp, r5
 80130b4:	440e      	add	r6, r1
 80130b6:	f67e a90d 	bls.w	80112d4 <forward_cast+0xd0>
 80130ba:	42bc      	cmp	r4, r7
 80130bc:	f001 863c 	beq.w	8014d38 <forward_cast+0x3b34>
 80130c0:	dde6      	ble.n	8013090 <forward_cast+0x1e8c>
 80130c2:	4944      	ldr	r1, [pc, #272]	@ (80131d4 <forward_cast+0x1fd0>)
 80130c4:	428c      	cmp	r4, r1
 80130c6:	f001 865d 	beq.w	8014d84 <forward_cast+0x3b80>
 80130ca:	dd1b      	ble.n	8013104 <forward_cast+0x1f00>
 80130cc:	4544      	cmp	r4, r8
 80130ce:	d120      	bne.n	8013112 <forward_cast+0x1f0e>
 80130d0:	e9d5 0100 	ldrd	r0, r1, [r5]
 80130d4:	f7ed fa2c 	bl	8000530 <__aeabi_l2f>
 80130d8:	ee07 0a90 	vmov	s15, r0
 80130dc:	4a3a      	ldr	r2, [pc, #232]	@ (80131c8 <forward_cast+0x1fc4>)
 80130de:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80130e2:	ee17 3a90 	vmov	r3, s15
 80130e6:	b219      	sxth	r1, r3
 80130e8:	4b38      	ldr	r3, [pc, #224]	@ (80131cc <forward_cast+0x1fc8>)
 80130ea:	e7df      	b.n	80130ac <forward_cast+0x1ea8>
 80130ec:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 80130f0:	428c      	cmp	r4, r1
 80130f2:	f001 8652 	beq.w	8014d9a <forward_cast+0x3b96>
 80130f6:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 80130fa:	428c      	cmp	r4, r1
 80130fc:	d109      	bne.n	8013112 <forward_cast+0x1f0e>
 80130fe:	f9b5 1000 	ldrsh.w	r1, [r5]
 8013102:	e7d3      	b.n	80130ac <forward_cast+0x1ea8>
 8013104:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 8013108:	428c      	cmp	r4, r1
 801310a:	f001 8658 	beq.w	8014dbe <forward_cast+0x3bba>
 801310e:	4554      	cmp	r4, sl
 8013110:	d0f5      	beq.n	80130fe <forward_cast+0x1efa>
 8013112:	2100      	movs	r1, #0
 8013114:	e7ca      	b.n	80130ac <forward_cast+0x1ea8>
 8013116:	455d      	cmp	r5, fp
 8013118:	f4be a8dc 	bcs.w	80112d4 <forward_cast+0xd0>
 801311c:	f8df 80a4 	ldr.w	r8, [pc, #164]	@ 80131c4 <forward_cast+0x1fc0>
 8013120:	4b2a      	ldr	r3, [pc, #168]	@ (80131cc <forward_cast+0x1fc8>)
 8013122:	4a29      	ldr	r2, [pc, #164]	@ (80131c8 <forward_cast+0x1fc4>)
 8013124:	e01c      	b.n	8013160 <forward_cast+0x1f5c>
 8013126:	4926      	ldr	r1, [pc, #152]	@ (80131c0 <forward_cast+0x1fbc>)
 8013128:	428c      	cmp	r4, r1
 801312a:	f001 8140 	beq.w	80143ae <forward_cast+0x31aa>
 801312e:	dd2f      	ble.n	8013190 <forward_cast+0x1f8c>
 8013130:	429c      	cmp	r4, r3
 8013132:	f001 8655 	beq.w	8014de0 <forward_cast+0x3bdc>
 8013136:	4294      	cmp	r4, r2
 8013138:	d13f      	bne.n	80131ba <forward_cast+0x1fb6>
 801313a:	7828      	ldrb	r0, [r5, #0]
 801313c:	3800      	subs	r0, #0
 801313e:	bf18      	it	ne
 8013140:	2001      	movne	r0, #1
 8013142:	f300 000f 	ssat	r0, #16, r0
 8013146:	b200      	sxth	r0, r0
 8013148:	444d      	add	r5, r9
 801314a:	9901      	ldr	r1, [sp, #4]
 801314c:	ee07 0a90 	vmov	s15, r0
 8013150:	45ab      	cmp	fp, r5
 8013152:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013156:	edc6 7a00 	vstr	s15, [r6]
 801315a:	440e      	add	r6, r1
 801315c:	f67e a8ba 	bls.w	80112d4 <forward_cast+0xd0>
 8013160:	4554      	cmp	r4, sl
 8013162:	f001 811c 	beq.w	801439e <forward_cast+0x319a>
 8013166:	ddde      	ble.n	8013126 <forward_cast+0x1f22>
 8013168:	491a      	ldr	r1, [pc, #104]	@ (80131d4 <forward_cast+0x1fd0>)
 801316a:	428c      	cmp	r4, r1
 801316c:	f001 862b 	beq.w	8014dc6 <forward_cast+0x3bc2>
 8013170:	dd19      	ble.n	80131a6 <forward_cast+0x1fa2>
 8013172:	4544      	cmp	r4, r8
 8013174:	d121      	bne.n	80131ba <forward_cast+0x1fb6>
 8013176:	e9d5 0100 	ldrd	r0, r1, [r5]
 801317a:	f7ed f9d9 	bl	8000530 <__aeabi_l2f>
 801317e:	ee07 0a90 	vmov	s15, r0
 8013182:	4b12      	ldr	r3, [pc, #72]	@ (80131cc <forward_cast+0x1fc8>)
 8013184:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013188:	4a0f      	ldr	r2, [pc, #60]	@ (80131c8 <forward_cast+0x1fc4>)
 801318a:	ee17 0a90 	vmov	r0, s15
 801318e:	e7d8      	b.n	8013142 <forward_cast+0x1f3e>
 8013190:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 8013194:	428c      	cmp	r4, r1
 8013196:	f001 8620 	beq.w	8014dda <forward_cast+0x3bd6>
 801319a:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 801319e:	428c      	cmp	r4, r1
 80131a0:	d10b      	bne.n	80131ba <forward_cast+0x1fb6>
 80131a2:	8828      	ldrh	r0, [r5, #0]
 80131a4:	e7cd      	b.n	8013142 <forward_cast+0x1f3e>
 80131a6:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 80131aa:	428c      	cmp	r4, r1
 80131ac:	f001 8626 	beq.w	8014dfc <forward_cast+0x3bf8>
 80131b0:	42bc      	cmp	r4, r7
 80131b2:	d102      	bne.n	80131ba <forward_cast+0x1fb6>
 80131b4:	f9b5 0000 	ldrsh.w	r0, [r5]
 80131b8:	e7c3      	b.n	8013142 <forward_cast+0x1f3e>
 80131ba:	2000      	movs	r0, #0
 80131bc:	e7c1      	b.n	8013142 <forward_cast+0x1f3e>
 80131be:	bf00      	nop
 80131c0:	00041040 	.word	0x00041040
 80131c4:	00842040 	.word	0x00842040
 80131c8:	00060440 	.word	0x00060440
 80131cc:	00042040 	.word	0x00042040
 80131d0:	00840440 	.word	0x00840440
 80131d4:	00841040 	.word	0x00841040
 80131d8:	00040440 	.word	0x00040440
 80131dc:	00821040 	.word	0x00821040
 80131e0:	455d      	cmp	r5, fp
 80131e2:	f4be a877 	bcs.w	80112d4 <forward_cast+0xd0>
 80131e6:	f8df a294 	ldr.w	sl, [pc, #660]	@ 801347c <forward_cast+0x2278>
 80131ea:	f8df 8288 	ldr.w	r8, [pc, #648]	@ 8013474 <forward_cast+0x2270>
 80131ee:	4f9b      	ldr	r7, [pc, #620]	@ (801345c <forward_cast+0x2258>)
 80131f0:	4b9b      	ldr	r3, [pc, #620]	@ (8013460 <forward_cast+0x225c>)
 80131f2:	4a9c      	ldr	r2, [pc, #624]	@ (8013464 <forward_cast+0x2260>)
 80131f4:	e014      	b.n	8013220 <forward_cast+0x201c>
 80131f6:	429c      	cmp	r4, r3
 80131f8:	f001 8604 	beq.w	8014e04 <forward_cast+0x3c00>
 80131fc:	dd2b      	ble.n	8013256 <forward_cast+0x2052>
 80131fe:	4294      	cmp	r4, r2
 8013200:	f001 861a 	beq.w	8014e38 <forward_cast+0x3c34>
 8013204:	4998      	ldr	r1, [pc, #608]	@ (8013468 <forward_cast+0x2264>)
 8013206:	428c      	cmp	r4, r1
 8013208:	d13e      	bne.n	8013288 <forward_cast+0x2084>
 801320a:	7829      	ldrb	r1, [r5, #0]
 801320c:	3900      	subs	r1, #0
 801320e:	bf18      	it	ne
 8013210:	2101      	movne	r1, #1
 8013212:	444d      	add	r5, r9
 8013214:	6031      	str	r1, [r6, #0]
 8013216:	9901      	ldr	r1, [sp, #4]
 8013218:	45ab      	cmp	fp, r5
 801321a:	440e      	add	r6, r1
 801321c:	f67e a85a 	bls.w	80112d4 <forward_cast+0xd0>
 8013220:	4554      	cmp	r4, sl
 8013222:	f000 8795 	beq.w	8014150 <forward_cast+0x2f4c>
 8013226:	dde6      	ble.n	80131f6 <forward_cast+0x1ff2>
 8013228:	4990      	ldr	r1, [pc, #576]	@ (801346c <forward_cast+0x2268>)
 801322a:	428c      	cmp	r4, r1
 801322c:	f001 85f7 	beq.w	8014e1e <forward_cast+0x3c1a>
 8013230:	dd1d      	ble.n	801326e <forward_cast+0x206a>
 8013232:	4544      	cmp	r4, r8
 8013234:	d128      	bne.n	8013288 <forward_cast+0x2084>
 8013236:	e9d5 0100 	ldrd	r0, r1, [r5]
 801323a:	f7ed f979 	bl	8000530 <__aeabi_l2f>
 801323e:	ee07 0a90 	vmov	s15, r0
 8013242:	4b87      	ldr	r3, [pc, #540]	@ (8013460 <forward_cast+0x225c>)
 8013244:	eef5 7a40 	vcmp.f32	s15, #0.0
 8013248:	4a86      	ldr	r2, [pc, #536]	@ (8013464 <forward_cast+0x2260>)
 801324a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801324e:	bf14      	ite	ne
 8013250:	2101      	movne	r1, #1
 8013252:	2100      	moveq	r1, #0
 8013254:	e7dd      	b.n	8013212 <forward_cast+0x200e>
 8013256:	4986      	ldr	r1, [pc, #536]	@ (8013470 <forward_cast+0x226c>)
 8013258:	428c      	cmp	r4, r1
 801325a:	d0d6      	beq.n	801320a <forward_cast+0x2006>
 801325c:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8013260:	428c      	cmp	r4, r1
 8013262:	d111      	bne.n	8013288 <forward_cast+0x2084>
 8013264:	8829      	ldrh	r1, [r5, #0]
 8013266:	3900      	subs	r1, #0
 8013268:	bf18      	it	ne
 801326a:	2101      	movne	r1, #1
 801326c:	e7d1      	b.n	8013212 <forward_cast+0x200e>
 801326e:	42bc      	cmp	r4, r7
 8013270:	f001 85f3 	beq.w	8014e5a <forward_cast+0x3c56>
 8013274:	f5a1 6100 	sub.w	r1, r1, #2048	@ 0x800
 8013278:	428c      	cmp	r4, r1
 801327a:	d105      	bne.n	8013288 <forward_cast+0x2084>
 801327c:	f9b5 1000 	ldrsh.w	r1, [r5]
 8013280:	3900      	subs	r1, #0
 8013282:	bf18      	it	ne
 8013284:	2101      	movne	r1, #1
 8013286:	e7c4      	b.n	8013212 <forward_cast+0x200e>
 8013288:	2100      	movs	r1, #0
 801328a:	e7c2      	b.n	8013212 <forward_cast+0x200e>
 801328c:	455d      	cmp	r5, fp
 801328e:	f4be a821 	bcs.w	80112d4 <forward_cast+0xd0>
 8013292:	4a75      	ldr	r2, [pc, #468]	@ (8013468 <forward_cast+0x2264>)
 8013294:	e014      	b.n	80132c0 <forward_cast+0x20bc>
 8013296:	4554      	cmp	r4, sl
 8013298:	f000 8748 	beq.w	801412c <forward_cast+0x2f28>
 801329c:	dd28      	ble.n	80132f0 <forward_cast+0x20ec>
 801329e:	4971      	ldr	r1, [pc, #452]	@ (8013464 <forward_cast+0x2260>)
 80132a0:	428c      	cmp	r4, r1
 80132a2:	f001 85ee 	beq.w	8014e82 <forward_cast+0x3c7e>
 80132a6:	4294      	cmp	r4, r2
 80132a8:	d135      	bne.n	8013316 <forward_cast+0x2112>
 80132aa:	7828      	ldrb	r0, [r5, #0]
 80132ac:	3800      	subs	r0, #0
 80132ae:	bf18      	it	ne
 80132b0:	2001      	movne	r0, #1
 80132b2:	444d      	add	r5, r9
 80132b4:	9901      	ldr	r1, [sp, #4]
 80132b6:	6030      	str	r0, [r6, #0]
 80132b8:	45ab      	cmp	fp, r5
 80132ba:	440e      	add	r6, r1
 80132bc:	f67e a80a 	bls.w	80112d4 <forward_cast+0xd0>
 80132c0:	4544      	cmp	r4, r8
 80132c2:	f000 868d 	beq.w	8013fe0 <forward_cast+0x2ddc>
 80132c6:	dde6      	ble.n	8013296 <forward_cast+0x2092>
 80132c8:	42bc      	cmp	r4, r7
 80132ca:	f001 85cd 	beq.w	8014e68 <forward_cast+0x3c64>
 80132ce:	dd19      	ble.n	8013304 <forward_cast+0x2100>
 80132d0:	4968      	ldr	r1, [pc, #416]	@ (8013474 <forward_cast+0x2270>)
 80132d2:	428c      	cmp	r4, r1
 80132d4:	d11f      	bne.n	8013316 <forward_cast+0x2112>
 80132d6:	e9d5 0100 	ldrd	r0, r1, [r5]
 80132da:	f7ed f929 	bl	8000530 <__aeabi_l2f>
 80132de:	ee07 0a90 	vmov	s15, r0
 80132e2:	4b65      	ldr	r3, [pc, #404]	@ (8013478 <forward_cast+0x2274>)
 80132e4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80132e8:	4a5f      	ldr	r2, [pc, #380]	@ (8013468 <forward_cast+0x2264>)
 80132ea:	ee17 0a90 	vmov	r0, s15
 80132ee:	e7e0      	b.n	80132b2 <forward_cast+0x20ae>
 80132f0:	495f      	ldr	r1, [pc, #380]	@ (8013470 <forward_cast+0x226c>)
 80132f2:	428c      	cmp	r4, r1
 80132f4:	f001 85c2 	beq.w	8014e7c <forward_cast+0x3c78>
 80132f8:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 80132fc:	428c      	cmp	r4, r1
 80132fe:	d10a      	bne.n	8013316 <forward_cast+0x2112>
 8013300:	8828      	ldrh	r0, [r5, #0]
 8013302:	e7d6      	b.n	80132b2 <forward_cast+0x20ae>
 8013304:	4955      	ldr	r1, [pc, #340]	@ (801345c <forward_cast+0x2258>)
 8013306:	428c      	cmp	r4, r1
 8013308:	f001 85c9 	beq.w	8014e9e <forward_cast+0x3c9a>
 801330c:	429c      	cmp	r4, r3
 801330e:	d102      	bne.n	8013316 <forward_cast+0x2112>
 8013310:	f9b5 0000 	ldrsh.w	r0, [r5]
 8013314:	e7cd      	b.n	80132b2 <forward_cast+0x20ae>
 8013316:	2000      	movs	r0, #0
 8013318:	e7cb      	b.n	80132b2 <forward_cast+0x20ae>
 801331a:	455d      	cmp	r5, fp
 801331c:	f4bd afda 	bcs.w	80112d4 <forward_cast+0xd0>
 8013320:	4f54      	ldr	r7, [pc, #336]	@ (8013474 <forward_cast+0x2270>)
 8013322:	4b50      	ldr	r3, [pc, #320]	@ (8013464 <forward_cast+0x2260>)
 8013324:	4a50      	ldr	r2, [pc, #320]	@ (8013468 <forward_cast+0x2264>)
 8013326:	e016      	b.n	8013356 <forward_cast+0x2152>
 8013328:	494d      	ldr	r1, [pc, #308]	@ (8013460 <forward_cast+0x225c>)
 801332a:	428c      	cmp	r4, r1
 801332c:	f000 8670 	beq.w	8014010 <forward_cast+0x2e0c>
 8013330:	dd29      	ble.n	8013386 <forward_cast+0x2182>
 8013332:	429c      	cmp	r4, r3
 8013334:	f001 85c4 	beq.w	8014ec0 <forward_cast+0x3cbc>
 8013338:	4294      	cmp	r4, r2
 801333a:	d139      	bne.n	80133b0 <forward_cast+0x21ac>
 801333c:	7828      	ldrb	r0, [r5, #0]
 801333e:	3800      	subs	r0, #0
 8013340:	bf18      	it	ne
 8013342:	2001      	movne	r0, #1
 8013344:	f300 000f 	ssat	r0, #16, r0
 8013348:	444d      	add	r5, r9
 801334a:	9901      	ldr	r1, [sp, #4]
 801334c:	8030      	strh	r0, [r6, #0]
 801334e:	45ab      	cmp	fp, r5
 8013350:	440e      	add	r6, r1
 8013352:	f67d afbf 	bls.w	80112d4 <forward_cast+0xd0>
 8013356:	4544      	cmp	r4, r8
 8013358:	f000 8652 	beq.w	8014000 <forward_cast+0x2dfc>
 801335c:	dde4      	ble.n	8013328 <forward_cast+0x2124>
 801335e:	4943      	ldr	r1, [pc, #268]	@ (801346c <forward_cast+0x2268>)
 8013360:	428c      	cmp	r4, r1
 8013362:	f001 85a0 	beq.w	8014ea6 <forward_cast+0x3ca2>
 8013366:	dd19      	ble.n	801339c <forward_cast+0x2198>
 8013368:	42bc      	cmp	r4, r7
 801336a:	d121      	bne.n	80133b0 <forward_cast+0x21ac>
 801336c:	e9d5 0100 	ldrd	r0, r1, [r5]
 8013370:	f7ed f8de 	bl	8000530 <__aeabi_l2f>
 8013374:	ee07 0a90 	vmov	s15, r0
 8013378:	4b3a      	ldr	r3, [pc, #232]	@ (8013464 <forward_cast+0x2260>)
 801337a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801337e:	4a3a      	ldr	r2, [pc, #232]	@ (8013468 <forward_cast+0x2264>)
 8013380:	ee17 0a90 	vmov	r0, s15
 8013384:	e7de      	b.n	8013344 <forward_cast+0x2140>
 8013386:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 801338a:	428c      	cmp	r4, r1
 801338c:	f001 8595 	beq.w	8014eba <forward_cast+0x3cb6>
 8013390:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8013394:	428c      	cmp	r4, r1
 8013396:	d10b      	bne.n	80133b0 <forward_cast+0x21ac>
 8013398:	8828      	ldrh	r0, [r5, #0]
 801339a:	e7d3      	b.n	8013344 <forward_cast+0x2140>
 801339c:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 80133a0:	428c      	cmp	r4, r1
 80133a2:	f001 859b 	beq.w	8014edc <forward_cast+0x3cd8>
 80133a6:	4554      	cmp	r4, sl
 80133a8:	d102      	bne.n	80133b0 <forward_cast+0x21ac>
 80133aa:	f9b5 0000 	ldrsh.w	r0, [r5]
 80133ae:	e7c9      	b.n	8013344 <forward_cast+0x2140>
 80133b0:	2000      	movs	r0, #0
 80133b2:	e7c7      	b.n	8013344 <forward_cast+0x2140>
 80133b4:	455d      	cmp	r5, fp
 80133b6:	f4bd af8d 	bcs.w	80112d4 <forward_cast+0xd0>
 80133ba:	2700      	movs	r7, #0
 80133bc:	f8df a0bc 	ldr.w	sl, [pc, #188]	@ 801347c <forward_cast+0x2278>
 80133c0:	f8df 80b0 	ldr.w	r8, [pc, #176]	@ 8013474 <forward_cast+0x2270>
 80133c4:	4b2c      	ldr	r3, [pc, #176]	@ (8013478 <forward_cast+0x2274>)
 80133c6:	4a26      	ldr	r2, [pc, #152]	@ (8013460 <forward_cast+0x225c>)
 80133c8:	e016      	b.n	80133f8 <forward_cast+0x21f4>
 80133ca:	4294      	cmp	r4, r2
 80133cc:	f000 85de 	beq.w	8013f8c <forward_cast+0x2d88>
 80133d0:	dd2c      	ble.n	801342c <forward_cast+0x2228>
 80133d2:	4924      	ldr	r1, [pc, #144]	@ (8013464 <forward_cast+0x2260>)
 80133d4:	428c      	cmp	r4, r1
 80133d6:	f001 8585 	beq.w	8014ee4 <forward_cast+0x3ce0>
 80133da:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 80133de:	428c      	cmp	r4, r1
 80133e0:	d133      	bne.n	801344a <forward_cast+0x2246>
 80133e2:	7829      	ldrb	r1, [r5, #0]
 80133e4:	3900      	subs	r1, #0
 80133e6:	bf18      	it	ne
 80133e8:	2101      	movne	r1, #1
 80133ea:	444d      	add	r5, r9
 80133ec:	55f1      	strb	r1, [r6, r7]
 80133ee:	9901      	ldr	r1, [sp, #4]
 80133f0:	45ab      	cmp	fp, r5
 80133f2:	440f      	add	r7, r1
 80133f4:	f67d af6e 	bls.w	80112d4 <forward_cast+0xd0>
 80133f8:	4554      	cmp	r4, sl
 80133fa:	f001 8583 	beq.w	8014f04 <forward_cast+0x3d00>
 80133fe:	dde4      	ble.n	80133ca <forward_cast+0x21c6>
 8013400:	491a      	ldr	r1, [pc, #104]	@ (801346c <forward_cast+0x2268>)
 8013402:	428c      	cmp	r4, r1
 8013404:	f000 85ce 	beq.w	8013fa4 <forward_cast+0x2da0>
 8013408:	dd19      	ble.n	801343e <forward_cast+0x223a>
 801340a:	4544      	cmp	r4, r8
 801340c:	d11d      	bne.n	801344a <forward_cast+0x2246>
 801340e:	e9d5 0100 	ldrd	r0, r1, [r5]
 8013412:	f7ed f88d 	bl	8000530 <__aeabi_l2f>
 8013416:	ee07 0a90 	vmov	s15, r0
 801341a:	4b17      	ldr	r3, [pc, #92]	@ (8013478 <forward_cast+0x2274>)
 801341c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013420:	4a0f      	ldr	r2, [pc, #60]	@ (8013460 <forward_cast+0x225c>)
 8013422:	edcd 7a02 	vstr	s15, [sp, #8]
 8013426:	f89d 1008 	ldrb.w	r1, [sp, #8]
 801342a:	e7de      	b.n	80133ea <forward_cast+0x21e6>
 801342c:	4910      	ldr	r1, [pc, #64]	@ (8013470 <forward_cast+0x226c>)
 801342e:	428c      	cmp	r4, r1
 8013430:	d003      	beq.n	801343a <forward_cast+0x2236>
 8013432:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8013436:	428c      	cmp	r4, r1
 8013438:	d107      	bne.n	801344a <forward_cast+0x2246>
 801343a:	7829      	ldrb	r1, [r5, #0]
 801343c:	e7d5      	b.n	80133ea <forward_cast+0x21e6>
 801343e:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 8013442:	428c      	cmp	r4, r1
 8013444:	d0f9      	beq.n	801343a <forward_cast+0x2236>
 8013446:	429c      	cmp	r4, r3
 8013448:	d0f7      	beq.n	801343a <forward_cast+0x2236>
 801344a:	2100      	movs	r1, #0
 801344c:	e7cd      	b.n	80133ea <forward_cast+0x21e6>
 801344e:	455d      	cmp	r5, fp
 8013450:	f4bd af40 	bcs.w	80112d4 <forward_cast+0xd0>
 8013454:	4f07      	ldr	r7, [pc, #28]	@ (8013474 <forward_cast+0x2270>)
 8013456:	4b03      	ldr	r3, [pc, #12]	@ (8013464 <forward_cast+0x2260>)
 8013458:	4a03      	ldr	r2, [pc, #12]	@ (8013468 <forward_cast+0x2264>)
 801345a:	e025      	b.n	80134a8 <forward_cast+0x22a4>
 801345c:	00840440 	.word	0x00840440
 8013460:	00041040 	.word	0x00041040
 8013464:	00042040 	.word	0x00042040
 8013468:	00060440 	.word	0x00060440
 801346c:	00841040 	.word	0x00841040
 8013470:	00040440 	.word	0x00040440
 8013474:	00842040 	.word	0x00842040
 8013478:	00840840 	.word	0x00840840
 801347c:	00821040 	.word	0x00821040
 8013480:	4554      	cmp	r4, sl
 8013482:	f000 85a3 	beq.w	8013fcc <forward_cast+0x2dc8>
 8013486:	dd27      	ble.n	80134d8 <forward_cast+0x22d4>
 8013488:	429c      	cmp	r4, r3
 801348a:	f001 855f 	beq.w	8014f4c <forward_cast+0x3d48>
 801348e:	4294      	cmp	r4, r2
 8013490:	d138      	bne.n	8013504 <forward_cast+0x2300>
 8013492:	7828      	ldrb	r0, [r5, #0]
 8013494:	3800      	subs	r0, #0
 8013496:	bf18      	it	ne
 8013498:	2001      	movne	r0, #1
 801349a:	444d      	add	r5, r9
 801349c:	9901      	ldr	r1, [sp, #4]
 801349e:	6030      	str	r0, [r6, #0]
 80134a0:	45ab      	cmp	fp, r5
 80134a2:	440e      	add	r6, r1
 80134a4:	f67d af16 	bls.w	80112d4 <forward_cast+0xd0>
 80134a8:	4544      	cmp	r4, r8
 80134aa:	f000 8587 	beq.w	8013fbc <forward_cast+0x2db8>
 80134ae:	dde7      	ble.n	8013480 <forward_cast+0x227c>
 80134b0:	49a6      	ldr	r1, [pc, #664]	@ (801374c <forward_cast+0x2548>)
 80134b2:	428c      	cmp	r4, r1
 80134b4:	f001 853d 	beq.w	8014f32 <forward_cast+0x3d2e>
 80134b8:	dd18      	ble.n	80134ec <forward_cast+0x22e8>
 80134ba:	42bc      	cmp	r4, r7
 80134bc:	d122      	bne.n	8013504 <forward_cast+0x2300>
 80134be:	e9d5 0100 	ldrd	r0, r1, [r5]
 80134c2:	f7ed f835 	bl	8000530 <__aeabi_l2f>
 80134c6:	ee07 0a90 	vmov	s15, r0
 80134ca:	4ba1      	ldr	r3, [pc, #644]	@ (8013750 <forward_cast+0x254c>)
 80134cc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80134d0:	4aa0      	ldr	r2, [pc, #640]	@ (8013754 <forward_cast+0x2550>)
 80134d2:	ee17 0a90 	vmov	r0, s15
 80134d6:	e7e0      	b.n	801349a <forward_cast+0x2296>
 80134d8:	499f      	ldr	r1, [pc, #636]	@ (8013758 <forward_cast+0x2554>)
 80134da:	428c      	cmp	r4, r1
 80134dc:	f001 8533 	beq.w	8014f46 <forward_cast+0x3d42>
 80134e0:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 80134e4:	428c      	cmp	r4, r1
 80134e6:	d10d      	bne.n	8013504 <forward_cast+0x2300>
 80134e8:	8828      	ldrh	r0, [r5, #0]
 80134ea:	e7d6      	b.n	801349a <forward_cast+0x2296>
 80134ec:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 80134f0:	428c      	cmp	r4, r1
 80134f2:	f001 8539 	beq.w	8014f68 <forward_cast+0x3d64>
 80134f6:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 80134fa:	428c      	cmp	r4, r1
 80134fc:	d102      	bne.n	8013504 <forward_cast+0x2300>
 80134fe:	f9b5 0000 	ldrsh.w	r0, [r5]
 8013502:	e7ca      	b.n	801349a <forward_cast+0x2296>
 8013504:	2000      	movs	r0, #0
 8013506:	e7c8      	b.n	801349a <forward_cast+0x2296>
 8013508:	455d      	cmp	r5, fp
 801350a:	f4bd aee3 	bcs.w	80112d4 <forward_cast+0xd0>
 801350e:	2300      	movs	r3, #0
 8013510:	4a92      	ldr	r2, [pc, #584]	@ (801375c <forward_cast+0x2558>)
 8013512:	4619      	mov	r1, r3
 8013514:	464b      	mov	r3, r9
 8013516:	46b9      	mov	r9, r7
 8013518:	4637      	mov	r7, r6
 801351a:	460e      	mov	r6, r1
 801351c:	e016      	b.n	801354c <forward_cast+0x2348>
 801351e:	4544      	cmp	r4, r8
 8013520:	f000 84ef 	beq.w	8013f02 <forward_cast+0x2cfe>
 8013524:	dd2e      	ble.n	8013584 <forward_cast+0x2380>
 8013526:	498a      	ldr	r1, [pc, #552]	@ (8013750 <forward_cast+0x254c>)
 8013528:	428c      	cmp	r4, r1
 801352a:	f000 832e 	beq.w	8013b8a <forward_cast+0x2986>
 801352e:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 8013532:	428c      	cmp	r4, r1
 8013534:	d133      	bne.n	801359e <forward_cast+0x239a>
 8013536:	7829      	ldrb	r1, [r5, #0]
 8013538:	3900      	subs	r1, #0
 801353a:	bf18      	it	ne
 801353c:	2101      	movne	r1, #1
 801353e:	441d      	add	r5, r3
 8013540:	55b9      	strb	r1, [r7, r6]
 8013542:	9901      	ldr	r1, [sp, #4]
 8013544:	45ab      	cmp	fp, r5
 8013546:	440e      	add	r6, r1
 8013548:	f67d aec4 	bls.w	80112d4 <forward_cast+0xd0>
 801354c:	454c      	cmp	r4, r9
 801354e:	f000 832c 	beq.w	8013baa <forward_cast+0x29a6>
 8013552:	dde4      	ble.n	801351e <forward_cast+0x231a>
 8013554:	497d      	ldr	r1, [pc, #500]	@ (801374c <forward_cast+0x2548>)
 8013556:	428c      	cmp	r4, r1
 8013558:	f000 84df 	beq.w	8013f1a <forward_cast+0x2d16>
 801355c:	dd19      	ble.n	8013592 <forward_cast+0x238e>
 801355e:	4980      	ldr	r1, [pc, #512]	@ (8013760 <forward_cast+0x255c>)
 8013560:	428c      	cmp	r4, r1
 8013562:	d11c      	bne.n	801359e <forward_cast+0x239a>
 8013564:	9303      	str	r3, [sp, #12]
 8013566:	e9d5 0100 	ldrd	r0, r1, [r5]
 801356a:	f7ec ffe1 	bl	8000530 <__aeabi_l2f>
 801356e:	ee07 0a90 	vmov	s15, r0
 8013572:	4a7a      	ldr	r2, [pc, #488]	@ (801375c <forward_cast+0x2558>)
 8013574:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013578:	9b03      	ldr	r3, [sp, #12]
 801357a:	edcd 7a02 	vstr	s15, [sp, #8]
 801357e:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8013582:	e7dc      	b.n	801353e <forward_cast+0x233a>
 8013584:	4554      	cmp	r4, sl
 8013586:	d002      	beq.n	801358e <forward_cast+0x238a>
 8013588:	4976      	ldr	r1, [pc, #472]	@ (8013764 <forward_cast+0x2560>)
 801358a:	428c      	cmp	r4, r1
 801358c:	d107      	bne.n	801359e <forward_cast+0x239a>
 801358e:	7829      	ldrb	r1, [r5, #0]
 8013590:	e7d5      	b.n	801353e <forward_cast+0x233a>
 8013592:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 8013596:	428c      	cmp	r4, r1
 8013598:	d0f9      	beq.n	801358e <forward_cast+0x238a>
 801359a:	4294      	cmp	r4, r2
 801359c:	d0f7      	beq.n	801358e <forward_cast+0x238a>
 801359e:	2100      	movs	r1, #0
 80135a0:	e7cd      	b.n	801353e <forward_cast+0x233a>
 80135a2:	455d      	cmp	r5, fp
 80135a4:	f4bd ae96 	bcs.w	80112d4 <forward_cast+0xd0>
 80135a8:	f8df 81b4 	ldr.w	r8, [pc, #436]	@ 8013760 <forward_cast+0x255c>
 80135ac:	4b68      	ldr	r3, [pc, #416]	@ (8013750 <forward_cast+0x254c>)
 80135ae:	4a69      	ldr	r2, [pc, #420]	@ (8013754 <forward_cast+0x2550>)
 80135b0:	e013      	b.n	80135da <forward_cast+0x23d6>
 80135b2:	4554      	cmp	r4, sl
 80135b4:	f000 84c5 	beq.w	8013f42 <forward_cast+0x2d3e>
 80135b8:	dd27      	ble.n	801360a <forward_cast+0x2406>
 80135ba:	429c      	cmp	r4, r3
 80135bc:	f000 8317 	beq.w	8013bee <forward_cast+0x29ea>
 80135c0:	4294      	cmp	r4, r2
 80135c2:	d138      	bne.n	8013636 <forward_cast+0x2432>
 80135c4:	7828      	ldrb	r0, [r5, #0]
 80135c6:	3800      	subs	r0, #0
 80135c8:	bf18      	it	ne
 80135ca:	2001      	movne	r0, #1
 80135cc:	444d      	add	r5, r9
 80135ce:	9901      	ldr	r1, [sp, #4]
 80135d0:	6030      	str	r0, [r6, #0]
 80135d2:	45ab      	cmp	fp, r5
 80135d4:	440e      	add	r6, r1
 80135d6:	f67d ae7d 	bls.w	80112d4 <forward_cast+0xd0>
 80135da:	42bc      	cmp	r4, r7
 80135dc:	f000 84a9 	beq.w	8013f32 <forward_cast+0x2d2e>
 80135e0:	dde7      	ble.n	80135b2 <forward_cast+0x23ae>
 80135e2:	495a      	ldr	r1, [pc, #360]	@ (801374c <forward_cast+0x2548>)
 80135e4:	428c      	cmp	r4, r1
 80135e6:	f000 82f7 	beq.w	8013bd8 <forward_cast+0x29d4>
 80135ea:	dd18      	ble.n	801361e <forward_cast+0x241a>
 80135ec:	4544      	cmp	r4, r8
 80135ee:	d122      	bne.n	8013636 <forward_cast+0x2432>
 80135f0:	e9d5 0100 	ldrd	r0, r1, [r5]
 80135f4:	f7ec ff9c 	bl	8000530 <__aeabi_l2f>
 80135f8:	ee07 0a90 	vmov	s15, r0
 80135fc:	4b54      	ldr	r3, [pc, #336]	@ (8013750 <forward_cast+0x254c>)
 80135fe:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013602:	4a54      	ldr	r2, [pc, #336]	@ (8013754 <forward_cast+0x2550>)
 8013604:	ee17 0a90 	vmov	r0, s15
 8013608:	e7e0      	b.n	80135cc <forward_cast+0x23c8>
 801360a:	4953      	ldr	r1, [pc, #332]	@ (8013758 <forward_cast+0x2554>)
 801360c:	428c      	cmp	r4, r1
 801360e:	f000 82ec 	beq.w	8013bea <forward_cast+0x29e6>
 8013612:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8013616:	428c      	cmp	r4, r1
 8013618:	d10d      	bne.n	8013636 <forward_cast+0x2432>
 801361a:	8828      	ldrh	r0, [r5, #0]
 801361c:	e7d6      	b.n	80135cc <forward_cast+0x23c8>
 801361e:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 8013622:	428c      	cmp	r4, r1
 8013624:	f000 82f0 	beq.w	8013c08 <forward_cast+0x2a04>
 8013628:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 801362c:	428c      	cmp	r4, r1
 801362e:	d102      	bne.n	8013636 <forward_cast+0x2432>
 8013630:	f9b5 0000 	ldrsh.w	r0, [r5]
 8013634:	e7ca      	b.n	80135cc <forward_cast+0x23c8>
 8013636:	2000      	movs	r0, #0
 8013638:	e7c8      	b.n	80135cc <forward_cast+0x23c8>
 801363a:	455d      	cmp	r5, fp
 801363c:	f4bd ae4a 	bcs.w	80112d4 <forward_cast+0xd0>
 8013640:	2700      	movs	r7, #0
 8013642:	f8df a128 	ldr.w	sl, [pc, #296]	@ 801376c <forward_cast+0x2568>
 8013646:	f8df 8118 	ldr.w	r8, [pc, #280]	@ 8013760 <forward_cast+0x255c>
 801364a:	4b44      	ldr	r3, [pc, #272]	@ (801375c <forward_cast+0x2558>)
 801364c:	4a46      	ldr	r2, [pc, #280]	@ (8013768 <forward_cast+0x2564>)
 801364e:	e018      	b.n	8013682 <forward_cast+0x247e>
 8013650:	4294      	cmp	r4, r2
 8013652:	f000 8261 	beq.w	8013b18 <forward_cast+0x2914>
 8013656:	dd2c      	ble.n	80136b2 <forward_cast+0x24ae>
 8013658:	493d      	ldr	r1, [pc, #244]	@ (8013750 <forward_cast+0x254c>)
 801365a:	428c      	cmp	r4, r1
 801365c:	f000 8285 	beq.w	8013b6a <forward_cast+0x2966>
 8013660:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 8013664:	428c      	cmp	r4, r1
 8013666:	d138      	bne.n	80136da <forward_cast+0x24d6>
 8013668:	7828      	ldrb	r0, [r5, #0]
 801366a:	3800      	subs	r0, #0
 801366c:	bf18      	it	ne
 801366e:	2001      	movne	r0, #1
 8013670:	f300 000f 	ssat	r0, #16, r0
 8013674:	444d      	add	r5, r9
 8013676:	9901      	ldr	r1, [sp, #4]
 8013678:	55f0      	strb	r0, [r6, r7]
 801367a:	45ab      	cmp	fp, r5
 801367c:	440f      	add	r7, r1
 801367e:	f67d ae29 	bls.w	80112d4 <forward_cast+0xd0>
 8013682:	4554      	cmp	r4, sl
 8013684:	f000 8251 	beq.w	8013b2a <forward_cast+0x2926>
 8013688:	dde2      	ble.n	8013650 <forward_cast+0x244c>
 801368a:	4930      	ldr	r1, [pc, #192]	@ (801374c <forward_cast+0x2548>)
 801368c:	428c      	cmp	r4, r1
 801368e:	f000 8261 	beq.w	8013b54 <forward_cast+0x2950>
 8013692:	dd18      	ble.n	80136c6 <forward_cast+0x24c2>
 8013694:	4544      	cmp	r4, r8
 8013696:	d120      	bne.n	80136da <forward_cast+0x24d6>
 8013698:	e9d5 0100 	ldrd	r0, r1, [r5]
 801369c:	f7ec ff48 	bl	8000530 <__aeabi_l2f>
 80136a0:	ee07 0a90 	vmov	s15, r0
 80136a4:	4b2d      	ldr	r3, [pc, #180]	@ (801375c <forward_cast+0x2558>)
 80136a6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80136aa:	4a2f      	ldr	r2, [pc, #188]	@ (8013768 <forward_cast+0x2564>)
 80136ac:	ee17 0a90 	vmov	r0, s15
 80136b0:	e7de      	b.n	8013670 <forward_cast+0x246c>
 80136b2:	4929      	ldr	r1, [pc, #164]	@ (8013758 <forward_cast+0x2554>)
 80136b4:	428c      	cmp	r4, r1
 80136b6:	f000 8256 	beq.w	8013b66 <forward_cast+0x2962>
 80136ba:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 80136be:	428c      	cmp	r4, r1
 80136c0:	d10b      	bne.n	80136da <forward_cast+0x24d6>
 80136c2:	8828      	ldrh	r0, [r5, #0]
 80136c4:	e7d4      	b.n	8013670 <forward_cast+0x246c>
 80136c6:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 80136ca:	428c      	cmp	r4, r1
 80136cc:	f000 825a 	beq.w	8013b84 <forward_cast+0x2980>
 80136d0:	429c      	cmp	r4, r3
 80136d2:	d102      	bne.n	80136da <forward_cast+0x24d6>
 80136d4:	f9b5 0000 	ldrsh.w	r0, [r5]
 80136d8:	e7ca      	b.n	8013670 <forward_cast+0x246c>
 80136da:	2000      	movs	r0, #0
 80136dc:	e7c8      	b.n	8013670 <forward_cast+0x246c>
 80136de:	455d      	cmp	r5, fp
 80136e0:	f4bd adf8 	bcs.w	80112d4 <forward_cast+0xd0>
 80136e4:	4b1a      	ldr	r3, [pc, #104]	@ (8013750 <forward_cast+0x254c>)
 80136e6:	4a1b      	ldr	r2, [pc, #108]	@ (8013754 <forward_cast+0x2550>)
 80136e8:	e016      	b.n	8013718 <forward_cast+0x2514>
 80136ea:	4554      	cmp	r4, sl
 80136ec:	f000 836b 	beq.w	8013dc6 <forward_cast+0x2bc2>
 80136f0:	dd3e      	ble.n	8013770 <forward_cast+0x256c>
 80136f2:	429c      	cmp	r4, r3
 80136f4:	f000 8296 	beq.w	8013c24 <forward_cast+0x2a20>
 80136f8:	4294      	cmp	r4, r2
 80136fa:	d14d      	bne.n	8013798 <forward_cast+0x2594>
 80136fc:	7828      	ldrb	r0, [r5, #0]
 80136fe:	3800      	subs	r0, #0
 8013700:	bf18      	it	ne
 8013702:	2001      	movne	r0, #1
 8013704:	f300 000f 	ssat	r0, #16, r0
 8013708:	444d      	add	r5, r9
 801370a:	b200      	sxth	r0, r0
 801370c:	9901      	ldr	r1, [sp, #4]
 801370e:	45ab      	cmp	fp, r5
 8013710:	6030      	str	r0, [r6, #0]
 8013712:	440e      	add	r6, r1
 8013714:	f67d adde 	bls.w	80112d4 <forward_cast+0xd0>
 8013718:	4544      	cmp	r4, r8
 801371a:	f000 834d 	beq.w	8013db8 <forward_cast+0x2bb4>
 801371e:	dde4      	ble.n	80136ea <forward_cast+0x24e6>
 8013720:	490a      	ldr	r1, [pc, #40]	@ (801374c <forward_cast+0x2548>)
 8013722:	428c      	cmp	r4, r1
 8013724:	f000 8273 	beq.w	8013c0e <forward_cast+0x2a0a>
 8013728:	dd2c      	ble.n	8013784 <forward_cast+0x2580>
 801372a:	490d      	ldr	r1, [pc, #52]	@ (8013760 <forward_cast+0x255c>)
 801372c:	428c      	cmp	r4, r1
 801372e:	d133      	bne.n	8013798 <forward_cast+0x2594>
 8013730:	e9d5 0100 	ldrd	r0, r1, [r5]
 8013734:	f7ec fefc 	bl	8000530 <__aeabi_l2f>
 8013738:	ee07 0a90 	vmov	s15, r0
 801373c:	4b04      	ldr	r3, [pc, #16]	@ (8013750 <forward_cast+0x254c>)
 801373e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013742:	4a04      	ldr	r2, [pc, #16]	@ (8013754 <forward_cast+0x2550>)
 8013744:	ee17 0a90 	vmov	r0, s15
 8013748:	e7dc      	b.n	8013704 <forward_cast+0x2500>
 801374a:	bf00      	nop
 801374c:	00841040 	.word	0x00841040
 8013750:	00042040 	.word	0x00042040
 8013754:	00060440 	.word	0x00060440
 8013758:	00040440 	.word	0x00040440
 801375c:	00840840 	.word	0x00840840
 8013760:	00842040 	.word	0x00842040
 8013764:	00040840 	.word	0x00040840
 8013768:	00041040 	.word	0x00041040
 801376c:	00821040 	.word	0x00821040
 8013770:	499c      	ldr	r1, [pc, #624]	@ (80139e4 <forward_cast+0x27e0>)
 8013772:	428c      	cmp	r4, r1
 8013774:	f000 8254 	beq.w	8013c20 <forward_cast+0x2a1c>
 8013778:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 801377c:	428c      	cmp	r4, r1
 801377e:	d10b      	bne.n	8013798 <forward_cast+0x2594>
 8013780:	8828      	ldrh	r0, [r5, #0]
 8013782:	e7bf      	b.n	8013704 <forward_cast+0x2500>
 8013784:	f5a1 6140 	sub.w	r1, r1, #3072	@ 0xc00
 8013788:	428c      	cmp	r4, r1
 801378a:	f000 8258 	beq.w	8013c3e <forward_cast+0x2a3a>
 801378e:	42bc      	cmp	r4, r7
 8013790:	d102      	bne.n	8013798 <forward_cast+0x2594>
 8013792:	f9b5 0000 	ldrsh.w	r0, [r5]
 8013796:	e7b5      	b.n	8013704 <forward_cast+0x2500>
 8013798:	2000      	movs	r0, #0
 801379a:	e7b3      	b.n	8013704 <forward_cast+0x2500>
 801379c:	455d      	cmp	r5, fp
 801379e:	f4bd ad99 	bcs.w	80112d4 <forward_cast+0xd0>
 80137a2:	2700      	movs	r7, #0
 80137a4:	f8df 825c 	ldr.w	r8, [pc, #604]	@ 8013a04 <forward_cast+0x2800>
 80137a8:	4b8f      	ldr	r3, [pc, #572]	@ (80139e8 <forward_cast+0x27e4>)
 80137aa:	4a90      	ldr	r2, [pc, #576]	@ (80139ec <forward_cast+0x27e8>)
 80137ac:	e018      	b.n	80137e0 <forward_cast+0x25dc>
 80137ae:	4294      	cmp	r4, r2
 80137b0:	f000 82e4 	beq.w	8013d7c <forward_cast+0x2b78>
 80137b4:	dd2d      	ble.n	8013812 <forward_cast+0x260e>
 80137b6:	498e      	ldr	r1, [pc, #568]	@ (80139f0 <forward_cast+0x27ec>)
 80137b8:	428c      	cmp	r4, r1
 80137ba:	f000 824e 	beq.w	8013c5a <forward_cast+0x2a56>
 80137be:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 80137c2:	428c      	cmp	r4, r1
 80137c4:	d136      	bne.n	8013834 <forward_cast+0x2630>
 80137c6:	7828      	ldrb	r0, [r5, #0]
 80137c8:	3800      	subs	r0, #0
 80137ca:	bf18      	it	ne
 80137cc:	2001      	movne	r0, #1
 80137ce:	f300 0007 	ssat	r0, #8, r0
 80137d2:	444d      	add	r5, r9
 80137d4:	9901      	ldr	r1, [sp, #4]
 80137d6:	55f0      	strb	r0, [r6, r7]
 80137d8:	45ab      	cmp	fp, r5
 80137da:	440f      	add	r7, r1
 80137dc:	f67d ad7a 	bls.w	80112d4 <forward_cast+0xd0>
 80137e0:	4984      	ldr	r1, [pc, #528]	@ (80139f4 <forward_cast+0x27f0>)
 80137e2:	428c      	cmp	r4, r1
 80137e4:	f000 82d3 	beq.w	8013d8e <forward_cast+0x2b8a>
 80137e8:	dde1      	ble.n	80137ae <forward_cast+0x25aa>
 80137ea:	4544      	cmp	r4, r8
 80137ec:	f000 822a 	beq.w	8013c44 <forward_cast+0x2a40>
 80137f0:	dd17      	ble.n	8013822 <forward_cast+0x261e>
 80137f2:	4981      	ldr	r1, [pc, #516]	@ (80139f8 <forward_cast+0x27f4>)
 80137f4:	428c      	cmp	r4, r1
 80137f6:	d11d      	bne.n	8013834 <forward_cast+0x2630>
 80137f8:	e9d5 0100 	ldrd	r0, r1, [r5]
 80137fc:	f7ec fe98 	bl	8000530 <__aeabi_l2f>
 8013800:	ee07 0a90 	vmov	s15, r0
 8013804:	4b78      	ldr	r3, [pc, #480]	@ (80139e8 <forward_cast+0x27e4>)
 8013806:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801380a:	4a78      	ldr	r2, [pc, #480]	@ (80139ec <forward_cast+0x27e8>)
 801380c:	ee17 0a90 	vmov	r0, s15
 8013810:	e7dd      	b.n	80137ce <forward_cast+0x25ca>
 8013812:	4554      	cmp	r4, sl
 8013814:	f000 821f 	beq.w	8013c56 <forward_cast+0x2a52>
 8013818:	4978      	ldr	r1, [pc, #480]	@ (80139fc <forward_cast+0x27f8>)
 801381a:	428c      	cmp	r4, r1
 801381c:	d10a      	bne.n	8013834 <forward_cast+0x2630>
 801381e:	8828      	ldrh	r0, [r5, #0]
 8013820:	e7d5      	b.n	80137ce <forward_cast+0x25ca>
 8013822:	4977      	ldr	r1, [pc, #476]	@ (8013a00 <forward_cast+0x27fc>)
 8013824:	428c      	cmp	r4, r1
 8013826:	f000 8225 	beq.w	8013c74 <forward_cast+0x2a70>
 801382a:	429c      	cmp	r4, r3
 801382c:	d102      	bne.n	8013834 <forward_cast+0x2630>
 801382e:	f9b5 0000 	ldrsh.w	r0, [r5]
 8013832:	e7cc      	b.n	80137ce <forward_cast+0x25ca>
 8013834:	2000      	movs	r0, #0
 8013836:	e7ca      	b.n	80137ce <forward_cast+0x25ca>
 8013838:	455d      	cmp	r5, fp
 801383a:	f4bd ad4b 	bcs.w	80112d4 <forward_cast+0xd0>
 801383e:	9f01      	ldr	r7, [sp, #4]
 8013840:	4621      	mov	r1, r4
 8013842:	4628      	mov	r0, r5
 8013844:	f7fd fc6a 	bl	801111c <_array_handle_get_as_float>
 8013848:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 801384c:	ee17 3a90 	vmov	r3, s15
 8013850:	f303 0307 	ssat	r3, #8, r3
 8013854:	444d      	add	r5, r9
 8013856:	b25b      	sxtb	r3, r3
 8013858:	45ab      	cmp	fp, r5
 801385a:	6033      	str	r3, [r6, #0]
 801385c:	443e      	add	r6, r7
 801385e:	d8ef      	bhi.n	8013840 <forward_cast+0x263c>
 8013860:	f7fd bd38 	b.w	80112d4 <forward_cast+0xd0>
 8013864:	455d      	cmp	r5, fp
 8013866:	f4bd ad35 	bcs.w	80112d4 <forward_cast+0xd0>
 801386a:	f04f 0800 	mov.w	r8, #0
 801386e:	4b64      	ldr	r3, [pc, #400]	@ (8013a00 <forward_cast+0x27fc>)
 8013870:	4a5d      	ldr	r2, [pc, #372]	@ (80139e8 <forward_cast+0x27e4>)
 8013872:	e019      	b.n	80138a8 <forward_cast+0x26a4>
 8013874:	42bc      	cmp	r4, r7
 8013876:	f000 8236 	beq.w	8013ce6 <forward_cast+0x2ae2>
 801387a:	dd2f      	ble.n	80138dc <forward_cast+0x26d8>
 801387c:	495c      	ldr	r1, [pc, #368]	@ (80139f0 <forward_cast+0x27ec>)
 801387e:	428c      	cmp	r4, r1
 8013880:	f000 8206 	beq.w	8013c90 <forward_cast+0x2a8c>
 8013884:	f501 31f2 	add.w	r1, r1, #123904	@ 0x1e400
 8013888:	428c      	cmp	r4, r1
 801388a:	d137      	bne.n	80138fc <forward_cast+0x26f8>
 801388c:	7828      	ldrb	r0, [r5, #0]
 801388e:	3800      	subs	r0, #0
 8013890:	bf18      	it	ne
 8013892:	2001      	movne	r0, #1
 8013894:	f380 0010 	usat	r0, #16, r0
 8013898:	444d      	add	r5, r9
 801389a:	9901      	ldr	r1, [sp, #4]
 801389c:	f806 0008 	strb.w	r0, [r6, r8]
 80138a0:	45ab      	cmp	fp, r5
 80138a2:	4488      	add	r8, r1
 80138a4:	f67d ad16 	bls.w	80112d4 <forward_cast+0xd0>
 80138a8:	4952      	ldr	r1, [pc, #328]	@ (80139f4 <forward_cast+0x27f0>)
 80138aa:	428c      	cmp	r4, r1
 80138ac:	f000 8224 	beq.w	8013cf8 <forward_cast+0x2af4>
 80138b0:	dde0      	ble.n	8013874 <forward_cast+0x2670>
 80138b2:	4954      	ldr	r1, [pc, #336]	@ (8013a04 <forward_cast+0x2800>)
 80138b4:	428c      	cmp	r4, r1
 80138b6:	f000 81e0 	beq.w	8013c7a <forward_cast+0x2a76>
 80138ba:	dd17      	ble.n	80138ec <forward_cast+0x26e8>
 80138bc:	494e      	ldr	r1, [pc, #312]	@ (80139f8 <forward_cast+0x27f4>)
 80138be:	428c      	cmp	r4, r1
 80138c0:	d11c      	bne.n	80138fc <forward_cast+0x26f8>
 80138c2:	e9d5 0100 	ldrd	r0, r1, [r5]
 80138c6:	f7ec fe33 	bl	8000530 <__aeabi_l2f>
 80138ca:	ee07 0a90 	vmov	s15, r0
 80138ce:	4b4c      	ldr	r3, [pc, #304]	@ (8013a00 <forward_cast+0x27fc>)
 80138d0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80138d4:	4a44      	ldr	r2, [pc, #272]	@ (80139e8 <forward_cast+0x27e4>)
 80138d6:	ee17 0a90 	vmov	r0, s15
 80138da:	e7db      	b.n	8013894 <forward_cast+0x2690>
 80138dc:	4554      	cmp	r4, sl
 80138de:	f000 81d5 	beq.w	8013c8c <forward_cast+0x2a88>
 80138e2:	4946      	ldr	r1, [pc, #280]	@ (80139fc <forward_cast+0x27f8>)
 80138e4:	428c      	cmp	r4, r1
 80138e6:	d109      	bne.n	80138fc <forward_cast+0x26f8>
 80138e8:	8828      	ldrh	r0, [r5, #0]
 80138ea:	e7d3      	b.n	8013894 <forward_cast+0x2690>
 80138ec:	429c      	cmp	r4, r3
 80138ee:	f000 81dc 	beq.w	8013caa <forward_cast+0x2aa6>
 80138f2:	4294      	cmp	r4, r2
 80138f4:	d102      	bne.n	80138fc <forward_cast+0x26f8>
 80138f6:	f9b5 0000 	ldrsh.w	r0, [r5]
 80138fa:	e7cb      	b.n	8013894 <forward_cast+0x2690>
 80138fc:	2000      	movs	r0, #0
 80138fe:	e7c9      	b.n	8013894 <forward_cast+0x2690>
 8013900:	455d      	cmp	r5, fp
 8013902:	f4bd ace7 	bcs.w	80112d4 <forward_cast+0xd0>
 8013906:	f8df a0ec 	ldr.w	sl, [pc, #236]	@ 80139f4 <forward_cast+0x27f0>
 801390a:	f8df 80ec 	ldr.w	r8, [pc, #236]	@ 80139f8 <forward_cast+0x27f4>
 801390e:	4f3c      	ldr	r7, [pc, #240]	@ (8013a00 <forward_cast+0x27fc>)
 8013910:	4b36      	ldr	r3, [pc, #216]	@ (80139ec <forward_cast+0x27e8>)
 8013912:	4a37      	ldr	r2, [pc, #220]	@ (80139f0 <forward_cast+0x27ec>)
 8013914:	e017      	b.n	8013946 <forward_cast+0x2742>
 8013916:	429c      	cmp	r4, r3
 8013918:	f000 81fc 	beq.w	8013d14 <forward_cast+0x2b10>
 801391c:	dd2b      	ble.n	8013976 <forward_cast+0x2772>
 801391e:	4294      	cmp	r4, r2
 8013920:	f000 81d1 	beq.w	8013cc6 <forward_cast+0x2ac2>
 8013924:	4938      	ldr	r1, [pc, #224]	@ (8013a08 <forward_cast+0x2804>)
 8013926:	428c      	cmp	r4, r1
 8013928:	d139      	bne.n	801399e <forward_cast+0x279a>
 801392a:	7828      	ldrb	r0, [r5, #0]
 801392c:	3800      	subs	r0, #0
 801392e:	bf18      	it	ne
 8013930:	2001      	movne	r0, #1
 8013932:	f380 0010 	usat	r0, #16, r0
 8013936:	444d      	add	r5, r9
 8013938:	b280      	uxth	r0, r0
 801393a:	9901      	ldr	r1, [sp, #4]
 801393c:	45ab      	cmp	fp, r5
 801393e:	6030      	str	r0, [r6, #0]
 8013940:	440e      	add	r6, r1
 8013942:	f67d acc7 	bls.w	80112d4 <forward_cast+0xd0>
 8013946:	4554      	cmp	r4, sl
 8013948:	f000 81dd 	beq.w	8013d06 <forward_cast+0x2b02>
 801394c:	dde3      	ble.n	8013916 <forward_cast+0x2712>
 801394e:	492d      	ldr	r1, [pc, #180]	@ (8013a04 <forward_cast+0x2800>)
 8013950:	428c      	cmp	r4, r1
 8013952:	f000 81ad 	beq.w	8013cb0 <forward_cast+0x2aac>
 8013956:	dd18      	ble.n	801398a <forward_cast+0x2786>
 8013958:	4544      	cmp	r4, r8
 801395a:	d120      	bne.n	801399e <forward_cast+0x279a>
 801395c:	e9d5 0100 	ldrd	r0, r1, [r5]
 8013960:	f7ec fde6 	bl	8000530 <__aeabi_l2f>
 8013964:	ee07 0a90 	vmov	s15, r0
 8013968:	4b20      	ldr	r3, [pc, #128]	@ (80139ec <forward_cast+0x27e8>)
 801396a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801396e:	4a20      	ldr	r2, [pc, #128]	@ (80139f0 <forward_cast+0x27ec>)
 8013970:	ee17 0a90 	vmov	r0, s15
 8013974:	e7dd      	b.n	8013932 <forward_cast+0x272e>
 8013976:	491b      	ldr	r1, [pc, #108]	@ (80139e4 <forward_cast+0x27e0>)
 8013978:	428c      	cmp	r4, r1
 801397a:	f000 81a2 	beq.w	8013cc2 <forward_cast+0x2abe>
 801397e:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8013982:	428c      	cmp	r4, r1
 8013984:	d10b      	bne.n	801399e <forward_cast+0x279a>
 8013986:	8828      	ldrh	r0, [r5, #0]
 8013988:	e7d3      	b.n	8013932 <forward_cast+0x272e>
 801398a:	42bc      	cmp	r4, r7
 801398c:	f000 81a8 	beq.w	8013ce0 <forward_cast+0x2adc>
 8013990:	f5a1 6100 	sub.w	r1, r1, #2048	@ 0x800
 8013994:	428c      	cmp	r4, r1
 8013996:	d102      	bne.n	801399e <forward_cast+0x279a>
 8013998:	f9b5 0000 	ldrsh.w	r0, [r5]
 801399c:	e7c9      	b.n	8013932 <forward_cast+0x272e>
 801399e:	2000      	movs	r0, #0
 80139a0:	e7c7      	b.n	8013932 <forward_cast+0x272e>
 80139a2:	455d      	cmp	r5, fp
 80139a4:	f4bd ac96 	bcs.w	80112d4 <forward_cast+0xd0>
 80139a8:	9f01      	ldr	r7, [sp, #4]
 80139aa:	4621      	mov	r1, r4
 80139ac:	4628      	mov	r0, r5
 80139ae:	f7fd fbb5 	bl	801111c <_array_handle_get_as_float>
 80139b2:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 80139b6:	ee17 3a90 	vmov	r3, s15
 80139ba:	f383 0308 	usat	r3, #8, r3
 80139be:	444d      	add	r5, r9
 80139c0:	7033      	strb	r3, [r6, #0]
 80139c2:	443e      	add	r6, r7
 80139c4:	45ab      	cmp	fp, r5
 80139c6:	d8f0      	bhi.n	80139aa <forward_cast+0x27a6>
 80139c8:	f7fd bc84 	b.w	80112d4 <forward_cast+0xd0>
 80139cc:	455d      	cmp	r5, fp
 80139ce:	f4bd ac81 	bcs.w	80112d4 <forward_cast+0xd0>
 80139d2:	f8df a020 	ldr.w	sl, [pc, #32]	@ 80139f4 <forward_cast+0x27f0>
 80139d6:	f8df 8020 	ldr.w	r8, [pc, #32]	@ 80139f8 <forward_cast+0x27f4>
 80139da:	4f09      	ldr	r7, [pc, #36]	@ (8013a00 <forward_cast+0x27fc>)
 80139dc:	4b03      	ldr	r3, [pc, #12]	@ (80139ec <forward_cast+0x27e8>)
 80139de:	4a04      	ldr	r2, [pc, #16]	@ (80139f0 <forward_cast+0x27ec>)
 80139e0:	e02a      	b.n	8013a38 <forward_cast+0x2834>
 80139e2:	bf00      	nop
 80139e4:	00040440 	.word	0x00040440
 80139e8:	00840840 	.word	0x00840840
 80139ec:	00041040 	.word	0x00041040
 80139f0:	00042040 	.word	0x00042040
 80139f4:	00821040 	.word	0x00821040
 80139f8:	00842040 	.word	0x00842040
 80139fc:	00040840 	.word	0x00040840
 8013a00:	00840440 	.word	0x00840440
 8013a04:	00841040 	.word	0x00841040
 8013a08:	00060440 	.word	0x00060440
 8013a0c:	429c      	cmp	r4, r3
 8013a0e:	d05f      	beq.n	8013ad0 <forward_cast+0x28cc>
 8013a10:	dd28      	ble.n	8013a64 <forward_cast+0x2860>
 8013a12:	4294      	cmp	r4, r2
 8013a14:	d070      	beq.n	8013af8 <forward_cast+0x28f4>
 8013a16:	49c9      	ldr	r1, [pc, #804]	@ (8013d3c <forward_cast+0x2b38>)
 8013a18:	428c      	cmp	r4, r1
 8013a1a:	d135      	bne.n	8013a88 <forward_cast+0x2884>
 8013a1c:	7828      	ldrb	r0, [r5, #0]
 8013a1e:	3800      	subs	r0, #0
 8013a20:	bf18      	it	ne
 8013a22:	2001      	movne	r0, #1
 8013a24:	f380 0008 	usat	r0, #8, r0
 8013a28:	444d      	add	r5, r9
 8013a2a:	b2c0      	uxtb	r0, r0
 8013a2c:	9901      	ldr	r1, [sp, #4]
 8013a2e:	45ab      	cmp	fp, r5
 8013a30:	6030      	str	r0, [r6, #0]
 8013a32:	440e      	add	r6, r1
 8013a34:	f67d ac4e 	bls.w	80112d4 <forward_cast+0xd0>
 8013a38:	4554      	cmp	r4, sl
 8013a3a:	d042      	beq.n	8013ac2 <forward_cast+0x28be>
 8013a3c:	dde6      	ble.n	8013a0c <forward_cast+0x2808>
 8013a3e:	49c0      	ldr	r1, [pc, #768]	@ (8013d40 <forward_cast+0x2b3c>)
 8013a40:	428c      	cmp	r4, r1
 8013a42:	d04e      	beq.n	8013ae2 <forward_cast+0x28de>
 8013a44:	dd17      	ble.n	8013a76 <forward_cast+0x2872>
 8013a46:	4544      	cmp	r4, r8
 8013a48:	d11e      	bne.n	8013a88 <forward_cast+0x2884>
 8013a4a:	e9d5 0100 	ldrd	r0, r1, [r5]
 8013a4e:	f7ec fd6f 	bl	8000530 <__aeabi_l2f>
 8013a52:	ee07 0a90 	vmov	s15, r0
 8013a56:	4bbb      	ldr	r3, [pc, #748]	@ (8013d44 <forward_cast+0x2b40>)
 8013a58:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013a5c:	4aba      	ldr	r2, [pc, #744]	@ (8013d48 <forward_cast+0x2b44>)
 8013a5e:	ee17 0a90 	vmov	r0, s15
 8013a62:	e7df      	b.n	8013a24 <forward_cast+0x2820>
 8013a64:	49b9      	ldr	r1, [pc, #740]	@ (8013d4c <forward_cast+0x2b48>)
 8013a66:	428c      	cmp	r4, r1
 8013a68:	d044      	beq.n	8013af4 <forward_cast+0x28f0>
 8013a6a:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8013a6e:	428c      	cmp	r4, r1
 8013a70:	d10a      	bne.n	8013a88 <forward_cast+0x2884>
 8013a72:	8828      	ldrh	r0, [r5, #0]
 8013a74:	e7d6      	b.n	8013a24 <forward_cast+0x2820>
 8013a76:	42bc      	cmp	r4, r7
 8013a78:	d04b      	beq.n	8013b12 <forward_cast+0x290e>
 8013a7a:	f5a1 6100 	sub.w	r1, r1, #2048	@ 0x800
 8013a7e:	428c      	cmp	r4, r1
 8013a80:	d102      	bne.n	8013a88 <forward_cast+0x2884>
 8013a82:	f9b5 0000 	ldrsh.w	r0, [r5]
 8013a86:	e7cd      	b.n	8013a24 <forward_cast+0x2820>
 8013a88:	2000      	movs	r0, #0
 8013a8a:	e7cb      	b.n	8013a24 <forward_cast+0x2820>
 8013a8c:	455d      	cmp	r5, fp
 8013a8e:	f4bd ac21 	bcs.w	80112d4 <forward_cast+0xd0>
 8013a92:	9f01      	ldr	r7, [sp, #4]
 8013a94:	4621      	mov	r1, r4
 8013a96:	4628      	mov	r0, r5
 8013a98:	f7fd fb40 	bl	801111c <_array_handle_get_as_float>
 8013a9c:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8013aa0:	ee17 3a90 	vmov	r3, s15
 8013aa4:	f383 0308 	usat	r3, #8, r3
 8013aa8:	b2db      	uxtb	r3, r3
 8013aaa:	444d      	add	r5, r9
 8013aac:	ee07 3a90 	vmov	s15, r3
 8013ab0:	45ab      	cmp	fp, r5
 8013ab2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013ab6:	edc6 7a00 	vstr	s15, [r6]
 8013aba:	443e      	add	r6, r7
 8013abc:	d8ea      	bhi.n	8013a94 <forward_cast+0x2890>
 8013abe:	f7fd bc09 	b.w	80112d4 <forward_cast+0xd0>
 8013ac2:	edd5 7a00 	vldr	s15, [r5]
 8013ac6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013aca:	ee17 0a90 	vmov	r0, s15
 8013ace:	e7a9      	b.n	8013a24 <forward_cast+0x2820>
 8013ad0:	edd5 7a00 	vldr	s15, [r5]
 8013ad4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013ad8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013adc:	ee17 0a90 	vmov	r0, s15
 8013ae0:	e7a0      	b.n	8013a24 <forward_cast+0x2820>
 8013ae2:	edd5 7a00 	vldr	s15, [r5]
 8013ae6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013aea:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013aee:	ee17 0a90 	vmov	r0, s15
 8013af2:	e797      	b.n	8013a24 <forward_cast+0x2820>
 8013af4:	7828      	ldrb	r0, [r5, #0]
 8013af6:	e795      	b.n	8013a24 <forward_cast+0x2820>
 8013af8:	e9d5 0100 	ldrd	r0, r1, [r5]
 8013afc:	f7ec fd10 	bl	8000520 <__aeabi_ul2f>
 8013b00:	ee07 0a90 	vmov	s15, r0
 8013b04:	4a90      	ldr	r2, [pc, #576]	@ (8013d48 <forward_cast+0x2b44>)
 8013b06:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013b0a:	4b8e      	ldr	r3, [pc, #568]	@ (8013d44 <forward_cast+0x2b40>)
 8013b0c:	ee17 0a90 	vmov	r0, s15
 8013b10:	e788      	b.n	8013a24 <forward_cast+0x2820>
 8013b12:	f995 0000 	ldrsb.w	r0, [r5]
 8013b16:	e785      	b.n	8013a24 <forward_cast+0x2820>
 8013b18:	edd5 7a00 	vldr	s15, [r5]
 8013b1c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013b20:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013b24:	ee17 0a90 	vmov	r0, s15
 8013b28:	e5a2      	b.n	8013670 <forward_cast+0x246c>
 8013b2a:	edd5 7a00 	vldr	s15, [r5]
 8013b2e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013b32:	ee17 0a90 	vmov	r0, s15
 8013b36:	e59b      	b.n	8013670 <forward_cast+0x246c>
 8013b38:	edd5 7a00 	vldr	s15, [r5]
 8013b3c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013b40:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013b44:	ee17 0a90 	vmov	r0, s15
 8013b48:	f7fe ba90 	b.w	801206c <forward_cast+0xe68>
 8013b4c:	f995 0000 	ldrsb.w	r0, [r5]
 8013b50:	f7fd bf7f 	b.w	8011a52 <forward_cast+0x84e>
 8013b54:	edd5 7a00 	vldr	s15, [r5]
 8013b58:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013b5c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013b60:	ee17 0a90 	vmov	r0, s15
 8013b64:	e584      	b.n	8013670 <forward_cast+0x246c>
 8013b66:	7828      	ldrb	r0, [r5, #0]
 8013b68:	e582      	b.n	8013670 <forward_cast+0x246c>
 8013b6a:	e9d5 0100 	ldrd	r0, r1, [r5]
 8013b6e:	f7ec fcd7 	bl	8000520 <__aeabi_ul2f>
 8013b72:	ee07 0a90 	vmov	s15, r0
 8013b76:	4a73      	ldr	r2, [pc, #460]	@ (8013d44 <forward_cast+0x2b40>)
 8013b78:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013b7c:	4b74      	ldr	r3, [pc, #464]	@ (8013d50 <forward_cast+0x2b4c>)
 8013b7e:	ee17 0a90 	vmov	r0, s15
 8013b82:	e575      	b.n	8013670 <forward_cast+0x246c>
 8013b84:	f995 0000 	ldrsb.w	r0, [r5]
 8013b88:	e572      	b.n	8013670 <forward_cast+0x246c>
 8013b8a:	e9d5 0100 	ldrd	r0, r1, [r5]
 8013b8e:	9303      	str	r3, [sp, #12]
 8013b90:	f7ec fcc6 	bl	8000520 <__aeabi_ul2f>
 8013b94:	ee07 0a90 	vmov	s15, r0
 8013b98:	9b03      	ldr	r3, [sp, #12]
 8013b9a:	4a6d      	ldr	r2, [pc, #436]	@ (8013d50 <forward_cast+0x2b4c>)
 8013b9c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013ba0:	edcd 7a02 	vstr	s15, [sp, #8]
 8013ba4:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8013ba8:	e4c9      	b.n	801353e <forward_cast+0x233a>
 8013baa:	edd5 7a00 	vldr	s15, [r5]
 8013bae:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013bb2:	edcd 7a02 	vstr	s15, [sp, #8]
 8013bb6:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8013bba:	e4c0      	b.n	801353e <forward_cast+0x233a>
 8013bbc:	edd5 7a00 	vldr	s15, [r5]
 8013bc0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013bc4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013bc8:	ee17 0a90 	vmov	r0, s15
 8013bcc:	f7fe baef 	b.w	80121ae <forward_cast+0xfaa>
 8013bd0:	f995 0000 	ldrsb.w	r0, [r5]
 8013bd4:	f7fe b810 	b.w	8011bf8 <forward_cast+0x9f4>
 8013bd8:	edd5 7a00 	vldr	s15, [r5]
 8013bdc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013be0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013be4:	ee17 0a90 	vmov	r0, s15
 8013be8:	e4f0      	b.n	80135cc <forward_cast+0x23c8>
 8013bea:	7828      	ldrb	r0, [r5, #0]
 8013bec:	e4ee      	b.n	80135cc <forward_cast+0x23c8>
 8013bee:	e9d5 0100 	ldrd	r0, r1, [r5]
 8013bf2:	f7ec fc95 	bl	8000520 <__aeabi_ul2f>
 8013bf6:	ee07 0a90 	vmov	s15, r0
 8013bfa:	4a50      	ldr	r2, [pc, #320]	@ (8013d3c <forward_cast+0x2b38>)
 8013bfc:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013c00:	4b51      	ldr	r3, [pc, #324]	@ (8013d48 <forward_cast+0x2b44>)
 8013c02:	ee17 0a90 	vmov	r0, s15
 8013c06:	e4e1      	b.n	80135cc <forward_cast+0x23c8>
 8013c08:	f995 0000 	ldrsb.w	r0, [r5]
 8013c0c:	e4de      	b.n	80135cc <forward_cast+0x23c8>
 8013c0e:	edd5 7a00 	vldr	s15, [r5]
 8013c12:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013c16:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013c1a:	ee17 0a90 	vmov	r0, s15
 8013c1e:	e571      	b.n	8013704 <forward_cast+0x2500>
 8013c20:	7828      	ldrb	r0, [r5, #0]
 8013c22:	e56f      	b.n	8013704 <forward_cast+0x2500>
 8013c24:	e9d5 0100 	ldrd	r0, r1, [r5]
 8013c28:	f7ec fc7a 	bl	8000520 <__aeabi_ul2f>
 8013c2c:	ee07 0a90 	vmov	s15, r0
 8013c30:	4a42      	ldr	r2, [pc, #264]	@ (8013d3c <forward_cast+0x2b38>)
 8013c32:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013c36:	4b44      	ldr	r3, [pc, #272]	@ (8013d48 <forward_cast+0x2b44>)
 8013c38:	ee17 0a90 	vmov	r0, s15
 8013c3c:	e562      	b.n	8013704 <forward_cast+0x2500>
 8013c3e:	f995 0000 	ldrsb.w	r0, [r5]
 8013c42:	e55f      	b.n	8013704 <forward_cast+0x2500>
 8013c44:	edd5 7a00 	vldr	s15, [r5]
 8013c48:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013c4c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013c50:	ee17 0a90 	vmov	r0, s15
 8013c54:	e5bb      	b.n	80137ce <forward_cast+0x25ca>
 8013c56:	7828      	ldrb	r0, [r5, #0]
 8013c58:	e5b9      	b.n	80137ce <forward_cast+0x25ca>
 8013c5a:	e9d5 0100 	ldrd	r0, r1, [r5]
 8013c5e:	f7ec fc5f 	bl	8000520 <__aeabi_ul2f>
 8013c62:	ee07 0a90 	vmov	s15, r0
 8013c66:	4a37      	ldr	r2, [pc, #220]	@ (8013d44 <forward_cast+0x2b40>)
 8013c68:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013c6c:	4b38      	ldr	r3, [pc, #224]	@ (8013d50 <forward_cast+0x2b4c>)
 8013c6e:	ee17 0a90 	vmov	r0, s15
 8013c72:	e5ac      	b.n	80137ce <forward_cast+0x25ca>
 8013c74:	f995 0000 	ldrsb.w	r0, [r5]
 8013c78:	e5a9      	b.n	80137ce <forward_cast+0x25ca>
 8013c7a:	edd5 7a00 	vldr	s15, [r5]
 8013c7e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013c82:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013c86:	ee17 0a90 	vmov	r0, s15
 8013c8a:	e603      	b.n	8013894 <forward_cast+0x2690>
 8013c8c:	7828      	ldrb	r0, [r5, #0]
 8013c8e:	e601      	b.n	8013894 <forward_cast+0x2690>
 8013c90:	e9d5 0100 	ldrd	r0, r1, [r5]
 8013c94:	f7ec fc44 	bl	8000520 <__aeabi_ul2f>
 8013c98:	ee07 0a90 	vmov	s15, r0
 8013c9c:	4a2c      	ldr	r2, [pc, #176]	@ (8013d50 <forward_cast+0x2b4c>)
 8013c9e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013ca2:	4b2c      	ldr	r3, [pc, #176]	@ (8013d54 <forward_cast+0x2b50>)
 8013ca4:	ee17 0a90 	vmov	r0, s15
 8013ca8:	e5f4      	b.n	8013894 <forward_cast+0x2690>
 8013caa:	f995 0000 	ldrsb.w	r0, [r5]
 8013cae:	e5f1      	b.n	8013894 <forward_cast+0x2690>
 8013cb0:	edd5 7a00 	vldr	s15, [r5]
 8013cb4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013cb8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013cbc:	ee17 0a90 	vmov	r0, s15
 8013cc0:	e637      	b.n	8013932 <forward_cast+0x272e>
 8013cc2:	7828      	ldrb	r0, [r5, #0]
 8013cc4:	e635      	b.n	8013932 <forward_cast+0x272e>
 8013cc6:	e9d5 0100 	ldrd	r0, r1, [r5]
 8013cca:	f7ec fc29 	bl	8000520 <__aeabi_ul2f>
 8013cce:	ee07 0a90 	vmov	s15, r0
 8013cd2:	4a1d      	ldr	r2, [pc, #116]	@ (8013d48 <forward_cast+0x2b44>)
 8013cd4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013cd8:	4b1a      	ldr	r3, [pc, #104]	@ (8013d44 <forward_cast+0x2b40>)
 8013cda:	ee17 0a90 	vmov	r0, s15
 8013cde:	e628      	b.n	8013932 <forward_cast+0x272e>
 8013ce0:	f995 0000 	ldrsb.w	r0, [r5]
 8013ce4:	e625      	b.n	8013932 <forward_cast+0x272e>
 8013ce6:	edd5 7a00 	vldr	s15, [r5]
 8013cea:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013cee:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013cf2:	ee17 0a90 	vmov	r0, s15
 8013cf6:	e5cd      	b.n	8013894 <forward_cast+0x2690>
 8013cf8:	edd5 7a00 	vldr	s15, [r5]
 8013cfc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013d00:	ee17 0a90 	vmov	r0, s15
 8013d04:	e5c6      	b.n	8013894 <forward_cast+0x2690>
 8013d06:	edd5 7a00 	vldr	s15, [r5]
 8013d0a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013d0e:	ee17 0a90 	vmov	r0, s15
 8013d12:	e60e      	b.n	8013932 <forward_cast+0x272e>
 8013d14:	edd5 7a00 	vldr	s15, [r5]
 8013d18:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013d1c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013d20:	ee17 0a90 	vmov	r0, s15
 8013d24:	e605      	b.n	8013932 <forward_cast+0x272e>
 8013d26:	edd5 7a00 	vldr	s15, [r5]
 8013d2a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013d2e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013d32:	ee17 1a90 	vmov	r1, s15
 8013d36:	b289      	uxth	r1, r1
 8013d38:	f7fd bd17 	b.w	801176a <forward_cast+0x566>
 8013d3c:	00060440 	.word	0x00060440
 8013d40:	00841040 	.word	0x00841040
 8013d44:	00041040 	.word	0x00041040
 8013d48:	00042040 	.word	0x00042040
 8013d4c:	00040440 	.word	0x00040440
 8013d50:	00840840 	.word	0x00840840
 8013d54:	00840440 	.word	0x00840440
 8013d58:	7829      	ldrb	r1, [r5, #0]
 8013d5a:	f7fd bd06 	b.w	801176a <forward_cast+0x566>
 8013d5e:	edd5 7a00 	vldr	s15, [r5]
 8013d62:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013d66:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013d6a:	ee17 1a90 	vmov	r1, s15
 8013d6e:	b289      	uxth	r1, r1
 8013d70:	f7fd bcab 	b.w	80116ca <forward_cast+0x4c6>
 8013d74:	f995 0000 	ldrsb.w	r0, [r5]
 8013d78:	f7fe ba19 	b.w	80121ae <forward_cast+0xfaa>
 8013d7c:	edd5 7a00 	vldr	s15, [r5]
 8013d80:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013d84:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013d88:	ee17 0a90 	vmov	r0, s15
 8013d8c:	e51f      	b.n	80137ce <forward_cast+0x25ca>
 8013d8e:	edd5 7a00 	vldr	s15, [r5]
 8013d92:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013d96:	ee17 0a90 	vmov	r0, s15
 8013d9a:	e518      	b.n	80137ce <forward_cast+0x25ca>
 8013d9c:	edd5 7a00 	vldr	s15, [r5]
 8013da0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013da4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013da8:	ee17 0a90 	vmov	r0, s15
 8013dac:	f7fd bc3d 	b.w	801162a <forward_cast+0x426>
 8013db0:	f995 0000 	ldrsb.w	r0, [r5]
 8013db4:	f7fe b95a 	b.w	801206c <forward_cast+0xe68>
 8013db8:	edd5 7a00 	vldr	s15, [r5]
 8013dbc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013dc0:	ee17 0a90 	vmov	r0, s15
 8013dc4:	e49e      	b.n	8013704 <forward_cast+0x2500>
 8013dc6:	edd5 7a00 	vldr	s15, [r5]
 8013dca:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013dce:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013dd2:	ee17 0a90 	vmov	r0, s15
 8013dd6:	e495      	b.n	8013704 <forward_cast+0x2500>
 8013dd8:	edd5 7a00 	vldr	s15, [r5]
 8013ddc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013de0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013de4:	ee17 0a90 	vmov	r0, s15
 8013de8:	f7fd bb5a 	b.w	80114a0 <forward_cast+0x29c>
 8013dec:	7828      	ldrb	r0, [r5, #0]
 8013dee:	f7fe ba7e 	b.w	80122ee <forward_cast+0x10ea>
 8013df2:	e9d5 0100 	ldrd	r0, r1, [r5]
 8013df6:	9303      	str	r3, [sp, #12]
 8013df8:	f7ec fb92 	bl	8000520 <__aeabi_ul2f>
 8013dfc:	ee07 0a90 	vmov	s15, r0
 8013e00:	9b03      	ldr	r3, [sp, #12]
 8013e02:	4af4      	ldr	r2, [pc, #976]	@ (80141d4 <forward_cast+0x2fd0>)
 8013e04:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013e08:	edcd 7a02 	vstr	s15, [sp, #8]
 8013e0c:	f99d 1008 	ldrsb.w	r1, [sp, #8]
 8013e10:	f7fe b971 	b.w	80120f6 <forward_cast+0xef2>
 8013e14:	edd5 7a00 	vldr	s15, [r5]
 8013e18:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013e1c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013e20:	ee17 0a90 	vmov	r0, s15
 8013e24:	f7fd bd4a 	b.w	80118bc <forward_cast+0x6b8>
 8013e28:	edd5 7a00 	vldr	s15, [r5]
 8013e2c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013e30:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013e34:	ee17 0a90 	vmov	r0, s15
 8013e38:	f7fd bd02 	b.w	8011840 <forward_cast+0x63c>
 8013e3c:	f995 0000 	ldrsb.w	r0, [r5]
 8013e40:	f7fd bd3c 	b.w	80118bc <forward_cast+0x6b8>
 8013e44:	edd5 7a00 	vldr	s15, [r5]
 8013e48:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013e4c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013e50:	ee17 0a90 	vmov	r0, s15
 8013e54:	f7fd bdfd 	b.w	8011a52 <forward_cast+0x84e>
 8013e58:	7829      	ldrb	r1, [r5, #0]
 8013e5a:	ee07 1a90 	vmov	s15, r1
 8013e5e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013e62:	f7fe bad6 	b.w	8012412 <forward_cast+0x120e>
 8013e66:	edd5 7a00 	vldr	s15, [r5]
 8013e6a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013e6e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013e72:	ee17 0a90 	vmov	r0, s15
 8013e76:	f7fd bdaa 	b.w	80119ce <forward_cast+0x7ca>
 8013e7a:	f995 1000 	ldrsb.w	r1, [r5]
 8013e7e:	3900      	subs	r1, #0
 8013e80:	bf18      	it	ne
 8013e82:	2101      	movne	r1, #1
 8013e84:	f7fe b89c 	b.w	8011fc0 <forward_cast+0xdbc>
 8013e88:	edd5 7a00 	vldr	s15, [r5]
 8013e8c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013e90:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013e94:	ee17 0a90 	vmov	r0, s15
 8013e98:	f7fd bf8e 	b.w	8011db8 <forward_cast+0xbb4>
 8013e9c:	7828      	ldrb	r0, [r5, #0]
 8013e9e:	f7fd bdd8 	b.w	8011a52 <forward_cast+0x84e>
 8013ea2:	edd5 7a00 	vldr	s15, [r5]
 8013ea6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013eaa:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013eae:	edcd 7a02 	vstr	s15, [sp, #8]
 8013eb2:	f99d 1008 	ldrsb.w	r1, [sp, #8]
 8013eb6:	f7fd bee4 	b.w	8011c82 <forward_cast+0xa7e>
 8013eba:	f995 1000 	ldrsb.w	r1, [r5]
 8013ebe:	ee07 1a90 	vmov	s15, r1
 8013ec2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013ec6:	f7fe baa4 	b.w	8012412 <forward_cast+0x120e>
 8013eca:	edd5 7a00 	vldr	s15, [r5]
 8013ece:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013ed2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013ed6:	ee17 0a90 	vmov	r0, s15
 8013eda:	f7fd be8d 	b.w	8011bf8 <forward_cast+0x9f4>
 8013ede:	f995 0000 	ldrsb.w	r0, [r5]
 8013ee2:	f7fd ba30 	b.w	8011346 <forward_cast+0x142>
 8013ee6:	edd5 7a00 	vldr	s15, [r5]
 8013eea:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013eee:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013ef2:	ee17 0a90 	vmov	r0, s15
 8013ef6:	f7fd be41 	b.w	8011b7c <forward_cast+0x978>
 8013efa:	f995 0000 	ldrsb.w	r0, [r5]
 8013efe:	f7fe b99b 	b.w	8012238 <forward_cast+0x1034>
 8013f02:	edd5 7a00 	vldr	s15, [r5]
 8013f06:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013f0a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013f0e:	edcd 7a02 	vstr	s15, [sp, #8]
 8013f12:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8013f16:	f7ff bb12 	b.w	801353e <forward_cast+0x233a>
 8013f1a:	edd5 7a00 	vldr	s15, [r5]
 8013f1e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013f22:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013f26:	edcd 7a02 	vstr	s15, [sp, #8]
 8013f2a:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8013f2e:	f7ff bb06 	b.w	801353e <forward_cast+0x233a>
 8013f32:	edd5 7a00 	vldr	s15, [r5]
 8013f36:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013f3a:	ee17 0a90 	vmov	r0, s15
 8013f3e:	f7ff bb45 	b.w	80135cc <forward_cast+0x23c8>
 8013f42:	edd5 7a00 	vldr	s15, [r5]
 8013f46:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013f4a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8013f4e:	ee17 0a90 	vmov	r0, s15
 8013f52:	f7ff bb3b 	b.w	80135cc <forward_cast+0x23c8>
 8013f56:	edd5 7a00 	vldr	s15, [r5]
 8013f5a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013f5e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013f62:	ee17 0a90 	vmov	r0, s15
 8013f66:	f7fe ba10 	b.w	801238a <forward_cast+0x1186>
 8013f6a:	7828      	ldrb	r0, [r5, #0]
 8013f6c:	f7fe ba0d 	b.w	801238a <forward_cast+0x1186>
 8013f70:	edd5 7a00 	vldr	s15, [r5]
 8013f74:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013f78:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013f7c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013f80:	f7fe ba47 	b.w	8012412 <forward_cast+0x120e>
 8013f84:	f995 0000 	ldrsb.w	r0, [r5]
 8013f88:	f7fd bc5a 	b.w	8011840 <forward_cast+0x63c>
 8013f8c:	edd5 7a00 	vldr	s15, [r5]
 8013f90:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013f94:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013f98:	edcd 7a02 	vstr	s15, [sp, #8]
 8013f9c:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8013fa0:	f7ff ba23 	b.w	80133ea <forward_cast+0x21e6>
 8013fa4:	edd5 7a00 	vldr	s15, [r5]
 8013fa8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8013fac:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013fb0:	edcd 7a02 	vstr	s15, [sp, #8]
 8013fb4:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8013fb8:	f7ff ba17 	b.w	80133ea <forward_cast+0x21e6>
 8013fbc:	edd5 7a00 	vldr	s15, [r5]
 8013fc0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013fc4:	ee17 0a90 	vmov	r0, s15
 8013fc8:	f7ff ba67 	b.w	801349a <forward_cast+0x2296>
 8013fcc:	edd5 7a00 	vldr	s15, [r5]
 8013fd0:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8013fd4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013fd8:	ee17 0a90 	vmov	r0, s15
 8013fdc:	f7ff ba5d 	b.w	801349a <forward_cast+0x2296>
 8013fe0:	edd5 7a00 	vldr	s15, [r5]
 8013fe4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013fe8:	ee17 0a90 	vmov	r0, s15
 8013fec:	f7ff b961 	b.w	80132b2 <forward_cast+0x20ae>
 8013ff0:	edd5 7a00 	vldr	s15, [r5]
 8013ff4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8013ff8:	ee17 0a90 	vmov	r0, s15
 8013ffc:	f7fd bb15 	b.w	801162a <forward_cast+0x426>
 8014000:	edd5 7a00 	vldr	s15, [r5]
 8014004:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014008:	ee17 0a90 	vmov	r0, s15
 801400c:	f7ff b99a 	b.w	8013344 <forward_cast+0x2140>
 8014010:	edd5 7a00 	vldr	s15, [r5]
 8014014:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014018:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801401c:	ee17 0a90 	vmov	r0, s15
 8014020:	f7ff b990 	b.w	8013344 <forward_cast+0x2140>
 8014024:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014028:	f7ec fa7a 	bl	8000520 <__aeabi_ul2f>
 801402c:	ee07 0a90 	vmov	s15, r0
 8014030:	4a69      	ldr	r2, [pc, #420]	@ (80141d8 <forward_cast+0x2fd4>)
 8014032:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014036:	4b69      	ldr	r3, [pc, #420]	@ (80141dc <forward_cast+0x2fd8>)
 8014038:	edcd 7a02 	vstr	s15, [sp, #8]
 801403c:	f99d 1008 	ldrsb.w	r1, [sp, #8]
 8014040:	f7fd be1f 	b.w	8011c82 <forward_cast+0xa7e>
 8014044:	edd5 7a00 	vldr	s15, [r5]
 8014048:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801404c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014050:	ee17 0a90 	vmov	r0, s15
 8014054:	f7fd bf50 	b.w	8011ef8 <forward_cast+0xcf4>
 8014058:	edd5 7a00 	vldr	s15, [r5]
 801405c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014060:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014064:	ee17 1a90 	vmov	r1, s15
 8014068:	b289      	uxth	r1, r1
 801406a:	f7fd b9c3 	b.w	80113f4 <forward_cast+0x1f0>
 801406e:	f995 0000 	ldrsb.w	r0, [r5]
 8014072:	f7fe ba08 	b.w	8012486 <forward_cast+0x1282>
 8014076:	edd5 7a00 	vldr	s15, [r5]
 801407a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801407e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014082:	ee17 0a90 	vmov	r0, s15
 8014086:	f7fd b95e 	b.w	8011346 <forward_cast+0x142>
 801408a:	f995 0000 	ldrsb.w	r0, [r5]
 801408e:	f7fd bacc 	b.w	801162a <forward_cast+0x426>
 8014092:	edd5 7a00 	vldr	s15, [r5]
 8014096:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801409a:	eef5 7a40 	vcmp.f32	s15, #0.0
 801409e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80140a2:	bf14      	ite	ne
 80140a4:	2101      	movne	r1, #1
 80140a6:	2100      	moveq	r1, #0
 80140a8:	f7fd bf8a 	b.w	8011fc0 <forward_cast+0xdbc>
 80140ac:	f995 0000 	ldrsb.w	r0, [r5]
 80140b0:	f7fd bf22 	b.w	8011ef8 <forward_cast+0xcf4>
 80140b4:	f995 1000 	ldrsb.w	r1, [r5]
 80140b8:	b289      	uxth	r1, r1
 80140ba:	f7fd bb06 	b.w	80116ca <forward_cast+0x4c6>
 80140be:	edd5 7a00 	vldr	s15, [r5]
 80140c2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80140c6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80140ca:	ee17 0a90 	vmov	r0, s15
 80140ce:	f7fd ba4f 	b.w	8011570 <forward_cast+0x36c>
 80140d2:	edd5 7a00 	vldr	s15, [r5]
 80140d6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80140da:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80140de:	edcd 7a02 	vstr	s15, [sp, #8]
 80140e2:	f99d 1008 	ldrsb.w	r1, [sp, #8]
 80140e6:	f7fe b806 	b.w	80120f6 <forward_cast+0xef2>
 80140ea:	f995 0000 	ldrsb.w	r0, [r5]
 80140ee:	f7fd ba3f 	b.w	8011570 <forward_cast+0x36c>
 80140f2:	edd5 7a00 	vldr	s15, [r5]
 80140f6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80140fa:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80140fe:	edcd 7a02 	vstr	s15, [sp, #8]
 8014102:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8014106:	f7fd bcf9 	b.w	8011afc <forward_cast+0x8f8>
 801410a:	7828      	ldrb	r0, [r5, #0]
 801410c:	f7fd b9c8 	b.w	80114a0 <forward_cast+0x29c>
 8014110:	edd5 7a00 	vldr	s15, [r5]
 8014114:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014118:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801411c:	ee17 0a90 	vmov	r0, s15
 8014120:	f7fe b88a 	b.w	8012238 <forward_cast+0x1034>
 8014124:	f995 0000 	ldrsb.w	r0, [r5]
 8014128:	f7fd bc51 	b.w	80119ce <forward_cast+0x7ca>
 801412c:	edd5 7a00 	vldr	s15, [r5]
 8014130:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014134:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014138:	ee17 0a90 	vmov	r0, s15
 801413c:	f7ff b8b9 	b.w	80132b2 <forward_cast+0x20ae>
 8014140:	edd5 7a00 	vldr	s15, [r5]
 8014144:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014148:	ee17 0a90 	vmov	r0, s15
 801414c:	f7fd b8fb 	b.w	8011346 <forward_cast+0x142>
 8014150:	edd5 7a00 	vldr	s15, [r5]
 8014154:	eef5 7a40 	vcmp.f32	s15, #0.0
 8014158:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801415c:	bf14      	ite	ne
 801415e:	2101      	movne	r1, #1
 8014160:	2100      	moveq	r1, #0
 8014162:	f7ff b856 	b.w	8013212 <forward_cast+0x200e>
 8014166:	edd5 7a00 	vldr	s15, [r5]
 801416a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801416e:	ee17 1a90 	vmov	r1, s15
 8014172:	b289      	uxth	r1, r1
 8014174:	f7fd baa9 	b.w	80116ca <forward_cast+0x4c6>
 8014178:	edd5 7a00 	vldr	s15, [r5]
 801417c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014180:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014184:	ee17 0a90 	vmov	r0, s15
 8014188:	f7fd be76 	b.w	8011e78 <forward_cast+0xc74>
 801418c:	edd5 7a00 	vldr	s15, [r5]
 8014190:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014194:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014198:	ee17 0a90 	vmov	r0, s15
 801419c:	f7fd bb50 	b.w	8011840 <forward_cast+0x63c>
 80141a0:	edd5 7a00 	vldr	s15, [r5]
 80141a4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80141a8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80141ac:	ee17 0a90 	vmov	r0, s15
 80141b0:	f7fe b842 	b.w	8012238 <forward_cast+0x1034>
 80141b4:	f995 0000 	ldrsb.w	r0, [r5]
 80141b8:	f7fd be5e 	b.w	8011e78 <forward_cast+0xc74>
 80141bc:	edd5 7a00 	vldr	s15, [r5]
 80141c0:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80141c4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80141c8:	edcd 7a02 	vstr	s15, [sp, #8]
 80141cc:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80141d0:	f7fd bbb9 	b.w	8011946 <forward_cast+0x742>
 80141d4:	00841040 	.word	0x00841040
 80141d8:	00041040 	.word	0x00041040
 80141dc:	00840840 	.word	0x00840840
 80141e0:	7828      	ldrb	r0, [r5, #0]
 80141e2:	f7fd b8b0 	b.w	8011346 <forward_cast+0x142>
 80141e6:	edd5 7a00 	vldr	s15, [r5]
 80141ea:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80141ee:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80141f2:	ee17 0a90 	vmov	r0, s15
 80141f6:	f7fd bb61 	b.w	80118bc <forward_cast+0x6b8>
 80141fa:	7828      	ldrb	r0, [r5, #0]
 80141fc:	f7fd b9b8 	b.w	8011570 <forward_cast+0x36c>
 8014200:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014204:	f7ec f98c 	bl	8000520 <__aeabi_ul2f>
 8014208:	ee07 0a90 	vmov	s15, r0
 801420c:	4ae7      	ldr	r2, [pc, #924]	@ (80145ac <forward_cast+0x33a8>)
 801420e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014212:	4be7      	ldr	r3, [pc, #924]	@ (80145b0 <forward_cast+0x33ac>)
 8014214:	ee17 0a90 	vmov	r0, s15
 8014218:	f7fd bcee 	b.w	8011bf8 <forward_cast+0x9f4>
 801421c:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014220:	f7ec f97e 	bl	8000520 <__aeabi_ul2f>
 8014224:	ee07 0a90 	vmov	s15, r0
 8014228:	4ae2      	ldr	r2, [pc, #904]	@ (80145b4 <forward_cast+0x33b0>)
 801422a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801422e:	4be2      	ldr	r3, [pc, #904]	@ (80145b8 <forward_cast+0x33b4>)
 8014230:	ee17 0a90 	vmov	r0, s15
 8014234:	f7fd be60 	b.w	8011ef8 <forward_cast+0xcf4>
 8014238:	e9d5 0100 	ldrd	r0, r1, [r5]
 801423c:	f7ec f970 	bl	8000520 <__aeabi_ul2f>
 8014240:	ee07 0a90 	vmov	s15, r0
 8014244:	4add      	ldr	r2, [pc, #884]	@ (80145bc <forward_cast+0x33b8>)
 8014246:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801424a:	4bda      	ldr	r3, [pc, #872]	@ (80145b4 <forward_cast+0x33b0>)
 801424c:	edcd 7a02 	vstr	s15, [sp, #8]
 8014250:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8014254:	f7fd bb77 	b.w	8011946 <forward_cast+0x742>
 8014258:	edd5 7a00 	vldr	s15, [r5]
 801425c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014260:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014264:	ee17 0a90 	vmov	r0, s15
 8014268:	f7fd be46 	b.w	8011ef8 <forward_cast+0xcf4>
 801426c:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014270:	f7ec f956 	bl	8000520 <__aeabi_ul2f>
 8014274:	ee07 0a90 	vmov	s15, r0
 8014278:	4ace      	ldr	r2, [pc, #824]	@ (80145b4 <forward_cast+0x33b0>)
 801427a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801427e:	4bce      	ldr	r3, [pc, #824]	@ (80145b8 <forward_cast+0x33b4>)
 8014280:	ee17 0a90 	vmov	r0, s15
 8014284:	f7fd b85f 	b.w	8011346 <forward_cast+0x142>
 8014288:	e9d5 0100 	ldrd	r0, r1, [r5]
 801428c:	f7ec f948 	bl	8000520 <__aeabi_ul2f>
 8014290:	ee07 0a90 	vmov	s15, r0
 8014294:	4aca      	ldr	r2, [pc, #808]	@ (80145c0 <forward_cast+0x33bc>)
 8014296:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801429a:	4bc6      	ldr	r3, [pc, #792]	@ (80145b4 <forward_cast+0x33b0>)
 801429c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80142a0:	f7fe b8b7 	b.w	8012412 <forward_cast+0x120e>
 80142a4:	edd5 7a00 	vldr	s15, [r5]
 80142a8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80142ac:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80142b0:	edcd 7a02 	vstr	s15, [sp, #8]
 80142b4:	f99d 1008 	ldrsb.w	r1, [sp, #8]
 80142b8:	f7fd bf1d 	b.w	80120f6 <forward_cast+0xef2>
 80142bc:	7828      	ldrb	r0, [r5, #0]
 80142be:	f7fd babf 	b.w	8011840 <forward_cast+0x63c>
 80142c2:	edd5 7a00 	vldr	s15, [r5]
 80142c6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80142ca:	edcd 7a02 	vstr	s15, [sp, #8]
 80142ce:	f99d 1008 	ldrsb.w	r1, [sp, #8]
 80142d2:	f7fd bcd6 	b.w	8011c82 <forward_cast+0xa7e>
 80142d6:	edd5 7a00 	vldr	s15, [r5]
 80142da:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80142de:	edcd 7a02 	vstr	s15, [sp, #8]
 80142e2:	f99d 1008 	ldrsb.w	r1, [sp, #8]
 80142e6:	f7fd bd11 	b.w	8011d0c <forward_cast+0xb08>
 80142ea:	edd5 7a00 	vldr	s15, [r5]
 80142ee:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80142f2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80142f6:	edcd 7a02 	vstr	s15, [sp, #8]
 80142fa:	f99d 1008 	ldrsb.w	r1, [sp, #8]
 80142fe:	f7fd bd05 	b.w	8011d0c <forward_cast+0xb08>
 8014302:	7828      	ldrb	r0, [r5, #0]
 8014304:	f7fd bb63 	b.w	80119ce <forward_cast+0x7ca>
 8014308:	edd5 7a00 	vldr	s15, [r5]
 801430c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014310:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014314:	ee17 0a90 	vmov	r0, s15
 8014318:	f7fd bf49 	b.w	80121ae <forward_cast+0xfaa>
 801431c:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014320:	f7ec f8fe 	bl	8000520 <__aeabi_ul2f>
 8014324:	ee07 0a90 	vmov	s15, r0
 8014328:	4aa4      	ldr	r2, [pc, #656]	@ (80145bc <forward_cast+0x33b8>)
 801432a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801432e:	4ba1      	ldr	r3, [pc, #644]	@ (80145b4 <forward_cast+0x33b0>)
 8014330:	edcd 7a02 	vstr	s15, [sp, #8]
 8014334:	f99d 1008 	ldrsb.w	r1, [sp, #8]
 8014338:	f7fd bce8 	b.w	8011d0c <forward_cast+0xb08>
 801433c:	edd5 7a00 	vldr	s15, [r5]
 8014340:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014344:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014348:	edcd 7a02 	vstr	s15, [sp, #8]
 801434c:	f99d 1008 	ldrsb.w	r1, [sp, #8]
 8014350:	f7fd bcdc 	b.w	8011d0c <forward_cast+0xb08>
 8014354:	7829      	ldrb	r1, [r5, #0]
 8014356:	f7fd b9b8 	b.w	80116ca <forward_cast+0x4c6>
 801435a:	edd5 7a00 	vldr	s15, [r5]
 801435e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014362:	ee17 0a90 	vmov	r0, s15
 8014366:	f7fd bdc7 	b.w	8011ef8 <forward_cast+0xcf4>
 801436a:	edd5 7a00 	vldr	s15, [r5]
 801436e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014372:	ee17 0a90 	vmov	r0, s15
 8014376:	f7fd baa1 	b.w	80118bc <forward_cast+0x6b8>
 801437a:	edd5 7a00 	vldr	s15, [r5]
 801437e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014382:	edcd 7a02 	vstr	s15, [sp, #8]
 8014386:	f89d 1008 	ldrb.w	r1, [sp, #8]
 801438a:	f7fd badc 	b.w	8011946 <forward_cast+0x742>
 801438e:	edd5 7a00 	vldr	s15, [r5]
 8014392:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014396:	ee17 0a90 	vmov	r0, s15
 801439a:	f7fd b8e9 	b.w	8011570 <forward_cast+0x36c>
 801439e:	edd5 7a00 	vldr	s15, [r5]
 80143a2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80143a6:	ee17 0a90 	vmov	r0, s15
 80143aa:	f7fe beca 	b.w	8013142 <forward_cast+0x1f3e>
 80143ae:	edd5 7a00 	vldr	s15, [r5]
 80143b2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80143b6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80143ba:	ee17 0a90 	vmov	r0, s15
 80143be:	f7fe bec0 	b.w	8013142 <forward_cast+0x1f3e>
 80143c2:	edd5 7a00 	vldr	s15, [r5]
 80143c6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80143ca:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80143ce:	ee17 0a90 	vmov	r0, s15
 80143d2:	f7fd bc11 	b.w	8011bf8 <forward_cast+0x9f4>
 80143d6:	edd5 7a00 	vldr	s15, [r5]
 80143da:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80143de:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80143e2:	edcd 7a02 	vstr	s15, [sp, #8]
 80143e6:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80143ea:	f7fd baac 	b.w	8011946 <forward_cast+0x742>
 80143ee:	edd5 7a00 	vldr	s15, [r5]
 80143f2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80143f6:	ee17 0a90 	vmov	r0, s15
 80143fa:	f7fd b851 	b.w	80114a0 <forward_cast+0x29c>
 80143fe:	edd5 7a00 	vldr	s15, [r5]
 8014402:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014406:	ee17 0a90 	vmov	r0, s15
 801440a:	f7fe b83c 	b.w	8012486 <forward_cast+0x1282>
 801440e:	edd5 7a00 	vldr	s15, [r5]
 8014412:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014416:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801441a:	ee17 0a90 	vmov	r0, s15
 801441e:	f7fe b832 	b.w	8012486 <forward_cast+0x1282>
 8014422:	f995 0000 	ldrsb.w	r0, [r5]
 8014426:	f7fd b83b 	b.w	80114a0 <forward_cast+0x29c>
 801442a:	e9d5 0100 	ldrd	r0, r1, [r5]
 801442e:	f7ec f877 	bl	8000520 <__aeabi_ul2f>
 8014432:	ee07 0a90 	vmov	s15, r0
 8014436:	4a61      	ldr	r2, [pc, #388]	@ (80145bc <forward_cast+0x33b8>)
 8014438:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801443c:	4b5d      	ldr	r3, [pc, #372]	@ (80145b4 <forward_cast+0x33b0>)
 801443e:	ee17 0a90 	vmov	r0, s15
 8014442:	f7fd ba3b 	b.w	80118bc <forward_cast+0x6b8>
 8014446:	e9d5 0100 	ldrd	r0, r1, [r5]
 801444a:	f7ec f869 	bl	8000520 <__aeabi_ul2f>
 801444e:	ee07 0a90 	vmov	s15, r0
 8014452:	4a5a      	ldr	r2, [pc, #360]	@ (80145bc <forward_cast+0x33b8>)
 8014454:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014458:	4b56      	ldr	r3, [pc, #344]	@ (80145b4 <forward_cast+0x33b0>)
 801445a:	ee17 0a90 	vmov	r0, s15
 801445e:	f7fd bcab 	b.w	8011db8 <forward_cast+0xbb4>
 8014462:	edd5 7a00 	vldr	s15, [r5]
 8014466:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801446a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801446e:	ee17 1a90 	vmov	r1, s15
 8014472:	b289      	uxth	r1, r1
 8014474:	f7fc bfbe 	b.w	80113f4 <forward_cast+0x1f0>
 8014478:	edd5 7a00 	vldr	s15, [r5]
 801447c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014480:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014484:	ee17 0a90 	vmov	r0, s15
 8014488:	f7fd bc96 	b.w	8011db8 <forward_cast+0xbb4>
 801448c:	f995 1000 	ldrsb.w	r1, [r5]
 8014490:	b289      	uxth	r1, r1
 8014492:	f7fd b96a 	b.w	801176a <forward_cast+0x566>
 8014496:	e9d5 0100 	ldrd	r0, r1, [r5]
 801449a:	f7ec f841 	bl	8000520 <__aeabi_ul2f>
 801449e:	ee07 0a90 	vmov	s15, r0
 80144a2:	4a43      	ldr	r2, [pc, #268]	@ (80145b0 <forward_cast+0x33ac>)
 80144a4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80144a8:	ee17 3a90 	vmov	r3, s15
 80144ac:	b299      	uxth	r1, r3
 80144ae:	4b43      	ldr	r3, [pc, #268]	@ (80145bc <forward_cast+0x33b8>)
 80144b0:	f7fd b95b 	b.w	801176a <forward_cast+0x566>
 80144b4:	edd5 7a00 	vldr	s15, [r5]
 80144b8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80144bc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80144c0:	ee17 1a90 	vmov	r1, s15
 80144c4:	b289      	uxth	r1, r1
 80144c6:	f7fd b950 	b.w	801176a <forward_cast+0x566>
 80144ca:	f995 0000 	ldrsb.w	r0, [r5]
 80144ce:	f7fd bf0e 	b.w	80122ee <forward_cast+0x10ea>
 80144d2:	edd5 7a00 	vldr	s15, [r5]
 80144d6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80144da:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80144de:	ee17 1a90 	vmov	r1, s15
 80144e2:	b209      	sxth	r1, r1
 80144e4:	f7fe bde2 	b.w	80130ac <forward_cast+0x1ea8>
 80144e8:	edd5 7a00 	vldr	s15, [r5]
 80144ec:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80144f0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80144f4:	f7fd bf8d 	b.w	8012412 <forward_cast+0x120e>
 80144f8:	edd5 7a00 	vldr	s15, [r5]
 80144fc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014500:	ee17 0a90 	vmov	r0, s15
 8014504:	f7fd bf41 	b.w	801238a <forward_cast+0x1186>
 8014508:	f995 0000 	ldrsb.w	r0, [r5]
 801450c:	f7fd bb36 	b.w	8011b7c <forward_cast+0x978>
 8014510:	edd5 7a00 	vldr	s15, [r5]
 8014514:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014518:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801451c:	ee17 0a90 	vmov	r0, s15
 8014520:	f7fc bfbe 	b.w	80114a0 <forward_cast+0x29c>
 8014524:	7828      	ldrb	r0, [r5, #0]
 8014526:	f7fd bc47 	b.w	8011db8 <forward_cast+0xbb4>
 801452a:	edd5 7a00 	vldr	s15, [r5]
 801452e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014532:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014536:	ee17 0a90 	vmov	r0, s15
 801453a:	f7fd bfa4 	b.w	8012486 <forward_cast+0x1282>
 801453e:	f995 0000 	ldrsb.w	r0, [r5]
 8014542:	f7fd bc39 	b.w	8011db8 <forward_cast+0xbb4>
 8014546:	e9d5 0100 	ldrd	r0, r1, [r5]
 801454a:	f7eb ffe9 	bl	8000520 <__aeabi_ul2f>
 801454e:	ee07 0a90 	vmov	s15, r0
 8014552:	4a1a      	ldr	r2, [pc, #104]	@ (80145bc <forward_cast+0x33b8>)
 8014554:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014558:	4b16      	ldr	r3, [pc, #88]	@ (80145b4 <forward_cast+0x33b0>)
 801455a:	ee17 0a90 	vmov	r0, s15
 801455e:	f7fc bf9f 	b.w	80114a0 <forward_cast+0x29c>
 8014562:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014566:	f7eb ffdb 	bl	8000520 <__aeabi_ul2f>
 801456a:	ee07 0a90 	vmov	s15, r0
 801456e:	4a15      	ldr	r2, [pc, #84]	@ (80145c4 <forward_cast+0x33c0>)
 8014570:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014574:	4b11      	ldr	r3, [pc, #68]	@ (80145bc <forward_cast+0x33b8>)
 8014576:	ee17 0a90 	vmov	r0, s15
 801457a:	f7fd bf06 	b.w	801238a <forward_cast+0x1186>
 801457e:	edd5 7a00 	vldr	s15, [r5]
 8014582:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014586:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801458a:	ee17 0a90 	vmov	r0, s15
 801458e:	f7fd befc 	b.w	801238a <forward_cast+0x1186>
 8014592:	7828      	ldrb	r0, [r5, #0]
 8014594:	f7fd bcb0 	b.w	8011ef8 <forward_cast+0xcf4>
 8014598:	edd5 7a00 	vldr	s15, [r5]
 801459c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80145a0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80145a4:	ee17 0a90 	vmov	r0, s15
 80145a8:	f7fd bd60 	b.w	801206c <forward_cast+0xe68>
 80145ac:	00060440 	.word	0x00060440
 80145b0:	00042040 	.word	0x00042040
 80145b4:	00840840 	.word	0x00840840
 80145b8:	00840440 	.word	0x00840440
 80145bc:	00041040 	.word	0x00041040
 80145c0:	00842040 	.word	0x00842040
 80145c4:	00040440 	.word	0x00040440
 80145c8:	e9d5 0100 	ldrd	r0, r1, [r5]
 80145cc:	f7eb ffa8 	bl	8000520 <__aeabi_ul2f>
 80145d0:	ee07 0a90 	vmov	s15, r0
 80145d4:	4adf      	ldr	r2, [pc, #892]	@ (8014954 <forward_cast+0x3750>)
 80145d6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80145da:	4bdf      	ldr	r3, [pc, #892]	@ (8014958 <forward_cast+0x3754>)
 80145dc:	edcd 7a02 	vstr	s15, [sp, #8]
 80145e0:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80145e4:	f7fd ba8a 	b.w	8011afc <forward_cast+0x8f8>
 80145e8:	edd5 7a00 	vldr	s15, [r5]
 80145ec:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80145f0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80145f4:	edcd 7a02 	vstr	s15, [sp, #8]
 80145f8:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80145fc:	f7fd ba7e 	b.w	8011afc <forward_cast+0x8f8>
 8014600:	7828      	ldrb	r0, [r5, #0]
 8014602:	f7fd bd33 	b.w	801206c <forward_cast+0xe68>
 8014606:	edd5 7a00 	vldr	s15, [r5]
 801460a:	eef5 7a40 	vcmp.f32	s15, #0.0
 801460e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014612:	bf14      	ite	ne
 8014614:	2101      	movne	r1, #1
 8014616:	2100      	moveq	r1, #0
 8014618:	f7fe bcdf 	b.w	8012fda <forward_cast+0x1dd6>
 801461c:	edd5 7a00 	vldr	s15, [r5]
 8014620:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014624:	eef5 7a40 	vcmp.f32	s15, #0.0
 8014628:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801462c:	bf14      	ite	ne
 801462e:	2101      	movne	r1, #1
 8014630:	2100      	moveq	r1, #0
 8014632:	f7fe bcd2 	b.w	8012fda <forward_cast+0x1dd6>
 8014636:	e9d5 0100 	ldrd	r0, r1, [r5]
 801463a:	f7eb ff71 	bl	8000520 <__aeabi_ul2f>
 801463e:	ee07 0a90 	vmov	s15, r0
 8014642:	4ac6      	ldr	r2, [pc, #792]	@ (801495c <forward_cast+0x3758>)
 8014644:	eef5 7a40 	vcmp.f32	s15, #0.0
 8014648:	4bc2      	ldr	r3, [pc, #776]	@ (8014954 <forward_cast+0x3750>)
 801464a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801464e:	bf14      	ite	ne
 8014650:	2101      	movne	r1, #1
 8014652:	2100      	moveq	r1, #0
 8014654:	f7fe bcc1 	b.w	8012fda <forward_cast+0x1dd6>
 8014658:	f995 1000 	ldrsb.w	r1, [r5]
 801465c:	3900      	subs	r1, #0
 801465e:	bf18      	it	ne
 8014660:	2101      	movne	r1, #1
 8014662:	f7fe bcba 	b.w	8012fda <forward_cast+0x1dd6>
 8014666:	e9d5 0100 	ldrd	r0, r1, [r5]
 801466a:	f7eb ff59 	bl	8000520 <__aeabi_ul2f>
 801466e:	ee07 0a90 	vmov	s15, r0
 8014672:	4aba      	ldr	r2, [pc, #744]	@ (801495c <forward_cast+0x3758>)
 8014674:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014678:	ee17 3a90 	vmov	r3, s15
 801467c:	b299      	uxth	r1, r3
 801467e:	4bb5      	ldr	r3, [pc, #724]	@ (8014954 <forward_cast+0x3750>)
 8014680:	f7fc beb8 	b.w	80113f4 <forward_cast+0x1f0>
 8014684:	7829      	ldrb	r1, [r5, #0]
 8014686:	f7fc beb5 	b.w	80113f4 <forward_cast+0x1f0>
 801468a:	edd5 7a00 	vldr	s15, [r5]
 801468e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014692:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014696:	ee17 0a90 	vmov	r0, s15
 801469a:	f7fd bbed 	b.w	8011e78 <forward_cast+0xc74>
 801469e:	7828      	ldrb	r0, [r5, #0]
 80146a0:	f7fd bbea 	b.w	8011e78 <forward_cast+0xc74>
 80146a4:	edd5 7a00 	vldr	s15, [r5]
 80146a8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80146ac:	ee17 1a90 	vmov	r1, s15
 80146b0:	b289      	uxth	r1, r1
 80146b2:	f7fd b85a 	b.w	801176a <forward_cast+0x566>
 80146b6:	edd5 7a00 	vldr	s15, [r5]
 80146ba:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80146be:	ee17 0a90 	vmov	r0, s15
 80146c2:	f7fd be14 	b.w	80122ee <forward_cast+0x10ea>
 80146c6:	edd5 7a00 	vldr	s15, [r5]
 80146ca:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80146ce:	ee17 1a90 	vmov	r1, s15
 80146d2:	b209      	sxth	r1, r1
 80146d4:	f7fe bbd6 	b.w	8012e84 <forward_cast+0x1c80>
 80146d8:	edd5 7a00 	vldr	s15, [r5]
 80146dc:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80146e0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80146e4:	ee17 1a90 	vmov	r1, s15
 80146e8:	b209      	sxth	r1, r1
 80146ea:	f7fe bbcb 	b.w	8012e84 <forward_cast+0x1c80>
 80146ee:	e9d5 0100 	ldrd	r0, r1, [r5]
 80146f2:	f7eb ff15 	bl	8000520 <__aeabi_ul2f>
 80146f6:	ee07 0a90 	vmov	s15, r0
 80146fa:	4a98      	ldr	r2, [pc, #608]	@ (801495c <forward_cast+0x3758>)
 80146fc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014700:	4b94      	ldr	r3, [pc, #592]	@ (8014954 <forward_cast+0x3750>)
 8014702:	ee17 0a90 	vmov	r0, s15
 8014706:	f7fd bbb7 	b.w	8011e78 <forward_cast+0xc74>
 801470a:	e9d5 0100 	ldrd	r0, r1, [r5]
 801470e:	f7eb ff07 	bl	8000520 <__aeabi_ul2f>
 8014712:	ee07 0a90 	vmov	s15, r0
 8014716:	4a91      	ldr	r2, [pc, #580]	@ (801495c <forward_cast+0x3758>)
 8014718:	eef5 7a40 	vcmp.f32	s15, #0.0
 801471c:	4b8d      	ldr	r3, [pc, #564]	@ (8014954 <forward_cast+0x3750>)
 801471e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014722:	bf14      	ite	ne
 8014724:	2101      	movne	r1, #1
 8014726:	2100      	moveq	r1, #0
 8014728:	f7fd bc4a 	b.w	8011fc0 <forward_cast+0xdbc>
 801472c:	edd5 7a00 	vldr	s15, [r5]
 8014730:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014734:	eef5 7a40 	vcmp.f32	s15, #0.0
 8014738:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801473c:	bf14      	ite	ne
 801473e:	2101      	movne	r1, #1
 8014740:	2100      	moveq	r1, #0
 8014742:	f7fd bc3d 	b.w	8011fc0 <forward_cast+0xdbc>
 8014746:	7828      	ldrb	r0, [r5, #0]
 8014748:	f7fd ba18 	b.w	8011b7c <forward_cast+0x978>
 801474c:	edd5 7a00 	vldr	s15, [r5]
 8014750:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014754:	edcd 7a02 	vstr	s15, [sp, #8]
 8014758:	f89d 1008 	ldrb.w	r1, [sp, #8]
 801475c:	f7fd b9ce 	b.w	8011afc <forward_cast+0x8f8>
 8014760:	edd5 7a00 	vldr	s15, [r5]
 8014764:	eef5 7a40 	vcmp.f32	s15, #0.0
 8014768:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801476c:	bf14      	ite	ne
 801476e:	2101      	movne	r1, #1
 8014770:	2100      	moveq	r1, #0
 8014772:	f7fd bc25 	b.w	8011fc0 <forward_cast+0xdbc>
 8014776:	edd5 7a00 	vldr	s15, [r5]
 801477a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801477e:	edcd 7a02 	vstr	s15, [sp, #8]
 8014782:	f99d 1008 	ldrsb.w	r1, [sp, #8]
 8014786:	f7fd bcb6 	b.w	80120f6 <forward_cast+0xef2>
 801478a:	edd5 7a00 	vldr	s15, [r5]
 801478e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014792:	ee17 0a90 	vmov	r0, s15
 8014796:	f7fd b9f1 	b.w	8011b7c <forward_cast+0x978>
 801479a:	e9d5 0100 	ldrd	r0, r1, [r5]
 801479e:	f7eb febf 	bl	8000520 <__aeabi_ul2f>
 80147a2:	ee07 0a90 	vmov	s15, r0
 80147a6:	4a6e      	ldr	r2, [pc, #440]	@ (8014960 <forward_cast+0x375c>)
 80147a8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80147ac:	4b6b      	ldr	r3, [pc, #428]	@ (801495c <forward_cast+0x3758>)
 80147ae:	ee17 0a90 	vmov	r0, s15
 80147b2:	f7fd b845 	b.w	8011840 <forward_cast+0x63c>
 80147b6:	e9d5 0100 	ldrd	r0, r1, [r5]
 80147ba:	f7eb feb1 	bl	8000520 <__aeabi_ul2f>
 80147be:	ee07 0a90 	vmov	s15, r0
 80147c2:	4b66      	ldr	r3, [pc, #408]	@ (801495c <forward_cast+0x3758>)
 80147c4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80147c8:	4a63      	ldr	r2, [pc, #396]	@ (8014958 <forward_cast+0x3754>)
 80147ca:	ee17 0a90 	vmov	r0, s15
 80147ce:	f7fd b9d5 	b.w	8011b7c <forward_cast+0x978>
 80147d2:	edd5 7a00 	vldr	s15, [r5]
 80147d6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80147da:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80147de:	ee17 0a90 	vmov	r0, s15
 80147e2:	f7fd b9cb 	b.w	8011b7c <forward_cast+0x978>
 80147e6:	7828      	ldrb	r0, [r5, #0]
 80147e8:	f7fd bd26 	b.w	8012238 <forward_cast+0x1034>
 80147ec:	e9d5 0100 	ldrd	r0, r1, [r5]
 80147f0:	f7eb fe96 	bl	8000520 <__aeabi_ul2f>
 80147f4:	ee07 0a90 	vmov	s15, r0
 80147f8:	4a58      	ldr	r2, [pc, #352]	@ (801495c <forward_cast+0x3758>)
 80147fa:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80147fe:	4b55      	ldr	r3, [pc, #340]	@ (8014954 <forward_cast+0x3750>)
 8014800:	ee17 0a90 	vmov	r0, s15
 8014804:	f7fd bc32 	b.w	801206c <forward_cast+0xe68>
 8014808:	e9d5 0100 	ldrd	r0, r1, [r5]
 801480c:	f7eb fe88 	bl	8000520 <__aeabi_ul2f>
 8014810:	ee07 0a90 	vmov	s15, r0
 8014814:	4a4f      	ldr	r2, [pc, #316]	@ (8014954 <forward_cast+0x3750>)
 8014816:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801481a:	4b4f      	ldr	r3, [pc, #316]	@ (8014958 <forward_cast+0x3754>)
 801481c:	ee17 0a90 	vmov	r0, s15
 8014820:	f7fc bea6 	b.w	8011570 <forward_cast+0x36c>
 8014824:	edd5 7a00 	vldr	s15, [r5]
 8014828:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801482c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014830:	ee17 0a90 	vmov	r0, s15
 8014834:	f7fc be9c 	b.w	8011570 <forward_cast+0x36c>
 8014838:	7828      	ldrb	r0, [r5, #0]
 801483a:	f7fd b9dd 	b.w	8011bf8 <forward_cast+0x9f4>
 801483e:	edd5 7a00 	vldr	s15, [r5]
 8014842:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014846:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801484a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801484e:	f7fd bde0 	b.w	8012412 <forward_cast+0x120e>
 8014852:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014856:	f7eb fe63 	bl	8000520 <__aeabi_ul2f>
 801485a:	ee07 0a90 	vmov	s15, r0
 801485e:	4a41      	ldr	r2, [pc, #260]	@ (8014964 <forward_cast+0x3760>)
 8014860:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8014864:	ee17 3a90 	vmov	r3, s15
 8014868:	b299      	uxth	r1, r3
 801486a:	4b3f      	ldr	r3, [pc, #252]	@ (8014968 <forward_cast+0x3764>)
 801486c:	f7fc bf2d 	b.w	80116ca <forward_cast+0x4c6>
 8014870:	edd5 7a00 	vldr	s15, [r5]
 8014874:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014878:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801487c:	ee17 1a90 	vmov	r1, s15
 8014880:	b289      	uxth	r1, r1
 8014882:	f7fc bf22 	b.w	80116ca <forward_cast+0x4c6>
 8014886:	7828      	ldrb	r0, [r5, #0]
 8014888:	f7fd bc91 	b.w	80121ae <forward_cast+0xfaa>
 801488c:	edd5 7a00 	vldr	s15, [r5]
 8014890:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014894:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014898:	edcd 7a02 	vstr	s15, [sp, #8]
 801489c:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80148a0:	f7fe ba95 	b.w	8012dce <forward_cast+0x1bca>
 80148a4:	e9d5 0100 	ldrd	r0, r1, [r5]
 80148a8:	f7eb fe3a 	bl	8000520 <__aeabi_ul2f>
 80148ac:	ee07 0a90 	vmov	s15, r0
 80148b0:	4a28      	ldr	r2, [pc, #160]	@ (8014954 <forward_cast+0x3750>)
 80148b2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80148b6:	4b28      	ldr	r3, [pc, #160]	@ (8014958 <forward_cast+0x3754>)
 80148b8:	edcd 7a02 	vstr	s15, [sp, #8]
 80148bc:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80148c0:	f7fe ba85 	b.w	8012dce <forward_cast+0x1bca>
 80148c4:	edd5 7a00 	vldr	s15, [r5]
 80148c8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80148cc:	edcd 7a02 	vstr	s15, [sp, #8]
 80148d0:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80148d4:	f7fe ba7b 	b.w	8012dce <forward_cast+0x1bca>
 80148d8:	edd5 7a00 	vldr	s15, [r5]
 80148dc:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80148e0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80148e4:	edcd 7a02 	vstr	s15, [sp, #8]
 80148e8:	f89d 1008 	ldrb.w	r1, [sp, #8]
 80148ec:	f7fe ba6f 	b.w	8012dce <forward_cast+0x1bca>
 80148f0:	edd5 7a00 	vldr	s15, [r5]
 80148f4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80148f8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80148fc:	f7fe ba0d 	b.w	8012d1a <forward_cast+0x1b16>
 8014900:	edd5 7a00 	vldr	s15, [r5]
 8014904:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014908:	ee17 0a90 	vmov	r0, s15
 801490c:	f7fd bc4f 	b.w	80121ae <forward_cast+0xfaa>
 8014910:	edd5 7a00 	vldr	s15, [r5]
 8014914:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014918:	f7fe b945 	b.w	8012ba6 <forward_cast+0x19a2>
 801491c:	edd5 7a00 	vldr	s15, [r5]
 8014920:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014924:	ee17 0a90 	vmov	r0, s15
 8014928:	f7fd b966 	b.w	8011bf8 <forward_cast+0x9f4>
 801492c:	edd5 7a00 	vldr	s15, [r5]
 8014930:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014934:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014938:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801493c:	f7fe b9ed 	b.w	8012d1a <forward_cast+0x1b16>
 8014940:	edd5 7a00 	vldr	s15, [r5]
 8014944:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014948:	ee17 1a90 	vmov	r1, s15
 801494c:	b289      	uxth	r1, r1
 801494e:	f7fc bd51 	b.w	80113f4 <forward_cast+0x1f0>
 8014952:	bf00      	nop
 8014954:	00041040 	.word	0x00041040
 8014958:	00840840 	.word	0x00840840
 801495c:	00042040 	.word	0x00042040
 8014960:	00060440 	.word	0x00060440
 8014964:	00040440 	.word	0x00040440
 8014968:	00840440 	.word	0x00840440
 801496c:	edd5 7a00 	vldr	s15, [r5]
 8014970:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014974:	ee17 0a90 	vmov	r0, s15
 8014978:	f7fd ba1e 	b.w	8011db8 <forward_cast+0xbb4>
 801497c:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014980:	f7eb fdce 	bl	8000520 <__aeabi_ul2f>
 8014984:	ee07 0a90 	vmov	s15, r0
 8014988:	4ae5      	ldr	r2, [pc, #916]	@ (8014d20 <forward_cast+0x3b1c>)
 801498a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801498e:	4be5      	ldr	r3, [pc, #916]	@ (8014d24 <forward_cast+0x3b20>)
 8014990:	ee17 0a90 	vmov	r0, s15
 8014994:	f7fd b85d 	b.w	8011a52 <forward_cast+0x84e>
 8014998:	e9d5 0100 	ldrd	r0, r1, [r5]
 801499c:	f7eb fdc0 	bl	8000520 <__aeabi_ul2f>
 80149a0:	ee07 0a90 	vmov	s15, r0
 80149a4:	4ae0      	ldr	r2, [pc, #896]	@ (8014d28 <forward_cast+0x3b24>)
 80149a6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80149aa:	4bdd      	ldr	r3, [pc, #884]	@ (8014d20 <forward_cast+0x3b1c>)
 80149ac:	ee17 0a90 	vmov	r0, s15
 80149b0:	f7fd bc9d 	b.w	80122ee <forward_cast+0x10ea>
 80149b4:	edd5 7a00 	vldr	s15, [r5]
 80149b8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80149bc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80149c0:	ee17 0a90 	vmov	r0, s15
 80149c4:	f7fd bc93 	b.w	80122ee <forward_cast+0x10ea>
 80149c8:	f995 0000 	ldrsb.w	r0, [r5]
 80149cc:	f7fd bcdd 	b.w	801238a <forward_cast+0x1186>
 80149d0:	edd5 7a00 	vldr	s15, [r5]
 80149d4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80149d8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80149dc:	ee17 0a90 	vmov	r0, s15
 80149e0:	f7fe b88e 	b.w	8012b00 <forward_cast+0x18fc>
 80149e4:	7828      	ldrb	r0, [r5, #0]
 80149e6:	f7fe b88b 	b.w	8012b00 <forward_cast+0x18fc>
 80149ea:	e9d5 0100 	ldrd	r0, r1, [r5]
 80149ee:	f7eb fd97 	bl	8000520 <__aeabi_ul2f>
 80149f2:	ee07 0a90 	vmov	s15, r0
 80149f6:	4acc      	ldr	r2, [pc, #816]	@ (8014d28 <forward_cast+0x3b24>)
 80149f8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80149fc:	4bc8      	ldr	r3, [pc, #800]	@ (8014d20 <forward_cast+0x3b1c>)
 80149fe:	ee17 0a90 	vmov	r0, s15
 8014a02:	f7fe b87d 	b.w	8012b00 <forward_cast+0x18fc>
 8014a06:	f995 0000 	ldrsb.w	r0, [r5]
 8014a0a:	f7fe b879 	b.w	8012b00 <forward_cast+0x18fc>
 8014a0e:	edd5 7a00 	vldr	s15, [r5]
 8014a12:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014a16:	f7fe b8c6 	b.w	8012ba6 <forward_cast+0x19a2>
 8014a1a:	7829      	ldrb	r1, [r5, #0]
 8014a1c:	ee07 1a90 	vmov	s15, r1
 8014a20:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014a24:	f7fe b8bf 	b.w	8012ba6 <forward_cast+0x19a2>
 8014a28:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014a2c:	f7eb fd78 	bl	8000520 <__aeabi_ul2f>
 8014a30:	4bbe      	ldr	r3, [pc, #760]	@ (8014d2c <forward_cast+0x3b28>)
 8014a32:	ee07 0a90 	vmov	s15, r0
 8014a36:	4abe      	ldr	r2, [pc, #760]	@ (8014d30 <forward_cast+0x3b2c>)
 8014a38:	f7fe b8b5 	b.w	8012ba6 <forward_cast+0x19a2>
 8014a3c:	f995 1000 	ldrsb.w	r1, [r5]
 8014a40:	ee07 1a90 	vmov	s15, r1
 8014a44:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014a48:	f7fe b8ad 	b.w	8012ba6 <forward_cast+0x19a2>
 8014a4c:	edd5 7a00 	vldr	s15, [r5]
 8014a50:	f7fe b8a9 	b.w	8012ba6 <forward_cast+0x19a2>
 8014a54:	edd5 7a00 	vldr	s15, [r5]
 8014a58:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014a5c:	ee17 0a90 	vmov	r0, s15
 8014a60:	f7fd bb04 	b.w	801206c <forward_cast+0xe68>
 8014a64:	edd5 7a00 	vldr	s15, [r5]
 8014a68:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014a6c:	ee17 0a90 	vmov	r0, s15
 8014a70:	f7fe b902 	b.w	8012c78 <forward_cast+0x1a74>
 8014a74:	edd5 7a00 	vldr	s15, [r5]
 8014a78:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014a7c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014a80:	ee17 0a90 	vmov	r0, s15
 8014a84:	f7fe b8f8 	b.w	8012c78 <forward_cast+0x1a74>
 8014a88:	edd5 7a00 	vldr	s15, [r5]
 8014a8c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014a90:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014a94:	ee17 0a90 	vmov	r0, s15
 8014a98:	f7fe b8ee 	b.w	8012c78 <forward_cast+0x1a74>
 8014a9c:	7828      	ldrb	r0, [r5, #0]
 8014a9e:	f7fe b8eb 	b.w	8012c78 <forward_cast+0x1a74>
 8014aa2:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014aa6:	f7eb fd3b 	bl	8000520 <__aeabi_ul2f>
 8014aaa:	ee07 0a90 	vmov	s15, r0
 8014aae:	4a9e      	ldr	r2, [pc, #632]	@ (8014d28 <forward_cast+0x3b24>)
 8014ab0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014ab4:	4b9a      	ldr	r3, [pc, #616]	@ (8014d20 <forward_cast+0x3b1c>)
 8014ab6:	ee17 0a90 	vmov	r0, s15
 8014aba:	f7fe b8dd 	b.w	8012c78 <forward_cast+0x1a74>
 8014abe:	f995 0000 	ldrsb.w	r0, [r5]
 8014ac2:	f7fe b8d9 	b.w	8012c78 <forward_cast+0x1a74>
 8014ac6:	edd5 7a00 	vldr	s15, [r5]
 8014aca:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014ace:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014ad2:	ee17 1a90 	vmov	r1, s15
 8014ad6:	b209      	sxth	r1, r1
 8014ad8:	f7fe ba32 	b.w	8012f40 <forward_cast+0x1d3c>
 8014adc:	edd5 7a00 	vldr	s15, [r5]
 8014ae0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014ae4:	ee17 0a90 	vmov	r0, s15
 8014ae8:	f7fc bf71 	b.w	80119ce <forward_cast+0x7ca>
 8014aec:	edd5 7a00 	vldr	s15, [r5]
 8014af0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014af4:	ee17 1a90 	vmov	r1, s15
 8014af8:	b209      	sxth	r1, r1
 8014afa:	f7fe ba21 	b.w	8012f40 <forward_cast+0x1d3c>
 8014afe:	edd5 7a00 	vldr	s15, [r5]
 8014b02:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014b06:	ee17 0a90 	vmov	r0, s15
 8014b0a:	f7fd bb95 	b.w	8012238 <forward_cast+0x1034>
 8014b0e:	edd5 7a00 	vldr	s15, [r5]
 8014b12:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014b16:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014b1a:	ee17 1a90 	vmov	r1, s15
 8014b1e:	b209      	sxth	r1, r1
 8014b20:	f7fe ba0e 	b.w	8012f40 <forward_cast+0x1d3c>
 8014b24:	7829      	ldrb	r1, [r5, #0]
 8014b26:	f7fe ba0b 	b.w	8012f40 <forward_cast+0x1d3c>
 8014b2a:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014b2e:	f7eb fcf7 	bl	8000520 <__aeabi_ul2f>
 8014b32:	ee07 0a90 	vmov	s15, r0
 8014b36:	4a7f      	ldr	r2, [pc, #508]	@ (8014d34 <forward_cast+0x3b30>)
 8014b38:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014b3c:	ee17 3a90 	vmov	r3, s15
 8014b40:	b219      	sxth	r1, r3
 8014b42:	4b79      	ldr	r3, [pc, #484]	@ (8014d28 <forward_cast+0x3b24>)
 8014b44:	f7fe b9fc 	b.w	8012f40 <forward_cast+0x1d3c>
 8014b48:	f995 1000 	ldrsb.w	r1, [r5]
 8014b4c:	f7fe b9f8 	b.w	8012f40 <forward_cast+0x1d3c>
 8014b50:	edd5 7a00 	vldr	s15, [r5]
 8014b54:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014b58:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014b5c:	edcd 7a02 	vstr	s15, [sp, #8]
 8014b60:	f99d 1008 	ldrsb.w	r1, [sp, #8]
 8014b64:	f7fd b88d 	b.w	8011c82 <forward_cast+0xa7e>
 8014b68:	7828      	ldrb	r0, [r5, #0]
 8014b6a:	f7fc bea7 	b.w	80118bc <forward_cast+0x6b8>
 8014b6e:	edd5 7a00 	vldr	s15, [r5]
 8014b72:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014b76:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014b7a:	ee17 0a90 	vmov	r0, s15
 8014b7e:	f7fc bf68 	b.w	8011a52 <forward_cast+0x84e>
 8014b82:	f995 1000 	ldrsb.w	r1, [r5]
 8014b86:	b289      	uxth	r1, r1
 8014b88:	f7fc bc34 	b.w	80113f4 <forward_cast+0x1f0>
 8014b8c:	edd5 7a00 	vldr	s15, [r5]
 8014b90:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014b94:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014b98:	ee17 1a90 	vmov	r1, s15
 8014b9c:	b209      	sxth	r1, r1
 8014b9e:	f7fe b971 	b.w	8012e84 <forward_cast+0x1c80>
 8014ba2:	7829      	ldrb	r1, [r5, #0]
 8014ba4:	f7fe b96e 	b.w	8012e84 <forward_cast+0x1c80>
 8014ba8:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014bac:	f7eb fcb8 	bl	8000520 <__aeabi_ul2f>
 8014bb0:	ee07 0a90 	vmov	s15, r0
 8014bb4:	4a5f      	ldr	r2, [pc, #380]	@ (8014d34 <forward_cast+0x3b30>)
 8014bb6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014bba:	ee17 3a90 	vmov	r3, s15
 8014bbe:	b219      	sxth	r1, r3
 8014bc0:	4b59      	ldr	r3, [pc, #356]	@ (8014d28 <forward_cast+0x3b24>)
 8014bc2:	f7fe b95f 	b.w	8012e84 <forward_cast+0x1c80>
 8014bc6:	f995 1000 	ldrsb.w	r1, [r5]
 8014bca:	f7fe b95b 	b.w	8012e84 <forward_cast+0x1c80>
 8014bce:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014bd2:	f7eb fca5 	bl	8000520 <__aeabi_ul2f>
 8014bd6:	ee07 0a90 	vmov	s15, r0
 8014bda:	4a56      	ldr	r2, [pc, #344]	@ (8014d34 <forward_cast+0x3b30>)
 8014bdc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014be0:	4b51      	ldr	r3, [pc, #324]	@ (8014d28 <forward_cast+0x3b24>)
 8014be2:	ee17 0a90 	vmov	r0, s15
 8014be6:	f7fd bb27 	b.w	8012238 <forward_cast+0x1034>
 8014bea:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014bee:	f7eb fc97 	bl	8000520 <__aeabi_ul2f>
 8014bf2:	ee07 0a90 	vmov	s15, r0
 8014bf6:	4a4c      	ldr	r2, [pc, #304]	@ (8014d28 <forward_cast+0x3b24>)
 8014bf8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014bfc:	4b48      	ldr	r3, [pc, #288]	@ (8014d20 <forward_cast+0x3b1c>)
 8014bfe:	ee17 0a90 	vmov	r0, s15
 8014c02:	f7fc bee4 	b.w	80119ce <forward_cast+0x7ca>
 8014c06:	edd5 7a00 	vldr	s15, [r5]
 8014c0a:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014c0e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014c12:	ee17 0a90 	vmov	r0, s15
 8014c16:	f7fc bb96 	b.w	8011346 <forward_cast+0x142>
 8014c1a:	7828      	ldrb	r0, [r5, #0]
 8014c1c:	f7fc bd05 	b.w	801162a <forward_cast+0x426>
 8014c20:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014c24:	f7eb fc7c 	bl	8000520 <__aeabi_ul2f>
 8014c28:	ee07 0a90 	vmov	s15, r0
 8014c2c:	4a3e      	ldr	r2, [pc, #248]	@ (8014d28 <forward_cast+0x3b24>)
 8014c2e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014c32:	4b3b      	ldr	r3, [pc, #236]	@ (8014d20 <forward_cast+0x3b1c>)
 8014c34:	ee17 0a90 	vmov	r0, s15
 8014c38:	f7fd bab9 	b.w	80121ae <forward_cast+0xfaa>
 8014c3c:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014c40:	f7eb fc6e 	bl	8000520 <__aeabi_ul2f>
 8014c44:	ee07 0a90 	vmov	s15, r0
 8014c48:	4a37      	ldr	r2, [pc, #220]	@ (8014d28 <forward_cast+0x3b24>)
 8014c4a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014c4e:	4b34      	ldr	r3, [pc, #208]	@ (8014d20 <forward_cast+0x3b1c>)
 8014c50:	ee17 0a90 	vmov	r0, s15
 8014c54:	f7fc bce9 	b.w	801162a <forward_cast+0x426>
 8014c58:	edd5 7a00 	vldr	s15, [r5]
 8014c5c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014c60:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014c64:	ee17 0a90 	vmov	r0, s15
 8014c68:	f7fc beb1 	b.w	80119ce <forward_cast+0x7ca>
 8014c6c:	edd5 7a00 	vldr	s15, [r5]
 8014c70:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014c74:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014c78:	ee17 0a90 	vmov	r0, s15
 8014c7c:	f7fc bcd5 	b.w	801162a <forward_cast+0x426>
 8014c80:	edd5 7a00 	vldr	s15, [r5]
 8014c84:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014c88:	ee17 0a90 	vmov	r0, s15
 8014c8c:	f7fd bf38 	b.w	8012b00 <forward_cast+0x18fc>
 8014c90:	edd5 7a00 	vldr	s15, [r5]
 8014c94:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014c98:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014c9c:	ee17 0a90 	vmov	r0, s15
 8014ca0:	f7fd bf2e 	b.w	8012b00 <forward_cast+0x18fc>
 8014ca4:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014ca8:	f7eb fc3a 	bl	8000520 <__aeabi_ul2f>
 8014cac:	ee07 0a90 	vmov	s15, r0
 8014cb0:	4a1f      	ldr	r2, [pc, #124]	@ (8014d30 <forward_cast+0x3b2c>)
 8014cb2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014cb6:	4b1b      	ldr	r3, [pc, #108]	@ (8014d24 <forward_cast+0x3b20>)
 8014cb8:	ee17 0a90 	vmov	r0, s15
 8014cbc:	f7fd bbe3 	b.w	8012486 <forward_cast+0x1282>
 8014cc0:	edd5 7a00 	vldr	s15, [r5]
 8014cc4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014cc8:	ee17 0a90 	vmov	r0, s15
 8014ccc:	f7fc bec1 	b.w	8011a52 <forward_cast+0x84e>
 8014cd0:	edd5 7a00 	vldr	s15, [r5]
 8014cd4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014cd8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014cdc:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014ce0:	f7fe b81b 	b.w	8012d1a <forward_cast+0x1b16>
 8014ce4:	7829      	ldrb	r1, [r5, #0]
 8014ce6:	ee07 1a90 	vmov	s15, r1
 8014cea:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014cee:	f7fe b814 	b.w	8012d1a <forward_cast+0x1b16>
 8014cf2:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014cf6:	f7eb fc13 	bl	8000520 <__aeabi_ul2f>
 8014cfa:	ee07 0a90 	vmov	s15, r0
 8014cfe:	4b0b      	ldr	r3, [pc, #44]	@ (8014d2c <forward_cast+0x3b28>)
 8014d00:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014d04:	4a0a      	ldr	r2, [pc, #40]	@ (8014d30 <forward_cast+0x3b2c>)
 8014d06:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014d0a:	f7fe b806 	b.w	8012d1a <forward_cast+0x1b16>
 8014d0e:	f995 1000 	ldrsb.w	r1, [r5]
 8014d12:	ee07 1a90 	vmov	s15, r1
 8014d16:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014d1a:	f7fd bffe 	b.w	8012d1a <forward_cast+0x1b16>
 8014d1e:	bf00      	nop
 8014d20:	00041040 	.word	0x00041040
 8014d24:	00840840 	.word	0x00840840
 8014d28:	00042040 	.word	0x00042040
 8014d2c:	00842040 	.word	0x00842040
 8014d30:	00841040 	.word	0x00841040
 8014d34:	00060440 	.word	0x00060440
 8014d38:	edd5 7a00 	vldr	s15, [r5]
 8014d3c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014d40:	ee17 1a90 	vmov	r1, s15
 8014d44:	b209      	sxth	r1, r1
 8014d46:	f7fe b9b1 	b.w	80130ac <forward_cast+0x1ea8>
 8014d4a:	edd5 7a00 	vldr	s15, [r5]
 8014d4e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014d52:	ee17 0a90 	vmov	r0, s15
 8014d56:	f7fc bd73 	b.w	8011840 <forward_cast+0x63c>
 8014d5a:	edd5 7a00 	vldr	s15, [r5]
 8014d5e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014d62:	eef5 7a40 	vcmp.f32	s15, #0.0
 8014d66:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014d6a:	bf14      	ite	ne
 8014d6c:	2101      	movne	r1, #1
 8014d6e:	2100      	moveq	r1, #0
 8014d70:	f7fe b933 	b.w	8012fda <forward_cast+0x1dd6>
 8014d74:	edd5 7a00 	vldr	s15, [r5]
 8014d78:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014d7c:	ee17 0a90 	vmov	r0, s15
 8014d80:	f7fd b87a 	b.w	8011e78 <forward_cast+0xc74>
 8014d84:	edd5 7a00 	vldr	s15, [r5]
 8014d88:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014d8c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014d90:	ee17 1a90 	vmov	r1, s15
 8014d94:	b209      	sxth	r1, r1
 8014d96:	f7fe b989 	b.w	80130ac <forward_cast+0x1ea8>
 8014d9a:	7829      	ldrb	r1, [r5, #0]
 8014d9c:	f7fe b986 	b.w	80130ac <forward_cast+0x1ea8>
 8014da0:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014da4:	f7eb fbbc 	bl	8000520 <__aeabi_ul2f>
 8014da8:	ee07 0a90 	vmov	s15, r0
 8014dac:	4a73      	ldr	r2, [pc, #460]	@ (8014f7c <forward_cast+0x3d78>)
 8014dae:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014db2:	ee17 3a90 	vmov	r3, s15
 8014db6:	b219      	sxth	r1, r3
 8014db8:	4b71      	ldr	r3, [pc, #452]	@ (8014f80 <forward_cast+0x3d7c>)
 8014dba:	f7fe b977 	b.w	80130ac <forward_cast+0x1ea8>
 8014dbe:	f995 1000 	ldrsb.w	r1, [r5]
 8014dc2:	f7fe b973 	b.w	80130ac <forward_cast+0x1ea8>
 8014dc6:	edd5 7a00 	vldr	s15, [r5]
 8014dca:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014dce:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014dd2:	ee17 0a90 	vmov	r0, s15
 8014dd6:	f7fe b9b4 	b.w	8013142 <forward_cast+0x1f3e>
 8014dda:	7828      	ldrb	r0, [r5, #0]
 8014ddc:	f7fe b9b1 	b.w	8013142 <forward_cast+0x1f3e>
 8014de0:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014de4:	f7eb fb9c 	bl	8000520 <__aeabi_ul2f>
 8014de8:	ee07 0a90 	vmov	s15, r0
 8014dec:	4a63      	ldr	r2, [pc, #396]	@ (8014f7c <forward_cast+0x3d78>)
 8014dee:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014df2:	4b63      	ldr	r3, [pc, #396]	@ (8014f80 <forward_cast+0x3d7c>)
 8014df4:	ee17 0a90 	vmov	r0, s15
 8014df8:	f7fe b9a3 	b.w	8013142 <forward_cast+0x1f3e>
 8014dfc:	f995 0000 	ldrsb.w	r0, [r5]
 8014e00:	f7fe b99f 	b.w	8013142 <forward_cast+0x1f3e>
 8014e04:	edd5 7a00 	vldr	s15, [r5]
 8014e08:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8014e0c:	eef5 7a40 	vcmp.f32	s15, #0.0
 8014e10:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014e14:	bf14      	ite	ne
 8014e16:	2101      	movne	r1, #1
 8014e18:	2100      	moveq	r1, #0
 8014e1a:	f7fe b9fa 	b.w	8013212 <forward_cast+0x200e>
 8014e1e:	edd5 7a00 	vldr	s15, [r5]
 8014e22:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014e26:	eef5 7a40 	vcmp.f32	s15, #0.0
 8014e2a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014e2e:	bf14      	ite	ne
 8014e30:	2101      	movne	r1, #1
 8014e32:	2100      	moveq	r1, #0
 8014e34:	f7fe b9ed 	b.w	8013212 <forward_cast+0x200e>
 8014e38:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014e3c:	f7eb fb70 	bl	8000520 <__aeabi_ul2f>
 8014e40:	ee07 0a90 	vmov	s15, r0
 8014e44:	4a4e      	ldr	r2, [pc, #312]	@ (8014f80 <forward_cast+0x3d7c>)
 8014e46:	eef5 7a40 	vcmp.f32	s15, #0.0
 8014e4a:	4b4e      	ldr	r3, [pc, #312]	@ (8014f84 <forward_cast+0x3d80>)
 8014e4c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014e50:	bf14      	ite	ne
 8014e52:	2101      	movne	r1, #1
 8014e54:	2100      	moveq	r1, #0
 8014e56:	f7fe b9dc 	b.w	8013212 <forward_cast+0x200e>
 8014e5a:	f995 1000 	ldrsb.w	r1, [r5]
 8014e5e:	3900      	subs	r1, #0
 8014e60:	bf18      	it	ne
 8014e62:	2101      	movne	r1, #1
 8014e64:	f7fe b9d5 	b.w	8013212 <forward_cast+0x200e>
 8014e68:	edd5 7a00 	vldr	s15, [r5]
 8014e6c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014e70:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014e74:	ee17 0a90 	vmov	r0, s15
 8014e78:	f7fe ba1b 	b.w	80132b2 <forward_cast+0x20ae>
 8014e7c:	7828      	ldrb	r0, [r5, #0]
 8014e7e:	f7fe ba18 	b.w	80132b2 <forward_cast+0x20ae>
 8014e82:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014e86:	f7eb fb4b 	bl	8000520 <__aeabi_ul2f>
 8014e8a:	ee07 0a90 	vmov	s15, r0
 8014e8e:	4a3b      	ldr	r2, [pc, #236]	@ (8014f7c <forward_cast+0x3d78>)
 8014e90:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014e94:	4b3c      	ldr	r3, [pc, #240]	@ (8014f88 <forward_cast+0x3d84>)
 8014e96:	ee17 0a90 	vmov	r0, s15
 8014e9a:	f7fe ba0a 	b.w	80132b2 <forward_cast+0x20ae>
 8014e9e:	f995 0000 	ldrsb.w	r0, [r5]
 8014ea2:	f7fe ba06 	b.w	80132b2 <forward_cast+0x20ae>
 8014ea6:	edd5 7a00 	vldr	s15, [r5]
 8014eaa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014eae:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014eb2:	ee17 0a90 	vmov	r0, s15
 8014eb6:	f7fe ba45 	b.w	8013344 <forward_cast+0x2140>
 8014eba:	7828      	ldrb	r0, [r5, #0]
 8014ebc:	f7fe ba42 	b.w	8013344 <forward_cast+0x2140>
 8014ec0:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014ec4:	f7eb fb2c 	bl	8000520 <__aeabi_ul2f>
 8014ec8:	ee07 0a90 	vmov	s15, r0
 8014ecc:	4a2b      	ldr	r2, [pc, #172]	@ (8014f7c <forward_cast+0x3d78>)
 8014ece:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014ed2:	4b2b      	ldr	r3, [pc, #172]	@ (8014f80 <forward_cast+0x3d7c>)
 8014ed4:	ee17 0a90 	vmov	r0, s15
 8014ed8:	f7fe ba34 	b.w	8013344 <forward_cast+0x2140>
 8014edc:	f995 0000 	ldrsb.w	r0, [r5]
 8014ee0:	f7fe ba30 	b.w	8013344 <forward_cast+0x2140>
 8014ee4:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014ee8:	f7eb fb1a 	bl	8000520 <__aeabi_ul2f>
 8014eec:	ee07 0a90 	vmov	s15, r0
 8014ef0:	4a24      	ldr	r2, [pc, #144]	@ (8014f84 <forward_cast+0x3d80>)
 8014ef2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014ef6:	4b24      	ldr	r3, [pc, #144]	@ (8014f88 <forward_cast+0x3d84>)
 8014ef8:	edcd 7a02 	vstr	s15, [sp, #8]
 8014efc:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8014f00:	f7fe ba73 	b.w	80133ea <forward_cast+0x21e6>
 8014f04:	edd5 7a00 	vldr	s15, [r5]
 8014f08:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014f0c:	edcd 7a02 	vstr	s15, [sp, #8]
 8014f10:	f89d 1008 	ldrb.w	r1, [sp, #8]
 8014f14:	f7fe ba69 	b.w	80133ea <forward_cast+0x21e6>
 8014f18:	edd5 7a00 	vldr	s15, [r5]
 8014f1c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014f20:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014f24:	ee17 0a90 	vmov	r0, s15
 8014f28:	f7fd b9e1 	b.w	80122ee <forward_cast+0x10ea>
 8014f2c:	7828      	ldrb	r0, [r5, #0]
 8014f2e:	f7fd baaa 	b.w	8012486 <forward_cast+0x1282>
 8014f32:	edd5 7a00 	vldr	s15, [r5]
 8014f36:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014f3a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014f3e:	ee17 0a90 	vmov	r0, s15
 8014f42:	f7fe baaa 	b.w	801349a <forward_cast+0x2296>
 8014f46:	7828      	ldrb	r0, [r5, #0]
 8014f48:	f7fe baa7 	b.w	801349a <forward_cast+0x2296>
 8014f4c:	e9d5 0100 	ldrd	r0, r1, [r5]
 8014f50:	f7eb fae6 	bl	8000520 <__aeabi_ul2f>
 8014f54:	ee07 0a90 	vmov	s15, r0
 8014f58:	4a08      	ldr	r2, [pc, #32]	@ (8014f7c <forward_cast+0x3d78>)
 8014f5a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014f5e:	4b08      	ldr	r3, [pc, #32]	@ (8014f80 <forward_cast+0x3d7c>)
 8014f60:	ee17 0a90 	vmov	r0, s15
 8014f64:	f7fe ba99 	b.w	801349a <forward_cast+0x2296>
 8014f68:	f995 0000 	ldrsb.w	r0, [r5]
 8014f6c:	f7fe ba95 	b.w	801349a <forward_cast+0x2296>
 8014f70:	2300      	movs	r3, #0
 8014f72:	681b      	ldr	r3, [r3, #0]
 8014f74:	deff      	udf	#255	@ 0xff
 8014f76:	2300      	movs	r3, #0
 8014f78:	685b      	ldr	r3, [r3, #4]
 8014f7a:	deff      	udf	#255	@ 0xff
 8014f7c:	00060440 	.word	0x00060440
 8014f80:	00042040 	.word	0x00042040
 8014f84:	00041040 	.word	0x00041040
 8014f88:	00840840 	.word	0x00840840

08014f8c <forward_concat>:
 8014f8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014f90:	ed2d 8b04 	vpush	{d8-d9}
 8014f94:	6982      	ldr	r2, [r0, #24]
 8014f96:	b087      	sub	sp, #28
 8014f98:	8813      	ldrh	r3, [r2, #0]
 8014f9a:	9002      	str	r0, [sp, #8]
 8014f9c:	2b00      	cmp	r3, #0
 8014f9e:	f000 8290 	beq.w	80154c2 <forward_concat+0x536>
 8014fa2:	2b01      	cmp	r3, #1
 8014fa4:	6856      	ldr	r6, [r2, #4]
 8014fa6:	f000 828c 	beq.w	80154c2 <forward_concat+0x536>
 8014faa:	6933      	ldr	r3, [r6, #16]
 8014fac:	9301      	str	r3, [sp, #4]
 8014fae:	b10b      	cbz	r3, 8014fb4 <forward_concat+0x28>
 8014fb0:	681b      	ldr	r3, [r3, #0]
 8014fb2:	9301      	str	r3, [sp, #4]
 8014fb4:	8830      	ldrh	r0, [r6, #0]
 8014fb6:	2300      	movs	r3, #0
 8014fb8:	4604      	mov	r4, r0
 8014fba:	4619      	mov	r1, r3
 8014fbc:	e00c      	b.n	8014fd8 <forward_concat+0x4c>
 8014fbe:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8014fc2:	b172      	cbz	r2, 8014fe2 <forward_concat+0x56>
 8014fc4:	6992      	ldr	r2, [r2, #24]
 8014fc6:	3301      	adds	r3, #1
 8014fc8:	6812      	ldr	r2, [r2, #0]
 8014fca:	f3c2 4243 	ubfx	r2, r2, #17, #4
 8014fce:	2a01      	cmp	r2, #1
 8014fd0:	bf0c      	ite	eq
 8014fd2:	2201      	moveq	r2, #1
 8014fd4:	2202      	movne	r2, #2
 8014fd6:	4311      	orrs	r1, r2
 8014fd8:	4298      	cmp	r0, r3
 8014fda:	d002      	beq.n	8014fe2 <forward_concat+0x56>
 8014fdc:	6872      	ldr	r2, [r6, #4]
 8014fde:	2a00      	cmp	r2, #0
 8014fe0:	d1ed      	bne.n	8014fbe <forward_concat+0x32>
 8014fe2:	9b01      	ldr	r3, [sp, #4]
 8014fe4:	699a      	ldr	r2, [r3, #24]
 8014fe6:	6813      	ldr	r3, [r2, #0]
 8014fe8:	6897      	ldr	r7, [r2, #8]
 8014fea:	f3c3 4243 	ubfx	r2, r3, #17, #4
 8014fee:	2a01      	cmp	r2, #1
 8014ff0:	d137      	bne.n	8015062 <forward_concat+0xd6>
 8014ff2:	2901      	cmp	r1, #1
 8014ff4:	d13c      	bne.n	8015070 <forward_concat+0xe4>
 8014ff6:	f04f 0b00 	mov.w	fp, #0
 8014ffa:	455c      	cmp	r4, fp
 8014ffc:	d933      	bls.n	8015066 <forward_concat+0xda>
 8014ffe:	6873      	ldr	r3, [r6, #4]
 8015000:	b38b      	cbz	r3, 8015066 <forward_concat+0xda>
 8015002:	f853 402b 	ldr.w	r4, [r3, fp, lsl #2]
 8015006:	b374      	cbz	r4, 8015066 <forward_concat+0xda>
 8015008:	9b02      	ldr	r3, [sp, #8]
 801500a:	6961      	ldr	r1, [r4, #20]
 801500c:	69d8      	ldr	r0, [r3, #28]
 801500e:	68e2      	ldr	r2, [r4, #12]
 8015010:	9b01      	ldr	r3, [sp, #4]
 8015012:	f851 5020 	ldr.w	r5, [r1, r0, lsl #2]
 8015016:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
 801501a:	68db      	ldr	r3, [r3, #12]
 801501c:	f8d4 c018 	ldr.w	ip, [r4, #24]
 8015020:	fb02 f905 	mul.w	r9, r2, r5
 8015024:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8015028:	e9dc 0100 	ldrd	r0, r1, [ip]
 801502c:	fb03 f805 	mul.w	r8, r3, r5
 8015030:	f001 fe36 	bl	8016ca0 <ai_array_get_byte_size>
 8015034:	69a3      	ldr	r3, [r4, #24]
 8015036:	fbb0 f0f9 	udiv	r0, r0, r9
 801503a:	689c      	ldr	r4, [r3, #8]
 801503c:	fb09 4500 	mla	r5, r9, r0, r4
 8015040:	42ac      	cmp	r4, r5
 8015042:	d209      	bcs.n	8015058 <forward_concat+0xcc>
 8015044:	46ba      	mov	sl, r7
 8015046:	4620      	mov	r0, r4
 8015048:	444c      	add	r4, r9
 801504a:	4651      	mov	r1, sl
 801504c:	464a      	mov	r2, r9
 801504e:	f001 fcfb 	bl	8016a48 <st_int8_copy>
 8015052:	42a5      	cmp	r5, r4
 8015054:	44c2      	add	sl, r8
 8015056:	d8f6      	bhi.n	8015046 <forward_concat+0xba>
 8015058:	444f      	add	r7, r9
 801505a:	f10b 0b01 	add.w	fp, fp, #1
 801505e:	8834      	ldrh	r4, [r6, #0]
 8015060:	e7cb      	b.n	8014ffa <forward_concat+0x6e>
 8015062:	2901      	cmp	r1, #1
 8015064:	d108      	bne.n	8015078 <forward_concat+0xec>
 8015066:	b007      	add	sp, #28
 8015068:	ecbd 8b04 	vpop	{d8-d9}
 801506c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015070:	2a01      	cmp	r2, #1
 8015072:	d1f6      	bne.n	8015062 <forward_concat+0xd6>
 8015074:	078a      	lsls	r2, r1, #30
 8015076:	d4f6      	bmi.n	8015066 <forward_concat+0xda>
 8015078:	9a01      	ldr	r2, [sp, #4]
 801507a:	6811      	ldr	r1, [r2, #0]
 801507c:	460c      	mov	r4, r1
 801507e:	2900      	cmp	r1, #0
 8015080:	f000 8209 	beq.w	8015496 <forward_concat+0x50a>
 8015084:	684a      	ldr	r2, [r1, #4]
 8015086:	2a00      	cmp	r2, #0
 8015088:	f000 8205 	beq.w	8015496 <forward_concat+0x50a>
 801508c:	8849      	ldrh	r1, [r1, #2]
 801508e:	2900      	cmp	r1, #0
 8015090:	f000 8201 	beq.w	8015496 <forward_concat+0x50a>
 8015094:	6812      	ldr	r2, [r2, #0]
 8015096:	edd2 8a00 	vldr	s17, [r2]
 801509a:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 801509e:	f3c3 53c0 	ubfx	r3, r3, #23, #1
 80150a2:	9603      	str	r6, [sp, #12]
 80150a4:	4626      	mov	r6, r4
 80150a6:	9305      	str	r3, [sp, #20]
 80150a8:	2300      	movs	r3, #0
 80150aa:	ee87 9aa8 	vdiv.f32	s18, s15, s17
 80150ae:	ed9f 8ab2 	vldr	s16, [pc, #712]	@ 8015378 <forward_concat+0x3ec>
 80150b2:	4699      	mov	r9, r3
 80150b4:	4548      	cmp	r0, r9
 80150b6:	d9d6      	bls.n	8015066 <forward_concat+0xda>
 80150b8:	9b03      	ldr	r3, [sp, #12]
 80150ba:	685b      	ldr	r3, [r3, #4]
 80150bc:	2b00      	cmp	r3, #0
 80150be:	d0d2      	beq.n	8015066 <forward_concat+0xda>
 80150c0:	f853 3029 	ldr.w	r3, [r3, r9, lsl #2]
 80150c4:	2b00      	cmp	r3, #0
 80150c6:	d0ce      	beq.n	8015066 <forward_concat+0xda>
 80150c8:	9a02      	ldr	r2, [sp, #8]
 80150ca:	9304      	str	r3, [sp, #16]
 80150cc:	69d2      	ldr	r2, [r2, #28]
 80150ce:	e9d3 1005 	ldrd	r1, r0, [r3, #20]
 80150d2:	f851 4022 	ldr.w	r4, [r1, r2, lsl #2]
 80150d6:	68d9      	ldr	r1, [r3, #12]
 80150d8:	9b01      	ldr	r3, [sp, #4]
 80150da:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
 80150de:	fb01 fb04 	mul.w	fp, r1, r4
 80150e2:	68d9      	ldr	r1, [r3, #12]
 80150e4:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 80150e8:	fb02 f804 	mul.w	r8, r2, r4
 80150ec:	e9d0 4100 	ldrd	r4, r1, [r0]
 80150f0:	4620      	mov	r0, r4
 80150f2:	f001 fdd5 	bl	8016ca0 <ai_array_get_byte_size>
 80150f6:	9b04      	ldr	r3, [sp, #16]
 80150f8:	f3c4 4243 	ubfx	r2, r4, #17, #4
 80150fc:	6999      	ldr	r1, [r3, #24]
 80150fe:	2a01      	cmp	r2, #1
 8015100:	688c      	ldr	r4, [r1, #8]
 8015102:	fbb0 f0fb 	udiv	r0, r0, fp
 8015106:	fb0b 4500 	mla	r5, fp, r0, r4
 801510a:	d05f      	beq.n	80151cc <forward_concat+0x240>
 801510c:	681a      	ldr	r2, [r3, #0]
 801510e:	2a00      	cmp	r2, #0
 8015110:	f000 80d3 	beq.w	80152ba <forward_concat+0x32e>
 8015114:	6851      	ldr	r1, [r2, #4]
 8015116:	2900      	cmp	r1, #0
 8015118:	f000 8141 	beq.w	801539e <forward_concat+0x412>
 801511c:	8850      	ldrh	r0, [r2, #2]
 801511e:	2800      	cmp	r0, #0
 8015120:	f000 813a 	beq.w	8015398 <forward_concat+0x40c>
 8015124:	680b      	ldr	r3, [r1, #0]
 8015126:	edd3 6a00 	vldr	s13, [r3]
 801512a:	684b      	ldr	r3, [r1, #4]
 801512c:	f993 0000 	ldrsb.w	r0, [r3]
 8015130:	2e00      	cmp	r6, #0
 8015132:	f000 80c8 	beq.w	80152c6 <forward_concat+0x33a>
 8015136:	6873      	ldr	r3, [r6, #4]
 8015138:	2b00      	cmp	r3, #0
 801513a:	f000 8134 	beq.w	80153a6 <forward_concat+0x41a>
 801513e:	8871      	ldrh	r1, [r6, #2]
 8015140:	b111      	cbz	r1, 8015148 <forward_concat+0x1bc>
 8015142:	685b      	ldr	r3, [r3, #4]
 8015144:	f993 1000 	ldrsb.w	r1, [r3]
 8015148:	eef4 8a66 	vcmp.f32	s17, s13
 801514c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015150:	bf0c      	ite	eq
 8015152:	2301      	moveq	r3, #1
 8015154:	2300      	movne	r3, #0
 8015156:	4288      	cmp	r0, r1
 8015158:	d102      	bne.n	8015160 <forward_concat+0x1d4>
 801515a:	2b00      	cmp	r3, #0
 801515c:	f040 80b5 	bne.w	80152ca <forward_concat+0x33e>
 8015160:	9905      	ldr	r1, [sp, #20]
 8015162:	2900      	cmp	r1, #0
 8015164:	d17e      	bne.n	8015264 <forward_concat+0x2d8>
 8015166:	2a00      	cmp	r2, #0
 8015168:	f000 8198 	beq.w	801549c <forward_concat+0x510>
 801516c:	6851      	ldr	r1, [r2, #4]
 801516e:	2900      	cmp	r1, #0
 8015170:	f000 818a 	beq.w	8015488 <forward_concat+0x4fc>
 8015174:	8852      	ldrh	r2, [r2, #2]
 8015176:	2a00      	cmp	r2, #0
 8015178:	f000 8186 	beq.w	8015488 <forward_concat+0x4fc>
 801517c:	684a      	ldr	r2, [r1, #4]
 801517e:	f892 c000 	ldrb.w	ip, [r2]
 8015182:	2e00      	cmp	r6, #0
 8015184:	f000 8185 	beq.w	8015492 <forward_concat+0x506>
 8015188:	6871      	ldr	r1, [r6, #4]
 801518a:	2900      	cmp	r1, #0
 801518c:	f000 818c 	beq.w	80154a8 <forward_concat+0x51c>
 8015190:	8872      	ldrh	r2, [r6, #2]
 8015192:	b10a      	cbz	r2, 8015198 <forward_concat+0x20c>
 8015194:	684a      	ldr	r2, [r1, #4]
 8015196:	7812      	ldrb	r2, [r2, #0]
 8015198:	4594      	cmp	ip, r2
 801519a:	f040 8109 	bne.w	80153b0 <forward_concat+0x424>
 801519e:	2b00      	cmp	r3, #0
 80151a0:	f000 8106 	beq.w	80153b0 <forward_concat+0x424>
 80151a4:	42ac      	cmp	r4, r5
 80151a6:	d209      	bcs.n	80151bc <forward_concat+0x230>
 80151a8:	46ba      	mov	sl, r7
 80151aa:	4620      	mov	r0, r4
 80151ac:	445c      	add	r4, fp
 80151ae:	4651      	mov	r1, sl
 80151b0:	465a      	mov	r2, fp
 80151b2:	f001 fc49 	bl	8016a48 <st_int8_copy>
 80151b6:	42a5      	cmp	r5, r4
 80151b8:	44c2      	add	sl, r8
 80151ba:	d8f6      	bhi.n	80151aa <forward_concat+0x21e>
 80151bc:	eb07 0e0b 	add.w	lr, r7, fp
 80151c0:	4677      	mov	r7, lr
 80151c2:	9b03      	ldr	r3, [sp, #12]
 80151c4:	f109 0901 	add.w	r9, r9, #1
 80151c8:	8818      	ldrh	r0, [r3, #0]
 80151ca:	e773      	b.n	80150b4 <forward_concat+0x128>
 80151cc:	f1bb 0f00 	cmp.w	fp, #0
 80151d0:	4659      	mov	r1, fp
 80151d2:	9b05      	ldr	r3, [sp, #20]
 80151d4:	bfb8      	it	lt
 80151d6:	f10b 0103 	addlt.w	r1, fp, #3
 80151da:	1089      	asrs	r1, r1, #2
 80151dc:	2b00      	cmp	r3, #0
 80151de:	f040 8084 	bne.w	80152ea <forward_concat+0x35e>
 80151e2:	2e00      	cmp	r6, #0
 80151e4:	f000 80e1 	beq.w	80153aa <forward_concat+0x41e>
 80151e8:	6873      	ldr	r3, [r6, #4]
 80151ea:	2b00      	cmp	r3, #0
 80151ec:	f000 80dd 	beq.w	80153aa <forward_concat+0x41e>
 80151f0:	8872      	ldrh	r2, [r6, #2]
 80151f2:	2a00      	cmp	r2, #0
 80151f4:	f000 80d9 	beq.w	80153aa <forward_concat+0x41e>
 80151f8:	685b      	ldr	r3, [r3, #4]
 80151fa:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 80151fe:	781b      	ldrb	r3, [r3, #0]
 8015200:	ee06 3a90 	vmov	s13, r3
 8015204:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8015208:	ee76 6aa7 	vadd.f32	s13, s13, s15
 801520c:	42ac      	cmp	r4, r5
 801520e:	d227      	bcs.n	8015260 <forward_concat+0x2d4>
 8015210:	f1bb 0f03 	cmp.w	fp, #3
 8015214:	eba8 0801 	sub.w	r8, r8, r1
 8015218:	dd22      	ble.n	8015260 <forward_concat+0x2d4>
 801521a:	46be      	mov	lr, r7
 801521c:	46f4      	mov	ip, lr
 801521e:	4620      	mov	r0, r4
 8015220:	2200      	movs	r2, #0
 8015222:	f810 3b01 	ldrb.w	r3, [r0], #1
 8015226:	eef0 7a66 	vmov.f32	s15, s13
 801522a:	ee07 3a10 	vmov	s14, r3
 801522e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8015232:	eee7 7a09 	vfma.f32	s15, s14, s18
 8015236:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801523a:	ee17 3a90 	vmov	r3, s15
 801523e:	f383 0308 	usat	r3, #8, r3
 8015242:	3201      	adds	r2, #1
 8015244:	f80c 3b01 	strb.w	r3, [ip], #1
 8015248:	4291      	cmp	r1, r2
 801524a:	dcea      	bgt.n	8015222 <forward_concat+0x296>
 801524c:	f1bb 0f03 	cmp.w	fp, #3
 8015250:	bfcc      	ite	gt
 8015252:	460b      	movgt	r3, r1
 8015254:	2301      	movle	r3, #1
 8015256:	441c      	add	r4, r3
 8015258:	4443      	add	r3, r8
 801525a:	42a5      	cmp	r5, r4
 801525c:	449e      	add	lr, r3
 801525e:	d8dd      	bhi.n	801521c <forward_concat+0x290>
 8015260:	440f      	add	r7, r1
 8015262:	e7ae      	b.n	80151c2 <forward_concat+0x236>
 8015264:	b142      	cbz	r2, 8015278 <forward_concat+0x2ec>
 8015266:	6851      	ldr	r1, [r2, #4]
 8015268:	2900      	cmp	r1, #0
 801526a:	f000 811f 	beq.w	80154ac <forward_concat+0x520>
 801526e:	8852      	ldrh	r2, [r2, #2]
 8015270:	b112      	cbz	r2, 8015278 <forward_concat+0x2ec>
 8015272:	684a      	ldr	r2, [r1, #4]
 8015274:	f992 2000 	ldrsb.w	r2, [r2]
 8015278:	2e00      	cmp	r6, #0
 801527a:	f000 8111 	beq.w	80154a0 <forward_concat+0x514>
 801527e:	6870      	ldr	r0, [r6, #4]
 8015280:	2800      	cmp	r0, #0
 8015282:	f000 810f 	beq.w	80154a4 <forward_concat+0x518>
 8015286:	8871      	ldrh	r1, [r6, #2]
 8015288:	b111      	cbz	r1, 8015290 <forward_concat+0x304>
 801528a:	6841      	ldr	r1, [r0, #4]
 801528c:	f991 1000 	ldrsb.w	r1, [r1]
 8015290:	428a      	cmp	r2, r1
 8015292:	f040 80bf 	bne.w	8015414 <forward_concat+0x488>
 8015296:	2b00      	cmp	r3, #0
 8015298:	f000 80bc 	beq.w	8015414 <forward_concat+0x488>
 801529c:	42ac      	cmp	r4, r5
 801529e:	d28d      	bcs.n	80151bc <forward_concat+0x230>
 80152a0:	46ba      	mov	sl, r7
 80152a2:	4620      	mov	r0, r4
 80152a4:	445c      	add	r4, fp
 80152a6:	4651      	mov	r1, sl
 80152a8:	465a      	mov	r2, fp
 80152aa:	f001 fbcd 	bl	8016a48 <st_int8_copy>
 80152ae:	42a5      	cmp	r5, r4
 80152b0:	44c2      	add	sl, r8
 80152b2:	d8f6      	bhi.n	80152a2 <forward_concat+0x316>
 80152b4:	eb07 0e0b 	add.w	lr, r7, fp
 80152b8:	e782      	b.n	80151c0 <forward_concat+0x234>
 80152ba:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 80152be:	4610      	mov	r0, r2
 80152c0:	2e00      	cmp	r6, #0
 80152c2:	f47f af38 	bne.w	8015136 <forward_concat+0x1aa>
 80152c6:	4631      	mov	r1, r6
 80152c8:	e73e      	b.n	8015148 <forward_concat+0x1bc>
 80152ca:	42ac      	cmp	r4, r5
 80152cc:	f4bf af76 	bcs.w	80151bc <forward_concat+0x230>
 80152d0:	46ba      	mov	sl, r7
 80152d2:	4620      	mov	r0, r4
 80152d4:	445c      	add	r4, fp
 80152d6:	4651      	mov	r1, sl
 80152d8:	465a      	mov	r2, fp
 80152da:	f001 fbb5 	bl	8016a48 <st_int8_copy>
 80152de:	42a5      	cmp	r5, r4
 80152e0:	44c2      	add	sl, r8
 80152e2:	d8f6      	bhi.n	80152d2 <forward_concat+0x346>
 80152e4:	eb07 0e0b 	add.w	lr, r7, fp
 80152e8:	e76a      	b.n	80151c0 <forward_concat+0x234>
 80152ea:	2e00      	cmp	r6, #0
 80152ec:	f000 80e0 	beq.w	80154b0 <forward_concat+0x524>
 80152f0:	6873      	ldr	r3, [r6, #4]
 80152f2:	2b00      	cmp	r3, #0
 80152f4:	f000 80e2 	beq.w	80154bc <forward_concat+0x530>
 80152f8:	8872      	ldrh	r2, [r6, #2]
 80152fa:	2a00      	cmp	r2, #0
 80152fc:	f000 80db 	beq.w	80154b6 <forward_concat+0x52a>
 8015300:	685b      	ldr	r3, [r3, #4]
 8015302:	f993 3000 	ldrsb.w	r3, [r3]
 8015306:	ee06 3a90 	vmov	s13, r3
 801530a:	42ac      	cmp	r4, r5
 801530c:	d2a8      	bcs.n	8015260 <forward_concat+0x2d4>
 801530e:	f1bb 0f03 	cmp.w	fp, #3
 8015312:	eba8 0801 	sub.w	r8, r8, r1
 8015316:	dda3      	ble.n	8015260 <forward_concat+0x2d4>
 8015318:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 801531c:	46be      	mov	lr, r7
 801531e:	eeb6 6a00 	vmov.f32	s12, #96	@ 0x3f000000  0.5
 8015322:	46f4      	mov	ip, lr
 8015324:	4620      	mov	r0, r4
 8015326:	2200      	movs	r2, #0
 8015328:	f810 3b01 	ldrb.w	r3, [r0], #1
 801532c:	eef0 7a66 	vmov.f32	s15, s13
 8015330:	ee07 3a10 	vmov	s14, r3
 8015334:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8015338:	eee7 7a09 	vfma.f32	s15, s14, s18
 801533c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8015340:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015344:	d41a      	bmi.n	801537c <forward_concat+0x3f0>
 8015346:	ee77 7a86 	vadd.f32	s15, s15, s12
 801534a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801534e:	ee17 3a90 	vmov	r3, s15
 8015352:	f303 0307 	ssat	r3, #8, r3
 8015356:	3201      	adds	r2, #1
 8015358:	f80c 3b01 	strb.w	r3, [ip], #1
 801535c:	4291      	cmp	r1, r2
 801535e:	dce3      	bgt.n	8015328 <forward_concat+0x39c>
 8015360:	f1bb 0f03 	cmp.w	fp, #3
 8015364:	bfcc      	ite	gt
 8015366:	460b      	movgt	r3, r1
 8015368:	2301      	movle	r3, #1
 801536a:	441c      	add	r4, r3
 801536c:	4443      	add	r3, r8
 801536e:	42a5      	cmp	r5, r4
 8015370:	449e      	add	lr, r3
 8015372:	d8d6      	bhi.n	8015322 <forward_concat+0x396>
 8015374:	440f      	add	r7, r1
 8015376:	e724      	b.n	80151c2 <forward_concat+0x236>
 8015378:	3efffffc 	.word	0x3efffffc
 801537c:	ee77 7ac8 	vsub.f32	s15, s15, s16
 8015380:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8015384:	ee17 3a90 	vmov	r3, s15
 8015388:	f303 0307 	ssat	r3, #8, r3
 801538c:	3201      	adds	r2, #1
 801538e:	f80c 3b01 	strb.w	r3, [ip], #1
 8015392:	428a      	cmp	r2, r1
 8015394:	dbc8      	blt.n	8015328 <forward_concat+0x39c>
 8015396:	e7e3      	b.n	8015360 <forward_concat+0x3d4>
 8015398:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 801539c:	e6c8      	b.n	8015130 <forward_concat+0x1a4>
 801539e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 80153a2:	4608      	mov	r0, r1
 80153a4:	e6c4      	b.n	8015130 <forward_concat+0x1a4>
 80153a6:	4619      	mov	r1, r3
 80153a8:	e6ce      	b.n	8015148 <forward_concat+0x1bc>
 80153aa:	eef6 6a00 	vmov.f32	s13, #96	@ 0x3f000000  0.5
 80153ae:	e72d      	b.n	801520c <forward_concat+0x280>
 80153b0:	42ac      	cmp	r4, r5
 80153b2:	ee69 6a26 	vmul.f32	s13, s18, s13
 80153b6:	f4bf af01 	bcs.w	80151bc <forward_concat+0x230>
 80153ba:	f1bb 0f00 	cmp.w	fp, #0
 80153be:	f77f aefd 	ble.w	80151bc <forward_concat+0x230>
 80153c2:	ee07 2a90 	vmov	s15, r2
 80153c6:	eb07 0e0b 	add.w	lr, r7, fp
 80153ca:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
 80153ce:	4670      	mov	r0, lr
 80153d0:	eef6 7a00 	vmov.f32	s15, #96	@ 0x3f000000  0.5
 80153d4:	ee36 6a27 	vadd.f32	s12, s12, s15
 80153d8:	463a      	mov	r2, r7
 80153da:	4621      	mov	r1, r4
 80153dc:	f811 3b01 	ldrb.w	r3, [r1], #1
 80153e0:	eeb0 7a46 	vmov.f32	s14, s12
 80153e4:	eba3 030c 	sub.w	r3, r3, ip
 80153e8:	ee07 3a90 	vmov	s15, r3
 80153ec:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80153f0:	eea7 7aa6 	vfma.f32	s14, s15, s13
 80153f4:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 80153f8:	ee17 3a90 	vmov	r3, s15
 80153fc:	f383 0308 	usat	r3, #8, r3
 8015400:	f802 3b01 	strb.w	r3, [r2], #1
 8015404:	4282      	cmp	r2, r0
 8015406:	d1e9      	bne.n	80153dc <forward_concat+0x450>
 8015408:	445c      	add	r4, fp
 801540a:	4447      	add	r7, r8
 801540c:	4440      	add	r0, r8
 801540e:	42ac      	cmp	r4, r5
 8015410:	d3e2      	bcc.n	80153d8 <forward_concat+0x44c>
 8015412:	e6d5      	b.n	80151c0 <forward_concat+0x234>
 8015414:	42ac      	cmp	r4, r5
 8015416:	ee69 6a26 	vmul.f32	s13, s18, s13
 801541a:	f4bf aecf 	bcs.w	80151bc <forward_concat+0x230>
 801541e:	f1bb 0f00 	cmp.w	fp, #0
 8015422:	f77f aecb 	ble.w	80151bc <forward_concat+0x230>
 8015426:	ee07 1a90 	vmov	s15, r1
 801542a:	eb04 000b 	add.w	r0, r4, fp
 801542e:	eef6 5a00 	vmov.f32	s11, #96	@ 0x3f000000  0.5
 8015432:	46bc      	mov	ip, r7
 8015434:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
 8015438:	4601      	mov	r1, r0
 801543a:	46e6      	mov	lr, ip
 801543c:	f914 3b01 	ldrsb.w	r3, [r4], #1
 8015440:	1a9b      	subs	r3, r3, r2
 8015442:	ee07 3a90 	vmov	s15, r3
 8015446:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801544a:	eef0 7a46 	vmov.f32	s15, s12
 801544e:	eee7 7a26 	vfma.f32	s15, s14, s13
 8015452:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8015456:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801545a:	bf4c      	ite	mi
 801545c:	ee77 7ac8 	vsubmi.f32	s15, s15, s16
 8015460:	ee77 7aa5 	vaddpl.f32	s15, s15, s11
 8015464:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8015468:	ee17 3a90 	vmov	r3, s15
 801546c:	f303 0307 	ssat	r3, #8, r3
 8015470:	428c      	cmp	r4, r1
 8015472:	f80e 3b01 	strb.w	r3, [lr], #1
 8015476:	d1e1      	bne.n	801543c <forward_concat+0x4b0>
 8015478:	42a8      	cmp	r0, r5
 801547a:	44c4      	add	ip, r8
 801547c:	4459      	add	r1, fp
 801547e:	4604      	mov	r4, r0
 8015480:	f4bf ae9c 	bcs.w	80151bc <forward_concat+0x230>
 8015484:	4458      	add	r0, fp
 8015486:	e7d8      	b.n	801543a <forward_concat+0x4ae>
 8015488:	f8dd c014 	ldr.w	ip, [sp, #20]
 801548c:	2e00      	cmp	r6, #0
 801548e:	f47f ae7b 	bne.w	8015188 <forward_concat+0x1fc>
 8015492:	4632      	mov	r2, r6
 8015494:	e680      	b.n	8015198 <forward_concat+0x20c>
 8015496:	eef7 8a00 	vmov.f32	s17, #112	@ 0x3f800000  1.0
 801549a:	e5fe      	b.n	801509a <forward_concat+0x10e>
 801549c:	468c      	mov	ip, r1
 801549e:	e670      	b.n	8015182 <forward_concat+0x1f6>
 80154a0:	4631      	mov	r1, r6
 80154a2:	e6f5      	b.n	8015290 <forward_concat+0x304>
 80154a4:	4601      	mov	r1, r0
 80154a6:	e6f3      	b.n	8015290 <forward_concat+0x304>
 80154a8:	460a      	mov	r2, r1
 80154aa:	e675      	b.n	8015198 <forward_concat+0x20c>
 80154ac:	460a      	mov	r2, r1
 80154ae:	e6e3      	b.n	8015278 <forward_concat+0x2ec>
 80154b0:	ee06 6a90 	vmov	s13, r6
 80154b4:	e729      	b.n	801530a <forward_concat+0x37e>
 80154b6:	ee06 2a90 	vmov	s13, r2
 80154ba:	e726      	b.n	801530a <forward_concat+0x37e>
 80154bc:	ee06 3a90 	vmov	s13, r3
 80154c0:	e723      	b.n	801530a <forward_concat+0x37e>
 80154c2:	2300      	movs	r3, #0
 80154c4:	685b      	ldr	r3, [r3, #4]
 80154c6:	deff      	udf	#255	@ 0xff

080154c8 <forward_argmax>:
 80154c8:	6983      	ldr	r3, [r0, #24]
 80154ca:	8819      	ldrh	r1, [r3, #0]
 80154cc:	b1f1      	cbz	r1, 801550c <forward_argmax+0x44>
 80154ce:	4602      	mov	r2, r0
 80154d0:	6858      	ldr	r0, [r3, #4]
 80154d2:	6843      	ldr	r3, [r0, #4]
 80154d4:	b103      	cbz	r3, 80154d8 <forward_argmax+0x10>
 80154d6:	681b      	ldr	r3, [r3, #0]
 80154d8:	2901      	cmp	r1, #1
 80154da:	d019      	beq.n	8015510 <forward_argmax+0x48>
 80154dc:	6901      	ldr	r1, [r0, #16]
 80154de:	b1d1      	cbz	r1, 8015516 <forward_argmax+0x4e>
 80154e0:	b570      	push	{r4, r5, r6, lr}
 80154e2:	6809      	ldr	r1, [r1, #0]
 80154e4:	b084      	sub	sp, #16
 80154e6:	68dc      	ldr	r4, [r3, #12]
 80154e8:	6998      	ldr	r0, [r3, #24]
 80154ea:	f9b2 601e 	ldrsh.w	r6, [r2, #30]
 80154ee:	f9b2 501c 	ldrsh.w	r5, [r2, #28]
 80154f2:	6989      	ldr	r1, [r1, #24]
 80154f4:	68e3      	ldr	r3, [r4, #12]
 80154f6:	68a2      	ldr	r2, [r4, #8]
 80154f8:	6880      	ldr	r0, [r0, #8]
 80154fa:	6889      	ldr	r1, [r1, #8]
 80154fc:	e9cd 5601 	strd	r5, r6, [sp, #4]
 8015500:	6864      	ldr	r4, [r4, #4]
 8015502:	9400      	str	r4, [sp, #0]
 8015504:	f000 fb78 	bl	8015bf8 <forward_lite_argmax_if32>
 8015508:	b004      	add	sp, #16
 801550a:	bd70      	pop	{r4, r5, r6, pc}
 801550c:	684b      	ldr	r3, [r1, #4]
 801550e:	deff      	udf	#255	@ 0xff
 8015510:	2300      	movs	r3, #0
 8015512:	685b      	ldr	r3, [r3, #4]
 8015514:	deff      	udf	#255	@ 0xff
 8015516:	698b      	ldr	r3, [r1, #24]
 8015518:	deff      	udf	#255	@ 0xff
 801551a:	bf00      	nop

0801551c <forward_eltwise>:
 801551c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015520:	6982      	ldr	r2, [r0, #24]
 8015522:	b09d      	sub	sp, #116	@ 0x74
 8015524:	8811      	ldrh	r1, [r2, #0]
 8015526:	9003      	str	r0, [sp, #12]
 8015528:	2900      	cmp	r1, #0
 801552a:	f000 80c7 	beq.w	80156bc <forward_eltwise+0x1a0>
 801552e:	6853      	ldr	r3, [r2, #4]
 8015530:	2b00      	cmp	r3, #0
 8015532:	f000 8116 	beq.w	8015762 <forward_eltwise+0x246>
 8015536:	8818      	ldrh	r0, [r3, #0]
 8015538:	f8d3 8004 	ldr.w	r8, [r3, #4]
 801553c:	f1b8 0f00 	cmp.w	r8, #0
 8015540:	d001      	beq.n	8015546 <forward_eltwise+0x2a>
 8015542:	f8d8 8000 	ldr.w	r8, [r8]
 8015546:	2901      	cmp	r1, #1
 8015548:	f000 810f 	beq.w	801576a <forward_eltwise+0x24e>
 801554c:	691b      	ldr	r3, [r3, #16]
 801554e:	9300      	str	r3, [sp, #0]
 8015550:	b10b      	cbz	r3, 8015556 <forward_eltwise+0x3a>
 8015552:	681b      	ldr	r3, [r3, #0]
 8015554:	9300      	str	r3, [sp, #0]
 8015556:	2300      	movs	r3, #0
 8015558:	2801      	cmp	r0, #1
 801555a:	930d      	str	r3, [sp, #52]	@ 0x34
 801555c:	9312      	str	r3, [sp, #72]	@ 0x48
 801555e:	9317      	str	r3, [sp, #92]	@ 0x5c
 8015560:	e9cd 330e 	strd	r3, r3, [sp, #56]	@ 0x38
 8015564:	e9cd 3310 	strd	r3, r3, [sp, #64]	@ 0x40
 8015568:	e9cd 3313 	strd	r3, r3, [sp, #76]	@ 0x4c
 801556c:	e9cd 3315 	strd	r3, r3, [sp, #84]	@ 0x54
 8015570:	e9cd 3318 	strd	r3, r3, [sp, #96]	@ 0x60
 8015574:	e9cd 331a 	strd	r3, r3, [sp, #104]	@ 0x68
 8015578:	ab0d      	add	r3, sp, #52	@ 0x34
 801557a:	9308      	str	r3, [sp, #32]
 801557c:	ab12      	add	r3, sp, #72	@ 0x48
 801557e:	930a      	str	r3, [sp, #40]	@ 0x28
 8015580:	ab17      	add	r3, sp, #92	@ 0x5c
 8015582:	930c      	str	r3, [sp, #48]	@ 0x30
 8015584:	f240 5302 	movw	r3, #1282	@ 0x502
 8015588:	9307      	str	r3, [sp, #28]
 801558a:	9309      	str	r3, [sp, #36]	@ 0x24
 801558c:	f240 5301 	movw	r3, #1281	@ 0x501
 8015590:	930b      	str	r3, [sp, #44]	@ 0x2c
 8015592:	9b03      	ldr	r3, [sp, #12]
 8015594:	e9d3 7307 	ldrd	r7, r3, [r3, #28]
 8015598:	9304      	str	r3, [sp, #16]
 801559a:	f240 80d8 	bls.w	801574e <forward_eltwise+0x232>
 801559e:	0083      	lsls	r3, r0, #2
 80155a0:	9305      	str	r3, [sp, #20]
 80155a2:	2304      	movs	r3, #4
 80155a4:	9301      	str	r3, [sp, #4]
 80155a6:	8813      	ldrh	r3, [r2, #0]
 80155a8:	2b00      	cmp	r3, #0
 80155aa:	f000 80e1 	beq.w	8015770 <forward_eltwise+0x254>
 80155ae:	6853      	ldr	r3, [r2, #4]
 80155b0:	685b      	ldr	r3, [r3, #4]
 80155b2:	2b00      	cmp	r3, #0
 80155b4:	f000 80d7 	beq.w	8015766 <forward_eltwise+0x24a>
 80155b8:	9a01      	ldr	r2, [sp, #4]
 80155ba:	f108 0108 	add.w	r1, r8, #8
 80155be:	f8d8 0008 	ldr.w	r0, [r8, #8]
 80155c2:	f853 a002 	ldr.w	sl, [r3, r2]
 80155c6:	f8da 3008 	ldr.w	r3, [sl, #8]
 80155ca:	f10a 0908 	add.w	r9, sl, #8
 80155ce:	4043      	eors	r3, r0
 80155d0:	f033 03ff 	bics.w	r3, r3, #255	@ 0xff
 80155d4:	d10f      	bne.n	80155f6 <forward_eltwise+0xda>
 80155d6:	f3c0 2017 	ubfx	r0, r0, #8, #24
 80155da:	2800      	cmp	r0, #0
 80155dc:	f000 8097 	beq.w	801570e <forward_eltwise+0x1f2>
 80155e0:	3801      	subs	r0, #1
 80155e2:	f8d8 200c 	ldr.w	r2, [r8, #12]
 80155e6:	f8da 300c 	ldr.w	r3, [sl, #12]
 80155ea:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
 80155ee:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80155f2:	429a      	cmp	r2, r3
 80155f4:	d0f1      	beq.n	80155da <forward_eltwise+0xbe>
 80155f6:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80155fa:	464a      	mov	r2, r9
 80155fc:	a80b      	add	r0, sp, #44	@ 0x2c
 80155fe:	9102      	str	r1, [sp, #8]
 8015600:	689d      	ldr	r5, [r3, #8]
 8015602:	f8da 3018 	ldr.w	r3, [sl, #24]
 8015606:	689c      	ldr	r4, [r3, #8]
 8015608:	9b00      	ldr	r3, [sp, #0]
 801560a:	699b      	ldr	r3, [r3, #24]
 801560c:	689e      	ldr	r6, [r3, #8]
 801560e:	f001 fb9d 	bl	8016d4c <core_get_broadcasted_shape>
 8015612:	f8da 2014 	ldr.w	r2, [sl, #20]
 8015616:	a807      	add	r0, sp, #28
 8015618:	f8d8 3014 	ldr.w	r3, [r8, #20]
 801561c:	f8d2 a004 	ldr.w	sl, [r2, #4]
 8015620:	9a00      	ldr	r2, [sp, #0]
 8015622:	9902      	ldr	r1, [sp, #8]
 8015624:	6952      	ldr	r2, [r2, #20]
 8015626:	685b      	ldr	r3, [r3, #4]
 8015628:	f8d2 8004 	ldr.w	r8, [r2, #4]
 801562c:	aa0b      	add	r2, sp, #44	@ 0x2c
 801562e:	f001 fbb5 	bl	8016d9c <core_compute_offsets>
 8015632:	4653      	mov	r3, sl
 8015634:	aa0b      	add	r2, sp, #44	@ 0x2c
 8015636:	4649      	mov	r1, r9
 8015638:	a809      	add	r0, sp, #36	@ 0x24
 801563a:	f001 fbaf 	bl	8016d9c <core_compute_offsets>
 801563e:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 8015640:	68d3      	ldr	r3, [r2, #12]
 8015642:	2b00      	cmp	r3, #0
 8015644:	d058      	beq.n	80156f8 <forward_eltwise+0x1dc>
 8015646:	2300      	movs	r3, #0
 8015648:	6891      	ldr	r1, [r2, #8]
 801564a:	9302      	str	r3, [sp, #8]
 801564c:	2900      	cmp	r1, #0
 801564e:	d053      	beq.n	80156f8 <forward_eltwise+0x1dc>
 8015650:	980b      	ldr	r0, [sp, #44]	@ 0x2c
 8015652:	f04f 0b00 	mov.w	fp, #0
 8015656:	f3c0 2017 	ubfx	r0, r0, #8, #24
 801565a:	f04f 0a00 	mov.w	sl, #0
 801565e:	2804      	cmp	r0, #4
 8015660:	bf8c      	ite	hi
 8015662:	6913      	ldrhi	r3, [r2, #16]
 8015664:	2301      	movls	r3, #1
 8015666:	459a      	cmp	sl, r3
 8015668:	d22a      	bcs.n	80156c0 <forward_eltwise+0x1a4>
 801566a:	6851      	ldr	r1, [r2, #4]
 801566c:	b1a9      	cbz	r1, 801569a <forward_eltwise+0x17e>
 801566e:	f04f 0900 	mov.w	r9, #0
 8015672:	4622      	mov	r2, r4
 8015674:	4629      	mov	r1, r5
 8015676:	4630      	mov	r0, r6
 8015678:	f109 0901 	add.w	r9, r9, #1
 801567c:	47b8      	blx	r7
 801567e:	9b08      	ldr	r3, [sp, #32]
 8015680:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 8015682:	4446      	add	r6, r8
 8015684:	685b      	ldr	r3, [r3, #4]
 8015686:	441d      	add	r5, r3
 8015688:	9b0a      	ldr	r3, [sp, #40]	@ 0x28
 801568a:	685b      	ldr	r3, [r3, #4]
 801568c:	441c      	add	r4, r3
 801568e:	6853      	ldr	r3, [r2, #4]
 8015690:	454b      	cmp	r3, r9
 8015692:	d8ee      	bhi.n	8015672 <forward_eltwise+0x156>
 8015694:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8015696:	f3c3 2017 	ubfx	r0, r3, #8, #24
 801569a:	9907      	ldr	r1, [sp, #28]
 801569c:	f5b1 6fa0 	cmp.w	r1, #1280	@ 0x500
 80156a0:	d302      	bcc.n	80156a8 <forward_eltwise+0x18c>
 80156a2:	9908      	ldr	r1, [sp, #32]
 80156a4:	690b      	ldr	r3, [r1, #16]
 80156a6:	441d      	add	r5, r3
 80156a8:	9909      	ldr	r1, [sp, #36]	@ 0x24
 80156aa:	f5b1 6fa0 	cmp.w	r1, #1280	@ 0x500
 80156ae:	d302      	bcc.n	80156b6 <forward_eltwise+0x19a>
 80156b0:	990a      	ldr	r1, [sp, #40]	@ 0x28
 80156b2:	690b      	ldr	r3, [r1, #16]
 80156b4:	441c      	add	r4, r3
 80156b6:	f10a 0a01 	add.w	sl, sl, #1
 80156ba:	e7d0      	b.n	801565e <forward_eltwise+0x142>
 80156bc:	684b      	ldr	r3, [r1, #4]
 80156be:	deff      	udf	#255	@ 0xff
 80156c0:	9b08      	ldr	r3, [sp, #32]
 80156c2:	f10b 0b01 	add.w	fp, fp, #1
 80156c6:	f8dd 9028 	ldr.w	r9, [sp, #40]	@ 0x28
 80156ca:	6899      	ldr	r1, [r3, #8]
 80156cc:	f8d2 c008 	ldr.w	ip, [r2, #8]
 80156d0:	440d      	add	r5, r1
 80156d2:	f8d9 1008 	ldr.w	r1, [r9, #8]
 80156d6:	45dc      	cmp	ip, fp
 80156d8:	440c      	add	r4, r1
 80156da:	d8be      	bhi.n	801565a <forward_eltwise+0x13e>
 80156dc:	68d8      	ldr	r0, [r3, #12]
 80156de:	469e      	mov	lr, r3
 80156e0:	f8d9 300c 	ldr.w	r3, [r9, #12]
 80156e4:	4661      	mov	r1, ip
 80156e6:	4405      	add	r5, r0
 80156e8:	441c      	add	r4, r3
 80156ea:	9b02      	ldr	r3, [sp, #8]
 80156ec:	3301      	adds	r3, #1
 80156ee:	4618      	mov	r0, r3
 80156f0:	9302      	str	r3, [sp, #8]
 80156f2:	68d3      	ldr	r3, [r2, #12]
 80156f4:	4298      	cmp	r0, r3
 80156f6:	d3a9      	bcc.n	801564c <forward_eltwise+0x130>
 80156f8:	9b01      	ldr	r3, [sp, #4]
 80156fa:	9a05      	ldr	r2, [sp, #20]
 80156fc:	3304      	adds	r3, #4
 80156fe:	4293      	cmp	r3, r2
 8015700:	9301      	str	r3, [sp, #4]
 8015702:	d024      	beq.n	801574e <forward_eltwise+0x232>
 8015704:	9b03      	ldr	r3, [sp, #12]
 8015706:	f8dd 8000 	ldr.w	r8, [sp]
 801570a:	699a      	ldr	r2, [r3, #24]
 801570c:	e74b      	b.n	80155a6 <forward_eltwise+0x8a>
 801570e:	9b00      	ldr	r3, [sp, #0]
 8015710:	464a      	mov	r2, r9
 8015712:	f8da 0018 	ldr.w	r0, [sl, #24]
 8015716:	699b      	ldr	r3, [r3, #24]
 8015718:	f8d8 4018 	ldr.w	r4, [r8, #24]
 801571c:	6885      	ldr	r5, [r0, #8]
 801571e:	a80b      	add	r0, sp, #44	@ 0x2c
 8015720:	689e      	ldr	r6, [r3, #8]
 8015722:	68a4      	ldr	r4, [r4, #8]
 8015724:	f001 fb12 	bl	8016d4c <core_get_broadcasted_shape>
 8015728:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 801572a:	0a1b      	lsrs	r3, r3, #8
 801572c:	d012      	beq.n	8015754 <forward_eltwise+0x238>
 801572e:	980c      	ldr	r0, [sp, #48]	@ 0x30
 8015730:	eb00 0283 	add.w	r2, r0, r3, lsl #2
 8015734:	2301      	movs	r3, #1
 8015736:	f852 1d04 	ldr.w	r1, [r2, #-4]!
 801573a:	4290      	cmp	r0, r2
 801573c:	fb01 f303 	mul.w	r3, r1, r3
 8015740:	d1f9      	bne.n	8015736 <forward_eltwise+0x21a>
 8015742:	4621      	mov	r1, r4
 8015744:	462a      	mov	r2, r5
 8015746:	4630      	mov	r0, r6
 8015748:	9c04      	ldr	r4, [sp, #16]
 801574a:	47a0      	blx	r4
 801574c:	e7d4      	b.n	80156f8 <forward_eltwise+0x1dc>
 801574e:	b01d      	add	sp, #116	@ 0x74
 8015750:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015754:	4621      	mov	r1, r4
 8015756:	2301      	movs	r3, #1
 8015758:	462a      	mov	r2, r5
 801575a:	4630      	mov	r0, r6
 801575c:	9c04      	ldr	r4, [sp, #16]
 801575e:	47a0      	blx	r4
 8015760:	e7ca      	b.n	80156f8 <forward_eltwise+0x1dc>
 8015762:	4618      	mov	r0, r3
 8015764:	e6e8      	b.n	8015538 <forward_eltwise+0x1c>
 8015766:	689b      	ldr	r3, [r3, #8]
 8015768:	deff      	udf	#255	@ 0xff
 801576a:	2300      	movs	r3, #0
 801576c:	685b      	ldr	r3, [r3, #4]
 801576e:	deff      	udf	#255	@ 0xff
 8015770:	685b      	ldr	r3, [r3, #4]
 8015772:	deff      	udf	#255	@ 0xff

08015774 <forward_arrayfeatureextractor>:
 8015774:	6982      	ldr	r2, [r0, #24]
 8015776:	8813      	ldrh	r3, [r2, #0]
 8015778:	2b00      	cmp	r3, #0
 801577a:	f000 80b5 	beq.w	80158e8 <forward_arrayfeatureextractor+0x174>
 801577e:	6852      	ldr	r2, [r2, #4]
 8015780:	2b01      	cmp	r3, #1
 8015782:	6853      	ldr	r3, [r2, #4]
 8015784:	bf14      	ite	ne
 8015786:	f102 010c 	addne.w	r1, r2, #12
 801578a:	2100      	moveq	r1, #0
 801578c:	2b00      	cmp	r3, #0
 801578e:	f000 8092 	beq.w	80158b6 <forward_arrayfeatureextractor+0x142>
 8015792:	e9d3 2300 	ldrd	r2, r3, [r3]
 8015796:	6849      	ldr	r1, [r1, #4]
 8015798:	2900      	cmp	r1, #0
 801579a:	f000 80a3 	beq.w	80158e4 <forward_arrayfeatureextractor+0x170>
 801579e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80157a2:	68d4      	ldr	r4, [r2, #12]
 80157a4:	b089      	sub	sp, #36	@ 0x24
 80157a6:	680d      	ldr	r5, [r1, #0]
 80157a8:	68e1      	ldr	r1, [r4, #12]
 80157aa:	699b      	ldr	r3, [r3, #24]
 80157ac:	9105      	str	r1, [sp, #20]
 80157ae:	68e9      	ldr	r1, [r5, #12]
 80157b0:	e9d2 2605 	ldrd	r2, r6, [r2, #20]
 80157b4:	f8d2 b004 	ldr.w	fp, [r2, #4]
 80157b8:	688a      	ldr	r2, [r1, #8]
 80157ba:	69a9      	ldr	r1, [r5, #24]
 80157bc:	9207      	str	r2, [sp, #28]
 80157be:	688a      	ldr	r2, [r1, #8]
 80157c0:	68b7      	ldr	r7, [r6, #8]
 80157c2:	9201      	str	r2, [sp, #4]
 80157c4:	68a2      	ldr	r2, [r4, #8]
 80157c6:	6864      	ldr	r4, [r4, #4]
 80157c8:	9206      	str	r2, [sp, #24]
 80157ca:	9403      	str	r4, [sp, #12]
 80157cc:	e9d6 0100 	ldrd	r0, r1, [r6]
 80157d0:	e9d3 6401 	ldrd	r6, r4, [r3, #4]
 80157d4:	f001 fa64 	bl	8016ca0 <ai_array_get_byte_size>
 80157d8:	69ab      	ldr	r3, [r5, #24]
 80157da:	e9d3 0100 	ldrd	r0, r1, [r3]
 80157de:	f001 fa5f 	bl	8016ca0 <ai_array_get_byte_size>
 80157e2:	9a06      	ldr	r2, [sp, #24]
 80157e4:	2a01      	cmp	r2, #1
 80157e6:	d033      	beq.n	8015850 <forward_arrayfeatureextractor+0xdc>
 80157e8:	9905      	ldr	r1, [sp, #20]
 80157ea:	b371      	cbz	r1, 801584a <forward_arrayfeatureextractor+0xd6>
 80157ec:	b36e      	cbz	r6, 801584a <forward_arrayfeatureextractor+0xd6>
 80157ee:	f04f 0900 	mov.w	r9, #0
 80157f2:	1f23      	subs	r3, r4, #4
 80157f4:	46da      	mov	sl, fp
 80157f6:	9304      	str	r3, [sp, #16]
 80157f8:	f8cd 9000 	str.w	r9, [sp]
 80157fc:	f8cd 9008 	str.w	r9, [sp, #8]
 8015800:	9b03      	ldr	r3, [sp, #12]
 8015802:	2500      	movs	r5, #0
 8015804:	f8dd b010 	ldr.w	fp, [sp, #16]
 8015808:	fb03 fa0a 	mul.w	sl, r3, sl
 801580c:	9b00      	ldr	r3, [sp, #0]
 801580e:	fb03 f80a 	mul.w	r8, r3, sl
 8015812:	9b01      	ldr	r3, [sp, #4]
 8015814:	fb09 340a 	mla	r4, r9, sl, r3
 8015818:	f85b 0f04 	ldr.w	r0, [fp, #4]!
 801581c:	3501      	adds	r5, #1
 801581e:	4621      	mov	r1, r4
 8015820:	4652      	mov	r2, sl
 8015822:	fb00 800a 	mla	r0, r0, sl, r8
 8015826:	4454      	add	r4, sl
 8015828:	4438      	add	r0, r7
 801582a:	f001 f90d 	bl	8016a48 <st_int8_copy>
 801582e:	42ae      	cmp	r6, r5
 8015830:	d1f2      	bne.n	8015818 <forward_arrayfeatureextractor+0xa4>
 8015832:	9a00      	ldr	r2, [sp, #0]
 8015834:	9906      	ldr	r1, [sp, #24]
 8015836:	9b02      	ldr	r3, [sp, #8]
 8015838:	440a      	add	r2, r1
 801583a:	3301      	adds	r3, #1
 801583c:	9200      	str	r2, [sp, #0]
 801583e:	9a07      	ldr	r2, [sp, #28]
 8015840:	9302      	str	r3, [sp, #8]
 8015842:	4491      	add	r9, r2
 8015844:	9a05      	ldr	r2, [sp, #20]
 8015846:	429a      	cmp	r2, r3
 8015848:	d1da      	bne.n	8015800 <forward_arrayfeatureextractor+0x8c>
 801584a:	b009      	add	sp, #36	@ 0x24
 801584c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015850:	9b05      	ldr	r3, [sp, #20]
 8015852:	2b01      	cmp	r3, #1
 8015854:	d031      	beq.n	80158ba <forward_arrayfeatureextractor+0x146>
 8015856:	9b03      	ldr	r3, [sp, #12]
 8015858:	2b00      	cmp	r3, #0
 801585a:	d0f6      	beq.n	801584a <forward_arrayfeatureextractor+0xd6>
 801585c:	9b05      	ldr	r3, [sp, #20]
 801585e:	fb03 f30b 	mul.w	r3, r3, fp
 8015862:	9300      	str	r3, [sp, #0]
 8015864:	2e00      	cmp	r6, #0
 8015866:	d0f0      	beq.n	801584a <forward_arrayfeatureextractor+0xd6>
 8015868:	1f23      	subs	r3, r4, #4
 801586a:	f04f 0800 	mov.w	r8, #0
 801586e:	9304      	str	r3, [sp, #16]
 8015870:	46c1      	mov	r9, r8
 8015872:	fb06 f30b 	mul.w	r3, r6, fp
 8015876:	9302      	str	r3, [sp, #8]
 8015878:	f8dd a010 	ldr.w	sl, [sp, #16]
 801587c:	2400      	movs	r4, #0
 801587e:	9d01      	ldr	r5, [sp, #4]
 8015880:	f85a 0f04 	ldr.w	r0, [sl, #4]!
 8015884:	3401      	adds	r4, #1
 8015886:	4629      	mov	r1, r5
 8015888:	465a      	mov	r2, fp
 801588a:	fb00 800b 	mla	r0, r0, fp, r8
 801588e:	445d      	add	r5, fp
 8015890:	4438      	add	r0, r7
 8015892:	f001 f8d9 	bl	8016a48 <st_int8_copy>
 8015896:	42a6      	cmp	r6, r4
 8015898:	d1f2      	bne.n	8015880 <forward_arrayfeatureextractor+0x10c>
 801589a:	f109 0901 	add.w	r9, r9, #1
 801589e:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
 80158a2:	4413      	add	r3, r2
 80158a4:	9301      	str	r3, [sp, #4]
 80158a6:	9b00      	ldr	r3, [sp, #0]
 80158a8:	4498      	add	r8, r3
 80158aa:	9b03      	ldr	r3, [sp, #12]
 80158ac:	454b      	cmp	r3, r9
 80158ae:	d1e3      	bne.n	8015878 <forward_arrayfeatureextractor+0x104>
 80158b0:	b009      	add	sp, #36	@ 0x24
 80158b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80158b6:	461a      	mov	r2, r3
 80158b8:	e76d      	b.n	8015796 <forward_arrayfeatureextractor+0x22>
 80158ba:	2e00      	cmp	r6, #0
 80158bc:	d0c5      	beq.n	801584a <forward_arrayfeatureextractor+0xd6>
 80158be:	3c04      	subs	r4, #4
 80158c0:	2500      	movs	r5, #0
 80158c2:	f8dd 8004 	ldr.w	r8, [sp, #4]
 80158c6:	f854 0f04 	ldr.w	r0, [r4, #4]!
 80158ca:	3501      	adds	r5, #1
 80158cc:	4641      	mov	r1, r8
 80158ce:	465a      	mov	r2, fp
 80158d0:	fb00 700b 	mla	r0, r0, fp, r7
 80158d4:	44d8      	add	r8, fp
 80158d6:	f001 f8b7 	bl	8016a48 <st_int8_copy>
 80158da:	42ae      	cmp	r6, r5
 80158dc:	d1f3      	bne.n	80158c6 <forward_arrayfeatureextractor+0x152>
 80158de:	b009      	add	sp, #36	@ 0x24
 80158e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80158e4:	68cb      	ldr	r3, [r1, #12]
 80158e6:	deff      	udf	#255	@ 0xff
 80158e8:	685b      	ldr	r3, [r3, #4]
 80158ea:	deff      	udf	#255	@ 0xff

080158ec <forward_zipmap>:
 80158ec:	6982      	ldr	r2, [r0, #24]
 80158ee:	8813      	ldrh	r3, [r2, #0]
 80158f0:	2b00      	cmp	r3, #0
 80158f2:	d074      	beq.n	80159de <forward_zipmap+0xf2>
 80158f4:	6851      	ldr	r1, [r2, #4]
 80158f6:	684a      	ldr	r2, [r1, #4]
 80158f8:	b102      	cbz	r2, 80158fc <forward_zipmap+0x10>
 80158fa:	6812      	ldr	r2, [r2, #0]
 80158fc:	2b01      	cmp	r3, #1
 80158fe:	f000 8097 	beq.w	8015a30 <forward_zipmap+0x144>
 8015902:	6908      	ldr	r0, [r1, #16]
 8015904:	2800      	cmp	r0, #0
 8015906:	f000 8091 	beq.w	8015a2c <forward_zipmap+0x140>
 801590a:	2b02      	cmp	r3, #2
 801590c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015910:	6994      	ldr	r4, [r2, #24]
 8015912:	b083      	sub	sp, #12
 8015914:	68d2      	ldr	r2, [r2, #12]
 8015916:	6800      	ldr	r0, [r0, #0]
 8015918:	68d7      	ldr	r7, [r2, #12]
 801591a:	6980      	ldr	r0, [r0, #24]
 801591c:	6852      	ldr	r2, [r2, #4]
 801591e:	68a5      	ldr	r5, [r4, #8]
 8015920:	fb02 f707 	mul.w	r7, r2, r7
 8015924:	6884      	ldr	r4, [r0, #8]
 8015926:	d07e      	beq.n	8015a26 <forward_zipmap+0x13a>
 8015928:	69cb      	ldr	r3, [r1, #28]
 801592a:	2b00      	cmp	r3, #0
 801592c:	d079      	beq.n	8015a22 <forward_zipmap+0x136>
 801592e:	681b      	ldr	r3, [r3, #0]
 8015930:	699a      	ldr	r2, [r3, #24]
 8015932:	68d9      	ldr	r1, [r3, #12]
 8015934:	6813      	ldr	r3, [r2, #0]
 8015936:	f8d1 8004 	ldr.w	r8, [r1, #4]
 801593a:	f8d2 9008 	ldr.w	r9, [r2, #8]
 801593e:	f3c3 13c6 	ubfx	r3, r3, #7, #7
 8015942:	2f00      	cmp	r7, #0
 8015944:	d048      	beq.n	80159d8 <forward_zipmap+0xec>
 8015946:	2600      	movs	r6, #0
 8015948:	2b10      	cmp	r3, #16
 801594a:	f10d 0a04 	add.w	sl, sp, #4
 801594e:	46b3      	mov	fp, r6
 8015950:	d03d      	beq.n	80159ce <forward_zipmap+0xe2>
 8015952:	2b08      	cmp	r3, #8
 8015954:	d11b      	bne.n	801598e <forward_zipmap+0xa2>
 8015956:	e05f      	b.n	8015a18 <forward_zipmap+0x12c>
 8015958:	4633      	mov	r3, r6
 801595a:	3601      	adds	r6, #1
 801595c:	eb09 0383 	add.w	r3, r9, r3, lsl #2
 8015960:	4621      	mov	r1, r4
 8015962:	2204      	movs	r2, #4
 8015964:	4650      	mov	r0, sl
 8015966:	edd3 7a00 	vldr	s15, [r3]
 801596a:	f10b 0b01 	add.w	fp, fp, #1
 801596e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8015972:	edcd 7a01 	vstr	s15, [sp, #4]
 8015976:	f001 f867 	bl	8016a48 <st_int8_copy>
 801597a:	1d21      	adds	r1, r4, #4
 801597c:	4628      	mov	r0, r5
 801597e:	2204      	movs	r2, #4
 8015980:	3408      	adds	r4, #8
 8015982:	f001 f861 	bl	8016a48 <st_int8_copy>
 8015986:	455f      	cmp	r7, fp
 8015988:	f105 0504 	add.w	r5, r5, #4
 801598c:	d024      	beq.n	80159d8 <forward_zipmap+0xec>
 801598e:	45b0      	cmp	r8, r6
 8015990:	d1e2      	bne.n	8015958 <forward_zipmap+0x6c>
 8015992:	2601      	movs	r6, #1
 8015994:	2300      	movs	r3, #0
 8015996:	e7e1      	b.n	801595c <forward_zipmap+0x70>
 8015998:	4633      	mov	r3, r6
 801599a:	3601      	adds	r6, #1
 801599c:	f839 3013 	ldrh.w	r3, [r9, r3, lsl #1]
 80159a0:	4621      	mov	r1, r4
 80159a2:	2204      	movs	r2, #4
 80159a4:	4650      	mov	r0, sl
 80159a6:	ee07 3a90 	vmov	s15, r3
 80159aa:	f10b 0b01 	add.w	fp, fp, #1
 80159ae:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80159b2:	edcd 7a01 	vstr	s15, [sp, #4]
 80159b6:	f001 f847 	bl	8016a48 <st_int8_copy>
 80159ba:	1d21      	adds	r1, r4, #4
 80159bc:	4628      	mov	r0, r5
 80159be:	2204      	movs	r2, #4
 80159c0:	3408      	adds	r4, #8
 80159c2:	f001 f841 	bl	8016a48 <st_int8_copy>
 80159c6:	455f      	cmp	r7, fp
 80159c8:	f105 0504 	add.w	r5, r5, #4
 80159cc:	d004      	beq.n	80159d8 <forward_zipmap+0xec>
 80159ce:	45b0      	cmp	r8, r6
 80159d0:	d1e2      	bne.n	8015998 <forward_zipmap+0xac>
 80159d2:	2601      	movs	r6, #1
 80159d4:	2300      	movs	r3, #0
 80159d6:	e7e1      	b.n	801599c <forward_zipmap+0xb0>
 80159d8:	b003      	add	sp, #12
 80159da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80159de:	685b      	ldr	r3, [r3, #4]
 80159e0:	deff      	udf	#255	@ 0xff
 80159e2:	4633      	mov	r3, r6
 80159e4:	3601      	adds	r6, #1
 80159e6:	f819 3003 	ldrb.w	r3, [r9, r3]
 80159ea:	4621      	mov	r1, r4
 80159ec:	2204      	movs	r2, #4
 80159ee:	4650      	mov	r0, sl
 80159f0:	ee07 3a90 	vmov	s15, r3
 80159f4:	f10b 0b01 	add.w	fp, fp, #1
 80159f8:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80159fc:	edcd 7a01 	vstr	s15, [sp, #4]
 8015a00:	f001 f822 	bl	8016a48 <st_int8_copy>
 8015a04:	1d21      	adds	r1, r4, #4
 8015a06:	4628      	mov	r0, r5
 8015a08:	2204      	movs	r2, #4
 8015a0a:	3408      	adds	r4, #8
 8015a0c:	f001 f81c 	bl	8016a48 <st_int8_copy>
 8015a10:	455f      	cmp	r7, fp
 8015a12:	f105 0504 	add.w	r5, r5, #4
 8015a16:	d0df      	beq.n	80159d8 <forward_zipmap+0xec>
 8015a18:	45b0      	cmp	r8, r6
 8015a1a:	d1e2      	bne.n	80159e2 <forward_zipmap+0xf6>
 8015a1c:	2601      	movs	r6, #1
 8015a1e:	2300      	movs	r3, #0
 8015a20:	e7e1      	b.n	80159e6 <forward_zipmap+0xfa>
 8015a22:	68db      	ldr	r3, [r3, #12]
 8015a24:	deff      	udf	#255	@ 0xff
 8015a26:	2300      	movs	r3, #0
 8015a28:	685b      	ldr	r3, [r3, #4]
 8015a2a:	deff      	udf	#255	@ 0xff
 8015a2c:	6983      	ldr	r3, [r0, #24]
 8015a2e:	deff      	udf	#255	@ 0xff
 8015a30:	2300      	movs	r3, #0
 8015a32:	685b      	ldr	r3, [r3, #4]
 8015a34:	deff      	udf	#255	@ 0xff
 8015a36:	bf00      	nop

08015a38 <forward_sigmoid>:
 8015a38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8015a3a:	ed2d 8b02 	vpush	{d8}
 8015a3e:	6982      	ldr	r2, [r0, #24]
 8015a40:	8813      	ldrh	r3, [r2, #0]
 8015a42:	2b00      	cmp	r3, #0
 8015a44:	d03b      	beq.n	8015abe <forward_sigmoid+0x86>
 8015a46:	6852      	ldr	r2, [r2, #4]
 8015a48:	6854      	ldr	r4, [r2, #4]
 8015a4a:	b104      	cbz	r4, 8015a4e <forward_sigmoid+0x16>
 8015a4c:	6824      	ldr	r4, [r4, #0]
 8015a4e:	2b01      	cmp	r3, #1
 8015a50:	d034      	beq.n	8015abc <forward_sigmoid+0x84>
 8015a52:	6915      	ldr	r5, [r2, #16]
 8015a54:	b105      	cbz	r5, 8015a58 <forward_sigmoid+0x20>
 8015a56:	682d      	ldr	r5, [r5, #0]
 8015a58:	68a3      	ldr	r3, [r4, #8]
 8015a5a:	0a1b      	lsrs	r3, r3, #8
 8015a5c:	d031      	beq.n	8015ac2 <forward_sigmoid+0x8a>
 8015a5e:	68e0      	ldr	r0, [r4, #12]
 8015a60:	2201      	movs	r2, #1
 8015a62:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8015a66:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 8015a6a:	4298      	cmp	r0, r3
 8015a6c:	fb01 f202 	mul.w	r2, r1, r2
 8015a70:	d1f9      	bne.n	8015a66 <forward_sigmoid+0x2e>
 8015a72:	69a7      	ldr	r7, [r4, #24]
 8015a74:	f06f 4340 	mvn.w	r3, #3221225472	@ 0xc0000000
 8015a78:	69a9      	ldr	r1, [r5, #24]
 8015a7a:	4413      	add	r3, r2
 8015a7c:	68ba      	ldr	r2, [r7, #8]
 8015a7e:	688e      	ldr	r6, [r1, #8]
 8015a80:	eb02 0583 	add.w	r5, r2, r3, lsl #2
 8015a84:	eb06 0683 	add.w	r6, r6, r3, lsl #2
 8015a88:	42aa      	cmp	r2, r5
 8015a8a:	d814      	bhi.n	8015ab6 <forward_sigmoid+0x7e>
 8015a8c:	eeb7 8a00 	vmov.f32	s16, #112	@ 0x3f800000  1.0
 8015a90:	3504      	adds	r5, #4
 8015a92:	3604      	adds	r6, #4
 8015a94:	462c      	mov	r4, r5
 8015a96:	ed35 0a01 	vldmdb	r5!, {s0}
 8015a9a:	eeb1 0a40 	vneg.f32	s0, s0
 8015a9e:	3c08      	subs	r4, #8
 8015aa0:	f002 fb8e 	bl	80181c0 <expf>
 8015aa4:	ee30 0a08 	vadd.f32	s0, s0, s16
 8015aa8:	eec8 7a00 	vdiv.f32	s15, s16, s0
 8015aac:	ed66 7a01 	vstmdb	r6!, {s15}
 8015ab0:	68bb      	ldr	r3, [r7, #8]
 8015ab2:	42a3      	cmp	r3, r4
 8015ab4:	d9ee      	bls.n	8015a94 <forward_sigmoid+0x5c>
 8015ab6:	ecbd 8b02 	vpop	{d8}
 8015aba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8015abc:	2300      	movs	r3, #0
 8015abe:	685b      	ldr	r3, [r3, #4]
 8015ac0:	deff      	udf	#255	@ 0xff
 8015ac2:	69ab      	ldr	r3, [r5, #24]
 8015ac4:	69a7      	ldr	r7, [r4, #24]
 8015ac6:	689e      	ldr	r6, [r3, #8]
 8015ac8:	68bd      	ldr	r5, [r7, #8]
 8015aca:	e7df      	b.n	8015a8c <forward_sigmoid+0x54>

08015acc <forward_relu>:
 8015acc:	6982      	ldr	r2, [r0, #24]
 8015ace:	8813      	ldrh	r3, [r2, #0]
 8015ad0:	b323      	cbz	r3, 8015b1c <forward_relu+0x50>
 8015ad2:	6851      	ldr	r1, [r2, #4]
 8015ad4:	684a      	ldr	r2, [r1, #4]
 8015ad6:	b102      	cbz	r2, 8015ada <forward_relu+0xe>
 8015ad8:	6812      	ldr	r2, [r2, #0]
 8015ada:	2b01      	cmp	r3, #1
 8015adc:	f000 8086 	beq.w	8015bec <forward_relu+0x120>
 8015ae0:	b470      	push	{r4, r5, r6}
 8015ae2:	690b      	ldr	r3, [r1, #16]
 8015ae4:	b103      	cbz	r3, 8015ae8 <forward_relu+0x1c>
 8015ae6:	681b      	ldr	r3, [r3, #0]
 8015ae8:	69c6      	ldr	r6, [r0, #28]
 8015aea:	b1ce      	cbz	r6, 8015b20 <forward_relu+0x54>
 8015aec:	6871      	ldr	r1, [r6, #4]
 8015aee:	6998      	ldr	r0, [r3, #24]
 8015af0:	2901      	cmp	r1, #1
 8015af2:	d03f      	beq.n	8015b74 <forward_relu+0xa8>
 8015af4:	6893      	ldr	r3, [r2, #8]
 8015af6:	6991      	ldr	r1, [r2, #24]
 8015af8:	0a1b      	lsrs	r3, r3, #8
 8015afa:	6880      	ldr	r0, [r0, #8]
 8015afc:	6889      	ldr	r1, [r1, #8]
 8015afe:	d06c      	beq.n	8015bda <forward_relu+0x10e>
 8015b00:	68d5      	ldr	r5, [r2, #12]
 8015b02:	2201      	movs	r2, #1
 8015b04:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8015b08:	f853 4d04 	ldr.w	r4, [r3, #-4]!
 8015b0c:	429d      	cmp	r5, r3
 8015b0e:	fb04 f202 	mul.w	r2, r4, r2
 8015b12:	d1f9      	bne.n	8015b08 <forward_relu+0x3c>
 8015b14:	68b3      	ldr	r3, [r6, #8]
 8015b16:	bc70      	pop	{r4, r5, r6}
 8015b18:	f000 b928 	b.w	8015d6c <forward_lite_nl_relu_generic_if32of32_kernel>
 8015b1c:	685b      	ldr	r3, [r3, #4]
 8015b1e:	deff      	udf	#255	@ 0xff
 8015b20:	6999      	ldr	r1, [r3, #24]
 8015b22:	6893      	ldr	r3, [r2, #8]
 8015b24:	6990      	ldr	r0, [r2, #24]
 8015b26:	0a1b      	lsrs	r3, r3, #8
 8015b28:	6889      	ldr	r1, [r1, #8]
 8015b2a:	6884      	ldr	r4, [r0, #8]
 8015b2c:	d057      	beq.n	8015bde <forward_relu+0x112>
 8015b2e:	68d5      	ldr	r5, [r2, #12]
 8015b30:	2201      	movs	r2, #1
 8015b32:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8015b36:	f853 0d04 	ldr.w	r0, [r3, #-4]!
 8015b3a:	429d      	cmp	r5, r3
 8015b3c:	fb00 f202 	mul.w	r2, r0, r2
 8015b40:	d1f9      	bne.n	8015b36 <forward_relu+0x6a>
 8015b42:	f06f 4340 	mvn.w	r3, #3221225472	@ 0xc0000000
 8015b46:	4413      	add	r3, r2
 8015b48:	eb04 0283 	add.w	r2, r4, r3, lsl #2
 8015b4c:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 8015b50:	4294      	cmp	r4, r2
 8015b52:	d80d      	bhi.n	8015b70 <forward_relu+0xa4>
 8015b54:	3204      	adds	r2, #4
 8015b56:	3104      	adds	r1, #4
 8015b58:	ed9f 7a26 	vldr	s14, [pc, #152]	@ 8015bf4 <forward_relu+0x128>
 8015b5c:	4613      	mov	r3, r2
 8015b5e:	ed72 7a01 	vldmdb	r2!, {s15}
 8015b62:	3b08      	subs	r3, #8
 8015b64:	fec7 7a87 	vmaxnm.f32	s15, s15, s14
 8015b68:	ed61 7a01 	vstmdb	r1!, {s15}
 8015b6c:	429c      	cmp	r4, r3
 8015b6e:	d9f5      	bls.n	8015b5c <forward_relu+0x90>
 8015b70:	bc70      	pop	{r4, r5, r6}
 8015b72:	4770      	bx	lr
 8015b74:	6993      	ldr	r3, [r2, #24]
 8015b76:	6880      	ldr	r0, [r0, #8]
 8015b78:	689c      	ldr	r4, [r3, #8]
 8015b7a:	6893      	ldr	r3, [r2, #8]
 8015b7c:	0a1b      	lsrs	r3, r3, #8
 8015b7e:	d030      	beq.n	8015be2 <forward_relu+0x116>
 8015b80:	68d5      	ldr	r5, [r2, #12]
 8015b82:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8015b86:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 8015b8a:	429d      	cmp	r5, r3
 8015b8c:	fb02 f101 	mul.w	r1, r2, r1
 8015b90:	d1f9      	bne.n	8015b86 <forward_relu+0xba>
 8015b92:	f06f 4240 	mvn.w	r2, #3221225472	@ 0xc0000000
 8015b96:	68b3      	ldr	r3, [r6, #8]
 8015b98:	440a      	add	r2, r1
 8015b9a:	ed93 7a00 	vldr	s14, [r3]
 8015b9e:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 8015ba2:	eb00 0082 	add.w	r0, r0, r2, lsl #2
 8015ba6:	429c      	cmp	r4, r3
 8015ba8:	d8e2      	bhi.n	8015b70 <forward_relu+0xa4>
 8015baa:	1d02      	adds	r2, r0, #4
 8015bac:	3304      	adds	r3, #4
 8015bae:	2000      	movs	r0, #0
 8015bb0:	ed53 7a01 	vldr	s15, [r3, #-4]
 8015bb4:	1f19      	subs	r1, r3, #4
 8015bb6:	3b08      	subs	r3, #8
 8015bb8:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8015bbc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015bc0:	d405      	bmi.n	8015bce <forward_relu+0x102>
 8015bc2:	429c      	cmp	r4, r3
 8015bc4:	f842 0d04 	str.w	r0, [r2, #-4]!
 8015bc8:	d8d2      	bhi.n	8015b70 <forward_relu+0xa4>
 8015bca:	460b      	mov	r3, r1
 8015bcc:	e7f0      	b.n	8015bb0 <forward_relu+0xe4>
 8015bce:	429c      	cmp	r4, r3
 8015bd0:	ed62 7a01 	vstmdb	r2!, {s15}
 8015bd4:	d8cc      	bhi.n	8015b70 <forward_relu+0xa4>
 8015bd6:	460b      	mov	r3, r1
 8015bd8:	e7ea      	b.n	8015bb0 <forward_relu+0xe4>
 8015bda:	2201      	movs	r2, #1
 8015bdc:	e79a      	b.n	8015b14 <forward_relu+0x48>
 8015bde:	4622      	mov	r2, r4
 8015be0:	e7b8      	b.n	8015b54 <forward_relu+0x88>
 8015be2:	68b2      	ldr	r2, [r6, #8]
 8015be4:	4623      	mov	r3, r4
 8015be6:	ed92 7a00 	vldr	s14, [r2]
 8015bea:	e7de      	b.n	8015baa <forward_relu+0xde>
 8015bec:	2300      	movs	r3, #0
 8015bee:	685b      	ldr	r3, [r3, #4]
 8015bf0:	deff      	udf	#255	@ 0xff
 8015bf2:	bf00      	nop
 8015bf4:	00000000 	.word	0x00000000

08015bf8 <forward_lite_argmax_if32>:
 8015bf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015bfc:	ed2d 8b02 	vpush	{d8}
 8015c00:	b089      	sub	sp, #36	@ 0x24
 8015c02:	4616      	mov	r6, r2
 8015c04:	4683      	mov	fp, r0
 8015c06:	460c      	mov	r4, r1
 8015c08:	9304      	str	r3, [sp, #16]
 8015c0a:	f9bd 3054 	ldrsh.w	r3, [sp, #84]	@ 0x54
 8015c0e:	f9bd 2058 	ldrsh.w	r2, [sp, #88]	@ 0x58
 8015c12:	2b03      	cmp	r3, #3
 8015c14:	9f14      	ldr	r7, [sp, #80]	@ 0x50
 8015c16:	9205      	str	r2, [sp, #20]
 8015c18:	d05c      	beq.n	8015cd4 <forward_lite_argmax_if32+0xdc>
 8015c1a:	2b02      	cmp	r3, #2
 8015c1c:	9b04      	ldr	r3, [sp, #16]
 8015c1e:	d03f      	beq.n	8015ca0 <forward_lite_argmax_if32+0xa8>
 8015c20:	b36b      	cbz	r3, 8015c7e <forward_lite_argmax_if32+0x86>
 8015c22:	fb07 f306 	mul.w	r3, r7, r6
 8015c26:	f04f 0a00 	mov.w	sl, #0
 8015c2a:	ea4f 0887 	mov.w	r8, r7, lsl #2
 8015c2e:	46bb      	mov	fp, r7
 8015c30:	9306      	str	r3, [sp, #24]
 8015c32:	46d1      	mov	r9, sl
 8015c34:	00b3      	lsls	r3, r6, #2
 8015c36:	ee08 0a10 	vmov	s16, r0
 8015c3a:	4657      	mov	r7, sl
 8015c3c:	9103      	str	r1, [sp, #12]
 8015c3e:	9307      	str	r3, [sp, #28]
 8015c40:	b196      	cbz	r6, 8015c68 <forward_lite_argmax_if32+0x70>
 8015c42:	ee18 3a10 	vmov	r3, s16
 8015c46:	9c05      	ldr	r4, [sp, #20]
 8015c48:	9d03      	ldr	r5, [sp, #12]
 8015c4a:	eb03 0a87 	add.w	sl, r3, r7, lsl #2
 8015c4e:	b1dc      	cbz	r4, 8015c88 <forward_lite_argmax_if32+0x90>
 8015c50:	2400      	movs	r4, #0
 8015c52:	3401      	adds	r4, #1
 8015c54:	4629      	mov	r1, r5
 8015c56:	4650      	mov	r0, sl
 8015c58:	465a      	mov	r2, fp
 8015c5a:	f000 f92d 	bl	8015eb8 <forward_lite_argmax_latest_f32_kernel_ch>
 8015c5e:	42a6      	cmp	r6, r4
 8015c60:	f105 0504 	add.w	r5, r5, #4
 8015c64:	44c2      	add	sl, r8
 8015c66:	d1f4      	bne.n	8015c52 <forward_lite_argmax_if32+0x5a>
 8015c68:	9b03      	ldr	r3, [sp, #12]
 8015c6a:	f109 0901 	add.w	r9, r9, #1
 8015c6e:	9a07      	ldr	r2, [sp, #28]
 8015c70:	4413      	add	r3, r2
 8015c72:	9303      	str	r3, [sp, #12]
 8015c74:	9b06      	ldr	r3, [sp, #24]
 8015c76:	441f      	add	r7, r3
 8015c78:	9b04      	ldr	r3, [sp, #16]
 8015c7a:	454b      	cmp	r3, r9
 8015c7c:	d1e0      	bne.n	8015c40 <forward_lite_argmax_if32+0x48>
 8015c7e:	b009      	add	sp, #36	@ 0x24
 8015c80:	ecbd 8b02 	vpop	{d8}
 8015c84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015c88:	3401      	adds	r4, #1
 8015c8a:	4629      	mov	r1, r5
 8015c8c:	4650      	mov	r0, sl
 8015c8e:	465a      	mov	r2, fp
 8015c90:	f000 f8f2 	bl	8015e78 <forward_lite_argmax_f32_kernel_ch>
 8015c94:	42a6      	cmp	r6, r4
 8015c96:	f105 0504 	add.w	r5, r5, #4
 8015c9a:	44c2      	add	sl, r8
 8015c9c:	d1f4      	bne.n	8015c88 <forward_lite_argmax_if32+0x90>
 8015c9e:	e7e3      	b.n	8015c68 <forward_lite_argmax_if32+0x70>
 8015ca0:	2b00      	cmp	r3, #0
 8015ca2:	d0ec      	beq.n	8015c7e <forward_lite_argmax_if32+0x86>
 8015ca4:	4615      	mov	r5, r2
 8015ca6:	fb07 f806 	mul.w	r8, r7, r6
 8015caa:	2a00      	cmp	r2, #0
 8015cac:	d149      	bne.n	8015d42 <forward_lite_argmax_if32+0x14a>
 8015cae:	ea4f 0a87 	mov.w	sl, r7, lsl #2
 8015cb2:	4691      	mov	r9, r2
 8015cb4:	462b      	mov	r3, r5
 8015cb6:	4621      	mov	r1, r4
 8015cb8:	4632      	mov	r2, r6
 8015cba:	4658      	mov	r0, fp
 8015cbc:	f109 0901 	add.w	r9, r9, #1
 8015cc0:	4445      	add	r5, r8
 8015cc2:	4454      	add	r4, sl
 8015cc4:	e9cd 7700 	strd	r7, r7, [sp]
 8015cc8:	f000 f916 	bl	8015ef8 <forward_lite_argmax_f32_kernel>
 8015ccc:	9b04      	ldr	r3, [sp, #16]
 8015cce:	454b      	cmp	r3, r9
 8015cd0:	d1f0      	bne.n	8015cb4 <forward_lite_argmax_if32+0xbc>
 8015cd2:	e7d4      	b.n	8015c7e <forward_lite_argmax_if32+0x86>
 8015cd4:	2e00      	cmp	r6, #0
 8015cd6:	d0d2      	beq.n	8015c7e <forward_lite_argmax_if32+0x86>
 8015cd8:	fb07 f806 	mul.w	r8, r7, r6
 8015cdc:	b9c2      	cbnz	r2, 8015d10 <forward_lite_argmax_if32+0x118>
 8015cde:	4644      	mov	r4, r8
 8015ce0:	4615      	mov	r5, r2
 8015ce2:	4691      	mov	r9, r2
 8015ce4:	f8dd a010 	ldr.w	sl, [sp, #16]
 8015ce8:	4688      	mov	r8, r1
 8015cea:	f109 0901 	add.w	r9, r9, #1
 8015cee:	462b      	mov	r3, r5
 8015cf0:	eb08 0185 	add.w	r1, r8, r5, lsl #2
 8015cf4:	4652      	mov	r2, sl
 8015cf6:	4658      	mov	r0, fp
 8015cf8:	443d      	add	r5, r7
 8015cfa:	e9cd 4700 	strd	r4, r7, [sp]
 8015cfe:	f000 f8fb 	bl	8015ef8 <forward_lite_argmax_f32_kernel>
 8015d02:	45b1      	cmp	r9, r6
 8015d04:	d1f1      	bne.n	8015cea <forward_lite_argmax_if32+0xf2>
 8015d06:	b009      	add	sp, #36	@ 0x24
 8015d08:	ecbd 8b02 	vpop	{d8}
 8015d0c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015d10:	2500      	movs	r5, #0
 8015d12:	4644      	mov	r4, r8
 8015d14:	f8dd a010 	ldr.w	sl, [sp, #16]
 8015d18:	4688      	mov	r8, r1
 8015d1a:	46a9      	mov	r9, r5
 8015d1c:	f109 0901 	add.w	r9, r9, #1
 8015d20:	462b      	mov	r3, r5
 8015d22:	eb08 0185 	add.w	r1, r8, r5, lsl #2
 8015d26:	4652      	mov	r2, sl
 8015d28:	4658      	mov	r0, fp
 8015d2a:	443d      	add	r5, r7
 8015d2c:	e9cd 4700 	strd	r4, r7, [sp]
 8015d30:	f000 f91a 	bl	8015f68 <forward_lite_argmax_latest_f32_kernel>
 8015d34:	454e      	cmp	r6, r9
 8015d36:	d1f1      	bne.n	8015d1c <forward_lite_argmax_if32+0x124>
 8015d38:	b009      	add	sp, #36	@ 0x24
 8015d3a:	ecbd 8b02 	vpop	{d8}
 8015d3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015d42:	2500      	movs	r5, #0
 8015d44:	ea4f 0a87 	mov.w	sl, r7, lsl #2
 8015d48:	46a9      	mov	r9, r5
 8015d4a:	462b      	mov	r3, r5
 8015d4c:	4621      	mov	r1, r4
 8015d4e:	4632      	mov	r2, r6
 8015d50:	4658      	mov	r0, fp
 8015d52:	f109 0901 	add.w	r9, r9, #1
 8015d56:	4445      	add	r5, r8
 8015d58:	4454      	add	r4, sl
 8015d5a:	e9cd 7700 	strd	r7, r7, [sp]
 8015d5e:	f000 f903 	bl	8015f68 <forward_lite_argmax_latest_f32_kernel>
 8015d62:	9b04      	ldr	r3, [sp, #16]
 8015d64:	454b      	cmp	r3, r9
 8015d66:	d1f0      	bne.n	8015d4a <forward_lite_argmax_if32+0x152>
 8015d68:	e789      	b.n	8015c7e <forward_lite_argmax_if32+0x86>
 8015d6a:	bf00      	nop

08015d6c <forward_lite_nl_relu_generic_if32of32_kernel>:
 8015d6c:	edd3 6a02 	vldr	s13, [r3, #8]
 8015d70:	ed93 7a00 	vldr	s14, [r3]
 8015d74:	eef5 6ac0 	vcmpe.f32	s13, #0.0
 8015d78:	ed93 6a01 	vldr	s12, [r3, #4]
 8015d7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015d80:	d42b      	bmi.n	8015dda <forward_lite_nl_relu_generic_if32of32_kernel+0x6e>
 8015d82:	f06f 4340 	mvn.w	r3, #3221225472	@ 0xc0000000
 8015d86:	4413      	add	r3, r2
 8015d88:	eb01 0283 	add.w	r2, r1, r3, lsl #2
 8015d8c:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 8015d90:	4291      	cmp	r1, r2
 8015d92:	d821      	bhi.n	8015dd8 <forward_lite_nl_relu_generic_if32of32_kernel+0x6c>
 8015d94:	f10c 0104 	add.w	r1, ip, #4
 8015d98:	1d13      	adds	r3, r2, #4
 8015d9a:	eba2 020c 	sub.w	r2, r2, ip
 8015d9e:	4408      	add	r0, r1
 8015da0:	e00c      	b.n	8015dbc <forward_lite_nl_relu_generic_if32of32_kernel+0x50>
 8015da2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8015da6:	ee77 5ac7 	vsub.f32	s11, s15, s14
 8015daa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015dae:	db01      	blt.n	8015db4 <forward_lite_nl_relu_generic_if32of32_kernel+0x48>
 8015db0:	ee65 7a86 	vmul.f32	s15, s11, s12
 8015db4:	4293      	cmp	r3, r2
 8015db6:	ed60 7a01 	vstmdb	r0!, {s15}
 8015dba:	d00c      	beq.n	8015dd6 <forward_lite_nl_relu_generic_if32of32_kernel+0x6a>
 8015dbc:	ed73 7a01 	vldmdb	r3!, {s15}
 8015dc0:	eef4 6ae7 	vcmpe.f32	s13, s15
 8015dc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015dc8:	daeb      	bge.n	8015da2 <forward_lite_nl_relu_generic_if32of32_kernel+0x36>
 8015dca:	eef0 7a66 	vmov.f32	s15, s13
 8015dce:	4293      	cmp	r3, r2
 8015dd0:	ed60 7a01 	vstmdb	r0!, {s15}
 8015dd4:	d1f2      	bne.n	8015dbc <forward_lite_nl_relu_generic_if32of32_kernel+0x50>
 8015dd6:	4770      	bx	lr
 8015dd8:	4770      	bx	lr
 8015dda:	eeb5 6a40 	vcmp.f32	s12, #0.0
 8015dde:	f06f 4340 	mvn.w	r3, #3221225472	@ 0xc0000000
 8015de2:	4413      	add	r3, r2
 8015de4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015de8:	eb01 0c83 	add.w	ip, r1, r3, lsl #2
 8015dec:	b500      	push	{lr}
 8015dee:	ea4f 0e83 	mov.w	lr, r3, lsl #2
 8015df2:	d019      	beq.n	8015e28 <forward_lite_nl_relu_generic_if32of32_kernel+0xbc>
 8015df4:	4561      	cmp	r1, ip
 8015df6:	d815      	bhi.n	8015e24 <forward_lite_nl_relu_generic_if32of32_kernel+0xb8>
 8015df8:	f10e 0204 	add.w	r2, lr, #4
 8015dfc:	f10c 0304 	add.w	r3, ip, #4
 8015e00:	ebac 010e 	sub.w	r1, ip, lr
 8015e04:	4402      	add	r2, r0
 8015e06:	ed73 7a01 	vldmdb	r3!, {s15}
 8015e0a:	eef4 7ac7 	vcmpe.f32	s15, s14
 8015e0e:	ee77 6ac7 	vsub.f32	s13, s15, s14
 8015e12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015e16:	ee66 6a86 	vmul.f32	s13, s13, s12
 8015e1a:	d827      	bhi.n	8015e6c <forward_lite_nl_relu_generic_if32of32_kernel+0x100>
 8015e1c:	428b      	cmp	r3, r1
 8015e1e:	ed62 6a01 	vstmdb	r2!, {s13}
 8015e22:	d1f0      	bne.n	8015e06 <forward_lite_nl_relu_generic_if32of32_kernel+0x9a>
 8015e24:	f85d fb04 	ldr.w	pc, [sp], #4
 8015e28:	4561      	cmp	r1, ip
 8015e2a:	d8fb      	bhi.n	8015e24 <forward_lite_nl_relu_generic_if32of32_kernel+0xb8>
 8015e2c:	f10e 0204 	add.w	r2, lr, #4
 8015e30:	f10c 0304 	add.w	r3, ip, #4
 8015e34:	ebac 010e 	sub.w	r1, ip, lr
 8015e38:	f04f 0c00 	mov.w	ip, #0
 8015e3c:	4402      	add	r2, r0
 8015e3e:	ed73 7a01 	vldmdb	r3!, {s15}
 8015e42:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8015e46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015e4a:	d40a      	bmi.n	8015e62 <forward_lite_nl_relu_generic_if32of32_kernel+0xf6>
 8015e4c:	428b      	cmp	r3, r1
 8015e4e:	f842 cd04 	str.w	ip, [r2, #-4]!
 8015e52:	d0e7      	beq.n	8015e24 <forward_lite_nl_relu_generic_if32of32_kernel+0xb8>
 8015e54:	ed73 7a01 	vldmdb	r3!, {s15}
 8015e58:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8015e5c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015e60:	d5f4      	bpl.n	8015e4c <forward_lite_nl_relu_generic_if32of32_kernel+0xe0>
 8015e62:	428b      	cmp	r3, r1
 8015e64:	ed62 7a01 	vstmdb	r2!, {s15}
 8015e68:	d1e9      	bne.n	8015e3e <forward_lite_nl_relu_generic_if32of32_kernel+0xd2>
 8015e6a:	e7db      	b.n	8015e24 <forward_lite_nl_relu_generic_if32of32_kernel+0xb8>
 8015e6c:	428b      	cmp	r3, r1
 8015e6e:	ed62 7a01 	vstmdb	r2!, {s15}
 8015e72:	d1c8      	bne.n	8015e06 <forward_lite_nl_relu_generic_if32of32_kernel+0x9a>
 8015e74:	e7d6      	b.n	8015e24 <forward_lite_nl_relu_generic_if32of32_kernel+0xb8>
 8015e76:	bf00      	nop

08015e78 <forward_lite_argmax_f32_kernel_ch>:
 8015e78:	b510      	push	{r4, lr}
 8015e7a:	2a01      	cmp	r2, #1
 8015e7c:	b082      	sub	sp, #8
 8015e7e:	f04f 0400 	mov.w	r4, #0
 8015e82:	ed90 7a00 	vldr	s14, [r0]
 8015e86:	9401      	str	r4, [sp, #4]
 8015e88:	d90f      	bls.n	8015eaa <forward_lite_argmax_f32_kernel_ch+0x32>
 8015e8a:	3004      	adds	r0, #4
 8015e8c:	2301      	movs	r3, #1
 8015e8e:	ecf0 7a01 	vldmia	r0!, {s15}
 8015e92:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8015e96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015e9a:	d502      	bpl.n	8015ea2 <forward_lite_argmax_f32_kernel_ch+0x2a>
 8015e9c:	eeb0 7a67 	vmov.f32	s14, s15
 8015ea0:	461c      	mov	r4, r3
 8015ea2:	3301      	adds	r3, #1
 8015ea4:	429a      	cmp	r2, r3
 8015ea6:	d1f2      	bne.n	8015e8e <forward_lite_argmax_f32_kernel_ch+0x16>
 8015ea8:	9401      	str	r4, [sp, #4]
 8015eaa:	2204      	movs	r2, #4
 8015eac:	eb0d 0002 	add.w	r0, sp, r2
 8015eb0:	f000 fdca 	bl	8016a48 <st_int8_copy>
 8015eb4:	b002      	add	sp, #8
 8015eb6:	bd10      	pop	{r4, pc}

08015eb8 <forward_lite_argmax_latest_f32_kernel_ch>:
 8015eb8:	b510      	push	{r4, lr}
 8015eba:	2a01      	cmp	r2, #1
 8015ebc:	b082      	sub	sp, #8
 8015ebe:	f04f 0400 	mov.w	r4, #0
 8015ec2:	ed90 7a00 	vldr	s14, [r0]
 8015ec6:	9401      	str	r4, [sp, #4]
 8015ec8:	d90f      	bls.n	8015eea <forward_lite_argmax_latest_f32_kernel_ch+0x32>
 8015eca:	3004      	adds	r0, #4
 8015ecc:	2301      	movs	r3, #1
 8015ece:	ecf0 7a01 	vldmia	r0!, {s15}
 8015ed2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8015ed6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015eda:	d802      	bhi.n	8015ee2 <forward_lite_argmax_latest_f32_kernel_ch+0x2a>
 8015edc:	eeb0 7a67 	vmov.f32	s14, s15
 8015ee0:	461c      	mov	r4, r3
 8015ee2:	3301      	adds	r3, #1
 8015ee4:	429a      	cmp	r2, r3
 8015ee6:	d1f2      	bne.n	8015ece <forward_lite_argmax_latest_f32_kernel_ch+0x16>
 8015ee8:	9401      	str	r4, [sp, #4]
 8015eea:	2204      	movs	r2, #4
 8015eec:	eb0d 0002 	add.w	r0, sp, r2
 8015ef0:	f000 fdaa 	bl	8016a48 <st_int8_copy>
 8015ef4:	b002      	add	sp, #8
 8015ef6:	bd10      	pop	{r4, pc}

08015ef8 <forward_lite_argmax_f32_kernel>:
 8015ef8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015efc:	b083      	sub	sp, #12
 8015efe:	9f0d      	ldr	r7, [sp, #52]	@ 0x34
 8015f00:	b37f      	cbz	r7, 8015f62 <forward_lite_argmax_f32_kernel+0x6a>
 8015f02:	461e      	mov	r6, r3
 8015f04:	eb00 0a83 	add.w	sl, r0, r3, lsl #2
 8015f08:	441f      	add	r7, r3
 8015f0a:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8015f0c:	4614      	mov	r4, r2
 8015f0e:	468b      	mov	fp, r1
 8015f10:	009d      	lsls	r5, r3, #2
 8015f12:	f04f 0800 	mov.w	r8, #0
 8015f16:	f1a5 0904 	sub.w	r9, r5, #4
 8015f1a:	2c01      	cmp	r4, #1
 8015f1c:	ecba 7a01 	vldmia	sl!, {s14}
 8015f20:	f8cd 8004 	str.w	r8, [sp, #4]
 8015f24:	d912      	bls.n	8015f4c <forward_lite_argmax_f32_kernel+0x54>
 8015f26:	eb09 0c0a 	add.w	ip, r9, sl
 8015f2a:	2300      	movs	r3, #0
 8015f2c:	2001      	movs	r0, #1
 8015f2e:	eddc 7a00 	vldr	s15, [ip]
 8015f32:	44ac      	add	ip, r5
 8015f34:	eef4 7ac7 	vcmpe.f32	s15, s14
 8015f38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015f3c:	dd02      	ble.n	8015f44 <forward_lite_argmax_f32_kernel+0x4c>
 8015f3e:	eeb0 7a67 	vmov.f32	s14, s15
 8015f42:	4603      	mov	r3, r0
 8015f44:	3001      	adds	r0, #1
 8015f46:	4284      	cmp	r4, r0
 8015f48:	d1f1      	bne.n	8015f2e <forward_lite_argmax_f32_kernel+0x36>
 8015f4a:	9301      	str	r3, [sp, #4]
 8015f4c:	2204      	movs	r2, #4
 8015f4e:	3601      	adds	r6, #1
 8015f50:	4659      	mov	r1, fp
 8015f52:	f10b 0b04 	add.w	fp, fp, #4
 8015f56:	eb0d 0002 	add.w	r0, sp, r2
 8015f5a:	f000 fd75 	bl	8016a48 <st_int8_copy>
 8015f5e:	42be      	cmp	r6, r7
 8015f60:	d1db      	bne.n	8015f1a <forward_lite_argmax_f32_kernel+0x22>
 8015f62:	b003      	add	sp, #12
 8015f64:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08015f68 <forward_lite_argmax_latest_f32_kernel>:
 8015f68:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015f6c:	b083      	sub	sp, #12
 8015f6e:	9f0d      	ldr	r7, [sp, #52]	@ 0x34
 8015f70:	b37f      	cbz	r7, 8015fd2 <forward_lite_argmax_latest_f32_kernel+0x6a>
 8015f72:	461e      	mov	r6, r3
 8015f74:	eb00 0a83 	add.w	sl, r0, r3, lsl #2
 8015f78:	441f      	add	r7, r3
 8015f7a:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8015f7c:	4614      	mov	r4, r2
 8015f7e:	468b      	mov	fp, r1
 8015f80:	009d      	lsls	r5, r3, #2
 8015f82:	f04f 0800 	mov.w	r8, #0
 8015f86:	f1a5 0904 	sub.w	r9, r5, #4
 8015f8a:	2c01      	cmp	r4, #1
 8015f8c:	ecba 7a01 	vldmia	sl!, {s14}
 8015f90:	f8cd 8004 	str.w	r8, [sp, #4]
 8015f94:	d912      	bls.n	8015fbc <forward_lite_argmax_latest_f32_kernel+0x54>
 8015f96:	eb09 0c0a 	add.w	ip, r9, sl
 8015f9a:	2300      	movs	r3, #0
 8015f9c:	2001      	movs	r0, #1
 8015f9e:	eddc 7a00 	vldr	s15, [ip]
 8015fa2:	44ac      	add	ip, r5
 8015fa4:	eef4 7ac7 	vcmpe.f32	s15, s14
 8015fa8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8015fac:	db02      	blt.n	8015fb4 <forward_lite_argmax_latest_f32_kernel+0x4c>
 8015fae:	eeb0 7a67 	vmov.f32	s14, s15
 8015fb2:	4603      	mov	r3, r0
 8015fb4:	3001      	adds	r0, #1
 8015fb6:	4284      	cmp	r4, r0
 8015fb8:	d1f1      	bne.n	8015f9e <forward_lite_argmax_latest_f32_kernel+0x36>
 8015fba:	9301      	str	r3, [sp, #4]
 8015fbc:	2204      	movs	r2, #4
 8015fbe:	3601      	adds	r6, #1
 8015fc0:	4659      	mov	r1, fp
 8015fc2:	f10b 0b04 	add.w	fp, fp, #4
 8015fc6:	eb0d 0002 	add.w	r0, sp, r2
 8015fca:	f000 fd3d 	bl	8016a48 <st_int8_copy>
 8015fce:	42be      	cmp	r6, r7
 8015fd0:	d1db      	bne.n	8015f8a <forward_lite_argmax_latest_f32_kernel+0x22>
 8015fd2:	b003      	add	sp, #12
 8015fd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08015fd8 <forward_lite_dense_if32of32wf32>:
 8015fd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8015fdc:	ed2d 8b0c 	vpush	{d8-d13}
 8015fe0:	e9d0 2305 	ldrd	r2, r3, [r0, #20]
 8015fe4:	6801      	ldr	r1, [r0, #0]
 8015fe6:	b083      	sub	sp, #12
 8015fe8:	fb02 f303 	mul.w	r3, r2, r3
 8015fec:	f8d0 8004 	ldr.w	r8, [r0, #4]
 8015ff0:	9100      	str	r1, [sp, #0]
 8015ff2:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8015ff6:	4299      	cmp	r1, r3
 8015ff8:	9301      	str	r3, [sp, #4]
 8015ffa:	f080 811c 	bcs.w	8016236 <forward_lite_dense_if32of32wf32+0x25e>
 8015ffe:	4607      	mov	r7, r0
 8016000:	6904      	ldr	r4, [r0, #16]
 8016002:	0096      	lsls	r6, r2, #2
 8016004:	9b00      	ldr	r3, [sp, #0]
 8016006:	68bd      	ldr	r5, [r7, #8]
 8016008:	eb03 0e06 	add.w	lr, r3, r6
 801600c:	461e      	mov	r6, r3
 801600e:	459e      	cmp	lr, r3
 8016010:	f240 8103 	bls.w	801621a <forward_lite_dense_if32of32wf32+0x242>
 8016014:	f1a4 0c10 	sub.w	ip, r4, #16
 8016018:	ea4f 0984 	mov.w	r9, r4, lsl #2
 801601c:	ea4f 1c1c 	mov.w	ip, ip, lsr #4
 8016020:	f10c 0c01 	add.w	ip, ip, #1
 8016024:	ea4f 1b8c 	mov.w	fp, ip, lsl #6
 8016028:	eb08 1c8c 	add.w	ip, r8, ip, lsl #6
 801602c:	2c0f      	cmp	r4, #15
 801602e:	f240 8107 	bls.w	8016240 <forward_lite_dense_if32of32wf32+0x268>
 8016032:	f108 0240 	add.w	r2, r8, #64	@ 0x40
 8016036:	f105 0340 	add.w	r3, r5, #64	@ 0x40
 801603a:	ed9f 7a95 	vldr	s14, [pc, #596]	@ 8016290 <forward_lite_dense_if32of32wf32+0x2b8>
 801603e:	4621      	mov	r1, r4
 8016040:	ed53 6a0f 	vldr	s13, [r3, #-60]	@ 0xffffffc4
 8016044:	3910      	subs	r1, #16
 8016046:	ed52 7a0f 	vldr	s15, [r2, #-60]	@ 0xffffffc4
 801604a:	3340      	adds	r3, #64	@ 0x40
 801604c:	ed52 4a10 	vldr	s9, [r2, #-64]	@ 0xffffffc0
 8016050:	290f      	cmp	r1, #15
 8016052:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8016056:	ed13 5a20 	vldr	s10, [r3, #-128]	@ 0xffffff80
 801605a:	ed52 5a0e 	vldr	s11, [r2, #-56]	@ 0xffffffc8
 801605e:	f102 0240 	add.w	r2, r2, #64	@ 0x40
 8016062:	ed13 6a1e 	vldr	s12, [r3, #-120]	@ 0xffffff88
 8016066:	eee4 7a85 	vfma.f32	s15, s9, s10
 801606a:	ed53 6a1d 	vldr	s13, [r3, #-116]	@ 0xffffff8c
 801606e:	ed12 da1d 	vldr	s26, [r2, #-116]	@ 0xffffff8c
 8016072:	ed52 ca1c 	vldr	s25, [r2, #-112]	@ 0xffffff90
 8016076:	ed13 ca1c 	vldr	s24, [r3, #-112]	@ 0xffffff90
 801607a:	ed52 ba1b 	vldr	s23, [r2, #-108]	@ 0xffffff94
 801607e:	ed13 ba1b 	vldr	s22, [r3, #-108]	@ 0xffffff94
 8016082:	eee5 7a86 	vfma.f32	s15, s11, s12
 8016086:	ed52 aa1a 	vldr	s21, [r2, #-104]	@ 0xffffff98
 801608a:	ed13 aa1a 	vldr	s20, [r3, #-104]	@ 0xffffff98
 801608e:	ed52 9a19 	vldr	s19, [r2, #-100]	@ 0xffffff9c
 8016092:	ed13 9a19 	vldr	s18, [r3, #-100]	@ 0xffffff9c
 8016096:	ed52 8a18 	vldr	s17, [r2, #-96]	@ 0xffffffa0
 801609a:	ed13 8a18 	vldr	s16, [r3, #-96]	@ 0xffffffa0
 801609e:	eeed 7a26 	vfma.f32	s15, s26, s13
 80160a2:	ed12 0a17 	vldr	s0, [r2, #-92]	@ 0xffffffa4
 80160a6:	ed53 0a17 	vldr	s1, [r3, #-92]	@ 0xffffffa4
 80160aa:	ed12 1a16 	vldr	s2, [r2, #-88]	@ 0xffffffa8
 80160ae:	ed53 1a16 	vldr	s3, [r3, #-88]	@ 0xffffffa8
 80160b2:	ed12 2a15 	vldr	s4, [r2, #-84]	@ 0xffffffac
 80160b6:	ed53 2a15 	vldr	s5, [r3, #-84]	@ 0xffffffac
 80160ba:	eeec 7a8c 	vfma.f32	s15, s25, s24
 80160be:	ed12 3a14 	vldr	s6, [r2, #-80]	@ 0xffffffb0
 80160c2:	ed53 3a14 	vldr	s7, [r3, #-80]	@ 0xffffffb0
 80160c6:	ed12 4a13 	vldr	s8, [r2, #-76]	@ 0xffffffb4
 80160ca:	ed53 4a13 	vldr	s9, [r3, #-76]	@ 0xffffffb4
 80160ce:	ed12 5a12 	vldr	s10, [r2, #-72]	@ 0xffffffb8
 80160d2:	ed53 5a12 	vldr	s11, [r3, #-72]	@ 0xffffffb8
 80160d6:	eeeb 7a8b 	vfma.f32	s15, s23, s22
 80160da:	ed12 6a11 	vldr	s12, [r2, #-68]	@ 0xffffffbc
 80160de:	ed53 6a11 	vldr	s13, [r3, #-68]	@ 0xffffffbc
 80160e2:	eeea 7a8a 	vfma.f32	s15, s21, s20
 80160e6:	eee9 7a89 	vfma.f32	s15, s19, s18
 80160ea:	eee8 7a88 	vfma.f32	s15, s17, s16
 80160ee:	eee0 7a20 	vfma.f32	s15, s0, s1
 80160f2:	eee1 7a21 	vfma.f32	s15, s2, s3
 80160f6:	eee2 7a22 	vfma.f32	s15, s4, s5
 80160fa:	eee3 7a23 	vfma.f32	s15, s6, s7
 80160fe:	eee4 7a24 	vfma.f32	s15, s8, s9
 8016102:	eee5 7a25 	vfma.f32	s15, s10, s11
 8016106:	eee6 7a26 	vfma.f32	s15, s12, s13
 801610a:	ee37 7a27 	vadd.f32	s14, s14, s15
 801610e:	d897      	bhi.n	8016040 <forward_lite_dense_if32of32wf32+0x68>
 8016110:	eb05 020b 	add.w	r2, r5, fp
 8016114:	f004 010f 	and.w	r1, r4, #15
 8016118:	4663      	mov	r3, ip
 801611a:	2903      	cmp	r1, #3
 801611c:	d95f      	bls.n	80161de <forward_lite_dense_if32of32wf32+0x206>
 801611e:	edd2 6a01 	vldr	s13, [r2, #4]
 8016122:	1f08      	subs	r0, r1, #4
 8016124:	edd3 7a01 	vldr	s15, [r3, #4]
 8016128:	ed93 4a00 	vldr	s8, [r3]
 801612c:	2803      	cmp	r0, #3
 801612e:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8016132:	edd2 4a00 	vldr	s9, [r2]
 8016136:	ed93 5a02 	vldr	s10, [r3, #8]
 801613a:	edd2 5a02 	vldr	s11, [r2, #8]
 801613e:	eee4 7a24 	vfma.f32	s15, s8, s9
 8016142:	ed93 6a03 	vldr	s12, [r3, #12]
 8016146:	edd2 6a03 	vldr	s13, [r2, #12]
 801614a:	ee77 7a27 	vadd.f32	s15, s14, s15
 801614e:	eee5 7a25 	vfma.f32	s15, s10, s11
 8016152:	eee6 7a26 	vfma.f32	s15, s12, s13
 8016156:	eeb0 7a67 	vmov.f32	s14, s15
 801615a:	d938      	bls.n	80161ce <forward_lite_dense_if32of32wf32+0x1f6>
 801615c:	edd2 6a05 	vldr	s13, [r2, #20]
 8016160:	f1a1 0a08 	sub.w	sl, r1, #8
 8016164:	edd3 7a05 	vldr	s15, [r3, #20]
 8016168:	ed93 4a04 	vldr	s8, [r3, #16]
 801616c:	f1ba 0f03 	cmp.w	sl, #3
 8016170:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8016174:	edd2 4a04 	vldr	s9, [r2, #16]
 8016178:	ed93 5a06 	vldr	s10, [r3, #24]
 801617c:	edd2 5a06 	vldr	s11, [r2, #24]
 8016180:	eee4 7a24 	vfma.f32	s15, s8, s9
 8016184:	ed93 6a07 	vldr	s12, [r3, #28]
 8016188:	edd2 6a07 	vldr	s13, [r2, #28]
 801618c:	eee5 7a25 	vfma.f32	s15, s10, s11
 8016190:	eee6 7a26 	vfma.f32	s15, s12, s13
 8016194:	ee37 7a27 	vadd.f32	s14, s14, s15
 8016198:	d919      	bls.n	80161ce <forward_lite_dense_if32of32wf32+0x1f6>
 801619a:	edd3 6a09 	vldr	s13, [r3, #36]	@ 0x24
 801619e:	edd2 7a09 	vldr	s15, [r2, #36]	@ 0x24
 80161a2:	ed92 4a08 	vldr	s8, [r2, #32]
 80161a6:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80161aa:	edd3 4a08 	vldr	s9, [r3, #32]
 80161ae:	ed92 5a0a 	vldr	s10, [r2, #40]	@ 0x28
 80161b2:	edd3 5a0a 	vldr	s11, [r3, #40]	@ 0x28
 80161b6:	eee4 7a24 	vfma.f32	s15, s8, s9
 80161ba:	ed92 6a0b 	vldr	s12, [r2, #44]	@ 0x2c
 80161be:	edd3 6a0b 	vldr	s13, [r3, #44]	@ 0x2c
 80161c2:	eee5 7a25 	vfma.f32	s15, s10, s11
 80161c6:	eee6 7a26 	vfma.f32	s15, s12, s13
 80161ca:	ee37 7a27 	vadd.f32	s14, s14, s15
 80161ce:	0880      	lsrs	r0, r0, #2
 80161d0:	f001 0103 	and.w	r1, r1, #3
 80161d4:	3001      	adds	r0, #1
 80161d6:	eb02 1200 	add.w	r2, r2, r0, lsl #4
 80161da:	eb03 1300 	add.w	r3, r3, r0, lsl #4
 80161de:	b1a9      	cbz	r1, 801620c <forward_lite_dense_if32of32wf32+0x234>
 80161e0:	edd3 6a00 	vldr	s13, [r3]
 80161e4:	3901      	subs	r1, #1
 80161e6:	edd2 7a00 	vldr	s15, [r2]
 80161ea:	eea6 7aa7 	vfma.f32	s14, s13, s15
 80161ee:	d00d      	beq.n	801620c <forward_lite_dense_if32of32wf32+0x234>
 80161f0:	edd3 6a01 	vldr	s13, [r3, #4]
 80161f4:	2901      	cmp	r1, #1
 80161f6:	edd2 7a01 	vldr	s15, [r2, #4]
 80161fa:	eea6 7aa7 	vfma.f32	s14, s13, s15
 80161fe:	d005      	beq.n	801620c <forward_lite_dense_if32of32wf32+0x234>
 8016200:	edd2 6a02 	vldr	s13, [r2, #8]
 8016204:	edd3 7a02 	vldr	s15, [r3, #8]
 8016208:	eea6 7aa7 	vfma.f32	s14, s13, s15
 801620c:	eca6 7a01 	vstmia	r6!, {s14}
 8016210:	45b6      	cmp	lr, r6
 8016212:	444d      	add	r5, r9
 8016214:	f63f af0a 	bhi.w	801602c <forward_lite_dense_if32of32wf32+0x54>
 8016218:	697a      	ldr	r2, [r7, #20]
 801621a:	68fb      	ldr	r3, [r7, #12]
 801621c:	b9b3      	cbnz	r3, 801624c <forward_lite_dense_if32of32wf32+0x274>
 801621e:	9b00      	ldr	r3, [sp, #0]
 8016220:	0096      	lsls	r6, r2, #2
 8016222:	9901      	ldr	r1, [sp, #4]
 8016224:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8016228:	693c      	ldr	r4, [r7, #16]
 801622a:	4299      	cmp	r1, r3
 801622c:	eb08 0884 	add.w	r8, r8, r4, lsl #2
 8016230:	9300      	str	r3, [sp, #0]
 8016232:	f63f aee7 	bhi.w	8016004 <forward_lite_dense_if32of32wf32+0x2c>
 8016236:	b003      	add	sp, #12
 8016238:	ecbd 8b0c 	vpop	{d8-d13}
 801623c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8016240:	4621      	mov	r1, r4
 8016242:	ed9f 7a13 	vldr	s14, [pc, #76]	@ 8016290 <forward_lite_dense_if32of32wf32+0x2b8>
 8016246:	462a      	mov	r2, r5
 8016248:	4643      	mov	r3, r8
 801624a:	e766      	b.n	801611a <forward_lite_dense_if32of32wf32+0x142>
 801624c:	2a00      	cmp	r2, #0
 801624e:	d0e6      	beq.n	801621e <forward_lite_dense_if32of32wf32+0x246>
 8016250:	9a00      	ldr	r2, [sp, #0]
 8016252:	ed93 7a00 	vldr	s14, [r3]
 8016256:	edd2 7a00 	vldr	s15, [r2]
 801625a:	4613      	mov	r3, r2
 801625c:	ee77 7a87 	vadd.f32	s15, s15, s14
 8016260:	edc2 7a00 	vstr	s15, [r2]
 8016264:	697a      	ldr	r2, [r7, #20]
 8016266:	2a01      	cmp	r2, #1
 8016268:	d9d9      	bls.n	801621e <forward_lite_dense_if32of32wf32+0x246>
 801626a:	1d19      	adds	r1, r3, #4
 801626c:	2301      	movs	r3, #1
 801626e:	68fa      	ldr	r2, [r7, #12]
 8016270:	ed91 7a00 	vldr	s14, [r1]
 8016274:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8016278:	3301      	adds	r3, #1
 801627a:	edd2 7a00 	vldr	s15, [r2]
 801627e:	ee77 7a87 	vadd.f32	s15, s15, s14
 8016282:	ece1 7a01 	vstmia	r1!, {s15}
 8016286:	697a      	ldr	r2, [r7, #20]
 8016288:	429a      	cmp	r2, r3
 801628a:	d8f0      	bhi.n	801626e <forward_lite_dense_if32of32wf32+0x296>
 801628c:	e7c7      	b.n	801621e <forward_lite_dense_if32of32wf32+0x246>
 801628e:	bf00      	nop
 8016290:	00000000 	.word	0x00000000

08016294 <forward_lite_dense_if32of32wf32_lut4>:
 8016294:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016298:	b08d      	sub	sp, #52	@ 0x34
 801629a:	4605      	mov	r5, r0
 801629c:	460c      	mov	r4, r1
 801629e:	9005      	str	r0, [sp, #20]
 80162a0:	4618      	mov	r0, r3
 80162a2:	920a      	str	r2, [sp, #40]	@ 0x28
 80162a4:	9e16      	ldr	r6, [sp, #88]	@ 0x58
 80162a6:	e9dd 2319 	ldrd	r2, r3, [sp, #100]	@ 0x64
 80162aa:	fb02 f303 	mul.w	r3, r2, r3
 80162ae:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 80162b2:	9d18      	ldr	r5, [sp, #96]	@ 0x60
 80162b4:	9308      	str	r3, [sp, #32]
 80162b6:	b126      	cbz	r6, 80162c2 <forward_lite_dense_if32of32wf32_lut4+0x2e>
 80162b8:	2240      	movs	r2, #64	@ 0x40
 80162ba:	4631      	mov	r1, r6
 80162bc:	f000 fbc4 	bl	8016a48 <st_int8_copy>
 80162c0:	4630      	mov	r0, r6
 80162c2:	9b05      	ldr	r3, [sp, #20]
 80162c4:	9a08      	ldr	r2, [sp, #32]
 80162c6:	4293      	cmp	r3, r2
 80162c8:	f080 80f7 	bcs.w	80164ba <forward_lite_dense_if32of32wf32_lut4+0x226>
 80162cc:	08eb      	lsrs	r3, r5, #3
 80162ce:	f005 0101 	and.w	r1, r5, #1
 80162d2:	9a19      	ldr	r2, [sp, #100]	@ 0x64
 80162d4:	f025 0801 	bic.w	r8, r5, #1
 80162d8:	eb04 1a43 	add.w	sl, r4, r3, lsl #5
 80162dc:	9301      	str	r3, [sp, #4]
 80162de:	009b      	lsls	r3, r3, #2
 80162e0:	9102      	str	r1, [sp, #8]
 80162e2:	0092      	lsls	r2, r2, #2
 80162e4:	f104 0b20 	add.w	fp, r4, #32
 80162e8:	00a9      	lsls	r1, r5, #2
 80162ea:	9304      	str	r3, [sp, #16]
 80162ec:	eb04 0888 	add.w	r8, r4, r8, lsl #2
 80162f0:	9b05      	ldr	r3, [sp, #20]
 80162f2:	9207      	str	r2, [sp, #28]
 80162f4:	9109      	str	r1, [sp, #36]	@ 0x24
 80162f6:	920b      	str	r2, [sp, #44]	@ 0x2c
 80162f8:	9a07      	ldr	r2, [sp, #28]
 80162fa:	eb03 0902 	add.w	r9, r3, r2
 80162fe:	f1ab 0220 	sub.w	r2, fp, #32
 8016302:	4599      	cmp	r9, r3
 8016304:	9206      	str	r2, [sp, #24]
 8016306:	f240 80db 	bls.w	80164c0 <forward_lite_dense_if32of32wf32_lut4+0x22c>
 801630a:	469e      	mov	lr, r3
 801630c:	9a0a      	ldr	r2, [sp, #40]	@ 0x28
 801630e:	f108 33ff 	add.w	r3, r8, #4294967295
 8016312:	9303      	str	r3, [sp, #12]
 8016314:	9b01      	ldr	r3, [sp, #4]
 8016316:	2b00      	cmp	r3, #0
 8016318:	f000 80b4 	beq.w	8016484 <forward_lite_dense_if32of32wf32_lut4+0x1f0>
 801631c:	9b04      	ldr	r3, [sp, #16]
 801631e:	ed9f 7a71 	vldr	s14, [pc, #452]	@ 80164e4 <forward_lite_dense_if32of32wf32_lut4+0x250>
 8016322:	18d4      	adds	r4, r2, r3
 8016324:	465b      	mov	r3, fp
 8016326:	7816      	ldrb	r6, [r2, #0]
 8016328:	3204      	adds	r2, #4
 801632a:	ed53 2a07 	vldr	s5, [r3, #-28]	@ 0xffffffe4
 801632e:	3320      	adds	r3, #32
 8016330:	f006 070f 	and.w	r7, r6, #15
 8016334:	0936      	lsrs	r6, r6, #4
 8016336:	f812 5c03 	ldrb.w	r5, [r2, #-3]
 801633a:	eb00 0787 	add.w	r7, r0, r7, lsl #2
 801633e:	ed13 4a10 	vldr	s8, [r3, #-64]	@ 0xffffffc0
 8016342:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 8016346:	ed53 3a0e 	vldr	s7, [r3, #-56]	@ 0xffffffc8
 801634a:	edd7 7a00 	vldr	s15, [r7]
 801634e:	ed96 3a00 	vldr	s6, [r6]
 8016352:	092e      	lsrs	r6, r5, #4
 8016354:	ee67 7aa2 	vmul.f32	s15, s15, s5
 8016358:	f005 050f 	and.w	r5, r5, #15
 801635c:	eb00 0686 	add.w	r6, r0, r6, lsl #2
 8016360:	f812 1c02 	ldrb.w	r1, [r2, #-2]
 8016364:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 8016368:	ed13 5a0d 	vldr	s10, [r3, #-52]	@ 0xffffffcc
 801636c:	eee3 7a04 	vfma.f32	s15, s6, s8
 8016370:	ed96 3a00 	vldr	s6, [r6]
 8016374:	ed95 4a00 	vldr	s8, [r5]
 8016378:	090d      	lsrs	r5, r1, #4
 801637a:	ed53 4a0c 	vldr	s9, [r3, #-48]	@ 0xffffffd0
 801637e:	f001 010f 	and.w	r1, r1, #15
 8016382:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 8016386:	ed13 6a0b 	vldr	s12, [r3, #-44]	@ 0xffffffd4
 801638a:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 801638e:	ed53 5a0a 	vldr	s11, [r3, #-40]	@ 0xffffffd8
 8016392:	ed53 6a09 	vldr	s13, [r3, #-36]	@ 0xffffffdc
 8016396:	eee3 7a23 	vfma.f32	s15, s6, s7
 801639a:	eee4 7a05 	vfma.f32	s15, s8, s10
 801639e:	ed95 4a00 	vldr	s8, [r5]
 80163a2:	ed91 5a00 	vldr	s10, [r1]
 80163a6:	f812 1c01 	ldrb.w	r1, [r2, #-1]
 80163aa:	42a2      	cmp	r2, r4
 80163ac:	ea4f 1511 	mov.w	r5, r1, lsr #4
 80163b0:	f001 010f 	and.w	r1, r1, #15
 80163b4:	eee4 7a24 	vfma.f32	s15, s8, s9
 80163b8:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 80163bc:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 80163c0:	eee5 7a06 	vfma.f32	s15, s10, s12
 80163c4:	ed95 5a00 	vldr	s10, [r5]
 80163c8:	ed91 6a00 	vldr	s12, [r1]
 80163cc:	eee5 7a25 	vfma.f32	s15, s10, s11
 80163d0:	eee6 7a26 	vfma.f32	s15, s12, s13
 80163d4:	ee37 7a27 	vadd.f32	s14, s14, s15
 80163d8:	d1a5      	bne.n	8016326 <forward_lite_dense_if32of32wf32_lut4+0x92>
 80163da:	4656      	mov	r6, sl
 80163dc:	4546      	cmp	r6, r8
 80163de:	d257      	bcs.n	8016490 <forward_lite_dense_if32of32wf32_lut4+0x1fc>
 80163e0:	9b03      	ldr	r3, [sp, #12]
 80163e2:	f106 0208 	add.w	r2, r6, #8
 80163e6:	1e61      	subs	r1, r4, #1
 80163e8:	1b9d      	subs	r5, r3, r6
 80163ea:	08ef      	lsrs	r7, r5, #3
 80163ec:	eb04 05d5 	add.w	r5, r4, r5, lsr #3
 80163f0:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 80163f4:	3208      	adds	r2, #8
 80163f6:	ed52 5a03 	vldr	s11, [r2, #-12]
 80163fa:	f003 0c0f 	and.w	ip, r3, #15
 80163fe:	091b      	lsrs	r3, r3, #4
 8016400:	ed52 6a04 	vldr	s13, [r2, #-16]
 8016404:	42a9      	cmp	r1, r5
 8016406:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 801640a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 801640e:	eddc 7a00 	vldr	s15, [ip]
 8016412:	ed93 6a00 	vldr	s12, [r3]
 8016416:	ee67 7aa5 	vmul.f32	s15, s15, s11
 801641a:	eee6 7a26 	vfma.f32	s15, s12, s13
 801641e:	ee37 7a27 	vadd.f32	s14, s14, s15
 8016422:	d1e5      	bne.n	80163f0 <forward_lite_dense_if32of32wf32_lut4+0x15c>
 8016424:	3701      	adds	r7, #1
 8016426:	19e2      	adds	r2, r4, r7
 8016428:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
 801642c:	9b02      	ldr	r3, [sp, #8]
 801642e:	b30b      	cbz	r3, 8016474 <forward_lite_dense_if32of32wf32_lut4+0x1e0>
 8016430:	f812 3b01 	ldrb.w	r3, [r2], #1
 8016434:	edd6 7a00 	vldr	s15, [r6]
 8016438:	091b      	lsrs	r3, r3, #4
 801643a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 801643e:	edd3 6a00 	vldr	s13, [r3]
 8016442:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8016446:	ecae 7a01 	vstmia	lr!, {s14}
 801644a:	45f1      	cmp	r9, lr
 801644c:	f63f af62 	bhi.w	8016314 <forward_lite_dense_if32of32wf32_lut4+0x80>
 8016450:	9b05      	ldr	r3, [sp, #20]
 8016452:	9a0b      	ldr	r2, [sp, #44]	@ 0x2c
 8016454:	1899      	adds	r1, r3, r2
 8016456:	9b17      	ldr	r3, [sp, #92]	@ 0x5c
 8016458:	b9e3      	cbnz	r3, 8016494 <forward_lite_dense_if32of32wf32_lut4+0x200>
 801645a:	9b08      	ldr	r3, [sp, #32]
 801645c:	428b      	cmp	r3, r1
 801645e:	d92c      	bls.n	80164ba <forward_lite_dense_if32of32wf32_lut4+0x226>
 8016460:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8016462:	4498      	add	r8, r3
 8016464:	449a      	add	sl, r3
 8016466:	449b      	add	fp, r3
 8016468:	9b05      	ldr	r3, [sp, #20]
 801646a:	4599      	cmp	r9, r3
 801646c:	d92a      	bls.n	80164c4 <forward_lite_dense_if32of32wf32_lut4+0x230>
 801646e:	460b      	mov	r3, r1
 8016470:	9105      	str	r1, [sp, #20]
 8016472:	e741      	b.n	80162f8 <forward_lite_dense_if32of32wf32_lut4+0x64>
 8016474:	ecae 7a01 	vstmia	lr!, {s14}
 8016478:	45f1      	cmp	r9, lr
 801647a:	d9e9      	bls.n	8016450 <forward_lite_dense_if32of32wf32_lut4+0x1bc>
 801647c:	9b01      	ldr	r3, [sp, #4]
 801647e:	2b00      	cmp	r3, #0
 8016480:	f47f af4c 	bne.w	801631c <forward_lite_dense_if32of32wf32_lut4+0x88>
 8016484:	9e06      	ldr	r6, [sp, #24]
 8016486:	4614      	mov	r4, r2
 8016488:	ed9f 7a16 	vldr	s14, [pc, #88]	@ 80164e4 <forward_lite_dense_if32of32wf32_lut4+0x250>
 801648c:	4546      	cmp	r6, r8
 801648e:	d3a7      	bcc.n	80163e0 <forward_lite_dense_if32of32wf32_lut4+0x14c>
 8016490:	4622      	mov	r2, r4
 8016492:	e7cb      	b.n	801642c <forward_lite_dense_if32of32wf32_lut4+0x198>
 8016494:	9b19      	ldr	r3, [sp, #100]	@ 0x64
 8016496:	2b00      	cmp	r3, #0
 8016498:	d0df      	beq.n	801645a <forward_lite_dense_if32of32wf32_lut4+0x1c6>
 801649a:	9b07      	ldr	r3, [sp, #28]
 801649c:	9a17      	ldr	r2, [sp, #92]	@ 0x5c
 801649e:	1acb      	subs	r3, r1, r3
 80164a0:	edd3 7a00 	vldr	s15, [r3]
 80164a4:	ecb2 7a01 	vldmia	r2!, {s14}
 80164a8:	ee77 7a87 	vadd.f32	s15, s15, s14
 80164ac:	ece3 7a01 	vstmia	r3!, {s15}
 80164b0:	428b      	cmp	r3, r1
 80164b2:	d1f5      	bne.n	80164a0 <forward_lite_dense_if32of32wf32_lut4+0x20c>
 80164b4:	9b08      	ldr	r3, [sp, #32]
 80164b6:	428b      	cmp	r3, r1
 80164b8:	d8d2      	bhi.n	8016460 <forward_lite_dense_if32of32wf32_lut4+0x1cc>
 80164ba:	b00d      	add	sp, #52	@ 0x34
 80164bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80164c0:	4619      	mov	r1, r3
 80164c2:	e7c8      	b.n	8016456 <forward_lite_dense_if32of32wf32_lut4+0x1c2>
 80164c4:	9b07      	ldr	r3, [sp, #28]
 80164c6:	1acb      	subs	r3, r1, r3
 80164c8:	461a      	mov	r2, r3
 80164ca:	9817      	ldr	r0, [sp, #92]	@ 0x5c
 80164cc:	ed92 7a00 	vldr	s14, [r2]
 80164d0:	ecf0 7a01 	vldmia	r0!, {s15}
 80164d4:	ee77 7a87 	vadd.f32	s15, s15, s14
 80164d8:	ece2 7a01 	vstmia	r2!, {s15}
 80164dc:	428a      	cmp	r2, r1
 80164de:	d1f5      	bne.n	80164cc <forward_lite_dense_if32of32wf32_lut4+0x238>
 80164e0:	e7f2      	b.n	80164c8 <forward_lite_dense_if32of32wf32_lut4+0x234>
 80164e2:	bf00      	nop
 80164e4:	00000000 	.word	0x00000000

080164e8 <forward_lite_dense_if32of32wf32_lut8>:
 80164e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80164ec:	b091      	sub	sp, #68	@ 0x44
 80164ee:	4699      	mov	r9, r3
 80164f0:	468b      	mov	fp, r1
 80164f2:	920e      	str	r2, [sp, #56]	@ 0x38
 80164f4:	9c1a      	ldr	r4, [sp, #104]	@ 0x68
 80164f6:	f8dd 8070 	ldr.w	r8, [sp, #112]	@ 0x70
 80164fa:	9003      	str	r0, [sp, #12]
 80164fc:	e9dd 231d 	ldrd	r2, r3, [sp, #116]	@ 0x74
 8016500:	fb02 f303 	mul.w	r3, r2, r3
 8016504:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8016508:	930c      	str	r3, [sp, #48]	@ 0x30
 801650a:	b134      	cbz	r4, 801651a <forward_lite_dense_if32of32wf32_lut8+0x32>
 801650c:	4648      	mov	r0, r9
 801650e:	46a1      	mov	r9, r4
 8016510:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8016514:	4621      	mov	r1, r4
 8016516:	f000 fa97 	bl	8016a48 <st_int8_copy>
 801651a:	9b03      	ldr	r3, [sp, #12]
 801651c:	9a0c      	ldr	r2, [sp, #48]	@ 0x30
 801651e:	4293      	cmp	r3, r2
 8016520:	f080 8084 	bcs.w	801662c <forward_lite_dense_if32of32wf32_lut8+0x144>
 8016524:	4bb7      	ldr	r3, [pc, #732]	@ (8016804 <forward_lite_dense_if32of32wf32_lut8+0x31c>)
 8016526:	9a1d      	ldr	r2, [sp, #116]	@ 0x74
 8016528:	4443      	add	r3, r8
 801652a:	9d03      	ldr	r5, [sp, #12]
 801652c:	0092      	lsls	r2, r2, #2
 801652e:	eddf 3ab6 	vldr	s7, [pc, #728]	@ 8016808 <forward_lite_dense_if32of32wf32_lut8+0x320>
 8016532:	009b      	lsls	r3, r3, #2
 8016534:	920b      	str	r2, [sp, #44]	@ 0x2c
 8016536:	f103 0120 	add.w	r1, r3, #32
 801653a:	930d      	str	r3, [sp, #52]	@ 0x34
 801653c:	445b      	add	r3, fp
 801653e:	920f      	str	r2, [sp, #60]	@ 0x3c
 8016540:	9105      	str	r1, [sp, #20]
 8016542:	9300      	str	r3, [sp, #0]
 8016544:	eb0b 0301 	add.w	r3, fp, r1
 8016548:	469a      	mov	sl, r3
 801654a:	469e      	mov	lr, r3
 801654c:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 801654e:	eb05 0c03 	add.w	ip, r5, r3
 8016552:	45ac      	cmp	ip, r5
 8016554:	d952      	bls.n	80165fc <forward_lite_dense_if32of32wf32_lut8+0x114>
 8016556:	9800      	ldr	r0, [sp, #0]
 8016558:	9b0d      	ldr	r3, [sp, #52]	@ 0x34
 801655a:	f100 011f 	add.w	r1, r0, #31
 801655e:	eba0 020b 	sub.w	r2, r0, fp
 8016562:	445b      	add	r3, fp
 8016564:	9101      	str	r1, [sp, #4]
 8016566:	eba1 010b 	sub.w	r1, r1, fp
 801656a:	0952      	lsrs	r2, r2, #5
 801656c:	9306      	str	r3, [sp, #24]
 801656e:	0889      	lsrs	r1, r1, #2
 8016570:	9b0e      	ldr	r3, [sp, #56]	@ 0x38
 8016572:	3101      	adds	r1, #1
 8016574:	9102      	str	r1, [sp, #8]
 8016576:	1c51      	adds	r1, r2, #1
 8016578:	00d2      	lsls	r2, r2, #3
 801657a:	3210      	adds	r2, #16
 801657c:	920a      	str	r2, [sp, #40]	@ 0x28
 801657e:	00ca      	lsls	r2, r1, #3
 8016580:	9208      	str	r2, [sp, #32]
 8016582:	eb0b 1241 	add.w	r2, fp, r1, lsl #5
 8016586:	9209      	str	r2, [sp, #36]	@ 0x24
 8016588:	1f02      	subs	r2, r0, #4
 801658a:	9204      	str	r2, [sp, #16]
 801658c:	f10b 0204 	add.w	r2, fp, #4
 8016590:	9207      	str	r2, [sp, #28]
 8016592:	f1b8 0f07 	cmp.w	r8, #7
 8016596:	d84c      	bhi.n	8016632 <forward_lite_dense_if32of32wf32_lut8+0x14a>
 8016598:	45d3      	cmp	fp, sl
 801659a:	ed9f 7a9b 	vldr	s14, [pc, #620]	@ 8016808 <forward_lite_dense_if32of32wf32_lut8+0x320>
 801659e:	d20f      	bcs.n	80165c0 <forward_lite_dense_if32of32wf32_lut8+0xd8>
 80165a0:	4659      	mov	r1, fp
 80165a2:	4618      	mov	r0, r3
 80165a4:	f810 2b01 	ldrb.w	r2, [r0], #1
 80165a8:	ecf1 7a01 	vldmia	r1!, {s15}
 80165ac:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 80165b0:	4551      	cmp	r1, sl
 80165b2:	edd2 6a00 	vldr	s13, [r2]
 80165b6:	eea6 7aa7 	vfma.f32	s14, s13, s15
 80165ba:	d3f3      	bcc.n	80165a4 <forward_lite_dense_if32of32wf32_lut8+0xbc>
 80165bc:	9a02      	ldr	r2, [sp, #8]
 80165be:	4413      	add	r3, r2
 80165c0:	eca5 7a01 	vstmia	r5!, {s14}
 80165c4:	45ac      	cmp	ip, r5
 80165c6:	d8e4      	bhi.n	8016592 <forward_lite_dense_if32of32wf32_lut8+0xaa>
 80165c8:	9b03      	ldr	r3, [sp, #12]
 80165ca:	46f3      	mov	fp, lr
 80165cc:	9a0f      	ldr	r2, [sp, #60]	@ 0x3c
 80165ce:	1899      	adds	r1, r3, r2
 80165d0:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 80165d2:	b9c3      	cbnz	r3, 8016606 <forward_lite_dense_if32of32wf32_lut8+0x11e>
 80165d4:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 80165d6:	428b      	cmp	r3, r1
 80165d8:	d928      	bls.n	801662c <forward_lite_dense_if32of32wf32_lut8+0x144>
 80165da:	9b00      	ldr	r3, [sp, #0]
 80165dc:	9a05      	ldr	r2, [sp, #20]
 80165de:	4413      	add	r3, r2
 80165e0:	4492      	add	sl, r2
 80165e2:	9300      	str	r3, [sp, #0]
 80165e4:	9b03      	ldr	r3, [sp, #12]
 80165e6:	459c      	cmp	ip, r3
 80165e8:	f240 821e 	bls.w	8016a28 <forward_lite_dense_if32of32wf32_lut8+0x540>
 80165ec:	460d      	mov	r5, r1
 80165ee:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 80165f0:	4496      	add	lr, r2
 80165f2:	9103      	str	r1, [sp, #12]
 80165f4:	eb05 0c03 	add.w	ip, r5, r3
 80165f8:	45ac      	cmp	ip, r5
 80165fa:	d8ac      	bhi.n	8016556 <forward_lite_dense_if32of32wf32_lut8+0x6e>
 80165fc:	9b1b      	ldr	r3, [sp, #108]	@ 0x6c
 80165fe:	4629      	mov	r1, r5
 8016600:	46f3      	mov	fp, lr
 8016602:	2b00      	cmp	r3, #0
 8016604:	d0e6      	beq.n	80165d4 <forward_lite_dense_if32of32wf32_lut8+0xec>
 8016606:	9b1d      	ldr	r3, [sp, #116]	@ 0x74
 8016608:	2b00      	cmp	r3, #0
 801660a:	d0e3      	beq.n	80165d4 <forward_lite_dense_if32of32wf32_lut8+0xec>
 801660c:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 801660e:	9a1b      	ldr	r2, [sp, #108]	@ 0x6c
 8016610:	1acb      	subs	r3, r1, r3
 8016612:	edd3 7a00 	vldr	s15, [r3]
 8016616:	ecb2 7a01 	vldmia	r2!, {s14}
 801661a:	ee77 7a87 	vadd.f32	s15, s15, s14
 801661e:	ece3 7a01 	vstmia	r3!, {s15}
 8016622:	428b      	cmp	r3, r1
 8016624:	d1f5      	bne.n	8016612 <forward_lite_dense_if32of32wf32_lut8+0x12a>
 8016626:	9b0c      	ldr	r3, [sp, #48]	@ 0x30
 8016628:	428b      	cmp	r3, r1
 801662a:	d8d6      	bhi.n	80165da <forward_lite_dense_if32of32wf32_lut8+0xf2>
 801662c:	b011      	add	sp, #68	@ 0x44
 801662e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8016632:	f003 0203 	and.w	r2, r3, #3
 8016636:	2a02      	cmp	r2, #2
 8016638:	f000 81ee 	beq.w	8016a18 <forward_lite_dense_if32of32wf32_lut8+0x530>
 801663c:	2a03      	cmp	r2, #3
 801663e:	f000 80e5 	beq.w	801680c <forward_lite_dense_if32of32wf32_lut8+0x324>
 8016642:	2a01      	cmp	r2, #1
 8016644:	f000 81d2 	beq.w	80169ec <forward_lite_dense_if32of32wf32_lut8+0x504>
 8016648:	9a06      	ldr	r2, [sp, #24]
 801664a:	ed9f 7a6f 	vldr	s14, [pc, #444]	@ 8016808 <forward_lite_dense_if32of32wf32_lut8+0x320>
 801664e:	4593      	cmp	fp, r2
 8016650:	f200 81e8 	bhi.w	8016a24 <forward_lite_dense_if32of32wf32_lut8+0x53c>
 8016654:	980a      	ldr	r0, [sp, #40]	@ 0x28
 8016656:	f103 0208 	add.w	r2, r3, #8
 801665a:	f10b 0120 	add.w	r1, fp, #32
 801665e:	18c4      	adds	r4, r0, r3
 8016660:	f812 0c07 	ldrb.w	r0, [r2, #-7]
 8016664:	3208      	adds	r2, #8
 8016666:	ed51 2a07 	vldr	s5, [r1, #-28]	@ 0xffffffe4
 801666a:	3120      	adds	r1, #32
 801666c:	eb09 0080 	add.w	r0, r9, r0, lsl #2
 8016670:	ed11 3a10 	vldr	s6, [r1, #-64]	@ 0xffffffc0
 8016674:	ed11 4a0e 	vldr	s8, [r1, #-56]	@ 0xffffffc8
 8016678:	edd0 7a00 	vldr	s15, [r0]
 801667c:	f812 0c10 	ldrb.w	r0, [r2, #-16]
 8016680:	ee67 7aa2 	vmul.f32	s15, s15, s5
 8016684:	ed51 4a0d 	vldr	s9, [r1, #-52]	@ 0xffffffcc
 8016688:	eb09 0080 	add.w	r0, r9, r0, lsl #2
 801668c:	ed11 5a0c 	vldr	s10, [r1, #-48]	@ 0xffffffd0
 8016690:	ed51 5a0b 	vldr	s11, [r1, #-44]	@ 0xffffffd4
 8016694:	edd0 2a00 	vldr	s5, [r0]
 8016698:	f812 0c0e 	ldrb.w	r0, [r2, #-14]
 801669c:	eee2 7a83 	vfma.f32	s15, s5, s6
 80166a0:	ed11 6a0a 	vldr	s12, [r1, #-40]	@ 0xffffffd8
 80166a4:	eb09 0080 	add.w	r0, r9, r0, lsl #2
 80166a8:	ed51 6a09 	vldr	s13, [r1, #-36]	@ 0xffffffdc
 80166ac:	ed90 3a00 	vldr	s6, [r0]
 80166b0:	f812 0c0d 	ldrb.w	r0, [r2, #-13]
 80166b4:	eee3 7a04 	vfma.f32	s15, s6, s8
 80166b8:	eb09 0080 	add.w	r0, r9, r0, lsl #2
 80166bc:	ed90 4a00 	vldr	s8, [r0]
 80166c0:	f812 0c0c 	ldrb.w	r0, [r2, #-12]
 80166c4:	eb09 0080 	add.w	r0, r9, r0, lsl #2
 80166c8:	eee4 7a24 	vfma.f32	s15, s8, s9
 80166cc:	edd0 4a00 	vldr	s9, [r0]
 80166d0:	f812 0c0b 	ldrb.w	r0, [r2, #-11]
 80166d4:	eb09 0080 	add.w	r0, r9, r0, lsl #2
 80166d8:	eee4 7a85 	vfma.f32	s15, s9, s10
 80166dc:	ed90 5a00 	vldr	s10, [r0]
 80166e0:	f812 0c0a 	ldrb.w	r0, [r2, #-10]
 80166e4:	eb09 0080 	add.w	r0, r9, r0, lsl #2
 80166e8:	eee5 7a25 	vfma.f32	s15, s10, s11
 80166ec:	edd0 5a00 	vldr	s11, [r0]
 80166f0:	f812 0c09 	ldrb.w	r0, [r2, #-9]
 80166f4:	42a2      	cmp	r2, r4
 80166f6:	eb09 0080 	add.w	r0, r9, r0, lsl #2
 80166fa:	eee5 7a86 	vfma.f32	s15, s11, s12
 80166fe:	ed90 6a00 	vldr	s12, [r0]
 8016702:	eee6 7a26 	vfma.f32	s15, s12, s13
 8016706:	ee37 7a27 	vadd.f32	s14, s14, s15
 801670a:	d1a9      	bne.n	8016660 <forward_lite_dense_if32of32wf32_lut8+0x178>
 801670c:	9a08      	ldr	r2, [sp, #32]
 801670e:	4413      	add	r3, r2
 8016710:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8016712:	4572      	cmp	r2, lr
 8016714:	f4bf af54 	bcs.w	80165c0 <forward_lite_dense_if32of32wf32_lut8+0xd8>
 8016718:	7819      	ldrb	r1, [r3, #0]
 801671a:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 801671e:	edd1 7a00 	vldr	s15, [r1]
 8016722:	4611      	mov	r1, r2
 8016724:	ecf1 6a01 	vldmia	r1!, {s13}
 8016728:	458a      	cmp	sl, r1
 801672a:	eea6 7aa7 	vfma.f32	s14, s13, s15
 801672e:	d963      	bls.n	80167f8 <forward_lite_dense_if32of32wf32_lut8+0x310>
 8016730:	7859      	ldrb	r1, [r3, #1]
 8016732:	edd2 6a01 	vldr	s13, [r2, #4]
 8016736:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 801673a:	edd1 7a00 	vldr	s15, [r1]
 801673e:	f102 0108 	add.w	r1, r2, #8
 8016742:	458a      	cmp	sl, r1
 8016744:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8016748:	d956      	bls.n	80167f8 <forward_lite_dense_if32of32wf32_lut8+0x310>
 801674a:	7899      	ldrb	r1, [r3, #2]
 801674c:	edd2 6a02 	vldr	s13, [r2, #8]
 8016750:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 8016754:	edd1 7a00 	vldr	s15, [r1]
 8016758:	f102 010c 	add.w	r1, r2, #12
 801675c:	458a      	cmp	sl, r1
 801675e:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8016762:	d949      	bls.n	80167f8 <forward_lite_dense_if32of32wf32_lut8+0x310>
 8016764:	78d9      	ldrb	r1, [r3, #3]
 8016766:	edd2 6a03 	vldr	s13, [r2, #12]
 801676a:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 801676e:	edd1 7a00 	vldr	s15, [r1]
 8016772:	f102 0110 	add.w	r1, r2, #16
 8016776:	458a      	cmp	sl, r1
 8016778:	eea6 7aa7 	vfma.f32	s14, s13, s15
 801677c:	d93c      	bls.n	80167f8 <forward_lite_dense_if32of32wf32_lut8+0x310>
 801677e:	7919      	ldrb	r1, [r3, #4]
 8016780:	edd2 6a04 	vldr	s13, [r2, #16]
 8016784:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 8016788:	edd1 7a00 	vldr	s15, [r1]
 801678c:	f102 0114 	add.w	r1, r2, #20
 8016790:	458a      	cmp	sl, r1
 8016792:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8016796:	d92f      	bls.n	80167f8 <forward_lite_dense_if32of32wf32_lut8+0x310>
 8016798:	7959      	ldrb	r1, [r3, #5]
 801679a:	edd2 6a05 	vldr	s13, [r2, #20]
 801679e:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 80167a2:	edd1 7a00 	vldr	s15, [r1]
 80167a6:	f102 0118 	add.w	r1, r2, #24
 80167aa:	458a      	cmp	sl, r1
 80167ac:	eea6 7aa7 	vfma.f32	s14, s13, s15
 80167b0:	d922      	bls.n	80167f8 <forward_lite_dense_if32of32wf32_lut8+0x310>
 80167b2:	7999      	ldrb	r1, [r3, #6]
 80167b4:	edd2 6a06 	vldr	s13, [r2, #24]
 80167b8:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 80167bc:	edd1 7a00 	vldr	s15, [r1]
 80167c0:	f102 011c 	add.w	r1, r2, #28
 80167c4:	458a      	cmp	sl, r1
 80167c6:	eea6 7aa7 	vfma.f32	s14, s13, s15
 80167ca:	d915      	bls.n	80167f8 <forward_lite_dense_if32of32wf32_lut8+0x310>
 80167cc:	79d9      	ldrb	r1, [r3, #7]
 80167ce:	edd2 6a07 	vldr	s13, [r2, #28]
 80167d2:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 80167d6:	edd1 7a00 	vldr	s15, [r1]
 80167da:	f102 0120 	add.w	r1, r2, #32
 80167de:	458a      	cmp	sl, r1
 80167e0:	eea6 7aa7 	vfma.f32	s14, s13, s15
 80167e4:	d908      	bls.n	80167f8 <forward_lite_dense_if32of32wf32_lut8+0x310>
 80167e6:	7a19      	ldrb	r1, [r3, #8]
 80167e8:	edd2 7a08 	vldr	s15, [r2, #32]
 80167ec:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 80167f0:	edd1 6a00 	vldr	s13, [r1]
 80167f4:	eea6 7aa7 	vfma.f32	s14, s13, s15
 80167f8:	9901      	ldr	r1, [sp, #4]
 80167fa:	1a8a      	subs	r2, r1, r2
 80167fc:	eb03 0292 	add.w	r2, r3, r2, lsr #2
 8016800:	1c53      	adds	r3, r2, #1
 8016802:	e6dd      	b.n	80165c0 <forward_lite_dense_if32of32wf32_lut8+0xd8>
 8016804:	3ffffff8 	.word	0x3ffffff8
 8016808:	00000000 	.word	0x00000000
 801680c:	eeb0 7a63 	vmov.f32	s14, s7
 8016810:	465a      	mov	r2, fp
 8016812:	461f      	mov	r7, r3
 8016814:	4610      	mov	r0, r2
 8016816:	f817 1b01 	ldrb.w	r1, [r7], #1
 801681a:	ecf0 7a01 	vldmia	r0!, {s15}
 801681e:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 8016822:	edd1 6a00 	vldr	s13, [r1]
 8016826:	9900      	ldr	r1, [sp, #0]
 8016828:	eea6 7aa7 	vfma.f32	s14, s13, s15
 801682c:	4288      	cmp	r0, r1
 801682e:	f200 80f7 	bhi.w	8016a20 <forward_lite_dense_if32of32wf32_lut8+0x538>
 8016832:	9904      	ldr	r1, [sp, #16]
 8016834:	f103 0411 	add.w	r4, r3, #17
 8016838:	3309      	adds	r3, #9
 801683a:	1a8e      	subs	r6, r1, r2
 801683c:	3224      	adds	r2, #36	@ 0x24
 801683e:	0976      	lsrs	r6, r6, #5
 8016840:	eb04 04c6 	add.w	r4, r4, r6, lsl #3
 8016844:	f813 1c07 	ldrb.w	r1, [r3, #-7]
 8016848:	3308      	adds	r3, #8
 801684a:	ed52 2a07 	vldr	s5, [r2, #-28]	@ 0xffffffe4
 801684e:	3220      	adds	r2, #32
 8016850:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 8016854:	ed12 3a10 	vldr	s6, [r2, #-64]	@ 0xffffffc0
 8016858:	ed12 4a0e 	vldr	s8, [r2, #-56]	@ 0xffffffc8
 801685c:	edd1 7a00 	vldr	s15, [r1]
 8016860:	f813 1c10 	ldrb.w	r1, [r3, #-16]
 8016864:	ee67 7aa2 	vmul.f32	s15, s15, s5
 8016868:	ed52 4a0d 	vldr	s9, [r2, #-52]	@ 0xffffffcc
 801686c:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 8016870:	ed12 5a0c 	vldr	s10, [r2, #-48]	@ 0xffffffd0
 8016874:	ed52 5a0b 	vldr	s11, [r2, #-44]	@ 0xffffffd4
 8016878:	edd1 2a00 	vldr	s5, [r1]
 801687c:	f813 1c0e 	ldrb.w	r1, [r3, #-14]
 8016880:	eee2 7a83 	vfma.f32	s15, s5, s6
 8016884:	ed12 6a0a 	vldr	s12, [r2, #-40]	@ 0xffffffd8
 8016888:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 801688c:	ed52 6a09 	vldr	s13, [r2, #-36]	@ 0xffffffdc
 8016890:	ed91 3a00 	vldr	s6, [r1]
 8016894:	f813 1c0d 	ldrb.w	r1, [r3, #-13]
 8016898:	eee3 7a04 	vfma.f32	s15, s6, s8
 801689c:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 80168a0:	ed91 4a00 	vldr	s8, [r1]
 80168a4:	f813 1c0c 	ldrb.w	r1, [r3, #-12]
 80168a8:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 80168ac:	eee4 7a24 	vfma.f32	s15, s8, s9
 80168b0:	edd1 4a00 	vldr	s9, [r1]
 80168b4:	f813 1c0b 	ldrb.w	r1, [r3, #-11]
 80168b8:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 80168bc:	eee4 7a85 	vfma.f32	s15, s9, s10
 80168c0:	ed91 5a00 	vldr	s10, [r1]
 80168c4:	f813 1c0a 	ldrb.w	r1, [r3, #-10]
 80168c8:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 80168cc:	eee5 7a25 	vfma.f32	s15, s10, s11
 80168d0:	edd1 5a00 	vldr	s11, [r1]
 80168d4:	f813 1c09 	ldrb.w	r1, [r3, #-9]
 80168d8:	42a3      	cmp	r3, r4
 80168da:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 80168de:	eee5 7a86 	vfma.f32	s15, s11, s12
 80168e2:	ed91 6a00 	vldr	s12, [r1]
 80168e6:	eee6 7a26 	vfma.f32	s15, s12, s13
 80168ea:	ee37 7a27 	vadd.f32	s14, s14, s15
 80168ee:	d1a9      	bne.n	8016844 <forward_lite_dense_if32of32wf32_lut8+0x35c>
 80168f0:	3601      	adds	r6, #1
 80168f2:	eb07 03c6 	add.w	r3, r7, r6, lsl #3
 80168f6:	eb00 1046 	add.w	r0, r0, r6, lsl #5
 80168fa:	4550      	cmp	r0, sl
 80168fc:	f4bf ae60 	bcs.w	80165c0 <forward_lite_dense_if32of32wf32_lut8+0xd8>
 8016900:	781a      	ldrb	r2, [r3, #0]
 8016902:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 8016906:	edd2 7a00 	vldr	s15, [r2]
 801690a:	4602      	mov	r2, r0
 801690c:	ecf2 6a01 	vldmia	r2!, {s13}
 8016910:	4592      	cmp	sl, r2
 8016912:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8016916:	d963      	bls.n	80169e0 <forward_lite_dense_if32of32wf32_lut8+0x4f8>
 8016918:	785a      	ldrb	r2, [r3, #1]
 801691a:	edd0 6a01 	vldr	s13, [r0, #4]
 801691e:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 8016922:	edd2 7a00 	vldr	s15, [r2]
 8016926:	f100 0208 	add.w	r2, r0, #8
 801692a:	4592      	cmp	sl, r2
 801692c:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8016930:	d956      	bls.n	80169e0 <forward_lite_dense_if32of32wf32_lut8+0x4f8>
 8016932:	789a      	ldrb	r2, [r3, #2]
 8016934:	edd0 6a02 	vldr	s13, [r0, #8]
 8016938:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 801693c:	edd2 7a00 	vldr	s15, [r2]
 8016940:	f100 020c 	add.w	r2, r0, #12
 8016944:	4592      	cmp	sl, r2
 8016946:	eea6 7aa7 	vfma.f32	s14, s13, s15
 801694a:	d949      	bls.n	80169e0 <forward_lite_dense_if32of32wf32_lut8+0x4f8>
 801694c:	78da      	ldrb	r2, [r3, #3]
 801694e:	edd0 6a03 	vldr	s13, [r0, #12]
 8016952:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 8016956:	edd2 7a00 	vldr	s15, [r2]
 801695a:	f100 0210 	add.w	r2, r0, #16
 801695e:	4592      	cmp	sl, r2
 8016960:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8016964:	d93c      	bls.n	80169e0 <forward_lite_dense_if32of32wf32_lut8+0x4f8>
 8016966:	791a      	ldrb	r2, [r3, #4]
 8016968:	edd0 6a04 	vldr	s13, [r0, #16]
 801696c:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 8016970:	edd2 7a00 	vldr	s15, [r2]
 8016974:	f100 0214 	add.w	r2, r0, #20
 8016978:	4592      	cmp	sl, r2
 801697a:	eea6 7aa7 	vfma.f32	s14, s13, s15
 801697e:	d92f      	bls.n	80169e0 <forward_lite_dense_if32of32wf32_lut8+0x4f8>
 8016980:	795a      	ldrb	r2, [r3, #5]
 8016982:	edd0 6a05 	vldr	s13, [r0, #20]
 8016986:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 801698a:	edd2 7a00 	vldr	s15, [r2]
 801698e:	f100 0218 	add.w	r2, r0, #24
 8016992:	4596      	cmp	lr, r2
 8016994:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8016998:	d922      	bls.n	80169e0 <forward_lite_dense_if32of32wf32_lut8+0x4f8>
 801699a:	799a      	ldrb	r2, [r3, #6]
 801699c:	edd0 6a06 	vldr	s13, [r0, #24]
 80169a0:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 80169a4:	edd2 7a00 	vldr	s15, [r2]
 80169a8:	f100 021c 	add.w	r2, r0, #28
 80169ac:	4596      	cmp	lr, r2
 80169ae:	eea6 7aa7 	vfma.f32	s14, s13, s15
 80169b2:	d915      	bls.n	80169e0 <forward_lite_dense_if32of32wf32_lut8+0x4f8>
 80169b4:	79da      	ldrb	r2, [r3, #7]
 80169b6:	edd0 6a07 	vldr	s13, [r0, #28]
 80169ba:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 80169be:	edd2 7a00 	vldr	s15, [r2]
 80169c2:	f100 0220 	add.w	r2, r0, #32
 80169c6:	4596      	cmp	lr, r2
 80169c8:	eea6 7aa7 	vfma.f32	s14, s13, s15
 80169cc:	d908      	bls.n	80169e0 <forward_lite_dense_if32of32wf32_lut8+0x4f8>
 80169ce:	7a1a      	ldrb	r2, [r3, #8]
 80169d0:	edd0 7a08 	vldr	s15, [r0, #32]
 80169d4:	eb09 0282 	add.w	r2, r9, r2, lsl #2
 80169d8:	edd2 6a00 	vldr	s13, [r2]
 80169dc:	eea6 7aa7 	vfma.f32	s14, s13, s15
 80169e0:	9a01      	ldr	r2, [sp, #4]
 80169e2:	1a10      	subs	r0, r2, r0
 80169e4:	eb03 0090 	add.w	r0, r3, r0, lsr #2
 80169e8:	1c43      	adds	r3, r0, #1
 80169ea:	e5e9      	b.n	80165c0 <forward_lite_dense_if32of32wf32_lut8+0xd8>
 80169ec:	f813 1b01 	ldrb.w	r1, [r3], #1
 80169f0:	eddb 7a00 	vldr	s15, [fp]
 80169f4:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 80169f8:	9a07      	ldr	r2, [sp, #28]
 80169fa:	ed91 7a00 	vldr	s14, [r1]
 80169fe:	ee27 7a27 	vmul.f32	s14, s14, s15
 8016a02:	f813 1b01 	ldrb.w	r1, [r3], #1
 8016a06:	ecf2 7a01 	vldmia	r2!, {s15}
 8016a0a:	eb09 0181 	add.w	r1, r9, r1, lsl #2
 8016a0e:	edd1 6a00 	vldr	s13, [r1]
 8016a12:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8016a16:	e6fc      	b.n	8016812 <forward_lite_dense_if32of32wf32_lut8+0x32a>
 8016a18:	eeb0 7a63 	vmov.f32	s14, s7
 8016a1c:	465a      	mov	r2, fp
 8016a1e:	e7f0      	b.n	8016a02 <forward_lite_dense_if32of32wf32_lut8+0x51a>
 8016a20:	463b      	mov	r3, r7
 8016a22:	e76a      	b.n	80168fa <forward_lite_dense_if32of32wf32_lut8+0x412>
 8016a24:	465a      	mov	r2, fp
 8016a26:	e674      	b.n	8016712 <forward_lite_dense_if32of32wf32_lut8+0x22a>
 8016a28:	9b0b      	ldr	r3, [sp, #44]	@ 0x2c
 8016a2a:	1acb      	subs	r3, r1, r3
 8016a2c:	461a      	mov	r2, r3
 8016a2e:	981b      	ldr	r0, [sp, #108]	@ 0x6c
 8016a30:	ed92 7a00 	vldr	s14, [r2]
 8016a34:	ecf0 7a01 	vldmia	r0!, {s15}
 8016a38:	ee77 7a87 	vadd.f32	s15, s15, s14
 8016a3c:	ece2 7a01 	vstmia	r2!, {s15}
 8016a40:	4291      	cmp	r1, r2
 8016a42:	d1f5      	bne.n	8016a30 <forward_lite_dense_if32of32wf32_lut8+0x548>
 8016a44:	e7f2      	b.n	8016a2c <forward_lite_dense_if32of32wf32_lut8+0x544>
 8016a46:	bf00      	nop

08016a48 <st_int8_copy>:
 8016a48:	4288      	cmp	r0, r1
 8016a4a:	d023      	beq.n	8016a94 <st_int8_copy+0x4c>
 8016a4c:	b312      	cbz	r2, 8016a94 <st_int8_copy+0x4c>
 8016a4e:	4288      	cmp	r0, r1
 8016a50:	eb00 0302 	add.w	r3, r0, r2
 8016a54:	d20b      	bcs.n	8016a6e <st_int8_copy+0x26>
 8016a56:	4299      	cmp	r1, r3
 8016a58:	d209      	bcs.n	8016a6e <st_int8_copy+0x26>
 8016a5a:	4298      	cmp	r0, r3
 8016a5c:	440a      	add	r2, r1
 8016a5e:	d219      	bcs.n	8016a94 <st_int8_copy+0x4c>
 8016a60:	f913 1d01 	ldrsb.w	r1, [r3, #-1]!
 8016a64:	4298      	cmp	r0, r3
 8016a66:	f802 1d01 	strb.w	r1, [r2, #-1]!
 8016a6a:	d1f9      	bne.n	8016a60 <st_int8_copy+0x18>
 8016a6c:	4770      	bx	lr
 8016a6e:	2a03      	cmp	r2, #3
 8016a70:	d811      	bhi.n	8016a96 <st_int8_copy+0x4e>
 8016a72:	f810 3b01 	ldrb.w	r3, [r0], #1
 8016a76:	f801 3b01 	strb.w	r3, [r1], #1
 8016a7a:	2a01      	cmp	r2, #1
 8016a7c:	d00a      	beq.n	8016a94 <st_int8_copy+0x4c>
 8016a7e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8016a82:	f801 3b01 	strb.w	r3, [r1], #1
 8016a86:	2a02      	cmp	r2, #2
 8016a88:	d004      	beq.n	8016a94 <st_int8_copy+0x4c>
 8016a8a:	f810 3b01 	ldrb.w	r3, [r0], #1
 8016a8e:	f801 3b01 	strb.w	r3, [r1], #1
 8016a92:	4770      	bx	lr
 8016a94:	4770      	bx	lr
 8016a96:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8016a9a:	f001 0403 	and.w	r4, r1, #3
 8016a9e:	f000 0e03 	and.w	lr, r0, #3
 8016aa2:	f1c4 0304 	rsb	r3, r4, #4
 8016aa6:	eba2 0c03 	sub.w	ip, r2, r3
 8016aaa:	f810 3b01 	ldrb.w	r3, [r0], #1
 8016aae:	f801 3b01 	strb.w	r3, [r1], #1
 8016ab2:	2c03      	cmp	r4, #3
 8016ab4:	f1c4 0202 	rsb	r2, r4, #2
 8016ab8:	d00e      	beq.n	8016ad8 <st_int8_copy+0x90>
 8016aba:	f810 3b01 	ldrb.w	r3, [r0], #1
 8016abe:	f801 3b01 	strb.w	r3, [r1], #1
 8016ac2:	2a00      	cmp	r2, #0
 8016ac4:	dd08      	ble.n	8016ad8 <st_int8_copy+0x90>
 8016ac6:	f810 3b01 	ldrb.w	r3, [r0], #1
 8016aca:	f801 3b01 	strb.w	r3, [r1], #1
 8016ace:	b91c      	cbnz	r4, 8016ad8 <st_int8_copy+0x90>
 8016ad0:	f810 3b01 	ldrb.w	r3, [r0], #1
 8016ad4:	f801 3b01 	strb.w	r3, [r1], #1
 8016ad8:	4574      	cmp	r4, lr
 8016ada:	d02b      	beq.n	8016b34 <st_int8_copy+0xec>
 8016adc:	ea4f 131c 	mov.w	r3, ip, lsr #4
 8016ae0:	1e5a      	subs	r2, r3, #1
 8016ae2:	b153      	cbz	r3, 8016afa <st_int8_copy+0xb2>
 8016ae4:	f850 3b04 	ldr.w	r3, [r0], #4
 8016ae8:	f850 4b04 	ldr.w	r4, [r0], #4
 8016aec:	f850 5b04 	ldr.w	r5, [r0], #4
 8016af0:	f850 6b04 	ldr.w	r6, [r0], #4
 8016af4:	c178      	stmia	r1!, {r3, r4, r5, r6}
 8016af6:	3a01      	subs	r2, #1
 8016af8:	d2f4      	bcs.n	8016ae4 <st_int8_copy+0x9c>
 8016afa:	f01c 0f08 	tst.w	ip, #8
 8016afe:	d004      	beq.n	8016b0a <st_int8_copy+0xc2>
 8016b00:	f850 3b04 	ldr.w	r3, [r0], #4
 8016b04:	f850 4b04 	ldr.w	r4, [r0], #4
 8016b08:	c118      	stmia	r1!, {r3, r4}
 8016b0a:	f01c 0f04 	tst.w	ip, #4
 8016b0e:	d003      	beq.n	8016b18 <st_int8_copy+0xd0>
 8016b10:	f850 3b04 	ldr.w	r3, [r0], #4
 8016b14:	f841 3b04 	str.w	r3, [r1], #4
 8016b18:	f01c 0f02 	tst.w	ip, #2
 8016b1c:	d003      	beq.n	8016b26 <st_int8_copy+0xde>
 8016b1e:	f830 3b02 	ldrh.w	r3, [r0], #2
 8016b22:	f821 3b02 	strh.w	r3, [r1], #2
 8016b26:	f01c 0f01 	tst.w	ip, #1
 8016b2a:	d001      	beq.n	8016b30 <st_int8_copy+0xe8>
 8016b2c:	7803      	ldrb	r3, [r0, #0]
 8016b2e:	700b      	strb	r3, [r1, #0]
 8016b30:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8016b34:	ea4f 139c 	mov.w	r3, ip, lsr #6
 8016b38:	f103 39ff 	add.w	r9, r3, #4294967295
 8016b3c:	b183      	cbz	r3, 8016b60 <st_int8_copy+0x118>
 8016b3e:	4688      	mov	r8, r1
 8016b40:	4686      	mov	lr, r0
 8016b42:	e8be 00ff 	ldmia.w	lr!, {r0, r1, r2, r3, r4, r5, r6, r7}
 8016b46:	e8a8 00ff 	stmia.w	r8!, {r0, r1, r2, r3, r4, r5, r6, r7}
 8016b4a:	e8be 00ff 	ldmia.w	lr!, {r0, r1, r2, r3, r4, r5, r6, r7}
 8016b4e:	e8a8 00ff 	stmia.w	r8!, {r0, r1, r2, r3, r4, r5, r6, r7}
 8016b52:	f109 39ff 	add.w	r9, r9, #4294967295
 8016b56:	4641      	mov	r1, r8
 8016b58:	4670      	mov	r0, lr
 8016b5a:	f1b9 3fff 	cmp.w	r9, #4294967295
 8016b5e:	d1ee      	bne.n	8016b3e <st_int8_copy+0xf6>
 8016b60:	f01c 0f20 	tst.w	ip, #32
 8016b64:	d007      	beq.n	8016b76 <st_int8_copy+0x12e>
 8016b66:	4688      	mov	r8, r1
 8016b68:	4686      	mov	lr, r0
 8016b6a:	e8be 00ff 	ldmia.w	lr!, {r0, r1, r2, r3, r4, r5, r6, r7}
 8016b6e:	e8a8 00ff 	stmia.w	r8!, {r0, r1, r2, r3, r4, r5, r6, r7}
 8016b72:	4641      	mov	r1, r8
 8016b74:	4670      	mov	r0, lr
 8016b76:	f01c 0f10 	tst.w	ip, #16
 8016b7a:	d001      	beq.n	8016b80 <st_int8_copy+0x138>
 8016b7c:	c878      	ldmia	r0!, {r3, r4, r5, r6}
 8016b7e:	c178      	stmia	r1!, {r3, r4, r5, r6}
 8016b80:	f01c 0f08 	tst.w	ip, #8
 8016b84:	d0c1      	beq.n	8016b0a <st_int8_copy+0xc2>
 8016b86:	c818      	ldmia	r0!, {r3, r4}
 8016b88:	c118      	stmia	r1!, {r3, r4}
 8016b8a:	e7be      	b.n	8016b0a <st_int8_copy+0xc2>

08016b8c <ai_sub_f32>:
 8016b8c:	edd1 7a00 	vldr	s15, [r1]
 8016b90:	ed92 7a00 	vldr	s14, [r2]
 8016b94:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8016b98:	edc0 7a00 	vstr	s15, [r0]
 8016b9c:	4770      	bx	lr
 8016b9e:	bf00      	nop

08016ba0 <ai_sub_buffer_f32>:
 8016ba0:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 8016ba4:	4298      	cmp	r0, r3
 8016ba6:	d209      	bcs.n	8016bbc <ai_sub_buffer_f32+0x1c>
 8016ba8:	ecf1 7a01 	vldmia	r1!, {s15}
 8016bac:	ecb2 7a01 	vldmia	r2!, {s14}
 8016bb0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8016bb4:	ece0 7a01 	vstmia	r0!, {s15}
 8016bb8:	4283      	cmp	r3, r0
 8016bba:	d8f5      	bhi.n	8016ba8 <ai_sub_buffer_f32+0x8>
 8016bbc:	4770      	bx	lr
 8016bbe:	bf00      	nop

08016bc0 <ai_array_to_buffer_fmt>:
 8016bc0:	f3c0 4343 	ubfx	r3, r0, #17, #4
 8016bc4:	2b02      	cmp	r3, #2
 8016bc6:	d055      	beq.n	8016c74 <ai_array_to_buffer_fmt+0xb4>
 8016bc8:	f020 437e 	bic.w	r3, r0, #4261412864	@ 0xfe000000
 8016bcc:	4a2c      	ldr	r2, [pc, #176]	@ (8016c80 <ai_array_to_buffer_fmt+0xc0>)
 8016bce:	4293      	cmp	r3, r2
 8016bd0:	d010      	beq.n	8016bf4 <ai_array_to_buffer_fmt+0x34>
 8016bd2:	dc21      	bgt.n	8016c18 <ai_array_to_buffer_fmt+0x58>
 8016bd4:	4a2b      	ldr	r2, [pc, #172]	@ (8016c84 <ai_array_to_buffer_fmt+0xc4>)
 8016bd6:	4293      	cmp	r3, r2
 8016bd8:	d00c      	beq.n	8016bf4 <ai_array_to_buffer_fmt+0x34>
 8016bda:	dd0f      	ble.n	8016bfc <ai_array_to_buffer_fmt+0x3c>
 8016bdc:	4a2a      	ldr	r2, [pc, #168]	@ (8016c88 <ai_array_to_buffer_fmt+0xc8>)
 8016bde:	4293      	cmp	r3, r2
 8016be0:	d008      	beq.n	8016bf4 <ai_array_to_buffer_fmt+0x34>
 8016be2:	f502 32fa 	add.w	r2, r2, #128000	@ 0x1f400
 8016be6:	4293      	cmp	r3, r2
 8016be8:	d004      	beq.n	8016bf4 <ai_array_to_buffer_fmt+0x34>
 8016bea:	4a28      	ldr	r2, [pc, #160]	@ (8016c8c <ai_array_to_buffer_fmt+0xcc>)
 8016bec:	4293      	cmp	r3, r2
 8016bee:	bf0c      	ite	eq
 8016bf0:	4613      	moveq	r3, r2
 8016bf2:	2340      	movne	r3, #64	@ 0x40
 8016bf4:	f000 40d0 	and.w	r0, r0, #1744830464	@ 0x68000000
 8016bf8:	4318      	orrs	r0, r3
 8016bfa:	4770      	bx	lr
 8016bfc:	f5a2 6280 	sub.w	r2, r2, #1024	@ 0x400
 8016c00:	4293      	cmp	r3, r2
 8016c02:	d0f7      	beq.n	8016bf4 <ai_array_to_buffer_fmt+0x34>
 8016c04:	dd2c      	ble.n	8016c60 <ai_array_to_buffer_fmt+0xa0>
 8016c06:	4a22      	ldr	r2, [pc, #136]	@ (8016c90 <ai_array_to_buffer_fmt+0xd0>)
 8016c08:	f000 40d0 	and.w	r0, r0, #1744830464	@ 0x68000000
 8016c0c:	4293      	cmp	r3, r2
 8016c0e:	bf0c      	ite	eq
 8016c10:	4613      	moveq	r3, r2
 8016c12:	2340      	movne	r3, #64	@ 0x40
 8016c14:	4318      	orrs	r0, r3
 8016c16:	4770      	bx	lr
 8016c18:	4a1e      	ldr	r2, [pc, #120]	@ (8016c94 <ai_array_to_buffer_fmt+0xd4>)
 8016c1a:	4293      	cmp	r3, r2
 8016c1c:	d0ea      	beq.n	8016bf4 <ai_array_to_buffer_fmt+0x34>
 8016c1e:	dd10      	ble.n	8016c42 <ai_array_to_buffer_fmt+0x82>
 8016c20:	4a1d      	ldr	r2, [pc, #116]	@ (8016c98 <ai_array_to_buffer_fmt+0xd8>)
 8016c22:	4293      	cmp	r3, r2
 8016c24:	d0e6      	beq.n	8016bf4 <ai_array_to_buffer_fmt+0x34>
 8016c26:	f202 72f1 	addw	r2, r2, #2033	@ 0x7f1
 8016c2a:	4293      	cmp	r3, r2
 8016c2c:	d0e2      	beq.n	8016bf4 <ai_array_to_buffer_fmt+0x34>
 8016c2e:	f5a2 6200 	sub.w	r2, r2, #2048	@ 0x800
 8016c32:	f000 40d0 	and.w	r0, r0, #1744830464	@ 0x68000000
 8016c36:	4293      	cmp	r3, r2
 8016c38:	bf0c      	ite	eq
 8016c3a:	4613      	moveq	r3, r2
 8016c3c:	2340      	movne	r3, #64	@ 0x40
 8016c3e:	4318      	orrs	r0, r3
 8016c40:	4770      	bx	lr
 8016c42:	f2a2 3287 	subw	r2, r2, #903	@ 0x387
 8016c46:	4293      	cmp	r3, r2
 8016c48:	d0d4      	beq.n	8016bf4 <ai_array_to_buffer_fmt+0x34>
 8016c4a:	f502 7260 	add.w	r2, r2, #896	@ 0x380
 8016c4e:	4293      	cmp	r3, r2
 8016c50:	d0d0      	beq.n	8016bf4 <ai_array_to_buffer_fmt+0x34>
 8016c52:	f5a2 6280 	sub.w	r2, r2, #1024	@ 0x400
 8016c56:	4293      	cmp	r3, r2
 8016c58:	bf0c      	ite	eq
 8016c5a:	4613      	moveq	r3, r2
 8016c5c:	2340      	movne	r3, #64	@ 0x40
 8016c5e:	e7c9      	b.n	8016bf4 <ai_array_to_buffer_fmt+0x34>
 8016c60:	f5a2 6280 	sub.w	r2, r2, #1024	@ 0x400
 8016c64:	4293      	cmp	r3, r2
 8016c66:	d0c5      	beq.n	8016bf4 <ai_array_to_buffer_fmt+0x34>
 8016c68:	3280      	adds	r2, #128	@ 0x80
 8016c6a:	4293      	cmp	r3, r2
 8016c6c:	bf0c      	ite	eq
 8016c6e:	4613      	moveq	r3, r2
 8016c70:	2340      	movne	r3, #64	@ 0x40
 8016c72:	e7bf      	b.n	8016bf4 <ai_array_to_buffer_fmt+0x34>
 8016c74:	4b09      	ldr	r3, [pc, #36]	@ (8016c9c <ai_array_to_buffer_fmt+0xdc>)
 8016c76:	4003      	ands	r3, r0
 8016c78:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8016c7c:	e7ba      	b.n	8016bf4 <ai_array_to_buffer_fmt+0x34>
 8016c7e:	bf00      	nop
 8016c80:	00821040 	.word	0x00821040
 8016c84:	00040840 	.word	0x00040840
 8016c88:	00041040 	.word	0x00041040
 8016c8c:	0004084f 	.word	0x0004084f
 8016c90:	00040447 	.word	0x00040447
 8016c94:	00840447 	.word	0x00840447
 8016c98:	0084084f 	.word	0x0084084f
 8016c9c:	00803fff 	.word	0x00803fff

08016ca0 <ai_array_get_byte_size>:
 8016ca0:	b321      	cbz	r1, 8016cec <ai_array_get_byte_size+0x4c>
 8016ca2:	f3c0 13c6 	ubfx	r3, r0, #7, #7
 8016ca6:	f46f 7288 	mvn.w	r2, #272	@ 0x110
 8016caa:	f3c0 5c41 	ubfx	ip, r0, #21, #2
 8016cae:	fb03 f101 	mul.w	r1, r3, r1
 8016cb2:	b500      	push	{lr}
 8016cb4:	f3c0 4e43 	ubfx	lr, r0, #17, #4
 8016cb8:	3107      	adds	r1, #7
 8016cba:	11c0      	asrs	r0, r0, #7
 8016cbc:	fa42 f20e 	asr.w	r2, r2, lr
 8016cc0:	f021 0107 	bic.w	r1, r1, #7
 8016cc4:	07d2      	lsls	r2, r2, #31
 8016cc6:	fa21 f10c 	lsr.w	r1, r1, ip
 8016cca:	d505      	bpl.n	8016cd8 <ai_array_get_byte_size+0x38>
 8016ccc:	2300      	movs	r3, #0
 8016cce:	3107      	adds	r1, #7
 8016cd0:	4419      	add	r1, r3
 8016cd2:	08c8      	lsrs	r0, r1, #3
 8016cd4:	f85d fb04 	ldr.w	pc, [sp], #4
 8016cd8:	f000 007f 	and.w	r0, r0, #127	@ 0x7f
 8016cdc:	3107      	adds	r1, #7
 8016cde:	fa40 f00c 	asr.w	r0, r0, ip
 8016ce2:	4083      	lsls	r3, r0
 8016ce4:	4419      	add	r1, r3
 8016ce6:	08c8      	lsrs	r0, r1, #3
 8016ce8:	f85d fb04 	ldr.w	pc, [sp], #4
 8016cec:	4608      	mov	r0, r1
 8016cee:	4770      	bx	lr

08016cf0 <ai_array_get_data_byte_size>:
 8016cf0:	b169      	cbz	r1, 8016d0e <ai_array_get_data_byte_size+0x1e>
 8016cf2:	f3c0 13c6 	ubfx	r3, r0, #7, #7
 8016cf6:	f3c0 5041 	ubfx	r0, r0, #21, #2
 8016cfa:	fb03 f101 	mul.w	r1, r3, r1
 8016cfe:	1dcb      	adds	r3, r1, #7
 8016d00:	f023 0307 	bic.w	r3, r3, #7
 8016d04:	fa23 f000 	lsr.w	r0, r3, r0
 8016d08:	3007      	adds	r0, #7
 8016d0a:	08c0      	lsrs	r0, r0, #3
 8016d0c:	4770      	bx	lr
 8016d0e:	4608      	mov	r0, r1
 8016d10:	4770      	bx	lr
 8016d12:	bf00      	nop

08016d14 <ai_version_get>:
 8016d14:	0212      	lsls	r2, r2, #8
 8016d16:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8016d1a:	ea42 6000 	orr.w	r0, r2, r0, lsl #24
 8016d1e:	4770      	bx	lr

08016d20 <get_tensor_byte_size>:
 8016d20:	b430      	push	{r4, r5}
 8016d22:	6985      	ldr	r5, [r0, #24]
 8016d24:	68c4      	ldr	r4, [r0, #12]
 8016d26:	6941      	ldr	r1, [r0, #20]
 8016d28:	4b06      	ldr	r3, [pc, #24]	@ (8016d44 <get_tensor_byte_size+0x24>)
 8016d2a:	6828      	ldr	r0, [r5, #0]
 8016d2c:	4a06      	ldr	r2, [pc, #24]	@ (8016d48 <get_tensor_byte_size+0x28>)
 8016d2e:	4003      	ands	r3, r0
 8016d30:	68c9      	ldr	r1, [r1, #12]
 8016d32:	68e0      	ldr	r0, [r4, #12]
 8016d34:	4293      	cmp	r3, r2
 8016d36:	fb01 f000 	mul.w	r0, r1, r0
 8016d3a:	d101      	bne.n	8016d40 <get_tensor_byte_size+0x20>
 8016d3c:	3007      	adds	r0, #7
 8016d3e:	08c0      	lsrs	r0, r0, #3
 8016d40:	bc30      	pop	{r4, r5}
 8016d42:	4770      	bx	lr
 8016d44:	017fffff 	.word	0x017fffff
 8016d48:	000400c0 	.word	0x000400c0

08016d4c <core_get_broadcasted_shape>:
 8016d4c:	b470      	push	{r4, r5, r6}
 8016d4e:	6804      	ldr	r4, [r0, #0]
 8016d50:	f3c4 2417 	ubfx	r4, r4, #8, #24
 8016d54:	b304      	cbz	r4, 8016d98 <core_get_broadcasted_shape+0x4c>
 8016d56:	4623      	mov	r3, r4
 8016d58:	3b01      	subs	r3, #1
 8016d5a:	429c      	cmp	r4, r3
 8016d5c:	d917      	bls.n	8016d8e <core_get_broadcasted_shape+0x42>
 8016d5e:	6815      	ldr	r5, [r2, #0]
 8016d60:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 8016d64:	2401      	movs	r4, #1
 8016d66:	ebb3 2f15 	cmp.w	r3, r5, lsr #8
 8016d6a:	d202      	bcs.n	8016d72 <core_get_broadcasted_shape+0x26>
 8016d6c:	6854      	ldr	r4, [r2, #4]
 8016d6e:	f854 4023 	ldr.w	r4, [r4, r3, lsl #2]
 8016d72:	680e      	ldr	r6, [r1, #0]
 8016d74:	2501      	movs	r5, #1
 8016d76:	ebb3 2f16 	cmp.w	r3, r6, lsr #8
 8016d7a:	d202      	bcs.n	8016d82 <core_get_broadcasted_shape+0x36>
 8016d7c:	684d      	ldr	r5, [r1, #4]
 8016d7e:	f855 500c 	ldr.w	r5, [r5, ip]
 8016d82:	42ac      	cmp	r4, r5
 8016d84:	bf38      	it	cc
 8016d86:	462c      	movcc	r4, r5
 8016d88:	6845      	ldr	r5, [r0, #4]
 8016d8a:	f845 400c 	str.w	r4, [r5, ip]
 8016d8e:	b11b      	cbz	r3, 8016d98 <core_get_broadcasted_shape+0x4c>
 8016d90:	6804      	ldr	r4, [r0, #0]
 8016d92:	f3c4 2417 	ubfx	r4, r4, #8, #24
 8016d96:	e7df      	b.n	8016d58 <core_get_broadcasted_shape+0xc>
 8016d98:	bc70      	pop	{r4, r5, r6}
 8016d9a:	4770      	bx	lr

08016d9c <core_compute_offsets>:
 8016d9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016da0:	e9d1 5c00 	ldrd	r5, ip, [r1]
 8016da4:	6857      	ldr	r7, [r2, #4]
 8016da6:	b085      	sub	sp, #20
 8016da8:	f8dc 4004 	ldr.w	r4, [ip, #4]
 8016dac:	687e      	ldr	r6, [r7, #4]
 8016dae:	1ba1      	subs	r1, r4, r6
 8016db0:	bf18      	it	ne
 8016db2:	2101      	movne	r1, #1
 8016db4:	f5b5 6fa0 	cmp.w	r5, #1280	@ 0x500
 8016db8:	9103      	str	r1, [sp, #12]
 8016dba:	d376      	bcc.n	8016eaa <core_compute_offsets+0x10e>
 8016dbc:	f8dc 9010 	ldr.w	r9, [ip, #16]
 8016dc0:	fb09 fe04 	mul.w	lr, r9, r4
 8016dc4:	6812      	ldr	r2, [r2, #0]
 8016dc6:	f8d0 b000 	ldr.w	fp, [r0]
 8016dca:	f5b2 6fa0 	cmp.w	r2, #1280	@ 0x500
 8016dce:	e9dc 5202 	ldrd	r5, r2, [ip, #8]
 8016dd2:	bf2c      	ite	cs
 8016dd4:	f8d7 a010 	ldrcs.w	sl, [r7, #16]
 8016dd8:	f04f 0a01 	movcc.w	sl, #1
 8016ddc:	9201      	str	r2, [sp, #4]
 8016dde:	ebb9 0c0a 	subs.w	ip, r9, sl
 8016de2:	e9d7 8202 	ldrd	r8, r2, [r7, #8]
 8016de6:	bf18      	it	ne
 8016de8:	f04f 0c01 	movne.w	ip, #1
 8016dec:	ebb5 0708 	subs.w	r7, r5, r8
 8016df0:	9202      	str	r2, [sp, #8]
 8016df2:	f3cb 2217 	ubfx	r2, fp, #8, #24
 8016df6:	bf18      	it	ne
 8016df8:	2701      	movne	r7, #1
 8016dfa:	f5bb 7f00 	cmp.w	fp, #512	@ 0x200
 8016dfe:	d321      	bcc.n	8016e44 <core_compute_offsets+0xa8>
 8016e00:	42b4      	cmp	r4, r6
 8016e02:	bf0c      	ite	eq
 8016e04:	461a      	moveq	r2, r3
 8016e06:	2200      	movne	r2, #0
 8016e08:	6841      	ldr	r1, [r0, #4]
 8016e0a:	604a      	str	r2, [r1, #4]
 8016e0c:	f8d0 b000 	ldr.w	fp, [r0]
 8016e10:	f5bb 6fa0 	cmp.w	fp, #1280	@ 0x500
 8016e14:	f3cb 2217 	ubfx	r2, fp, #8, #24
 8016e18:	d314      	bcc.n	8016e44 <core_compute_offsets+0xa8>
 8016e1a:	9a03      	ldr	r2, [sp, #12]
 8016e1c:	45d1      	cmp	r9, sl
 8016e1e:	bf14      	ite	ne
 8016e20:	2200      	movne	r2, #0
 8016e22:	f002 0201 	andeq.w	r2, r2, #1
 8016e26:	42b4      	cmp	r4, r6
 8016e28:	bf14      	ite	ne
 8016e2a:	f04f 0900 	movne.w	r9, #0
 8016e2e:	f00c 0901 	andeq.w	r9, ip, #1
 8016e32:	6846      	ldr	r6, [r0, #4]
 8016e34:	fb04 2219 	mls	r2, r4, r9, r2
 8016e38:	fb03 f202 	mul.w	r2, r3, r2
 8016e3c:	6132      	str	r2, [r6, #16]
 8016e3e:	6802      	ldr	r2, [r0, #0]
 8016e40:	f3c2 2217 	ubfx	r2, r2, #8, #24
 8016e44:	2a02      	cmp	r2, #2
 8016e46:	fb0e f607 	mul.w	r6, lr, r7
 8016e4a:	d911      	bls.n	8016e70 <core_compute_offsets+0xd4>
 8016e4c:	9a03      	ldr	r2, [sp, #12]
 8016e4e:	4545      	cmp	r5, r8
 8016e50:	bf14      	ite	ne
 8016e52:	2200      	movne	r2, #0
 8016e54:	f002 0201 	andeq.w	r2, r2, #1
 8016e58:	ea0c 0202 	and.w	r2, ip, r2
 8016e5c:	1b92      	subs	r2, r2, r6
 8016e5e:	fb04 240c 	mla	r4, r4, ip, r2
 8016e62:	6842      	ldr	r2, [r0, #4]
 8016e64:	fb03 f404 	mul.w	r4, r3, r4
 8016e68:	6094      	str	r4, [r2, #8]
 8016e6a:	6802      	ldr	r2, [r0, #0]
 8016e6c:	f3c2 2217 	ubfx	r2, r2, #8, #24
 8016e70:	e9dd 4101 	ldrd	r4, r1, [sp, #4]
 8016e74:	428c      	cmp	r4, r1
 8016e76:	d116      	bne.n	8016ea6 <core_compute_offsets+0x10a>
 8016e78:	b1af      	cbz	r7, 8016ea6 <core_compute_offsets+0x10a>
 8016e7a:	9903      	ldr	r1, [sp, #12]
 8016e7c:	ea01 010c 	and.w	r1, r1, ip
 8016e80:	2a03      	cmp	r2, #3
 8016e82:	d90d      	bls.n	8016ea0 <core_compute_offsets+0x104>
 8016e84:	fb0e f505 	mul.w	r5, lr, r5
 8016e88:	e9dd 2401 	ldrd	r2, r4, [sp, #4]
 8016e8c:	1b12      	subs	r2, r2, r4
 8016e8e:	bf18      	it	ne
 8016e90:	2201      	movne	r2, #1
 8016e92:	fb02 1115 	mls	r1, r2, r5, r1
 8016e96:	6842      	ldr	r2, [r0, #4]
 8016e98:	4431      	add	r1, r6
 8016e9a:	fb03 f101 	mul.w	r1, r3, r1
 8016e9e:	60d1      	str	r1, [r2, #12]
 8016ea0:	b005      	add	sp, #20
 8016ea2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8016ea6:	2100      	movs	r1, #0
 8016ea8:	e7ea      	b.n	8016e80 <core_compute_offsets+0xe4>
 8016eaa:	46a6      	mov	lr, r4
 8016eac:	f04f 0901 	mov.w	r9, #1
 8016eb0:	e788      	b.n	8016dc4 <core_compute_offsets+0x28>
 8016eb2:	bf00      	nop

08016eb4 <sbrk_aligned>:
 8016eb4:	b570      	push	{r4, r5, r6, lr}
 8016eb6:	4e0f      	ldr	r6, [pc, #60]	@ (8016ef4 <sbrk_aligned+0x40>)
 8016eb8:	460c      	mov	r4, r1
 8016eba:	6831      	ldr	r1, [r6, #0]
 8016ebc:	4605      	mov	r5, r0
 8016ebe:	b911      	cbnz	r1, 8016ec6 <sbrk_aligned+0x12>
 8016ec0:	f000 fb54 	bl	801756c <_sbrk_r>
 8016ec4:	6030      	str	r0, [r6, #0]
 8016ec6:	4621      	mov	r1, r4
 8016ec8:	4628      	mov	r0, r5
 8016eca:	f000 fb4f 	bl	801756c <_sbrk_r>
 8016ece:	1c43      	adds	r3, r0, #1
 8016ed0:	d103      	bne.n	8016eda <sbrk_aligned+0x26>
 8016ed2:	f04f 34ff 	mov.w	r4, #4294967295
 8016ed6:	4620      	mov	r0, r4
 8016ed8:	bd70      	pop	{r4, r5, r6, pc}
 8016eda:	1cc4      	adds	r4, r0, #3
 8016edc:	f024 0403 	bic.w	r4, r4, #3
 8016ee0:	42a0      	cmp	r0, r4
 8016ee2:	d0f8      	beq.n	8016ed6 <sbrk_aligned+0x22>
 8016ee4:	1a21      	subs	r1, r4, r0
 8016ee6:	4628      	mov	r0, r5
 8016ee8:	f000 fb40 	bl	801756c <_sbrk_r>
 8016eec:	3001      	adds	r0, #1
 8016eee:	d1f2      	bne.n	8016ed6 <sbrk_aligned+0x22>
 8016ef0:	e7ef      	b.n	8016ed2 <sbrk_aligned+0x1e>
 8016ef2:	bf00      	nop
 8016ef4:	240060e8 	.word	0x240060e8

08016ef8 <_malloc_r>:
 8016ef8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8016efc:	1ccd      	adds	r5, r1, #3
 8016efe:	f025 0503 	bic.w	r5, r5, #3
 8016f02:	3508      	adds	r5, #8
 8016f04:	2d0c      	cmp	r5, #12
 8016f06:	bf38      	it	cc
 8016f08:	250c      	movcc	r5, #12
 8016f0a:	2d00      	cmp	r5, #0
 8016f0c:	4606      	mov	r6, r0
 8016f0e:	db01      	blt.n	8016f14 <_malloc_r+0x1c>
 8016f10:	42a9      	cmp	r1, r5
 8016f12:	d904      	bls.n	8016f1e <_malloc_r+0x26>
 8016f14:	230c      	movs	r3, #12
 8016f16:	6033      	str	r3, [r6, #0]
 8016f18:	2000      	movs	r0, #0
 8016f1a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8016f1e:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 8016ff4 <_malloc_r+0xfc>
 8016f22:	f000 f869 	bl	8016ff8 <__malloc_lock>
 8016f26:	f8d8 3000 	ldr.w	r3, [r8]
 8016f2a:	461c      	mov	r4, r3
 8016f2c:	bb44      	cbnz	r4, 8016f80 <_malloc_r+0x88>
 8016f2e:	4629      	mov	r1, r5
 8016f30:	4630      	mov	r0, r6
 8016f32:	f7ff ffbf 	bl	8016eb4 <sbrk_aligned>
 8016f36:	1c43      	adds	r3, r0, #1
 8016f38:	4604      	mov	r4, r0
 8016f3a:	d158      	bne.n	8016fee <_malloc_r+0xf6>
 8016f3c:	f8d8 4000 	ldr.w	r4, [r8]
 8016f40:	4627      	mov	r7, r4
 8016f42:	2f00      	cmp	r7, #0
 8016f44:	d143      	bne.n	8016fce <_malloc_r+0xd6>
 8016f46:	2c00      	cmp	r4, #0
 8016f48:	d04b      	beq.n	8016fe2 <_malloc_r+0xea>
 8016f4a:	6823      	ldr	r3, [r4, #0]
 8016f4c:	4639      	mov	r1, r7
 8016f4e:	4630      	mov	r0, r6
 8016f50:	eb04 0903 	add.w	r9, r4, r3
 8016f54:	f000 fb0a 	bl	801756c <_sbrk_r>
 8016f58:	4581      	cmp	r9, r0
 8016f5a:	d142      	bne.n	8016fe2 <_malloc_r+0xea>
 8016f5c:	6821      	ldr	r1, [r4, #0]
 8016f5e:	1a6d      	subs	r5, r5, r1
 8016f60:	4629      	mov	r1, r5
 8016f62:	4630      	mov	r0, r6
 8016f64:	f7ff ffa6 	bl	8016eb4 <sbrk_aligned>
 8016f68:	3001      	adds	r0, #1
 8016f6a:	d03a      	beq.n	8016fe2 <_malloc_r+0xea>
 8016f6c:	6823      	ldr	r3, [r4, #0]
 8016f6e:	442b      	add	r3, r5
 8016f70:	6023      	str	r3, [r4, #0]
 8016f72:	f8d8 3000 	ldr.w	r3, [r8]
 8016f76:	685a      	ldr	r2, [r3, #4]
 8016f78:	bb62      	cbnz	r2, 8016fd4 <_malloc_r+0xdc>
 8016f7a:	f8c8 7000 	str.w	r7, [r8]
 8016f7e:	e00f      	b.n	8016fa0 <_malloc_r+0xa8>
 8016f80:	6822      	ldr	r2, [r4, #0]
 8016f82:	1b52      	subs	r2, r2, r5
 8016f84:	d420      	bmi.n	8016fc8 <_malloc_r+0xd0>
 8016f86:	2a0b      	cmp	r2, #11
 8016f88:	d917      	bls.n	8016fba <_malloc_r+0xc2>
 8016f8a:	1961      	adds	r1, r4, r5
 8016f8c:	42a3      	cmp	r3, r4
 8016f8e:	6025      	str	r5, [r4, #0]
 8016f90:	bf18      	it	ne
 8016f92:	6059      	strne	r1, [r3, #4]
 8016f94:	6863      	ldr	r3, [r4, #4]
 8016f96:	bf08      	it	eq
 8016f98:	f8c8 1000 	streq.w	r1, [r8]
 8016f9c:	5162      	str	r2, [r4, r5]
 8016f9e:	604b      	str	r3, [r1, #4]
 8016fa0:	4630      	mov	r0, r6
 8016fa2:	f000 f82f 	bl	8017004 <__malloc_unlock>
 8016fa6:	f104 000b 	add.w	r0, r4, #11
 8016faa:	1d23      	adds	r3, r4, #4
 8016fac:	f020 0007 	bic.w	r0, r0, #7
 8016fb0:	1ac2      	subs	r2, r0, r3
 8016fb2:	bf1c      	itt	ne
 8016fb4:	1a1b      	subne	r3, r3, r0
 8016fb6:	50a3      	strne	r3, [r4, r2]
 8016fb8:	e7af      	b.n	8016f1a <_malloc_r+0x22>
 8016fba:	6862      	ldr	r2, [r4, #4]
 8016fbc:	42a3      	cmp	r3, r4
 8016fbe:	bf0c      	ite	eq
 8016fc0:	f8c8 2000 	streq.w	r2, [r8]
 8016fc4:	605a      	strne	r2, [r3, #4]
 8016fc6:	e7eb      	b.n	8016fa0 <_malloc_r+0xa8>
 8016fc8:	4623      	mov	r3, r4
 8016fca:	6864      	ldr	r4, [r4, #4]
 8016fcc:	e7ae      	b.n	8016f2c <_malloc_r+0x34>
 8016fce:	463c      	mov	r4, r7
 8016fd0:	687f      	ldr	r7, [r7, #4]
 8016fd2:	e7b6      	b.n	8016f42 <_malloc_r+0x4a>
 8016fd4:	461a      	mov	r2, r3
 8016fd6:	685b      	ldr	r3, [r3, #4]
 8016fd8:	42a3      	cmp	r3, r4
 8016fda:	d1fb      	bne.n	8016fd4 <_malloc_r+0xdc>
 8016fdc:	2300      	movs	r3, #0
 8016fde:	6053      	str	r3, [r2, #4]
 8016fe0:	e7de      	b.n	8016fa0 <_malloc_r+0xa8>
 8016fe2:	230c      	movs	r3, #12
 8016fe4:	6033      	str	r3, [r6, #0]
 8016fe6:	4630      	mov	r0, r6
 8016fe8:	f000 f80c 	bl	8017004 <__malloc_unlock>
 8016fec:	e794      	b.n	8016f18 <_malloc_r+0x20>
 8016fee:	6005      	str	r5, [r0, #0]
 8016ff0:	e7d6      	b.n	8016fa0 <_malloc_r+0xa8>
 8016ff2:	bf00      	nop
 8016ff4:	240060ec 	.word	0x240060ec

08016ff8 <__malloc_lock>:
 8016ff8:	4801      	ldr	r0, [pc, #4]	@ (8017000 <__malloc_lock+0x8>)
 8016ffa:	f000 bb04 	b.w	8017606 <__retarget_lock_acquire_recursive>
 8016ffe:	bf00      	nop
 8017000:	24006230 	.word	0x24006230

08017004 <__malloc_unlock>:
 8017004:	4801      	ldr	r0, [pc, #4]	@ (801700c <__malloc_unlock+0x8>)
 8017006:	f000 baff 	b.w	8017608 <__retarget_lock_release_recursive>
 801700a:	bf00      	nop
 801700c:	24006230 	.word	0x24006230

08017010 <_realloc_r>:
 8017010:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8017014:	4680      	mov	r8, r0
 8017016:	4615      	mov	r5, r2
 8017018:	460c      	mov	r4, r1
 801701a:	b921      	cbnz	r1, 8017026 <_realloc_r+0x16>
 801701c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8017020:	4611      	mov	r1, r2
 8017022:	f7ff bf69 	b.w	8016ef8 <_malloc_r>
 8017026:	b92a      	cbnz	r2, 8017034 <_realloc_r+0x24>
 8017028:	f000 fafe 	bl	8017628 <_free_r>
 801702c:	2400      	movs	r4, #0
 801702e:	4620      	mov	r0, r4
 8017030:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8017034:	f000 fb42 	bl	80176bc <_malloc_usable_size_r>
 8017038:	4285      	cmp	r5, r0
 801703a:	4606      	mov	r6, r0
 801703c:	d802      	bhi.n	8017044 <_realloc_r+0x34>
 801703e:	ebb5 0f50 	cmp.w	r5, r0, lsr #1
 8017042:	d8f4      	bhi.n	801702e <_realloc_r+0x1e>
 8017044:	4629      	mov	r1, r5
 8017046:	4640      	mov	r0, r8
 8017048:	f7ff ff56 	bl	8016ef8 <_malloc_r>
 801704c:	4607      	mov	r7, r0
 801704e:	2800      	cmp	r0, #0
 8017050:	d0ec      	beq.n	801702c <_realloc_r+0x1c>
 8017052:	42b5      	cmp	r5, r6
 8017054:	462a      	mov	r2, r5
 8017056:	4621      	mov	r1, r4
 8017058:	bf28      	it	cs
 801705a:	4632      	movcs	r2, r6
 801705c:	f000 fad5 	bl	801760a <memcpy>
 8017060:	4621      	mov	r1, r4
 8017062:	4640      	mov	r0, r8
 8017064:	f000 fae0 	bl	8017628 <_free_r>
 8017068:	463c      	mov	r4, r7
 801706a:	e7e0      	b.n	801702e <_realloc_r+0x1e>

0801706c <std>:
 801706c:	2300      	movs	r3, #0
 801706e:	b510      	push	{r4, lr}
 8017070:	4604      	mov	r4, r0
 8017072:	e9c0 3300 	strd	r3, r3, [r0]
 8017076:	e9c0 3304 	strd	r3, r3, [r0, #16]
 801707a:	6083      	str	r3, [r0, #8]
 801707c:	8181      	strh	r1, [r0, #12]
 801707e:	6643      	str	r3, [r0, #100]	@ 0x64
 8017080:	81c2      	strh	r2, [r0, #14]
 8017082:	6183      	str	r3, [r0, #24]
 8017084:	4619      	mov	r1, r3
 8017086:	2208      	movs	r2, #8
 8017088:	305c      	adds	r0, #92	@ 0x5c
 801708a:	f000 fa33 	bl	80174f4 <memset>
 801708e:	4b0d      	ldr	r3, [pc, #52]	@ (80170c4 <std+0x58>)
 8017090:	6263      	str	r3, [r4, #36]	@ 0x24
 8017092:	4b0d      	ldr	r3, [pc, #52]	@ (80170c8 <std+0x5c>)
 8017094:	62a3      	str	r3, [r4, #40]	@ 0x28
 8017096:	4b0d      	ldr	r3, [pc, #52]	@ (80170cc <std+0x60>)
 8017098:	62e3      	str	r3, [r4, #44]	@ 0x2c
 801709a:	4b0d      	ldr	r3, [pc, #52]	@ (80170d0 <std+0x64>)
 801709c:	6323      	str	r3, [r4, #48]	@ 0x30
 801709e:	4b0d      	ldr	r3, [pc, #52]	@ (80170d4 <std+0x68>)
 80170a0:	6224      	str	r4, [r4, #32]
 80170a2:	429c      	cmp	r4, r3
 80170a4:	d006      	beq.n	80170b4 <std+0x48>
 80170a6:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 80170aa:	4294      	cmp	r4, r2
 80170ac:	d002      	beq.n	80170b4 <std+0x48>
 80170ae:	33d0      	adds	r3, #208	@ 0xd0
 80170b0:	429c      	cmp	r4, r3
 80170b2:	d105      	bne.n	80170c0 <std+0x54>
 80170b4:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 80170b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80170bc:	f000 baa2 	b.w	8017604 <__retarget_lock_init_recursive>
 80170c0:	bd10      	pop	{r4, pc}
 80170c2:	bf00      	nop
 80170c4:	08017311 	.word	0x08017311
 80170c8:	08017333 	.word	0x08017333
 80170cc:	0801736b 	.word	0x0801736b
 80170d0:	0801738f 	.word	0x0801738f
 80170d4:	240060f0 	.word	0x240060f0

080170d8 <stdio_exit_handler>:
 80170d8:	4a02      	ldr	r2, [pc, #8]	@ (80170e4 <stdio_exit_handler+0xc>)
 80170da:	4903      	ldr	r1, [pc, #12]	@ (80170e8 <stdio_exit_handler+0x10>)
 80170dc:	4803      	ldr	r0, [pc, #12]	@ (80170ec <stdio_exit_handler+0x14>)
 80170de:	f000 b869 	b.w	80171b4 <_fwalk_sglue>
 80170e2:	bf00      	nop
 80170e4:	24000cd4 	.word	0x24000cd4
 80170e8:	08018025 	.word	0x08018025
 80170ec:	24000ce4 	.word	0x24000ce4

080170f0 <cleanup_stdio>:
 80170f0:	6841      	ldr	r1, [r0, #4]
 80170f2:	4b0c      	ldr	r3, [pc, #48]	@ (8017124 <cleanup_stdio+0x34>)
 80170f4:	4299      	cmp	r1, r3
 80170f6:	b510      	push	{r4, lr}
 80170f8:	4604      	mov	r4, r0
 80170fa:	d001      	beq.n	8017100 <cleanup_stdio+0x10>
 80170fc:	f000 ff92 	bl	8018024 <_fflush_r>
 8017100:	68a1      	ldr	r1, [r4, #8]
 8017102:	4b09      	ldr	r3, [pc, #36]	@ (8017128 <cleanup_stdio+0x38>)
 8017104:	4299      	cmp	r1, r3
 8017106:	d002      	beq.n	801710e <cleanup_stdio+0x1e>
 8017108:	4620      	mov	r0, r4
 801710a:	f000 ff8b 	bl	8018024 <_fflush_r>
 801710e:	68e1      	ldr	r1, [r4, #12]
 8017110:	4b06      	ldr	r3, [pc, #24]	@ (801712c <cleanup_stdio+0x3c>)
 8017112:	4299      	cmp	r1, r3
 8017114:	d004      	beq.n	8017120 <cleanup_stdio+0x30>
 8017116:	4620      	mov	r0, r4
 8017118:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801711c:	f000 bf82 	b.w	8018024 <_fflush_r>
 8017120:	bd10      	pop	{r4, pc}
 8017122:	bf00      	nop
 8017124:	240060f0 	.word	0x240060f0
 8017128:	24006158 	.word	0x24006158
 801712c:	240061c0 	.word	0x240061c0

08017130 <global_stdio_init.part.0>:
 8017130:	b510      	push	{r4, lr}
 8017132:	4b0b      	ldr	r3, [pc, #44]	@ (8017160 <global_stdio_init.part.0+0x30>)
 8017134:	4c0b      	ldr	r4, [pc, #44]	@ (8017164 <global_stdio_init.part.0+0x34>)
 8017136:	4a0c      	ldr	r2, [pc, #48]	@ (8017168 <global_stdio_init.part.0+0x38>)
 8017138:	601a      	str	r2, [r3, #0]
 801713a:	4620      	mov	r0, r4
 801713c:	2200      	movs	r2, #0
 801713e:	2104      	movs	r1, #4
 8017140:	f7ff ff94 	bl	801706c <std>
 8017144:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 8017148:	2201      	movs	r2, #1
 801714a:	2109      	movs	r1, #9
 801714c:	f7ff ff8e 	bl	801706c <std>
 8017150:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 8017154:	2202      	movs	r2, #2
 8017156:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801715a:	2112      	movs	r1, #18
 801715c:	f7ff bf86 	b.w	801706c <std>
 8017160:	24006228 	.word	0x24006228
 8017164:	240060f0 	.word	0x240060f0
 8017168:	080170d9 	.word	0x080170d9

0801716c <__sfp_lock_acquire>:
 801716c:	4801      	ldr	r0, [pc, #4]	@ (8017174 <__sfp_lock_acquire+0x8>)
 801716e:	f000 ba4a 	b.w	8017606 <__retarget_lock_acquire_recursive>
 8017172:	bf00      	nop
 8017174:	24006231 	.word	0x24006231

08017178 <__sfp_lock_release>:
 8017178:	4801      	ldr	r0, [pc, #4]	@ (8017180 <__sfp_lock_release+0x8>)
 801717a:	f000 ba45 	b.w	8017608 <__retarget_lock_release_recursive>
 801717e:	bf00      	nop
 8017180:	24006231 	.word	0x24006231

08017184 <__sinit>:
 8017184:	b510      	push	{r4, lr}
 8017186:	4604      	mov	r4, r0
 8017188:	f7ff fff0 	bl	801716c <__sfp_lock_acquire>
 801718c:	6a23      	ldr	r3, [r4, #32]
 801718e:	b11b      	cbz	r3, 8017198 <__sinit+0x14>
 8017190:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8017194:	f7ff bff0 	b.w	8017178 <__sfp_lock_release>
 8017198:	4b04      	ldr	r3, [pc, #16]	@ (80171ac <__sinit+0x28>)
 801719a:	6223      	str	r3, [r4, #32]
 801719c:	4b04      	ldr	r3, [pc, #16]	@ (80171b0 <__sinit+0x2c>)
 801719e:	681b      	ldr	r3, [r3, #0]
 80171a0:	2b00      	cmp	r3, #0
 80171a2:	d1f5      	bne.n	8017190 <__sinit+0xc>
 80171a4:	f7ff ffc4 	bl	8017130 <global_stdio_init.part.0>
 80171a8:	e7f2      	b.n	8017190 <__sinit+0xc>
 80171aa:	bf00      	nop
 80171ac:	080170f1 	.word	0x080170f1
 80171b0:	24006228 	.word	0x24006228

080171b4 <_fwalk_sglue>:
 80171b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80171b8:	4607      	mov	r7, r0
 80171ba:	4688      	mov	r8, r1
 80171bc:	4614      	mov	r4, r2
 80171be:	2600      	movs	r6, #0
 80171c0:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 80171c4:	f1b9 0901 	subs.w	r9, r9, #1
 80171c8:	d505      	bpl.n	80171d6 <_fwalk_sglue+0x22>
 80171ca:	6824      	ldr	r4, [r4, #0]
 80171cc:	2c00      	cmp	r4, #0
 80171ce:	d1f7      	bne.n	80171c0 <_fwalk_sglue+0xc>
 80171d0:	4630      	mov	r0, r6
 80171d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80171d6:	89ab      	ldrh	r3, [r5, #12]
 80171d8:	2b01      	cmp	r3, #1
 80171da:	d907      	bls.n	80171ec <_fwalk_sglue+0x38>
 80171dc:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 80171e0:	3301      	adds	r3, #1
 80171e2:	d003      	beq.n	80171ec <_fwalk_sglue+0x38>
 80171e4:	4629      	mov	r1, r5
 80171e6:	4638      	mov	r0, r7
 80171e8:	47c0      	blx	r8
 80171ea:	4306      	orrs	r6, r0
 80171ec:	3568      	adds	r5, #104	@ 0x68
 80171ee:	e7e9      	b.n	80171c4 <_fwalk_sglue+0x10>

080171f0 <iprintf>:
 80171f0:	b40f      	push	{r0, r1, r2, r3}
 80171f2:	b507      	push	{r0, r1, r2, lr}
 80171f4:	4906      	ldr	r1, [pc, #24]	@ (8017210 <iprintf+0x20>)
 80171f6:	ab04      	add	r3, sp, #16
 80171f8:	6808      	ldr	r0, [r1, #0]
 80171fa:	f853 2b04 	ldr.w	r2, [r3], #4
 80171fe:	6881      	ldr	r1, [r0, #8]
 8017200:	9301      	str	r3, [sp, #4]
 8017202:	f000 fbe5 	bl	80179d0 <_vfiprintf_r>
 8017206:	b003      	add	sp, #12
 8017208:	f85d eb04 	ldr.w	lr, [sp], #4
 801720c:	b004      	add	sp, #16
 801720e:	4770      	bx	lr
 8017210:	24000ce0 	.word	0x24000ce0

08017214 <_puts_r>:
 8017214:	6a03      	ldr	r3, [r0, #32]
 8017216:	b570      	push	{r4, r5, r6, lr}
 8017218:	6884      	ldr	r4, [r0, #8]
 801721a:	4605      	mov	r5, r0
 801721c:	460e      	mov	r6, r1
 801721e:	b90b      	cbnz	r3, 8017224 <_puts_r+0x10>
 8017220:	f7ff ffb0 	bl	8017184 <__sinit>
 8017224:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8017226:	07db      	lsls	r3, r3, #31
 8017228:	d405      	bmi.n	8017236 <_puts_r+0x22>
 801722a:	89a3      	ldrh	r3, [r4, #12]
 801722c:	0598      	lsls	r0, r3, #22
 801722e:	d402      	bmi.n	8017236 <_puts_r+0x22>
 8017230:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8017232:	f000 f9e8 	bl	8017606 <__retarget_lock_acquire_recursive>
 8017236:	89a3      	ldrh	r3, [r4, #12]
 8017238:	0719      	lsls	r1, r3, #28
 801723a:	d502      	bpl.n	8017242 <_puts_r+0x2e>
 801723c:	6923      	ldr	r3, [r4, #16]
 801723e:	2b00      	cmp	r3, #0
 8017240:	d135      	bne.n	80172ae <_puts_r+0x9a>
 8017242:	4621      	mov	r1, r4
 8017244:	4628      	mov	r0, r5
 8017246:	f000 f8e5 	bl	8017414 <__swsetup_r>
 801724a:	b380      	cbz	r0, 80172ae <_puts_r+0x9a>
 801724c:	f04f 35ff 	mov.w	r5, #4294967295
 8017250:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8017252:	07da      	lsls	r2, r3, #31
 8017254:	d405      	bmi.n	8017262 <_puts_r+0x4e>
 8017256:	89a3      	ldrh	r3, [r4, #12]
 8017258:	059b      	lsls	r3, r3, #22
 801725a:	d402      	bmi.n	8017262 <_puts_r+0x4e>
 801725c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 801725e:	f000 f9d3 	bl	8017608 <__retarget_lock_release_recursive>
 8017262:	4628      	mov	r0, r5
 8017264:	bd70      	pop	{r4, r5, r6, pc}
 8017266:	2b00      	cmp	r3, #0
 8017268:	da04      	bge.n	8017274 <_puts_r+0x60>
 801726a:	69a2      	ldr	r2, [r4, #24]
 801726c:	429a      	cmp	r2, r3
 801726e:	dc17      	bgt.n	80172a0 <_puts_r+0x8c>
 8017270:	290a      	cmp	r1, #10
 8017272:	d015      	beq.n	80172a0 <_puts_r+0x8c>
 8017274:	6823      	ldr	r3, [r4, #0]
 8017276:	1c5a      	adds	r2, r3, #1
 8017278:	6022      	str	r2, [r4, #0]
 801727a:	7019      	strb	r1, [r3, #0]
 801727c:	68a3      	ldr	r3, [r4, #8]
 801727e:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 8017282:	3b01      	subs	r3, #1
 8017284:	60a3      	str	r3, [r4, #8]
 8017286:	2900      	cmp	r1, #0
 8017288:	d1ed      	bne.n	8017266 <_puts_r+0x52>
 801728a:	2b00      	cmp	r3, #0
 801728c:	da11      	bge.n	80172b2 <_puts_r+0x9e>
 801728e:	4622      	mov	r2, r4
 8017290:	210a      	movs	r1, #10
 8017292:	4628      	mov	r0, r5
 8017294:	f000 f87f 	bl	8017396 <__swbuf_r>
 8017298:	3001      	adds	r0, #1
 801729a:	d0d7      	beq.n	801724c <_puts_r+0x38>
 801729c:	250a      	movs	r5, #10
 801729e:	e7d7      	b.n	8017250 <_puts_r+0x3c>
 80172a0:	4622      	mov	r2, r4
 80172a2:	4628      	mov	r0, r5
 80172a4:	f000 f877 	bl	8017396 <__swbuf_r>
 80172a8:	3001      	adds	r0, #1
 80172aa:	d1e7      	bne.n	801727c <_puts_r+0x68>
 80172ac:	e7ce      	b.n	801724c <_puts_r+0x38>
 80172ae:	3e01      	subs	r6, #1
 80172b0:	e7e4      	b.n	801727c <_puts_r+0x68>
 80172b2:	6823      	ldr	r3, [r4, #0]
 80172b4:	1c5a      	adds	r2, r3, #1
 80172b6:	6022      	str	r2, [r4, #0]
 80172b8:	220a      	movs	r2, #10
 80172ba:	701a      	strb	r2, [r3, #0]
 80172bc:	e7ee      	b.n	801729c <_puts_r+0x88>
	...

080172c0 <puts>:
 80172c0:	4b02      	ldr	r3, [pc, #8]	@ (80172cc <puts+0xc>)
 80172c2:	4601      	mov	r1, r0
 80172c4:	6818      	ldr	r0, [r3, #0]
 80172c6:	f7ff bfa5 	b.w	8017214 <_puts_r>
 80172ca:	bf00      	nop
 80172cc:	24000ce0 	.word	0x24000ce0

080172d0 <siprintf>:
 80172d0:	b40e      	push	{r1, r2, r3}
 80172d2:	b500      	push	{lr}
 80172d4:	b09c      	sub	sp, #112	@ 0x70
 80172d6:	ab1d      	add	r3, sp, #116	@ 0x74
 80172d8:	9002      	str	r0, [sp, #8]
 80172da:	9006      	str	r0, [sp, #24]
 80172dc:	f06f 4100 	mvn.w	r1, #2147483648	@ 0x80000000
 80172e0:	4809      	ldr	r0, [pc, #36]	@ (8017308 <siprintf+0x38>)
 80172e2:	9107      	str	r1, [sp, #28]
 80172e4:	9104      	str	r1, [sp, #16]
 80172e6:	4909      	ldr	r1, [pc, #36]	@ (801730c <siprintf+0x3c>)
 80172e8:	f853 2b04 	ldr.w	r2, [r3], #4
 80172ec:	9105      	str	r1, [sp, #20]
 80172ee:	6800      	ldr	r0, [r0, #0]
 80172f0:	9301      	str	r3, [sp, #4]
 80172f2:	a902      	add	r1, sp, #8
 80172f4:	f000 fa46 	bl	8017784 <_svfiprintf_r>
 80172f8:	9b02      	ldr	r3, [sp, #8]
 80172fa:	2200      	movs	r2, #0
 80172fc:	701a      	strb	r2, [r3, #0]
 80172fe:	b01c      	add	sp, #112	@ 0x70
 8017300:	f85d eb04 	ldr.w	lr, [sp], #4
 8017304:	b003      	add	sp, #12
 8017306:	4770      	bx	lr
 8017308:	24000ce0 	.word	0x24000ce0
 801730c:	ffff0208 	.word	0xffff0208

08017310 <__sread>:
 8017310:	b510      	push	{r4, lr}
 8017312:	460c      	mov	r4, r1
 8017314:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8017318:	f000 f916 	bl	8017548 <_read_r>
 801731c:	2800      	cmp	r0, #0
 801731e:	bfab      	itete	ge
 8017320:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 8017322:	89a3      	ldrhlt	r3, [r4, #12]
 8017324:	181b      	addge	r3, r3, r0
 8017326:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 801732a:	bfac      	ite	ge
 801732c:	6563      	strge	r3, [r4, #84]	@ 0x54
 801732e:	81a3      	strhlt	r3, [r4, #12]
 8017330:	bd10      	pop	{r4, pc}

08017332 <__swrite>:
 8017332:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8017336:	461f      	mov	r7, r3
 8017338:	898b      	ldrh	r3, [r1, #12]
 801733a:	05db      	lsls	r3, r3, #23
 801733c:	4605      	mov	r5, r0
 801733e:	460c      	mov	r4, r1
 8017340:	4616      	mov	r6, r2
 8017342:	d505      	bpl.n	8017350 <__swrite+0x1e>
 8017344:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8017348:	2302      	movs	r3, #2
 801734a:	2200      	movs	r2, #0
 801734c:	f000 f8ea 	bl	8017524 <_lseek_r>
 8017350:	89a3      	ldrh	r3, [r4, #12]
 8017352:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8017356:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 801735a:	81a3      	strh	r3, [r4, #12]
 801735c:	4632      	mov	r2, r6
 801735e:	463b      	mov	r3, r7
 8017360:	4628      	mov	r0, r5
 8017362:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8017366:	f000 b911 	b.w	801758c <_write_r>

0801736a <__sseek>:
 801736a:	b510      	push	{r4, lr}
 801736c:	460c      	mov	r4, r1
 801736e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8017372:	f000 f8d7 	bl	8017524 <_lseek_r>
 8017376:	1c43      	adds	r3, r0, #1
 8017378:	89a3      	ldrh	r3, [r4, #12]
 801737a:	bf15      	itete	ne
 801737c:	6560      	strne	r0, [r4, #84]	@ 0x54
 801737e:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 8017382:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 8017386:	81a3      	strheq	r3, [r4, #12]
 8017388:	bf18      	it	ne
 801738a:	81a3      	strhne	r3, [r4, #12]
 801738c:	bd10      	pop	{r4, pc}

0801738e <__sclose>:
 801738e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8017392:	f000 b8b7 	b.w	8017504 <_close_r>

08017396 <__swbuf_r>:
 8017396:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8017398:	460e      	mov	r6, r1
 801739a:	4614      	mov	r4, r2
 801739c:	4605      	mov	r5, r0
 801739e:	b118      	cbz	r0, 80173a8 <__swbuf_r+0x12>
 80173a0:	6a03      	ldr	r3, [r0, #32]
 80173a2:	b90b      	cbnz	r3, 80173a8 <__swbuf_r+0x12>
 80173a4:	f7ff feee 	bl	8017184 <__sinit>
 80173a8:	69a3      	ldr	r3, [r4, #24]
 80173aa:	60a3      	str	r3, [r4, #8]
 80173ac:	89a3      	ldrh	r3, [r4, #12]
 80173ae:	071a      	lsls	r2, r3, #28
 80173b0:	d501      	bpl.n	80173b6 <__swbuf_r+0x20>
 80173b2:	6923      	ldr	r3, [r4, #16]
 80173b4:	b943      	cbnz	r3, 80173c8 <__swbuf_r+0x32>
 80173b6:	4621      	mov	r1, r4
 80173b8:	4628      	mov	r0, r5
 80173ba:	f000 f82b 	bl	8017414 <__swsetup_r>
 80173be:	b118      	cbz	r0, 80173c8 <__swbuf_r+0x32>
 80173c0:	f04f 37ff 	mov.w	r7, #4294967295
 80173c4:	4638      	mov	r0, r7
 80173c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80173c8:	6823      	ldr	r3, [r4, #0]
 80173ca:	6922      	ldr	r2, [r4, #16]
 80173cc:	1a98      	subs	r0, r3, r2
 80173ce:	6963      	ldr	r3, [r4, #20]
 80173d0:	b2f6      	uxtb	r6, r6
 80173d2:	4283      	cmp	r3, r0
 80173d4:	4637      	mov	r7, r6
 80173d6:	dc05      	bgt.n	80173e4 <__swbuf_r+0x4e>
 80173d8:	4621      	mov	r1, r4
 80173da:	4628      	mov	r0, r5
 80173dc:	f000 fe22 	bl	8018024 <_fflush_r>
 80173e0:	2800      	cmp	r0, #0
 80173e2:	d1ed      	bne.n	80173c0 <__swbuf_r+0x2a>
 80173e4:	68a3      	ldr	r3, [r4, #8]
 80173e6:	3b01      	subs	r3, #1
 80173e8:	60a3      	str	r3, [r4, #8]
 80173ea:	6823      	ldr	r3, [r4, #0]
 80173ec:	1c5a      	adds	r2, r3, #1
 80173ee:	6022      	str	r2, [r4, #0]
 80173f0:	701e      	strb	r6, [r3, #0]
 80173f2:	6962      	ldr	r2, [r4, #20]
 80173f4:	1c43      	adds	r3, r0, #1
 80173f6:	429a      	cmp	r2, r3
 80173f8:	d004      	beq.n	8017404 <__swbuf_r+0x6e>
 80173fa:	89a3      	ldrh	r3, [r4, #12]
 80173fc:	07db      	lsls	r3, r3, #31
 80173fe:	d5e1      	bpl.n	80173c4 <__swbuf_r+0x2e>
 8017400:	2e0a      	cmp	r6, #10
 8017402:	d1df      	bne.n	80173c4 <__swbuf_r+0x2e>
 8017404:	4621      	mov	r1, r4
 8017406:	4628      	mov	r0, r5
 8017408:	f000 fe0c 	bl	8018024 <_fflush_r>
 801740c:	2800      	cmp	r0, #0
 801740e:	d0d9      	beq.n	80173c4 <__swbuf_r+0x2e>
 8017410:	e7d6      	b.n	80173c0 <__swbuf_r+0x2a>
	...

08017414 <__swsetup_r>:
 8017414:	b538      	push	{r3, r4, r5, lr}
 8017416:	4b29      	ldr	r3, [pc, #164]	@ (80174bc <__swsetup_r+0xa8>)
 8017418:	4605      	mov	r5, r0
 801741a:	6818      	ldr	r0, [r3, #0]
 801741c:	460c      	mov	r4, r1
 801741e:	b118      	cbz	r0, 8017428 <__swsetup_r+0x14>
 8017420:	6a03      	ldr	r3, [r0, #32]
 8017422:	b90b      	cbnz	r3, 8017428 <__swsetup_r+0x14>
 8017424:	f7ff feae 	bl	8017184 <__sinit>
 8017428:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801742c:	0719      	lsls	r1, r3, #28
 801742e:	d422      	bmi.n	8017476 <__swsetup_r+0x62>
 8017430:	06da      	lsls	r2, r3, #27
 8017432:	d407      	bmi.n	8017444 <__swsetup_r+0x30>
 8017434:	2209      	movs	r2, #9
 8017436:	602a      	str	r2, [r5, #0]
 8017438:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801743c:	81a3      	strh	r3, [r4, #12]
 801743e:	f04f 30ff 	mov.w	r0, #4294967295
 8017442:	e033      	b.n	80174ac <__swsetup_r+0x98>
 8017444:	0758      	lsls	r0, r3, #29
 8017446:	d512      	bpl.n	801746e <__swsetup_r+0x5a>
 8017448:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 801744a:	b141      	cbz	r1, 801745e <__swsetup_r+0x4a>
 801744c:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 8017450:	4299      	cmp	r1, r3
 8017452:	d002      	beq.n	801745a <__swsetup_r+0x46>
 8017454:	4628      	mov	r0, r5
 8017456:	f000 f8e7 	bl	8017628 <_free_r>
 801745a:	2300      	movs	r3, #0
 801745c:	6363      	str	r3, [r4, #52]	@ 0x34
 801745e:	89a3      	ldrh	r3, [r4, #12]
 8017460:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 8017464:	81a3      	strh	r3, [r4, #12]
 8017466:	2300      	movs	r3, #0
 8017468:	6063      	str	r3, [r4, #4]
 801746a:	6923      	ldr	r3, [r4, #16]
 801746c:	6023      	str	r3, [r4, #0]
 801746e:	89a3      	ldrh	r3, [r4, #12]
 8017470:	f043 0308 	orr.w	r3, r3, #8
 8017474:	81a3      	strh	r3, [r4, #12]
 8017476:	6923      	ldr	r3, [r4, #16]
 8017478:	b94b      	cbnz	r3, 801748e <__swsetup_r+0x7a>
 801747a:	89a3      	ldrh	r3, [r4, #12]
 801747c:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 8017480:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 8017484:	d003      	beq.n	801748e <__swsetup_r+0x7a>
 8017486:	4621      	mov	r1, r4
 8017488:	4628      	mov	r0, r5
 801748a:	f000 fe19 	bl	80180c0 <__smakebuf_r>
 801748e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8017492:	f013 0201 	ands.w	r2, r3, #1
 8017496:	d00a      	beq.n	80174ae <__swsetup_r+0x9a>
 8017498:	2200      	movs	r2, #0
 801749a:	60a2      	str	r2, [r4, #8]
 801749c:	6962      	ldr	r2, [r4, #20]
 801749e:	4252      	negs	r2, r2
 80174a0:	61a2      	str	r2, [r4, #24]
 80174a2:	6922      	ldr	r2, [r4, #16]
 80174a4:	b942      	cbnz	r2, 80174b8 <__swsetup_r+0xa4>
 80174a6:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 80174aa:	d1c5      	bne.n	8017438 <__swsetup_r+0x24>
 80174ac:	bd38      	pop	{r3, r4, r5, pc}
 80174ae:	0799      	lsls	r1, r3, #30
 80174b0:	bf58      	it	pl
 80174b2:	6962      	ldrpl	r2, [r4, #20]
 80174b4:	60a2      	str	r2, [r4, #8]
 80174b6:	e7f4      	b.n	80174a2 <__swsetup_r+0x8e>
 80174b8:	2000      	movs	r0, #0
 80174ba:	e7f7      	b.n	80174ac <__swsetup_r+0x98>
 80174bc:	24000ce0 	.word	0x24000ce0

080174c0 <memmove>:
 80174c0:	4288      	cmp	r0, r1
 80174c2:	b510      	push	{r4, lr}
 80174c4:	eb01 0402 	add.w	r4, r1, r2
 80174c8:	d902      	bls.n	80174d0 <memmove+0x10>
 80174ca:	4284      	cmp	r4, r0
 80174cc:	4623      	mov	r3, r4
 80174ce:	d807      	bhi.n	80174e0 <memmove+0x20>
 80174d0:	1e43      	subs	r3, r0, #1
 80174d2:	42a1      	cmp	r1, r4
 80174d4:	d008      	beq.n	80174e8 <memmove+0x28>
 80174d6:	f811 2b01 	ldrb.w	r2, [r1], #1
 80174da:	f803 2f01 	strb.w	r2, [r3, #1]!
 80174de:	e7f8      	b.n	80174d2 <memmove+0x12>
 80174e0:	4402      	add	r2, r0
 80174e2:	4601      	mov	r1, r0
 80174e4:	428a      	cmp	r2, r1
 80174e6:	d100      	bne.n	80174ea <memmove+0x2a>
 80174e8:	bd10      	pop	{r4, pc}
 80174ea:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80174ee:	f802 4d01 	strb.w	r4, [r2, #-1]!
 80174f2:	e7f7      	b.n	80174e4 <memmove+0x24>

080174f4 <memset>:
 80174f4:	4402      	add	r2, r0
 80174f6:	4603      	mov	r3, r0
 80174f8:	4293      	cmp	r3, r2
 80174fa:	d100      	bne.n	80174fe <memset+0xa>
 80174fc:	4770      	bx	lr
 80174fe:	f803 1b01 	strb.w	r1, [r3], #1
 8017502:	e7f9      	b.n	80174f8 <memset+0x4>

08017504 <_close_r>:
 8017504:	b538      	push	{r3, r4, r5, lr}
 8017506:	4d06      	ldr	r5, [pc, #24]	@ (8017520 <_close_r+0x1c>)
 8017508:	2300      	movs	r3, #0
 801750a:	4604      	mov	r4, r0
 801750c:	4608      	mov	r0, r1
 801750e:	602b      	str	r3, [r5, #0]
 8017510:	f000 fefa 	bl	8018308 <_close>
 8017514:	1c43      	adds	r3, r0, #1
 8017516:	d102      	bne.n	801751e <_close_r+0x1a>
 8017518:	682b      	ldr	r3, [r5, #0]
 801751a:	b103      	cbz	r3, 801751e <_close_r+0x1a>
 801751c:	6023      	str	r3, [r4, #0]
 801751e:	bd38      	pop	{r3, r4, r5, pc}
 8017520:	2400622c 	.word	0x2400622c

08017524 <_lseek_r>:
 8017524:	b538      	push	{r3, r4, r5, lr}
 8017526:	4d07      	ldr	r5, [pc, #28]	@ (8017544 <_lseek_r+0x20>)
 8017528:	4604      	mov	r4, r0
 801752a:	4608      	mov	r0, r1
 801752c:	4611      	mov	r1, r2
 801752e:	2200      	movs	r2, #0
 8017530:	602a      	str	r2, [r5, #0]
 8017532:	461a      	mov	r2, r3
 8017534:	f000 ff00 	bl	8018338 <_lseek>
 8017538:	1c43      	adds	r3, r0, #1
 801753a:	d102      	bne.n	8017542 <_lseek_r+0x1e>
 801753c:	682b      	ldr	r3, [r5, #0]
 801753e:	b103      	cbz	r3, 8017542 <_lseek_r+0x1e>
 8017540:	6023      	str	r3, [r4, #0]
 8017542:	bd38      	pop	{r3, r4, r5, pc}
 8017544:	2400622c 	.word	0x2400622c

08017548 <_read_r>:
 8017548:	b538      	push	{r3, r4, r5, lr}
 801754a:	4d07      	ldr	r5, [pc, #28]	@ (8017568 <_read_r+0x20>)
 801754c:	4604      	mov	r4, r0
 801754e:	4608      	mov	r0, r1
 8017550:	4611      	mov	r1, r2
 8017552:	2200      	movs	r2, #0
 8017554:	602a      	str	r2, [r5, #0]
 8017556:	461a      	mov	r2, r3
 8017558:	f000 fef6 	bl	8018348 <_read>
 801755c:	1c43      	adds	r3, r0, #1
 801755e:	d102      	bne.n	8017566 <_read_r+0x1e>
 8017560:	682b      	ldr	r3, [r5, #0]
 8017562:	b103      	cbz	r3, 8017566 <_read_r+0x1e>
 8017564:	6023      	str	r3, [r4, #0]
 8017566:	bd38      	pop	{r3, r4, r5, pc}
 8017568:	2400622c 	.word	0x2400622c

0801756c <_sbrk_r>:
 801756c:	b538      	push	{r3, r4, r5, lr}
 801756e:	4d06      	ldr	r5, [pc, #24]	@ (8017588 <_sbrk_r+0x1c>)
 8017570:	2300      	movs	r3, #0
 8017572:	4604      	mov	r4, r0
 8017574:	4608      	mov	r0, r1
 8017576:	602b      	str	r3, [r5, #0]
 8017578:	f7ea fa02 	bl	8001980 <_sbrk>
 801757c:	1c43      	adds	r3, r0, #1
 801757e:	d102      	bne.n	8017586 <_sbrk_r+0x1a>
 8017580:	682b      	ldr	r3, [r5, #0]
 8017582:	b103      	cbz	r3, 8017586 <_sbrk_r+0x1a>
 8017584:	6023      	str	r3, [r4, #0]
 8017586:	bd38      	pop	{r3, r4, r5, pc}
 8017588:	2400622c 	.word	0x2400622c

0801758c <_write_r>:
 801758c:	b538      	push	{r3, r4, r5, lr}
 801758e:	4d07      	ldr	r5, [pc, #28]	@ (80175ac <_write_r+0x20>)
 8017590:	4604      	mov	r4, r0
 8017592:	4608      	mov	r0, r1
 8017594:	4611      	mov	r1, r2
 8017596:	2200      	movs	r2, #0
 8017598:	602a      	str	r2, [r5, #0]
 801759a:	461a      	mov	r2, r3
 801759c:	f000 fedc 	bl	8018358 <_write>
 80175a0:	1c43      	adds	r3, r0, #1
 80175a2:	d102      	bne.n	80175aa <_write_r+0x1e>
 80175a4:	682b      	ldr	r3, [r5, #0]
 80175a6:	b103      	cbz	r3, 80175aa <_write_r+0x1e>
 80175a8:	6023      	str	r3, [r4, #0]
 80175aa:	bd38      	pop	{r3, r4, r5, pc}
 80175ac:	2400622c 	.word	0x2400622c

080175b0 <__errno>:
 80175b0:	4b01      	ldr	r3, [pc, #4]	@ (80175b8 <__errno+0x8>)
 80175b2:	6818      	ldr	r0, [r3, #0]
 80175b4:	4770      	bx	lr
 80175b6:	bf00      	nop
 80175b8:	24000ce0 	.word	0x24000ce0

080175bc <__libc_init_array>:
 80175bc:	b570      	push	{r4, r5, r6, lr}
 80175be:	4d0d      	ldr	r5, [pc, #52]	@ (80175f4 <__libc_init_array+0x38>)
 80175c0:	4c0d      	ldr	r4, [pc, #52]	@ (80175f8 <__libc_init_array+0x3c>)
 80175c2:	1b64      	subs	r4, r4, r5
 80175c4:	10a4      	asrs	r4, r4, #2
 80175c6:	2600      	movs	r6, #0
 80175c8:	42a6      	cmp	r6, r4
 80175ca:	d109      	bne.n	80175e0 <__libc_init_array+0x24>
 80175cc:	4d0b      	ldr	r5, [pc, #44]	@ (80175fc <__libc_init_array+0x40>)
 80175ce:	4c0c      	ldr	r4, [pc, #48]	@ (8017600 <__libc_init_array+0x44>)
 80175d0:	f000 feca 	bl	8018368 <_init>
 80175d4:	1b64      	subs	r4, r4, r5
 80175d6:	10a4      	asrs	r4, r4, #2
 80175d8:	2600      	movs	r6, #0
 80175da:	42a6      	cmp	r6, r4
 80175dc:	d105      	bne.n	80175ea <__libc_init_array+0x2e>
 80175de:	bd70      	pop	{r4, r5, r6, pc}
 80175e0:	f855 3b04 	ldr.w	r3, [r5], #4
 80175e4:	4798      	blx	r3
 80175e6:	3601      	adds	r6, #1
 80175e8:	e7ee      	b.n	80175c8 <__libc_init_array+0xc>
 80175ea:	f855 3b04 	ldr.w	r3, [r5], #4
 80175ee:	4798      	blx	r3
 80175f0:	3601      	adds	r6, #1
 80175f2:	e7f2      	b.n	80175da <__libc_init_array+0x1e>
 80175f4:	080224e0 	.word	0x080224e0
 80175f8:	080224e0 	.word	0x080224e0
 80175fc:	080224e0 	.word	0x080224e0
 8017600:	080224e4 	.word	0x080224e4

08017604 <__retarget_lock_init_recursive>:
 8017604:	4770      	bx	lr

08017606 <__retarget_lock_acquire_recursive>:
 8017606:	4770      	bx	lr

08017608 <__retarget_lock_release_recursive>:
 8017608:	4770      	bx	lr

0801760a <memcpy>:
 801760a:	440a      	add	r2, r1
 801760c:	4291      	cmp	r1, r2
 801760e:	f100 33ff 	add.w	r3, r0, #4294967295
 8017612:	d100      	bne.n	8017616 <memcpy+0xc>
 8017614:	4770      	bx	lr
 8017616:	b510      	push	{r4, lr}
 8017618:	f811 4b01 	ldrb.w	r4, [r1], #1
 801761c:	f803 4f01 	strb.w	r4, [r3, #1]!
 8017620:	4291      	cmp	r1, r2
 8017622:	d1f9      	bne.n	8017618 <memcpy+0xe>
 8017624:	bd10      	pop	{r4, pc}
	...

08017628 <_free_r>:
 8017628:	b538      	push	{r3, r4, r5, lr}
 801762a:	4605      	mov	r5, r0
 801762c:	2900      	cmp	r1, #0
 801762e:	d041      	beq.n	80176b4 <_free_r+0x8c>
 8017630:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8017634:	1f0c      	subs	r4, r1, #4
 8017636:	2b00      	cmp	r3, #0
 8017638:	bfb8      	it	lt
 801763a:	18e4      	addlt	r4, r4, r3
 801763c:	f7ff fcdc 	bl	8016ff8 <__malloc_lock>
 8017640:	4a1d      	ldr	r2, [pc, #116]	@ (80176b8 <_free_r+0x90>)
 8017642:	6813      	ldr	r3, [r2, #0]
 8017644:	b933      	cbnz	r3, 8017654 <_free_r+0x2c>
 8017646:	6063      	str	r3, [r4, #4]
 8017648:	6014      	str	r4, [r2, #0]
 801764a:	4628      	mov	r0, r5
 801764c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8017650:	f7ff bcd8 	b.w	8017004 <__malloc_unlock>
 8017654:	42a3      	cmp	r3, r4
 8017656:	d908      	bls.n	801766a <_free_r+0x42>
 8017658:	6820      	ldr	r0, [r4, #0]
 801765a:	1821      	adds	r1, r4, r0
 801765c:	428b      	cmp	r3, r1
 801765e:	bf01      	itttt	eq
 8017660:	6819      	ldreq	r1, [r3, #0]
 8017662:	685b      	ldreq	r3, [r3, #4]
 8017664:	1809      	addeq	r1, r1, r0
 8017666:	6021      	streq	r1, [r4, #0]
 8017668:	e7ed      	b.n	8017646 <_free_r+0x1e>
 801766a:	461a      	mov	r2, r3
 801766c:	685b      	ldr	r3, [r3, #4]
 801766e:	b10b      	cbz	r3, 8017674 <_free_r+0x4c>
 8017670:	42a3      	cmp	r3, r4
 8017672:	d9fa      	bls.n	801766a <_free_r+0x42>
 8017674:	6811      	ldr	r1, [r2, #0]
 8017676:	1850      	adds	r0, r2, r1
 8017678:	42a0      	cmp	r0, r4
 801767a:	d10b      	bne.n	8017694 <_free_r+0x6c>
 801767c:	6820      	ldr	r0, [r4, #0]
 801767e:	4401      	add	r1, r0
 8017680:	1850      	adds	r0, r2, r1
 8017682:	4283      	cmp	r3, r0
 8017684:	6011      	str	r1, [r2, #0]
 8017686:	d1e0      	bne.n	801764a <_free_r+0x22>
 8017688:	6818      	ldr	r0, [r3, #0]
 801768a:	685b      	ldr	r3, [r3, #4]
 801768c:	6053      	str	r3, [r2, #4]
 801768e:	4408      	add	r0, r1
 8017690:	6010      	str	r0, [r2, #0]
 8017692:	e7da      	b.n	801764a <_free_r+0x22>
 8017694:	d902      	bls.n	801769c <_free_r+0x74>
 8017696:	230c      	movs	r3, #12
 8017698:	602b      	str	r3, [r5, #0]
 801769a:	e7d6      	b.n	801764a <_free_r+0x22>
 801769c:	6820      	ldr	r0, [r4, #0]
 801769e:	1821      	adds	r1, r4, r0
 80176a0:	428b      	cmp	r3, r1
 80176a2:	bf04      	itt	eq
 80176a4:	6819      	ldreq	r1, [r3, #0]
 80176a6:	685b      	ldreq	r3, [r3, #4]
 80176a8:	6063      	str	r3, [r4, #4]
 80176aa:	bf04      	itt	eq
 80176ac:	1809      	addeq	r1, r1, r0
 80176ae:	6021      	streq	r1, [r4, #0]
 80176b0:	6054      	str	r4, [r2, #4]
 80176b2:	e7ca      	b.n	801764a <_free_r+0x22>
 80176b4:	bd38      	pop	{r3, r4, r5, pc}
 80176b6:	bf00      	nop
 80176b8:	240060ec 	.word	0x240060ec

080176bc <_malloc_usable_size_r>:
 80176bc:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80176c0:	1f18      	subs	r0, r3, #4
 80176c2:	2b00      	cmp	r3, #0
 80176c4:	bfbc      	itt	lt
 80176c6:	580b      	ldrlt	r3, [r1, r0]
 80176c8:	18c0      	addlt	r0, r0, r3
 80176ca:	4770      	bx	lr

080176cc <__ssputs_r>:
 80176cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80176d0:	688e      	ldr	r6, [r1, #8]
 80176d2:	461f      	mov	r7, r3
 80176d4:	42be      	cmp	r6, r7
 80176d6:	680b      	ldr	r3, [r1, #0]
 80176d8:	4682      	mov	sl, r0
 80176da:	460c      	mov	r4, r1
 80176dc:	4690      	mov	r8, r2
 80176de:	d82d      	bhi.n	801773c <__ssputs_r+0x70>
 80176e0:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 80176e4:	f412 6f90 	tst.w	r2, #1152	@ 0x480
 80176e8:	d026      	beq.n	8017738 <__ssputs_r+0x6c>
 80176ea:	6965      	ldr	r5, [r4, #20]
 80176ec:	6909      	ldr	r1, [r1, #16]
 80176ee:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 80176f2:	eba3 0901 	sub.w	r9, r3, r1
 80176f6:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 80176fa:	1c7b      	adds	r3, r7, #1
 80176fc:	444b      	add	r3, r9
 80176fe:	106d      	asrs	r5, r5, #1
 8017700:	429d      	cmp	r5, r3
 8017702:	bf38      	it	cc
 8017704:	461d      	movcc	r5, r3
 8017706:	0553      	lsls	r3, r2, #21
 8017708:	d527      	bpl.n	801775a <__ssputs_r+0x8e>
 801770a:	4629      	mov	r1, r5
 801770c:	f7ff fbf4 	bl	8016ef8 <_malloc_r>
 8017710:	4606      	mov	r6, r0
 8017712:	b360      	cbz	r0, 801776e <__ssputs_r+0xa2>
 8017714:	6921      	ldr	r1, [r4, #16]
 8017716:	464a      	mov	r2, r9
 8017718:	f7ff ff77 	bl	801760a <memcpy>
 801771c:	89a3      	ldrh	r3, [r4, #12]
 801771e:	f423 6390 	bic.w	r3, r3, #1152	@ 0x480
 8017722:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8017726:	81a3      	strh	r3, [r4, #12]
 8017728:	6126      	str	r6, [r4, #16]
 801772a:	6165      	str	r5, [r4, #20]
 801772c:	444e      	add	r6, r9
 801772e:	eba5 0509 	sub.w	r5, r5, r9
 8017732:	6026      	str	r6, [r4, #0]
 8017734:	60a5      	str	r5, [r4, #8]
 8017736:	463e      	mov	r6, r7
 8017738:	42be      	cmp	r6, r7
 801773a:	d900      	bls.n	801773e <__ssputs_r+0x72>
 801773c:	463e      	mov	r6, r7
 801773e:	6820      	ldr	r0, [r4, #0]
 8017740:	4632      	mov	r2, r6
 8017742:	4641      	mov	r1, r8
 8017744:	f7ff febc 	bl	80174c0 <memmove>
 8017748:	68a3      	ldr	r3, [r4, #8]
 801774a:	1b9b      	subs	r3, r3, r6
 801774c:	60a3      	str	r3, [r4, #8]
 801774e:	6823      	ldr	r3, [r4, #0]
 8017750:	4433      	add	r3, r6
 8017752:	6023      	str	r3, [r4, #0]
 8017754:	2000      	movs	r0, #0
 8017756:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801775a:	462a      	mov	r2, r5
 801775c:	f7ff fc58 	bl	8017010 <_realloc_r>
 8017760:	4606      	mov	r6, r0
 8017762:	2800      	cmp	r0, #0
 8017764:	d1e0      	bne.n	8017728 <__ssputs_r+0x5c>
 8017766:	6921      	ldr	r1, [r4, #16]
 8017768:	4650      	mov	r0, sl
 801776a:	f7ff ff5d 	bl	8017628 <_free_r>
 801776e:	230c      	movs	r3, #12
 8017770:	f8ca 3000 	str.w	r3, [sl]
 8017774:	89a3      	ldrh	r3, [r4, #12]
 8017776:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801777a:	81a3      	strh	r3, [r4, #12]
 801777c:	f04f 30ff 	mov.w	r0, #4294967295
 8017780:	e7e9      	b.n	8017756 <__ssputs_r+0x8a>
	...

08017784 <_svfiprintf_r>:
 8017784:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8017788:	4698      	mov	r8, r3
 801778a:	898b      	ldrh	r3, [r1, #12]
 801778c:	061b      	lsls	r3, r3, #24
 801778e:	b09d      	sub	sp, #116	@ 0x74
 8017790:	4607      	mov	r7, r0
 8017792:	460d      	mov	r5, r1
 8017794:	4614      	mov	r4, r2
 8017796:	d510      	bpl.n	80177ba <_svfiprintf_r+0x36>
 8017798:	690b      	ldr	r3, [r1, #16]
 801779a:	b973      	cbnz	r3, 80177ba <_svfiprintf_r+0x36>
 801779c:	2140      	movs	r1, #64	@ 0x40
 801779e:	f7ff fbab 	bl	8016ef8 <_malloc_r>
 80177a2:	6028      	str	r0, [r5, #0]
 80177a4:	6128      	str	r0, [r5, #16]
 80177a6:	b930      	cbnz	r0, 80177b6 <_svfiprintf_r+0x32>
 80177a8:	230c      	movs	r3, #12
 80177aa:	603b      	str	r3, [r7, #0]
 80177ac:	f04f 30ff 	mov.w	r0, #4294967295
 80177b0:	b01d      	add	sp, #116	@ 0x74
 80177b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80177b6:	2340      	movs	r3, #64	@ 0x40
 80177b8:	616b      	str	r3, [r5, #20]
 80177ba:	2300      	movs	r3, #0
 80177bc:	9309      	str	r3, [sp, #36]	@ 0x24
 80177be:	2320      	movs	r3, #32
 80177c0:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 80177c4:	f8cd 800c 	str.w	r8, [sp, #12]
 80177c8:	2330      	movs	r3, #48	@ 0x30
 80177ca:	f8df 819c 	ldr.w	r8, [pc, #412]	@ 8017968 <_svfiprintf_r+0x1e4>
 80177ce:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 80177d2:	f04f 0901 	mov.w	r9, #1
 80177d6:	4623      	mov	r3, r4
 80177d8:	469a      	mov	sl, r3
 80177da:	f813 2b01 	ldrb.w	r2, [r3], #1
 80177de:	b10a      	cbz	r2, 80177e4 <_svfiprintf_r+0x60>
 80177e0:	2a25      	cmp	r2, #37	@ 0x25
 80177e2:	d1f9      	bne.n	80177d8 <_svfiprintf_r+0x54>
 80177e4:	ebba 0b04 	subs.w	fp, sl, r4
 80177e8:	d00b      	beq.n	8017802 <_svfiprintf_r+0x7e>
 80177ea:	465b      	mov	r3, fp
 80177ec:	4622      	mov	r2, r4
 80177ee:	4629      	mov	r1, r5
 80177f0:	4638      	mov	r0, r7
 80177f2:	f7ff ff6b 	bl	80176cc <__ssputs_r>
 80177f6:	3001      	adds	r0, #1
 80177f8:	f000 80a7 	beq.w	801794a <_svfiprintf_r+0x1c6>
 80177fc:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 80177fe:	445a      	add	r2, fp
 8017800:	9209      	str	r2, [sp, #36]	@ 0x24
 8017802:	f89a 3000 	ldrb.w	r3, [sl]
 8017806:	2b00      	cmp	r3, #0
 8017808:	f000 809f 	beq.w	801794a <_svfiprintf_r+0x1c6>
 801780c:	2300      	movs	r3, #0
 801780e:	f04f 32ff 	mov.w	r2, #4294967295
 8017812:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8017816:	f10a 0a01 	add.w	sl, sl, #1
 801781a:	9304      	str	r3, [sp, #16]
 801781c:	9307      	str	r3, [sp, #28]
 801781e:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 8017822:	931a      	str	r3, [sp, #104]	@ 0x68
 8017824:	4654      	mov	r4, sl
 8017826:	2205      	movs	r2, #5
 8017828:	f814 1b01 	ldrb.w	r1, [r4], #1
 801782c:	484e      	ldr	r0, [pc, #312]	@ (8017968 <_svfiprintf_r+0x1e4>)
 801782e:	f7e8 fd5f 	bl	80002f0 <memchr>
 8017832:	9a04      	ldr	r2, [sp, #16]
 8017834:	b9d8      	cbnz	r0, 801786e <_svfiprintf_r+0xea>
 8017836:	06d0      	lsls	r0, r2, #27
 8017838:	bf44      	itt	mi
 801783a:	2320      	movmi	r3, #32
 801783c:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8017840:	0711      	lsls	r1, r2, #28
 8017842:	bf44      	itt	mi
 8017844:	232b      	movmi	r3, #43	@ 0x2b
 8017846:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 801784a:	f89a 3000 	ldrb.w	r3, [sl]
 801784e:	2b2a      	cmp	r3, #42	@ 0x2a
 8017850:	d015      	beq.n	801787e <_svfiprintf_r+0xfa>
 8017852:	9a07      	ldr	r2, [sp, #28]
 8017854:	4654      	mov	r4, sl
 8017856:	2000      	movs	r0, #0
 8017858:	f04f 0c0a 	mov.w	ip, #10
 801785c:	4621      	mov	r1, r4
 801785e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8017862:	3b30      	subs	r3, #48	@ 0x30
 8017864:	2b09      	cmp	r3, #9
 8017866:	d94b      	bls.n	8017900 <_svfiprintf_r+0x17c>
 8017868:	b1b0      	cbz	r0, 8017898 <_svfiprintf_r+0x114>
 801786a:	9207      	str	r2, [sp, #28]
 801786c:	e014      	b.n	8017898 <_svfiprintf_r+0x114>
 801786e:	eba0 0308 	sub.w	r3, r0, r8
 8017872:	fa09 f303 	lsl.w	r3, r9, r3
 8017876:	4313      	orrs	r3, r2
 8017878:	9304      	str	r3, [sp, #16]
 801787a:	46a2      	mov	sl, r4
 801787c:	e7d2      	b.n	8017824 <_svfiprintf_r+0xa0>
 801787e:	9b03      	ldr	r3, [sp, #12]
 8017880:	1d19      	adds	r1, r3, #4
 8017882:	681b      	ldr	r3, [r3, #0]
 8017884:	9103      	str	r1, [sp, #12]
 8017886:	2b00      	cmp	r3, #0
 8017888:	bfbb      	ittet	lt
 801788a:	425b      	neglt	r3, r3
 801788c:	f042 0202 	orrlt.w	r2, r2, #2
 8017890:	9307      	strge	r3, [sp, #28]
 8017892:	9307      	strlt	r3, [sp, #28]
 8017894:	bfb8      	it	lt
 8017896:	9204      	strlt	r2, [sp, #16]
 8017898:	7823      	ldrb	r3, [r4, #0]
 801789a:	2b2e      	cmp	r3, #46	@ 0x2e
 801789c:	d10a      	bne.n	80178b4 <_svfiprintf_r+0x130>
 801789e:	7863      	ldrb	r3, [r4, #1]
 80178a0:	2b2a      	cmp	r3, #42	@ 0x2a
 80178a2:	d132      	bne.n	801790a <_svfiprintf_r+0x186>
 80178a4:	9b03      	ldr	r3, [sp, #12]
 80178a6:	1d1a      	adds	r2, r3, #4
 80178a8:	681b      	ldr	r3, [r3, #0]
 80178aa:	9203      	str	r2, [sp, #12]
 80178ac:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 80178b0:	3402      	adds	r4, #2
 80178b2:	9305      	str	r3, [sp, #20]
 80178b4:	f8df a0c0 	ldr.w	sl, [pc, #192]	@ 8017978 <_svfiprintf_r+0x1f4>
 80178b8:	7821      	ldrb	r1, [r4, #0]
 80178ba:	2203      	movs	r2, #3
 80178bc:	4650      	mov	r0, sl
 80178be:	f7e8 fd17 	bl	80002f0 <memchr>
 80178c2:	b138      	cbz	r0, 80178d4 <_svfiprintf_r+0x150>
 80178c4:	9b04      	ldr	r3, [sp, #16]
 80178c6:	eba0 000a 	sub.w	r0, r0, sl
 80178ca:	2240      	movs	r2, #64	@ 0x40
 80178cc:	4082      	lsls	r2, r0
 80178ce:	4313      	orrs	r3, r2
 80178d0:	3401      	adds	r4, #1
 80178d2:	9304      	str	r3, [sp, #16]
 80178d4:	f814 1b01 	ldrb.w	r1, [r4], #1
 80178d8:	4824      	ldr	r0, [pc, #144]	@ (801796c <_svfiprintf_r+0x1e8>)
 80178da:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 80178de:	2206      	movs	r2, #6
 80178e0:	f7e8 fd06 	bl	80002f0 <memchr>
 80178e4:	2800      	cmp	r0, #0
 80178e6:	d036      	beq.n	8017956 <_svfiprintf_r+0x1d2>
 80178e8:	4b21      	ldr	r3, [pc, #132]	@ (8017970 <_svfiprintf_r+0x1ec>)
 80178ea:	bb1b      	cbnz	r3, 8017934 <_svfiprintf_r+0x1b0>
 80178ec:	9b03      	ldr	r3, [sp, #12]
 80178ee:	3307      	adds	r3, #7
 80178f0:	f023 0307 	bic.w	r3, r3, #7
 80178f4:	3308      	adds	r3, #8
 80178f6:	9303      	str	r3, [sp, #12]
 80178f8:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 80178fa:	4433      	add	r3, r6
 80178fc:	9309      	str	r3, [sp, #36]	@ 0x24
 80178fe:	e76a      	b.n	80177d6 <_svfiprintf_r+0x52>
 8017900:	fb0c 3202 	mla	r2, ip, r2, r3
 8017904:	460c      	mov	r4, r1
 8017906:	2001      	movs	r0, #1
 8017908:	e7a8      	b.n	801785c <_svfiprintf_r+0xd8>
 801790a:	2300      	movs	r3, #0
 801790c:	3401      	adds	r4, #1
 801790e:	9305      	str	r3, [sp, #20]
 8017910:	4619      	mov	r1, r3
 8017912:	f04f 0c0a 	mov.w	ip, #10
 8017916:	4620      	mov	r0, r4
 8017918:	f810 2b01 	ldrb.w	r2, [r0], #1
 801791c:	3a30      	subs	r2, #48	@ 0x30
 801791e:	2a09      	cmp	r2, #9
 8017920:	d903      	bls.n	801792a <_svfiprintf_r+0x1a6>
 8017922:	2b00      	cmp	r3, #0
 8017924:	d0c6      	beq.n	80178b4 <_svfiprintf_r+0x130>
 8017926:	9105      	str	r1, [sp, #20]
 8017928:	e7c4      	b.n	80178b4 <_svfiprintf_r+0x130>
 801792a:	fb0c 2101 	mla	r1, ip, r1, r2
 801792e:	4604      	mov	r4, r0
 8017930:	2301      	movs	r3, #1
 8017932:	e7f0      	b.n	8017916 <_svfiprintf_r+0x192>
 8017934:	ab03      	add	r3, sp, #12
 8017936:	9300      	str	r3, [sp, #0]
 8017938:	462a      	mov	r2, r5
 801793a:	4b0e      	ldr	r3, [pc, #56]	@ (8017974 <_svfiprintf_r+0x1f0>)
 801793c:	a904      	add	r1, sp, #16
 801793e:	4638      	mov	r0, r7
 8017940:	f3af 8000 	nop.w
 8017944:	1c42      	adds	r2, r0, #1
 8017946:	4606      	mov	r6, r0
 8017948:	d1d6      	bne.n	80178f8 <_svfiprintf_r+0x174>
 801794a:	89ab      	ldrh	r3, [r5, #12]
 801794c:	065b      	lsls	r3, r3, #25
 801794e:	f53f af2d 	bmi.w	80177ac <_svfiprintf_r+0x28>
 8017952:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8017954:	e72c      	b.n	80177b0 <_svfiprintf_r+0x2c>
 8017956:	ab03      	add	r3, sp, #12
 8017958:	9300      	str	r3, [sp, #0]
 801795a:	462a      	mov	r2, r5
 801795c:	4b05      	ldr	r3, [pc, #20]	@ (8017974 <_svfiprintf_r+0x1f0>)
 801795e:	a904      	add	r1, sp, #16
 8017960:	4638      	mov	r0, r7
 8017962:	f000 f9bb 	bl	8017cdc <_printf_i>
 8017966:	e7ed      	b.n	8017944 <_svfiprintf_r+0x1c0>
 8017968:	08022358 	.word	0x08022358
 801796c:	08022362 	.word	0x08022362
 8017970:	00000000 	.word	0x00000000
 8017974:	080176cd 	.word	0x080176cd
 8017978:	0802235e 	.word	0x0802235e

0801797c <__sfputc_r>:
 801797c:	6893      	ldr	r3, [r2, #8]
 801797e:	3b01      	subs	r3, #1
 8017980:	2b00      	cmp	r3, #0
 8017982:	b410      	push	{r4}
 8017984:	6093      	str	r3, [r2, #8]
 8017986:	da08      	bge.n	801799a <__sfputc_r+0x1e>
 8017988:	6994      	ldr	r4, [r2, #24]
 801798a:	42a3      	cmp	r3, r4
 801798c:	db01      	blt.n	8017992 <__sfputc_r+0x16>
 801798e:	290a      	cmp	r1, #10
 8017990:	d103      	bne.n	801799a <__sfputc_r+0x1e>
 8017992:	f85d 4b04 	ldr.w	r4, [sp], #4
 8017996:	f7ff bcfe 	b.w	8017396 <__swbuf_r>
 801799a:	6813      	ldr	r3, [r2, #0]
 801799c:	1c58      	adds	r0, r3, #1
 801799e:	6010      	str	r0, [r2, #0]
 80179a0:	7019      	strb	r1, [r3, #0]
 80179a2:	4608      	mov	r0, r1
 80179a4:	f85d 4b04 	ldr.w	r4, [sp], #4
 80179a8:	4770      	bx	lr

080179aa <__sfputs_r>:
 80179aa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80179ac:	4606      	mov	r6, r0
 80179ae:	460f      	mov	r7, r1
 80179b0:	4614      	mov	r4, r2
 80179b2:	18d5      	adds	r5, r2, r3
 80179b4:	42ac      	cmp	r4, r5
 80179b6:	d101      	bne.n	80179bc <__sfputs_r+0x12>
 80179b8:	2000      	movs	r0, #0
 80179ba:	e007      	b.n	80179cc <__sfputs_r+0x22>
 80179bc:	f814 1b01 	ldrb.w	r1, [r4], #1
 80179c0:	463a      	mov	r2, r7
 80179c2:	4630      	mov	r0, r6
 80179c4:	f7ff ffda 	bl	801797c <__sfputc_r>
 80179c8:	1c43      	adds	r3, r0, #1
 80179ca:	d1f3      	bne.n	80179b4 <__sfputs_r+0xa>
 80179cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080179d0 <_vfiprintf_r>:
 80179d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80179d4:	460d      	mov	r5, r1
 80179d6:	b09d      	sub	sp, #116	@ 0x74
 80179d8:	4614      	mov	r4, r2
 80179da:	4698      	mov	r8, r3
 80179dc:	4606      	mov	r6, r0
 80179de:	b118      	cbz	r0, 80179e8 <_vfiprintf_r+0x18>
 80179e0:	6a03      	ldr	r3, [r0, #32]
 80179e2:	b90b      	cbnz	r3, 80179e8 <_vfiprintf_r+0x18>
 80179e4:	f7ff fbce 	bl	8017184 <__sinit>
 80179e8:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 80179ea:	07d9      	lsls	r1, r3, #31
 80179ec:	d405      	bmi.n	80179fa <_vfiprintf_r+0x2a>
 80179ee:	89ab      	ldrh	r3, [r5, #12]
 80179f0:	059a      	lsls	r2, r3, #22
 80179f2:	d402      	bmi.n	80179fa <_vfiprintf_r+0x2a>
 80179f4:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 80179f6:	f7ff fe06 	bl	8017606 <__retarget_lock_acquire_recursive>
 80179fa:	89ab      	ldrh	r3, [r5, #12]
 80179fc:	071b      	lsls	r3, r3, #28
 80179fe:	d501      	bpl.n	8017a04 <_vfiprintf_r+0x34>
 8017a00:	692b      	ldr	r3, [r5, #16]
 8017a02:	b99b      	cbnz	r3, 8017a2c <_vfiprintf_r+0x5c>
 8017a04:	4629      	mov	r1, r5
 8017a06:	4630      	mov	r0, r6
 8017a08:	f7ff fd04 	bl	8017414 <__swsetup_r>
 8017a0c:	b170      	cbz	r0, 8017a2c <_vfiprintf_r+0x5c>
 8017a0e:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 8017a10:	07dc      	lsls	r4, r3, #31
 8017a12:	d504      	bpl.n	8017a1e <_vfiprintf_r+0x4e>
 8017a14:	f04f 30ff 	mov.w	r0, #4294967295
 8017a18:	b01d      	add	sp, #116	@ 0x74
 8017a1a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8017a1e:	89ab      	ldrh	r3, [r5, #12]
 8017a20:	0598      	lsls	r0, r3, #22
 8017a22:	d4f7      	bmi.n	8017a14 <_vfiprintf_r+0x44>
 8017a24:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 8017a26:	f7ff fdef 	bl	8017608 <__retarget_lock_release_recursive>
 8017a2a:	e7f3      	b.n	8017a14 <_vfiprintf_r+0x44>
 8017a2c:	2300      	movs	r3, #0
 8017a2e:	9309      	str	r3, [sp, #36]	@ 0x24
 8017a30:	2320      	movs	r3, #32
 8017a32:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 8017a36:	f8cd 800c 	str.w	r8, [sp, #12]
 8017a3a:	2330      	movs	r3, #48	@ 0x30
 8017a3c:	f8df 81ac 	ldr.w	r8, [pc, #428]	@ 8017bec <_vfiprintf_r+0x21c>
 8017a40:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 8017a44:	f04f 0901 	mov.w	r9, #1
 8017a48:	4623      	mov	r3, r4
 8017a4a:	469a      	mov	sl, r3
 8017a4c:	f813 2b01 	ldrb.w	r2, [r3], #1
 8017a50:	b10a      	cbz	r2, 8017a56 <_vfiprintf_r+0x86>
 8017a52:	2a25      	cmp	r2, #37	@ 0x25
 8017a54:	d1f9      	bne.n	8017a4a <_vfiprintf_r+0x7a>
 8017a56:	ebba 0b04 	subs.w	fp, sl, r4
 8017a5a:	d00b      	beq.n	8017a74 <_vfiprintf_r+0xa4>
 8017a5c:	465b      	mov	r3, fp
 8017a5e:	4622      	mov	r2, r4
 8017a60:	4629      	mov	r1, r5
 8017a62:	4630      	mov	r0, r6
 8017a64:	f7ff ffa1 	bl	80179aa <__sfputs_r>
 8017a68:	3001      	adds	r0, #1
 8017a6a:	f000 80a7 	beq.w	8017bbc <_vfiprintf_r+0x1ec>
 8017a6e:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 8017a70:	445a      	add	r2, fp
 8017a72:	9209      	str	r2, [sp, #36]	@ 0x24
 8017a74:	f89a 3000 	ldrb.w	r3, [sl]
 8017a78:	2b00      	cmp	r3, #0
 8017a7a:	f000 809f 	beq.w	8017bbc <_vfiprintf_r+0x1ec>
 8017a7e:	2300      	movs	r3, #0
 8017a80:	f04f 32ff 	mov.w	r2, #4294967295
 8017a84:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8017a88:	f10a 0a01 	add.w	sl, sl, #1
 8017a8c:	9304      	str	r3, [sp, #16]
 8017a8e:	9307      	str	r3, [sp, #28]
 8017a90:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 8017a94:	931a      	str	r3, [sp, #104]	@ 0x68
 8017a96:	4654      	mov	r4, sl
 8017a98:	2205      	movs	r2, #5
 8017a9a:	f814 1b01 	ldrb.w	r1, [r4], #1
 8017a9e:	4853      	ldr	r0, [pc, #332]	@ (8017bec <_vfiprintf_r+0x21c>)
 8017aa0:	f7e8 fc26 	bl	80002f0 <memchr>
 8017aa4:	9a04      	ldr	r2, [sp, #16]
 8017aa6:	b9d8      	cbnz	r0, 8017ae0 <_vfiprintf_r+0x110>
 8017aa8:	06d1      	lsls	r1, r2, #27
 8017aaa:	bf44      	itt	mi
 8017aac:	2320      	movmi	r3, #32
 8017aae:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8017ab2:	0713      	lsls	r3, r2, #28
 8017ab4:	bf44      	itt	mi
 8017ab6:	232b      	movmi	r3, #43	@ 0x2b
 8017ab8:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 8017abc:	f89a 3000 	ldrb.w	r3, [sl]
 8017ac0:	2b2a      	cmp	r3, #42	@ 0x2a
 8017ac2:	d015      	beq.n	8017af0 <_vfiprintf_r+0x120>
 8017ac4:	9a07      	ldr	r2, [sp, #28]
 8017ac6:	4654      	mov	r4, sl
 8017ac8:	2000      	movs	r0, #0
 8017aca:	f04f 0c0a 	mov.w	ip, #10
 8017ace:	4621      	mov	r1, r4
 8017ad0:	f811 3b01 	ldrb.w	r3, [r1], #1
 8017ad4:	3b30      	subs	r3, #48	@ 0x30
 8017ad6:	2b09      	cmp	r3, #9
 8017ad8:	d94b      	bls.n	8017b72 <_vfiprintf_r+0x1a2>
 8017ada:	b1b0      	cbz	r0, 8017b0a <_vfiprintf_r+0x13a>
 8017adc:	9207      	str	r2, [sp, #28]
 8017ade:	e014      	b.n	8017b0a <_vfiprintf_r+0x13a>
 8017ae0:	eba0 0308 	sub.w	r3, r0, r8
 8017ae4:	fa09 f303 	lsl.w	r3, r9, r3
 8017ae8:	4313      	orrs	r3, r2
 8017aea:	9304      	str	r3, [sp, #16]
 8017aec:	46a2      	mov	sl, r4
 8017aee:	e7d2      	b.n	8017a96 <_vfiprintf_r+0xc6>
 8017af0:	9b03      	ldr	r3, [sp, #12]
 8017af2:	1d19      	adds	r1, r3, #4
 8017af4:	681b      	ldr	r3, [r3, #0]
 8017af6:	9103      	str	r1, [sp, #12]
 8017af8:	2b00      	cmp	r3, #0
 8017afa:	bfbb      	ittet	lt
 8017afc:	425b      	neglt	r3, r3
 8017afe:	f042 0202 	orrlt.w	r2, r2, #2
 8017b02:	9307      	strge	r3, [sp, #28]
 8017b04:	9307      	strlt	r3, [sp, #28]
 8017b06:	bfb8      	it	lt
 8017b08:	9204      	strlt	r2, [sp, #16]
 8017b0a:	7823      	ldrb	r3, [r4, #0]
 8017b0c:	2b2e      	cmp	r3, #46	@ 0x2e
 8017b0e:	d10a      	bne.n	8017b26 <_vfiprintf_r+0x156>
 8017b10:	7863      	ldrb	r3, [r4, #1]
 8017b12:	2b2a      	cmp	r3, #42	@ 0x2a
 8017b14:	d132      	bne.n	8017b7c <_vfiprintf_r+0x1ac>
 8017b16:	9b03      	ldr	r3, [sp, #12]
 8017b18:	1d1a      	adds	r2, r3, #4
 8017b1a:	681b      	ldr	r3, [r3, #0]
 8017b1c:	9203      	str	r2, [sp, #12]
 8017b1e:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 8017b22:	3402      	adds	r4, #2
 8017b24:	9305      	str	r3, [sp, #20]
 8017b26:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 8017bfc <_vfiprintf_r+0x22c>
 8017b2a:	7821      	ldrb	r1, [r4, #0]
 8017b2c:	2203      	movs	r2, #3
 8017b2e:	4650      	mov	r0, sl
 8017b30:	f7e8 fbde 	bl	80002f0 <memchr>
 8017b34:	b138      	cbz	r0, 8017b46 <_vfiprintf_r+0x176>
 8017b36:	9b04      	ldr	r3, [sp, #16]
 8017b38:	eba0 000a 	sub.w	r0, r0, sl
 8017b3c:	2240      	movs	r2, #64	@ 0x40
 8017b3e:	4082      	lsls	r2, r0
 8017b40:	4313      	orrs	r3, r2
 8017b42:	3401      	adds	r4, #1
 8017b44:	9304      	str	r3, [sp, #16]
 8017b46:	f814 1b01 	ldrb.w	r1, [r4], #1
 8017b4a:	4829      	ldr	r0, [pc, #164]	@ (8017bf0 <_vfiprintf_r+0x220>)
 8017b4c:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 8017b50:	2206      	movs	r2, #6
 8017b52:	f7e8 fbcd 	bl	80002f0 <memchr>
 8017b56:	2800      	cmp	r0, #0
 8017b58:	d03f      	beq.n	8017bda <_vfiprintf_r+0x20a>
 8017b5a:	4b26      	ldr	r3, [pc, #152]	@ (8017bf4 <_vfiprintf_r+0x224>)
 8017b5c:	bb1b      	cbnz	r3, 8017ba6 <_vfiprintf_r+0x1d6>
 8017b5e:	9b03      	ldr	r3, [sp, #12]
 8017b60:	3307      	adds	r3, #7
 8017b62:	f023 0307 	bic.w	r3, r3, #7
 8017b66:	3308      	adds	r3, #8
 8017b68:	9303      	str	r3, [sp, #12]
 8017b6a:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 8017b6c:	443b      	add	r3, r7
 8017b6e:	9309      	str	r3, [sp, #36]	@ 0x24
 8017b70:	e76a      	b.n	8017a48 <_vfiprintf_r+0x78>
 8017b72:	fb0c 3202 	mla	r2, ip, r2, r3
 8017b76:	460c      	mov	r4, r1
 8017b78:	2001      	movs	r0, #1
 8017b7a:	e7a8      	b.n	8017ace <_vfiprintf_r+0xfe>
 8017b7c:	2300      	movs	r3, #0
 8017b7e:	3401      	adds	r4, #1
 8017b80:	9305      	str	r3, [sp, #20]
 8017b82:	4619      	mov	r1, r3
 8017b84:	f04f 0c0a 	mov.w	ip, #10
 8017b88:	4620      	mov	r0, r4
 8017b8a:	f810 2b01 	ldrb.w	r2, [r0], #1
 8017b8e:	3a30      	subs	r2, #48	@ 0x30
 8017b90:	2a09      	cmp	r2, #9
 8017b92:	d903      	bls.n	8017b9c <_vfiprintf_r+0x1cc>
 8017b94:	2b00      	cmp	r3, #0
 8017b96:	d0c6      	beq.n	8017b26 <_vfiprintf_r+0x156>
 8017b98:	9105      	str	r1, [sp, #20]
 8017b9a:	e7c4      	b.n	8017b26 <_vfiprintf_r+0x156>
 8017b9c:	fb0c 2101 	mla	r1, ip, r1, r2
 8017ba0:	4604      	mov	r4, r0
 8017ba2:	2301      	movs	r3, #1
 8017ba4:	e7f0      	b.n	8017b88 <_vfiprintf_r+0x1b8>
 8017ba6:	ab03      	add	r3, sp, #12
 8017ba8:	9300      	str	r3, [sp, #0]
 8017baa:	462a      	mov	r2, r5
 8017bac:	4b12      	ldr	r3, [pc, #72]	@ (8017bf8 <_vfiprintf_r+0x228>)
 8017bae:	a904      	add	r1, sp, #16
 8017bb0:	4630      	mov	r0, r6
 8017bb2:	f3af 8000 	nop.w
 8017bb6:	4607      	mov	r7, r0
 8017bb8:	1c78      	adds	r0, r7, #1
 8017bba:	d1d6      	bne.n	8017b6a <_vfiprintf_r+0x19a>
 8017bbc:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 8017bbe:	07d9      	lsls	r1, r3, #31
 8017bc0:	d405      	bmi.n	8017bce <_vfiprintf_r+0x1fe>
 8017bc2:	89ab      	ldrh	r3, [r5, #12]
 8017bc4:	059a      	lsls	r2, r3, #22
 8017bc6:	d402      	bmi.n	8017bce <_vfiprintf_r+0x1fe>
 8017bc8:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 8017bca:	f7ff fd1d 	bl	8017608 <__retarget_lock_release_recursive>
 8017bce:	89ab      	ldrh	r3, [r5, #12]
 8017bd0:	065b      	lsls	r3, r3, #25
 8017bd2:	f53f af1f 	bmi.w	8017a14 <_vfiprintf_r+0x44>
 8017bd6:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8017bd8:	e71e      	b.n	8017a18 <_vfiprintf_r+0x48>
 8017bda:	ab03      	add	r3, sp, #12
 8017bdc:	9300      	str	r3, [sp, #0]
 8017bde:	462a      	mov	r2, r5
 8017be0:	4b05      	ldr	r3, [pc, #20]	@ (8017bf8 <_vfiprintf_r+0x228>)
 8017be2:	a904      	add	r1, sp, #16
 8017be4:	4630      	mov	r0, r6
 8017be6:	f000 f879 	bl	8017cdc <_printf_i>
 8017bea:	e7e4      	b.n	8017bb6 <_vfiprintf_r+0x1e6>
 8017bec:	08022358 	.word	0x08022358
 8017bf0:	08022362 	.word	0x08022362
 8017bf4:	00000000 	.word	0x00000000
 8017bf8:	080179ab 	.word	0x080179ab
 8017bfc:	0802235e 	.word	0x0802235e

08017c00 <_printf_common>:
 8017c00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8017c04:	4616      	mov	r6, r2
 8017c06:	4698      	mov	r8, r3
 8017c08:	688a      	ldr	r2, [r1, #8]
 8017c0a:	690b      	ldr	r3, [r1, #16]
 8017c0c:	f8dd 9020 	ldr.w	r9, [sp, #32]
 8017c10:	4293      	cmp	r3, r2
 8017c12:	bfb8      	it	lt
 8017c14:	4613      	movlt	r3, r2
 8017c16:	6033      	str	r3, [r6, #0]
 8017c18:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 8017c1c:	4607      	mov	r7, r0
 8017c1e:	460c      	mov	r4, r1
 8017c20:	b10a      	cbz	r2, 8017c26 <_printf_common+0x26>
 8017c22:	3301      	adds	r3, #1
 8017c24:	6033      	str	r3, [r6, #0]
 8017c26:	6823      	ldr	r3, [r4, #0]
 8017c28:	0699      	lsls	r1, r3, #26
 8017c2a:	bf42      	ittt	mi
 8017c2c:	6833      	ldrmi	r3, [r6, #0]
 8017c2e:	3302      	addmi	r3, #2
 8017c30:	6033      	strmi	r3, [r6, #0]
 8017c32:	6825      	ldr	r5, [r4, #0]
 8017c34:	f015 0506 	ands.w	r5, r5, #6
 8017c38:	d106      	bne.n	8017c48 <_printf_common+0x48>
 8017c3a:	f104 0a19 	add.w	sl, r4, #25
 8017c3e:	68e3      	ldr	r3, [r4, #12]
 8017c40:	6832      	ldr	r2, [r6, #0]
 8017c42:	1a9b      	subs	r3, r3, r2
 8017c44:	42ab      	cmp	r3, r5
 8017c46:	dc26      	bgt.n	8017c96 <_printf_common+0x96>
 8017c48:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 8017c4c:	6822      	ldr	r2, [r4, #0]
 8017c4e:	3b00      	subs	r3, #0
 8017c50:	bf18      	it	ne
 8017c52:	2301      	movne	r3, #1
 8017c54:	0692      	lsls	r2, r2, #26
 8017c56:	d42b      	bmi.n	8017cb0 <_printf_common+0xb0>
 8017c58:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 8017c5c:	4641      	mov	r1, r8
 8017c5e:	4638      	mov	r0, r7
 8017c60:	47c8      	blx	r9
 8017c62:	3001      	adds	r0, #1
 8017c64:	d01e      	beq.n	8017ca4 <_printf_common+0xa4>
 8017c66:	6823      	ldr	r3, [r4, #0]
 8017c68:	6922      	ldr	r2, [r4, #16]
 8017c6a:	f003 0306 	and.w	r3, r3, #6
 8017c6e:	2b04      	cmp	r3, #4
 8017c70:	bf02      	ittt	eq
 8017c72:	68e5      	ldreq	r5, [r4, #12]
 8017c74:	6833      	ldreq	r3, [r6, #0]
 8017c76:	1aed      	subeq	r5, r5, r3
 8017c78:	68a3      	ldr	r3, [r4, #8]
 8017c7a:	bf0c      	ite	eq
 8017c7c:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8017c80:	2500      	movne	r5, #0
 8017c82:	4293      	cmp	r3, r2
 8017c84:	bfc4      	itt	gt
 8017c86:	1a9b      	subgt	r3, r3, r2
 8017c88:	18ed      	addgt	r5, r5, r3
 8017c8a:	2600      	movs	r6, #0
 8017c8c:	341a      	adds	r4, #26
 8017c8e:	42b5      	cmp	r5, r6
 8017c90:	d11a      	bne.n	8017cc8 <_printf_common+0xc8>
 8017c92:	2000      	movs	r0, #0
 8017c94:	e008      	b.n	8017ca8 <_printf_common+0xa8>
 8017c96:	2301      	movs	r3, #1
 8017c98:	4652      	mov	r2, sl
 8017c9a:	4641      	mov	r1, r8
 8017c9c:	4638      	mov	r0, r7
 8017c9e:	47c8      	blx	r9
 8017ca0:	3001      	adds	r0, #1
 8017ca2:	d103      	bne.n	8017cac <_printf_common+0xac>
 8017ca4:	f04f 30ff 	mov.w	r0, #4294967295
 8017ca8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8017cac:	3501      	adds	r5, #1
 8017cae:	e7c6      	b.n	8017c3e <_printf_common+0x3e>
 8017cb0:	18e1      	adds	r1, r4, r3
 8017cb2:	1c5a      	adds	r2, r3, #1
 8017cb4:	2030      	movs	r0, #48	@ 0x30
 8017cb6:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 8017cba:	4422      	add	r2, r4
 8017cbc:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 8017cc0:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 8017cc4:	3302      	adds	r3, #2
 8017cc6:	e7c7      	b.n	8017c58 <_printf_common+0x58>
 8017cc8:	2301      	movs	r3, #1
 8017cca:	4622      	mov	r2, r4
 8017ccc:	4641      	mov	r1, r8
 8017cce:	4638      	mov	r0, r7
 8017cd0:	47c8      	blx	r9
 8017cd2:	3001      	adds	r0, #1
 8017cd4:	d0e6      	beq.n	8017ca4 <_printf_common+0xa4>
 8017cd6:	3601      	adds	r6, #1
 8017cd8:	e7d9      	b.n	8017c8e <_printf_common+0x8e>
	...

08017cdc <_printf_i>:
 8017cdc:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8017ce0:	7e0f      	ldrb	r7, [r1, #24]
 8017ce2:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 8017ce4:	2f78      	cmp	r7, #120	@ 0x78
 8017ce6:	4691      	mov	r9, r2
 8017ce8:	4680      	mov	r8, r0
 8017cea:	460c      	mov	r4, r1
 8017cec:	469a      	mov	sl, r3
 8017cee:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 8017cf2:	d807      	bhi.n	8017d04 <_printf_i+0x28>
 8017cf4:	2f62      	cmp	r7, #98	@ 0x62
 8017cf6:	d80a      	bhi.n	8017d0e <_printf_i+0x32>
 8017cf8:	2f00      	cmp	r7, #0
 8017cfa:	f000 80d2 	beq.w	8017ea2 <_printf_i+0x1c6>
 8017cfe:	2f58      	cmp	r7, #88	@ 0x58
 8017d00:	f000 80b9 	beq.w	8017e76 <_printf_i+0x19a>
 8017d04:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 8017d08:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 8017d0c:	e03a      	b.n	8017d84 <_printf_i+0xa8>
 8017d0e:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 8017d12:	2b15      	cmp	r3, #21
 8017d14:	d8f6      	bhi.n	8017d04 <_printf_i+0x28>
 8017d16:	a101      	add	r1, pc, #4	@ (adr r1, 8017d1c <_printf_i+0x40>)
 8017d18:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8017d1c:	08017d75 	.word	0x08017d75
 8017d20:	08017d89 	.word	0x08017d89
 8017d24:	08017d05 	.word	0x08017d05
 8017d28:	08017d05 	.word	0x08017d05
 8017d2c:	08017d05 	.word	0x08017d05
 8017d30:	08017d05 	.word	0x08017d05
 8017d34:	08017d89 	.word	0x08017d89
 8017d38:	08017d05 	.word	0x08017d05
 8017d3c:	08017d05 	.word	0x08017d05
 8017d40:	08017d05 	.word	0x08017d05
 8017d44:	08017d05 	.word	0x08017d05
 8017d48:	08017e89 	.word	0x08017e89
 8017d4c:	08017db3 	.word	0x08017db3
 8017d50:	08017e43 	.word	0x08017e43
 8017d54:	08017d05 	.word	0x08017d05
 8017d58:	08017d05 	.word	0x08017d05
 8017d5c:	08017eab 	.word	0x08017eab
 8017d60:	08017d05 	.word	0x08017d05
 8017d64:	08017db3 	.word	0x08017db3
 8017d68:	08017d05 	.word	0x08017d05
 8017d6c:	08017d05 	.word	0x08017d05
 8017d70:	08017e4b 	.word	0x08017e4b
 8017d74:	6833      	ldr	r3, [r6, #0]
 8017d76:	1d1a      	adds	r2, r3, #4
 8017d78:	681b      	ldr	r3, [r3, #0]
 8017d7a:	6032      	str	r2, [r6, #0]
 8017d7c:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 8017d80:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 8017d84:	2301      	movs	r3, #1
 8017d86:	e09d      	b.n	8017ec4 <_printf_i+0x1e8>
 8017d88:	6833      	ldr	r3, [r6, #0]
 8017d8a:	6820      	ldr	r0, [r4, #0]
 8017d8c:	1d19      	adds	r1, r3, #4
 8017d8e:	6031      	str	r1, [r6, #0]
 8017d90:	0606      	lsls	r6, r0, #24
 8017d92:	d501      	bpl.n	8017d98 <_printf_i+0xbc>
 8017d94:	681d      	ldr	r5, [r3, #0]
 8017d96:	e003      	b.n	8017da0 <_printf_i+0xc4>
 8017d98:	0645      	lsls	r5, r0, #25
 8017d9a:	d5fb      	bpl.n	8017d94 <_printf_i+0xb8>
 8017d9c:	f9b3 5000 	ldrsh.w	r5, [r3]
 8017da0:	2d00      	cmp	r5, #0
 8017da2:	da03      	bge.n	8017dac <_printf_i+0xd0>
 8017da4:	232d      	movs	r3, #45	@ 0x2d
 8017da6:	426d      	negs	r5, r5
 8017da8:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8017dac:	4859      	ldr	r0, [pc, #356]	@ (8017f14 <_printf_i+0x238>)
 8017dae:	230a      	movs	r3, #10
 8017db0:	e011      	b.n	8017dd6 <_printf_i+0xfa>
 8017db2:	6821      	ldr	r1, [r4, #0]
 8017db4:	6833      	ldr	r3, [r6, #0]
 8017db6:	0608      	lsls	r0, r1, #24
 8017db8:	f853 5b04 	ldr.w	r5, [r3], #4
 8017dbc:	d402      	bmi.n	8017dc4 <_printf_i+0xe8>
 8017dbe:	0649      	lsls	r1, r1, #25
 8017dc0:	bf48      	it	mi
 8017dc2:	b2ad      	uxthmi	r5, r5
 8017dc4:	2f6f      	cmp	r7, #111	@ 0x6f
 8017dc6:	4853      	ldr	r0, [pc, #332]	@ (8017f14 <_printf_i+0x238>)
 8017dc8:	6033      	str	r3, [r6, #0]
 8017dca:	bf14      	ite	ne
 8017dcc:	230a      	movne	r3, #10
 8017dce:	2308      	moveq	r3, #8
 8017dd0:	2100      	movs	r1, #0
 8017dd2:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 8017dd6:	6866      	ldr	r6, [r4, #4]
 8017dd8:	60a6      	str	r6, [r4, #8]
 8017dda:	2e00      	cmp	r6, #0
 8017ddc:	bfa2      	ittt	ge
 8017dde:	6821      	ldrge	r1, [r4, #0]
 8017de0:	f021 0104 	bicge.w	r1, r1, #4
 8017de4:	6021      	strge	r1, [r4, #0]
 8017de6:	b90d      	cbnz	r5, 8017dec <_printf_i+0x110>
 8017de8:	2e00      	cmp	r6, #0
 8017dea:	d04b      	beq.n	8017e84 <_printf_i+0x1a8>
 8017dec:	4616      	mov	r6, r2
 8017dee:	fbb5 f1f3 	udiv	r1, r5, r3
 8017df2:	fb03 5711 	mls	r7, r3, r1, r5
 8017df6:	5dc7      	ldrb	r7, [r0, r7]
 8017df8:	f806 7d01 	strb.w	r7, [r6, #-1]!
 8017dfc:	462f      	mov	r7, r5
 8017dfe:	42bb      	cmp	r3, r7
 8017e00:	460d      	mov	r5, r1
 8017e02:	d9f4      	bls.n	8017dee <_printf_i+0x112>
 8017e04:	2b08      	cmp	r3, #8
 8017e06:	d10b      	bne.n	8017e20 <_printf_i+0x144>
 8017e08:	6823      	ldr	r3, [r4, #0]
 8017e0a:	07df      	lsls	r7, r3, #31
 8017e0c:	d508      	bpl.n	8017e20 <_printf_i+0x144>
 8017e0e:	6923      	ldr	r3, [r4, #16]
 8017e10:	6861      	ldr	r1, [r4, #4]
 8017e12:	4299      	cmp	r1, r3
 8017e14:	bfde      	ittt	le
 8017e16:	2330      	movle	r3, #48	@ 0x30
 8017e18:	f806 3c01 	strble.w	r3, [r6, #-1]
 8017e1c:	f106 36ff 	addle.w	r6, r6, #4294967295
 8017e20:	1b92      	subs	r2, r2, r6
 8017e22:	6122      	str	r2, [r4, #16]
 8017e24:	f8cd a000 	str.w	sl, [sp]
 8017e28:	464b      	mov	r3, r9
 8017e2a:	aa03      	add	r2, sp, #12
 8017e2c:	4621      	mov	r1, r4
 8017e2e:	4640      	mov	r0, r8
 8017e30:	f7ff fee6 	bl	8017c00 <_printf_common>
 8017e34:	3001      	adds	r0, #1
 8017e36:	d14a      	bne.n	8017ece <_printf_i+0x1f2>
 8017e38:	f04f 30ff 	mov.w	r0, #4294967295
 8017e3c:	b004      	add	sp, #16
 8017e3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8017e42:	6823      	ldr	r3, [r4, #0]
 8017e44:	f043 0320 	orr.w	r3, r3, #32
 8017e48:	6023      	str	r3, [r4, #0]
 8017e4a:	4833      	ldr	r0, [pc, #204]	@ (8017f18 <_printf_i+0x23c>)
 8017e4c:	2778      	movs	r7, #120	@ 0x78
 8017e4e:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 8017e52:	6823      	ldr	r3, [r4, #0]
 8017e54:	6831      	ldr	r1, [r6, #0]
 8017e56:	061f      	lsls	r7, r3, #24
 8017e58:	f851 5b04 	ldr.w	r5, [r1], #4
 8017e5c:	d402      	bmi.n	8017e64 <_printf_i+0x188>
 8017e5e:	065f      	lsls	r7, r3, #25
 8017e60:	bf48      	it	mi
 8017e62:	b2ad      	uxthmi	r5, r5
 8017e64:	6031      	str	r1, [r6, #0]
 8017e66:	07d9      	lsls	r1, r3, #31
 8017e68:	bf44      	itt	mi
 8017e6a:	f043 0320 	orrmi.w	r3, r3, #32
 8017e6e:	6023      	strmi	r3, [r4, #0]
 8017e70:	b11d      	cbz	r5, 8017e7a <_printf_i+0x19e>
 8017e72:	2310      	movs	r3, #16
 8017e74:	e7ac      	b.n	8017dd0 <_printf_i+0xf4>
 8017e76:	4827      	ldr	r0, [pc, #156]	@ (8017f14 <_printf_i+0x238>)
 8017e78:	e7e9      	b.n	8017e4e <_printf_i+0x172>
 8017e7a:	6823      	ldr	r3, [r4, #0]
 8017e7c:	f023 0320 	bic.w	r3, r3, #32
 8017e80:	6023      	str	r3, [r4, #0]
 8017e82:	e7f6      	b.n	8017e72 <_printf_i+0x196>
 8017e84:	4616      	mov	r6, r2
 8017e86:	e7bd      	b.n	8017e04 <_printf_i+0x128>
 8017e88:	6833      	ldr	r3, [r6, #0]
 8017e8a:	6825      	ldr	r5, [r4, #0]
 8017e8c:	6961      	ldr	r1, [r4, #20]
 8017e8e:	1d18      	adds	r0, r3, #4
 8017e90:	6030      	str	r0, [r6, #0]
 8017e92:	062e      	lsls	r6, r5, #24
 8017e94:	681b      	ldr	r3, [r3, #0]
 8017e96:	d501      	bpl.n	8017e9c <_printf_i+0x1c0>
 8017e98:	6019      	str	r1, [r3, #0]
 8017e9a:	e002      	b.n	8017ea2 <_printf_i+0x1c6>
 8017e9c:	0668      	lsls	r0, r5, #25
 8017e9e:	d5fb      	bpl.n	8017e98 <_printf_i+0x1bc>
 8017ea0:	8019      	strh	r1, [r3, #0]
 8017ea2:	2300      	movs	r3, #0
 8017ea4:	6123      	str	r3, [r4, #16]
 8017ea6:	4616      	mov	r6, r2
 8017ea8:	e7bc      	b.n	8017e24 <_printf_i+0x148>
 8017eaa:	6833      	ldr	r3, [r6, #0]
 8017eac:	1d1a      	adds	r2, r3, #4
 8017eae:	6032      	str	r2, [r6, #0]
 8017eb0:	681e      	ldr	r6, [r3, #0]
 8017eb2:	6862      	ldr	r2, [r4, #4]
 8017eb4:	2100      	movs	r1, #0
 8017eb6:	4630      	mov	r0, r6
 8017eb8:	f7e8 fa1a 	bl	80002f0 <memchr>
 8017ebc:	b108      	cbz	r0, 8017ec2 <_printf_i+0x1e6>
 8017ebe:	1b80      	subs	r0, r0, r6
 8017ec0:	6060      	str	r0, [r4, #4]
 8017ec2:	6863      	ldr	r3, [r4, #4]
 8017ec4:	6123      	str	r3, [r4, #16]
 8017ec6:	2300      	movs	r3, #0
 8017ec8:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8017ecc:	e7aa      	b.n	8017e24 <_printf_i+0x148>
 8017ece:	6923      	ldr	r3, [r4, #16]
 8017ed0:	4632      	mov	r2, r6
 8017ed2:	4649      	mov	r1, r9
 8017ed4:	4640      	mov	r0, r8
 8017ed6:	47d0      	blx	sl
 8017ed8:	3001      	adds	r0, #1
 8017eda:	d0ad      	beq.n	8017e38 <_printf_i+0x15c>
 8017edc:	6823      	ldr	r3, [r4, #0]
 8017ede:	079b      	lsls	r3, r3, #30
 8017ee0:	d413      	bmi.n	8017f0a <_printf_i+0x22e>
 8017ee2:	68e0      	ldr	r0, [r4, #12]
 8017ee4:	9b03      	ldr	r3, [sp, #12]
 8017ee6:	4298      	cmp	r0, r3
 8017ee8:	bfb8      	it	lt
 8017eea:	4618      	movlt	r0, r3
 8017eec:	e7a6      	b.n	8017e3c <_printf_i+0x160>
 8017eee:	2301      	movs	r3, #1
 8017ef0:	4632      	mov	r2, r6
 8017ef2:	4649      	mov	r1, r9
 8017ef4:	4640      	mov	r0, r8
 8017ef6:	47d0      	blx	sl
 8017ef8:	3001      	adds	r0, #1
 8017efa:	d09d      	beq.n	8017e38 <_printf_i+0x15c>
 8017efc:	3501      	adds	r5, #1
 8017efe:	68e3      	ldr	r3, [r4, #12]
 8017f00:	9903      	ldr	r1, [sp, #12]
 8017f02:	1a5b      	subs	r3, r3, r1
 8017f04:	42ab      	cmp	r3, r5
 8017f06:	dcf2      	bgt.n	8017eee <_printf_i+0x212>
 8017f08:	e7eb      	b.n	8017ee2 <_printf_i+0x206>
 8017f0a:	2500      	movs	r5, #0
 8017f0c:	f104 0619 	add.w	r6, r4, #25
 8017f10:	e7f5      	b.n	8017efe <_printf_i+0x222>
 8017f12:	bf00      	nop
 8017f14:	08022369 	.word	0x08022369
 8017f18:	0802237a 	.word	0x0802237a

08017f1c <__sflush_r>:
 8017f1c:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 8017f20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8017f24:	0716      	lsls	r6, r2, #28
 8017f26:	4605      	mov	r5, r0
 8017f28:	460c      	mov	r4, r1
 8017f2a:	d454      	bmi.n	8017fd6 <__sflush_r+0xba>
 8017f2c:	684b      	ldr	r3, [r1, #4]
 8017f2e:	2b00      	cmp	r3, #0
 8017f30:	dc02      	bgt.n	8017f38 <__sflush_r+0x1c>
 8017f32:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 8017f34:	2b00      	cmp	r3, #0
 8017f36:	dd48      	ble.n	8017fca <__sflush_r+0xae>
 8017f38:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 8017f3a:	2e00      	cmp	r6, #0
 8017f3c:	d045      	beq.n	8017fca <__sflush_r+0xae>
 8017f3e:	2300      	movs	r3, #0
 8017f40:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 8017f44:	682f      	ldr	r7, [r5, #0]
 8017f46:	6a21      	ldr	r1, [r4, #32]
 8017f48:	602b      	str	r3, [r5, #0]
 8017f4a:	d030      	beq.n	8017fae <__sflush_r+0x92>
 8017f4c:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 8017f4e:	89a3      	ldrh	r3, [r4, #12]
 8017f50:	0759      	lsls	r1, r3, #29
 8017f52:	d505      	bpl.n	8017f60 <__sflush_r+0x44>
 8017f54:	6863      	ldr	r3, [r4, #4]
 8017f56:	1ad2      	subs	r2, r2, r3
 8017f58:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8017f5a:	b10b      	cbz	r3, 8017f60 <__sflush_r+0x44>
 8017f5c:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 8017f5e:	1ad2      	subs	r2, r2, r3
 8017f60:	2300      	movs	r3, #0
 8017f62:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 8017f64:	6a21      	ldr	r1, [r4, #32]
 8017f66:	4628      	mov	r0, r5
 8017f68:	47b0      	blx	r6
 8017f6a:	1c43      	adds	r3, r0, #1
 8017f6c:	89a3      	ldrh	r3, [r4, #12]
 8017f6e:	d106      	bne.n	8017f7e <__sflush_r+0x62>
 8017f70:	6829      	ldr	r1, [r5, #0]
 8017f72:	291d      	cmp	r1, #29
 8017f74:	d82b      	bhi.n	8017fce <__sflush_r+0xb2>
 8017f76:	4a2a      	ldr	r2, [pc, #168]	@ (8018020 <__sflush_r+0x104>)
 8017f78:	410a      	asrs	r2, r1
 8017f7a:	07d6      	lsls	r6, r2, #31
 8017f7c:	d427      	bmi.n	8017fce <__sflush_r+0xb2>
 8017f7e:	2200      	movs	r2, #0
 8017f80:	6062      	str	r2, [r4, #4]
 8017f82:	04d9      	lsls	r1, r3, #19
 8017f84:	6922      	ldr	r2, [r4, #16]
 8017f86:	6022      	str	r2, [r4, #0]
 8017f88:	d504      	bpl.n	8017f94 <__sflush_r+0x78>
 8017f8a:	1c42      	adds	r2, r0, #1
 8017f8c:	d101      	bne.n	8017f92 <__sflush_r+0x76>
 8017f8e:	682b      	ldr	r3, [r5, #0]
 8017f90:	b903      	cbnz	r3, 8017f94 <__sflush_r+0x78>
 8017f92:	6560      	str	r0, [r4, #84]	@ 0x54
 8017f94:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8017f96:	602f      	str	r7, [r5, #0]
 8017f98:	b1b9      	cbz	r1, 8017fca <__sflush_r+0xae>
 8017f9a:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 8017f9e:	4299      	cmp	r1, r3
 8017fa0:	d002      	beq.n	8017fa8 <__sflush_r+0x8c>
 8017fa2:	4628      	mov	r0, r5
 8017fa4:	f7ff fb40 	bl	8017628 <_free_r>
 8017fa8:	2300      	movs	r3, #0
 8017faa:	6363      	str	r3, [r4, #52]	@ 0x34
 8017fac:	e00d      	b.n	8017fca <__sflush_r+0xae>
 8017fae:	2301      	movs	r3, #1
 8017fb0:	4628      	mov	r0, r5
 8017fb2:	47b0      	blx	r6
 8017fb4:	4602      	mov	r2, r0
 8017fb6:	1c50      	adds	r0, r2, #1
 8017fb8:	d1c9      	bne.n	8017f4e <__sflush_r+0x32>
 8017fba:	682b      	ldr	r3, [r5, #0]
 8017fbc:	2b00      	cmp	r3, #0
 8017fbe:	d0c6      	beq.n	8017f4e <__sflush_r+0x32>
 8017fc0:	2b1d      	cmp	r3, #29
 8017fc2:	d001      	beq.n	8017fc8 <__sflush_r+0xac>
 8017fc4:	2b16      	cmp	r3, #22
 8017fc6:	d11e      	bne.n	8018006 <__sflush_r+0xea>
 8017fc8:	602f      	str	r7, [r5, #0]
 8017fca:	2000      	movs	r0, #0
 8017fcc:	e022      	b.n	8018014 <__sflush_r+0xf8>
 8017fce:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8017fd2:	b21b      	sxth	r3, r3
 8017fd4:	e01b      	b.n	801800e <__sflush_r+0xf2>
 8017fd6:	690f      	ldr	r7, [r1, #16]
 8017fd8:	2f00      	cmp	r7, #0
 8017fda:	d0f6      	beq.n	8017fca <__sflush_r+0xae>
 8017fdc:	0793      	lsls	r3, r2, #30
 8017fde:	680e      	ldr	r6, [r1, #0]
 8017fe0:	bf08      	it	eq
 8017fe2:	694b      	ldreq	r3, [r1, #20]
 8017fe4:	600f      	str	r7, [r1, #0]
 8017fe6:	bf18      	it	ne
 8017fe8:	2300      	movne	r3, #0
 8017fea:	eba6 0807 	sub.w	r8, r6, r7
 8017fee:	608b      	str	r3, [r1, #8]
 8017ff0:	f1b8 0f00 	cmp.w	r8, #0
 8017ff4:	dde9      	ble.n	8017fca <__sflush_r+0xae>
 8017ff6:	6a21      	ldr	r1, [r4, #32]
 8017ff8:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 8017ffa:	4643      	mov	r3, r8
 8017ffc:	463a      	mov	r2, r7
 8017ffe:	4628      	mov	r0, r5
 8018000:	47b0      	blx	r6
 8018002:	2800      	cmp	r0, #0
 8018004:	dc08      	bgt.n	8018018 <__sflush_r+0xfc>
 8018006:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 801800a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 801800e:	81a3      	strh	r3, [r4, #12]
 8018010:	f04f 30ff 	mov.w	r0, #4294967295
 8018014:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8018018:	4407      	add	r7, r0
 801801a:	eba8 0800 	sub.w	r8, r8, r0
 801801e:	e7e7      	b.n	8017ff0 <__sflush_r+0xd4>
 8018020:	dfbffffe 	.word	0xdfbffffe

08018024 <_fflush_r>:
 8018024:	b538      	push	{r3, r4, r5, lr}
 8018026:	690b      	ldr	r3, [r1, #16]
 8018028:	4605      	mov	r5, r0
 801802a:	460c      	mov	r4, r1
 801802c:	b913      	cbnz	r3, 8018034 <_fflush_r+0x10>
 801802e:	2500      	movs	r5, #0
 8018030:	4628      	mov	r0, r5
 8018032:	bd38      	pop	{r3, r4, r5, pc}
 8018034:	b118      	cbz	r0, 801803e <_fflush_r+0x1a>
 8018036:	6a03      	ldr	r3, [r0, #32]
 8018038:	b90b      	cbnz	r3, 801803e <_fflush_r+0x1a>
 801803a:	f7ff f8a3 	bl	8017184 <__sinit>
 801803e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8018042:	2b00      	cmp	r3, #0
 8018044:	d0f3      	beq.n	801802e <_fflush_r+0xa>
 8018046:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 8018048:	07d0      	lsls	r0, r2, #31
 801804a:	d404      	bmi.n	8018056 <_fflush_r+0x32>
 801804c:	0599      	lsls	r1, r3, #22
 801804e:	d402      	bmi.n	8018056 <_fflush_r+0x32>
 8018050:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 8018052:	f7ff fad8 	bl	8017606 <__retarget_lock_acquire_recursive>
 8018056:	4628      	mov	r0, r5
 8018058:	4621      	mov	r1, r4
 801805a:	f7ff ff5f 	bl	8017f1c <__sflush_r>
 801805e:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 8018060:	07da      	lsls	r2, r3, #31
 8018062:	4605      	mov	r5, r0
 8018064:	d4e4      	bmi.n	8018030 <_fflush_r+0xc>
 8018066:	89a3      	ldrh	r3, [r4, #12]
 8018068:	059b      	lsls	r3, r3, #22
 801806a:	d4e1      	bmi.n	8018030 <_fflush_r+0xc>
 801806c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 801806e:	f7ff facb 	bl	8017608 <__retarget_lock_release_recursive>
 8018072:	e7dd      	b.n	8018030 <_fflush_r+0xc>

08018074 <__swhatbuf_r>:
 8018074:	b570      	push	{r4, r5, r6, lr}
 8018076:	460c      	mov	r4, r1
 8018078:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 801807c:	2900      	cmp	r1, #0
 801807e:	b096      	sub	sp, #88	@ 0x58
 8018080:	4615      	mov	r5, r2
 8018082:	461e      	mov	r6, r3
 8018084:	da0d      	bge.n	80180a2 <__swhatbuf_r+0x2e>
 8018086:	89a3      	ldrh	r3, [r4, #12]
 8018088:	f013 0f80 	tst.w	r3, #128	@ 0x80
 801808c:	f04f 0100 	mov.w	r1, #0
 8018090:	bf14      	ite	ne
 8018092:	2340      	movne	r3, #64	@ 0x40
 8018094:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 8018098:	2000      	movs	r0, #0
 801809a:	6031      	str	r1, [r6, #0]
 801809c:	602b      	str	r3, [r5, #0]
 801809e:	b016      	add	sp, #88	@ 0x58
 80180a0:	bd70      	pop	{r4, r5, r6, pc}
 80180a2:	466a      	mov	r2, sp
 80180a4:	f000 f848 	bl	8018138 <_fstat_r>
 80180a8:	2800      	cmp	r0, #0
 80180aa:	dbec      	blt.n	8018086 <__swhatbuf_r+0x12>
 80180ac:	9901      	ldr	r1, [sp, #4]
 80180ae:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 80180b2:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 80180b6:	4259      	negs	r1, r3
 80180b8:	4159      	adcs	r1, r3
 80180ba:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 80180be:	e7eb      	b.n	8018098 <__swhatbuf_r+0x24>

080180c0 <__smakebuf_r>:
 80180c0:	898b      	ldrh	r3, [r1, #12]
 80180c2:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80180c4:	079d      	lsls	r5, r3, #30
 80180c6:	4606      	mov	r6, r0
 80180c8:	460c      	mov	r4, r1
 80180ca:	d507      	bpl.n	80180dc <__smakebuf_r+0x1c>
 80180cc:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 80180d0:	6023      	str	r3, [r4, #0]
 80180d2:	6123      	str	r3, [r4, #16]
 80180d4:	2301      	movs	r3, #1
 80180d6:	6163      	str	r3, [r4, #20]
 80180d8:	b003      	add	sp, #12
 80180da:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80180dc:	ab01      	add	r3, sp, #4
 80180de:	466a      	mov	r2, sp
 80180e0:	f7ff ffc8 	bl	8018074 <__swhatbuf_r>
 80180e4:	9f00      	ldr	r7, [sp, #0]
 80180e6:	4605      	mov	r5, r0
 80180e8:	4639      	mov	r1, r7
 80180ea:	4630      	mov	r0, r6
 80180ec:	f7fe ff04 	bl	8016ef8 <_malloc_r>
 80180f0:	b948      	cbnz	r0, 8018106 <__smakebuf_r+0x46>
 80180f2:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80180f6:	059a      	lsls	r2, r3, #22
 80180f8:	d4ee      	bmi.n	80180d8 <__smakebuf_r+0x18>
 80180fa:	f023 0303 	bic.w	r3, r3, #3
 80180fe:	f043 0302 	orr.w	r3, r3, #2
 8018102:	81a3      	strh	r3, [r4, #12]
 8018104:	e7e2      	b.n	80180cc <__smakebuf_r+0xc>
 8018106:	89a3      	ldrh	r3, [r4, #12]
 8018108:	6020      	str	r0, [r4, #0]
 801810a:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 801810e:	81a3      	strh	r3, [r4, #12]
 8018110:	9b01      	ldr	r3, [sp, #4]
 8018112:	e9c4 0704 	strd	r0, r7, [r4, #16]
 8018116:	b15b      	cbz	r3, 8018130 <__smakebuf_r+0x70>
 8018118:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 801811c:	4630      	mov	r0, r6
 801811e:	f000 f81d 	bl	801815c <_isatty_r>
 8018122:	b128      	cbz	r0, 8018130 <__smakebuf_r+0x70>
 8018124:	89a3      	ldrh	r3, [r4, #12]
 8018126:	f023 0303 	bic.w	r3, r3, #3
 801812a:	f043 0301 	orr.w	r3, r3, #1
 801812e:	81a3      	strh	r3, [r4, #12]
 8018130:	89a3      	ldrh	r3, [r4, #12]
 8018132:	431d      	orrs	r5, r3
 8018134:	81a5      	strh	r5, [r4, #12]
 8018136:	e7cf      	b.n	80180d8 <__smakebuf_r+0x18>

08018138 <_fstat_r>:
 8018138:	b538      	push	{r3, r4, r5, lr}
 801813a:	4d07      	ldr	r5, [pc, #28]	@ (8018158 <_fstat_r+0x20>)
 801813c:	2300      	movs	r3, #0
 801813e:	4604      	mov	r4, r0
 8018140:	4608      	mov	r0, r1
 8018142:	4611      	mov	r1, r2
 8018144:	602b      	str	r3, [r5, #0]
 8018146:	f000 f8e7 	bl	8018318 <_fstat>
 801814a:	1c43      	adds	r3, r0, #1
 801814c:	d102      	bne.n	8018154 <_fstat_r+0x1c>
 801814e:	682b      	ldr	r3, [r5, #0]
 8018150:	b103      	cbz	r3, 8018154 <_fstat_r+0x1c>
 8018152:	6023      	str	r3, [r4, #0]
 8018154:	bd38      	pop	{r3, r4, r5, pc}
 8018156:	bf00      	nop
 8018158:	2400622c 	.word	0x2400622c

0801815c <_isatty_r>:
 801815c:	b538      	push	{r3, r4, r5, lr}
 801815e:	4d06      	ldr	r5, [pc, #24]	@ (8018178 <_isatty_r+0x1c>)
 8018160:	2300      	movs	r3, #0
 8018162:	4604      	mov	r4, r0
 8018164:	4608      	mov	r0, r1
 8018166:	602b      	str	r3, [r5, #0]
 8018168:	f000 f8de 	bl	8018328 <_isatty>
 801816c:	1c43      	adds	r3, r0, #1
 801816e:	d102      	bne.n	8018176 <_isatty_r+0x1a>
 8018170:	682b      	ldr	r3, [r5, #0]
 8018172:	b103      	cbz	r3, 8018176 <_isatty_r+0x1a>
 8018174:	6023      	str	r3, [r4, #0]
 8018176:	bd38      	pop	{r3, r4, r5, pc}
 8018178:	2400622c 	.word	0x2400622c
 801817c:	00000000 	.word	0x00000000

08018180 <sqrt>:
 8018180:	b508      	push	{r3, lr}
 8018182:	ed2d 8b04 	vpush	{d8-d9}
 8018186:	eeb0 8b40 	vmov.f64	d8, d0
 801818a:	f000 f8b9 	bl	8018300 <__ieee754_sqrt>
 801818e:	eeb4 8b48 	vcmp.f64	d8, d8
 8018192:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018196:	d60c      	bvs.n	80181b2 <sqrt+0x32>
 8018198:	ed9f 9b07 	vldr	d9, [pc, #28]	@ 80181b8 <sqrt+0x38>
 801819c:	eeb4 8bc9 	vcmpe.f64	d8, d9
 80181a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80181a4:	d505      	bpl.n	80181b2 <sqrt+0x32>
 80181a6:	f7ff fa03 	bl	80175b0 <__errno>
 80181aa:	ee89 0b09 	vdiv.f64	d0, d9, d9
 80181ae:	2321      	movs	r3, #33	@ 0x21
 80181b0:	6003      	str	r3, [r0, #0]
 80181b2:	ecbd 8b04 	vpop	{d8-d9}
 80181b6:	bd08      	pop	{r3, pc}
	...

080181c0 <expf>:
 80181c0:	ee10 2a10 	vmov	r2, s0
 80181c4:	f240 412a 	movw	r1, #1066	@ 0x42a
 80181c8:	f3c2 530a 	ubfx	r3, r2, #20, #11
 80181cc:	428b      	cmp	r3, r1
 80181ce:	b430      	push	{r4, r5}
 80181d0:	eeb7 6ac0 	vcvt.f64.f32	d6, s0
 80181d4:	d92a      	bls.n	801822c <expf+0x6c>
 80181d6:	f512 0f00 	cmn.w	r2, #8388608	@ 0x800000
 80181da:	d058      	beq.n	801828e <expf+0xce>
 80181dc:	f5b3 6fff 	cmp.w	r3, #2040	@ 0x7f8
 80181e0:	d303      	bcc.n	80181ea <expf+0x2a>
 80181e2:	ee30 0a00 	vadd.f32	s0, s0, s0
 80181e6:	bc30      	pop	{r4, r5}
 80181e8:	4770      	bx	lr
 80181ea:	eddf 7a2a 	vldr	s15, [pc, #168]	@ 8018294 <expf+0xd4>
 80181ee:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80181f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80181f6:	dd03      	ble.n	8018200 <expf+0x40>
 80181f8:	bc30      	pop	{r4, r5}
 80181fa:	2000      	movs	r0, #0
 80181fc:	f000 b87a 	b.w	80182f4 <__math_oflowf>
 8018200:	eddf 7a25 	vldr	s15, [pc, #148]	@ 8018298 <expf+0xd8>
 8018204:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8018208:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801820c:	d503      	bpl.n	8018216 <expf+0x56>
 801820e:	bc30      	pop	{r4, r5}
 8018210:	2000      	movs	r0, #0
 8018212:	f000 b863 	b.w	80182dc <__math_uflowf>
 8018216:	eddf 7a21 	vldr	s15, [pc, #132]	@ 801829c <expf+0xdc>
 801821a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801821e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018222:	d503      	bpl.n	801822c <expf+0x6c>
 8018224:	bc30      	pop	{r4, r5}
 8018226:	2000      	movs	r0, #0
 8018228:	f000 b85e 	b.w	80182e8 <__math_may_uflowf>
 801822c:	4b1c      	ldr	r3, [pc, #112]	@ (80182a0 <expf+0xe0>)
 801822e:	eeb7 0b00 	vmov.f64	d0, #112	@ 0x3f800000  1.0
 8018232:	ed93 5b4a 	vldr	d5, [r3, #296]	@ 0x128
 8018236:	ed93 4b48 	vldr	d4, [r3, #288]	@ 0x120
 801823a:	eeb0 7b44 	vmov.f64	d7, d4
 801823e:	eea5 7b06 	vfma.f64	d7, d5, d6
 8018242:	ee17 0a10 	vmov	r0, s14
 8018246:	ee37 7b44 	vsub.f64	d7, d7, d4
 801824a:	f000 021f 	and.w	r2, r0, #31
 801824e:	ee95 7b06 	vfnms.f64	d7, d5, d6
 8018252:	ed93 5b4c 	vldr	d5, [r3, #304]	@ 0x130
 8018256:	ee27 4b07 	vmul.f64	d4, d7, d7
 801825a:	ed93 6b4e 	vldr	d6, [r3, #312]	@ 0x138
 801825e:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
 8018262:	eea5 6b07 	vfma.f64	d6, d5, d7
 8018266:	f853 4032 	ldr.w	r4, [r3, r2, lsl #3]
 801826a:	684d      	ldr	r5, [r1, #4]
 801826c:	ed93 5b50 	vldr	d5, [r3, #320]	@ 0x140
 8018270:	2100      	movs	r1, #0
 8018272:	190a      	adds	r2, r1, r4
 8018274:	eb05 33c0 	add.w	r3, r5, r0, lsl #15
 8018278:	eea5 0b07 	vfma.f64	d0, d5, d7
 801827c:	ec43 2b17 	vmov	d7, r2, r3
 8018280:	eea6 0b04 	vfma.f64	d0, d6, d4
 8018284:	ee20 0b07 	vmul.f64	d0, d0, d7
 8018288:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
 801828c:	e7ab      	b.n	80181e6 <expf+0x26>
 801828e:	ed9f 0a05 	vldr	s0, [pc, #20]	@ 80182a4 <expf+0xe4>
 8018292:	e7a8      	b.n	80181e6 <expf+0x26>
 8018294:	42b17217 	.word	0x42b17217
 8018298:	c2cff1b4 	.word	0xc2cff1b4
 801829c:	c2ce8ecf 	.word	0xc2ce8ecf
 80182a0:	08022390 	.word	0x08022390
 80182a4:	00000000 	.word	0x00000000

080182a8 <with_errnof>:
 80182a8:	b510      	push	{r4, lr}
 80182aa:	ed2d 8b02 	vpush	{d8}
 80182ae:	eeb0 8a40 	vmov.f32	s16, s0
 80182b2:	4604      	mov	r4, r0
 80182b4:	f7ff f97c 	bl	80175b0 <__errno>
 80182b8:	eeb0 0a48 	vmov.f32	s0, s16
 80182bc:	ecbd 8b02 	vpop	{d8}
 80182c0:	6004      	str	r4, [r0, #0]
 80182c2:	bd10      	pop	{r4, pc}

080182c4 <xflowf>:
 80182c4:	b130      	cbz	r0, 80182d4 <xflowf+0x10>
 80182c6:	eef1 7a40 	vneg.f32	s15, s0
 80182ca:	ee27 0a80 	vmul.f32	s0, s15, s0
 80182ce:	2022      	movs	r0, #34	@ 0x22
 80182d0:	f7ff bfea 	b.w	80182a8 <with_errnof>
 80182d4:	eef0 7a40 	vmov.f32	s15, s0
 80182d8:	e7f7      	b.n	80182ca <xflowf+0x6>
	...

080182dc <__math_uflowf>:
 80182dc:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 80182e4 <__math_uflowf+0x8>
 80182e0:	f7ff bff0 	b.w	80182c4 <xflowf>
 80182e4:	10000000 	.word	0x10000000

080182e8 <__math_may_uflowf>:
 80182e8:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 80182f0 <__math_may_uflowf+0x8>
 80182ec:	f7ff bfea 	b.w	80182c4 <xflowf>
 80182f0:	1a200000 	.word	0x1a200000

080182f4 <__math_oflowf>:
 80182f4:	ed9f 0a01 	vldr	s0, [pc, #4]	@ 80182fc <__math_oflowf+0x8>
 80182f8:	f7ff bfe4 	b.w	80182c4 <xflowf>
 80182fc:	70000000 	.word	0x70000000

08018300 <__ieee754_sqrt>:
 8018300:	eeb1 0bc0 	vsqrt.f64	d0, d0
 8018304:	4770      	bx	lr
	...

08018308 <_close>:
 8018308:	4b02      	ldr	r3, [pc, #8]	@ (8018314 <_close+0xc>)
 801830a:	2258      	movs	r2, #88	@ 0x58
 801830c:	601a      	str	r2, [r3, #0]
 801830e:	f04f 30ff 	mov.w	r0, #4294967295
 8018312:	4770      	bx	lr
 8018314:	2400622c 	.word	0x2400622c

08018318 <_fstat>:
 8018318:	4b02      	ldr	r3, [pc, #8]	@ (8018324 <_fstat+0xc>)
 801831a:	2258      	movs	r2, #88	@ 0x58
 801831c:	601a      	str	r2, [r3, #0]
 801831e:	f04f 30ff 	mov.w	r0, #4294967295
 8018322:	4770      	bx	lr
 8018324:	2400622c 	.word	0x2400622c

08018328 <_isatty>:
 8018328:	4b02      	ldr	r3, [pc, #8]	@ (8018334 <_isatty+0xc>)
 801832a:	2258      	movs	r2, #88	@ 0x58
 801832c:	601a      	str	r2, [r3, #0]
 801832e:	2000      	movs	r0, #0
 8018330:	4770      	bx	lr
 8018332:	bf00      	nop
 8018334:	2400622c 	.word	0x2400622c

08018338 <_lseek>:
 8018338:	4b02      	ldr	r3, [pc, #8]	@ (8018344 <_lseek+0xc>)
 801833a:	2258      	movs	r2, #88	@ 0x58
 801833c:	601a      	str	r2, [r3, #0]
 801833e:	f04f 30ff 	mov.w	r0, #4294967295
 8018342:	4770      	bx	lr
 8018344:	2400622c 	.word	0x2400622c

08018348 <_read>:
 8018348:	4b02      	ldr	r3, [pc, #8]	@ (8018354 <_read+0xc>)
 801834a:	2258      	movs	r2, #88	@ 0x58
 801834c:	601a      	str	r2, [r3, #0]
 801834e:	f04f 30ff 	mov.w	r0, #4294967295
 8018352:	4770      	bx	lr
 8018354:	2400622c 	.word	0x2400622c

08018358 <_write>:
 8018358:	4b02      	ldr	r3, [pc, #8]	@ (8018364 <_write+0xc>)
 801835a:	2258      	movs	r2, #88	@ 0x58
 801835c:	601a      	str	r2, [r3, #0]
 801835e:	f04f 30ff 	mov.w	r0, #4294967295
 8018362:	4770      	bx	lr
 8018364:	2400622c 	.word	0x2400622c

08018368 <_init>:
 8018368:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801836a:	bf00      	nop
 801836c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801836e:	bc08      	pop	{r3}
 8018370:	469e      	mov	lr, r3
 8018372:	4770      	bx	lr

08018374 <_fini>:
 8018374:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8018376:	bf00      	nop
 8018378:	bcf8      	pop	{r3, r4, r5, r6, r7}
 801837a:	bc08      	pop	{r3}
 801837c:	469e      	mov	lr, r3
 801837e:	4770      	bx	lr
